<?xml version="1.0" encoding="UTF-8"?>
<!--
*************************************************
	         AnyLogic Project File
*************************************************
-->
<AnyLogicWorkspace WorkspaceVersion="1.9" AnyLogicVersion="8.9.2.202410172110" AlpVersion="8.9.2">
<Model>
	<Id>1634127996010</Id>
	<Name><![CDATA[SimOpt_V8]]></Name>
	<EngineVersion>6</EngineVersion>
	<JavaPackageName><![CDATA[simopt]]></JavaPackageName>
	<ModelTimeUnit><![CDATA[Day]]></ModelTimeUnit>
	
	<Folders>
		
	</Folders>
	<ActiveObjectClasses>
		<!--   =========   Active Object Class   ========  -->
		<ActiveObjectClass>
			<Id>1634127996028</Id>
			<Name><![CDATA[Main]]></Name>
			<Import><![CDATA[import com.google.gson.Gson;
import java.util.stream.*;
import java.util.Optional;
import static java.util.Arrays.stream; // for streaming arrays
import com.anylogic.libraries.processmodeling.Seize.RecalculateResourceChoiceConditionsEvent;
import java.text.DecimalFormat; 
import java.text.NumberFormat; 
import one.util.streamex.StreamEx;
import org.eclipse.jdt.internal.compiler.ast.SuperReference;
import java.text.*;
import com.google.gson.GsonBuilder;
import java.util.function.Consumer;
import org.h2.expression.aggregate.ListaggArguments;
import java.time.LocalDateTime;
import java.util.concurrent.atomic.AtomicReference;
import java.io.*;
import java.text.SimpleDateFormat;
import java.util.Date;]]></Import>
			<StartupCode><![CDATA[
traceln("In Main Agent");

DBQueries db = new DBQueries();

mrpFileNameSuffix = new SimpleDateFormat("yyyyMMddHHmm").format(new Date());

simParams = db.GetSimulationParameters();
simParams.setSimulationPCName(null, pcName);
boolean parameterVariation = !varNormalSimulationRun;

traceln("Start Main: " + pcName);

optimizationParameters = db.GetOptimizationParameterbyStatus(simParams,
OptimizationParameter.ACTIVE_OPTIMIZATION_PARAMETER, false, parameterVariation,pcName);

//Nachsimuieren eines einzelnen Parameters
if(checkSingleOptimizationParameter > 0){
	optimizationParameters = db.GetOptimizationParameterbyId(simParams, checkSingleOptimizationParameter);
	traceln("ATTENTION ----> Check Single Optimization Parameter ist set with value: " + checkSingleOptimizationParameter);
}

traceln("Current Replication Count: " + currentReplicationCount);

replicationStart = LocalDateTime.now();

if(optimizationParameters.getId() > 0 && !varNormalSimulationRun && 
	optimizationParameters.getSimulationParameter() != null || checkSingleOptimizationParameter > 0){
	SimulationParameter.UpdateExperiment(optimizationParameters,simParams);	
	simParams = db.GetSimulationParameters();
	traceln("Parameter Variation is started - with Optimization Parameter " + optimizationParameters.getId());
}

if(optimizationParameters.getId() > 0) {
	traceln("Parameter Variation is started - with Optimization Parameter " + optimizationParameters.getId());
}	

if(varNormalSimulationRun){
	simParams.setSimulationPCName("",null);
	traceln("Simulation PC Name: " + simParams.getSimulationPCName());
	pcName = simParams.getSimulationPCName();
}	
	

list_ForecastInputParameter = ForecastInputParameter.ReadForecastExcelIntputParameters(simParams.getInputFileLocation());

items = db.GetItems(simParams);

routings = db.GetRouting(simParams,items);

items = Item.SetRouting(simParams,items,routings);

orderPasts = db.GetOrderPast(simParams, items);

interArrivalTimes = db.GetInterArrivalTime(simParams);

traceln(interArrivalTimes.size());

bom = db.GetBOM(items,simParams, items);				

maxBomLevel = BOM.GetMaxBomLevel(bom, simParams);
//traceln("Max Bom Level: " + (maxBomLevel.getLevel()));
getEngine().setStopTime(simParams.getSimulationRunTime());
traceln("Stop Time: " + getEngine().getStopTime() + " WarumUp Time: " + simParams.getWarumUpTime());

textSimulatedTimePeriod.setText("Stop Time: " + getEngine().getStopTime() + " " + getEngine().getTimeUnit()+"s");
textWarumUpTime.setText("WarumUp Time: " + simParams.getWarumUpTime() +" " + getEngine().getTimeUnit() + "s");

//traceln("Max BOM Level " + maxBomLevel.getLevel());
//traceln("Query Machines");
resources = db.GetResources(simParams);
resourceGroups = ResourceGroup.GetResourcesGroups(simParams);
//traceln("Order Future");
orderFuture = db.GetOrderFuture(simParams, items);
bomMatrix = db.GetBOMMatrix(simParams);

resourceCapacity = db.GetResourceCapacity(simParams);

simParams.setAvoidScenarioUpdates(SimulationParameter.AVOID_SCENARIO_UPDATES);

simParams.setUseIdealCFLine(UseIdealCFLine);
simParams.setMachineFailure(MachineFailure);

/** Function to set the optimizatino parameters **/
Function_ApplyOptimizationParameters();

forecastMasterdata = db.GetForecast(items,simParams,list_ForecastInputParameter);

resourceConsumption = db.GetResourceConsumption(simParams, routings);
textSimulationExperiment.setText("Experiment: " + simParams.getExperiment());

//textPlannedUtilization.setText("Planned Utilization: " + db.GetPlannedSystemUtilization(simParams) + " %");

warumUpTime.restart(simParams.getWarumUpTime());

long countEndItems = items.stream().filter(e -> e.getType().equalsIgnoreCase(Item.ITEM_TYPE_SALES)).count();

demandVariationMeanArray = new double[(int)countEndItems][simParams.getDemandVariationHorizon() + 1];
demandVariationCount = new int[(int)countEndItems];

long countComponents = items.stream().filter(e -> e.getType().equalsIgnoreCase(Item.ITEM_TYPE_COMPONENT)).count();

//List<Item> components = items.stream().filter(e -> e.getType().equalsIgnoreCase(Item.ITEM_TYPE_SALES)).collect(Collectors.toList());

simParams.setCountEndItems((int)countEndItems);
simParams.setComponents((int) countComponents);
simParams.setCountResources(resources.size());

traceln("Experiment: " + simParams.getExperiment() + " Optimization Type: " + simParams.getOptimizationType());
traceln("Forecast Inputfile location: " + simParams.getInputFileLocation());
traceln("Demand Scenario: " + simParams.getDemandScenario());
traceln("Forecat Scenario: " + simParams.getForecastScenario());
traceln("Parameter Variation Host: " + simParams.getOptimizationParameterSource());
traceln("Apply RPS: " + simParams.getApplyRPS());
traceln("Apply ConWip: " + simParams.getApplyConWip());
traceln("Forecast Update Frozen Zone: " + simParams.getForecastUpdateFrozenZone());
traceln("Use Ideal CF Line: " + simParams.getUseIdealCFLine());
traceln("Machine Failure: " + simParams.getMachineFailure());

//Set Simulation Parameters from config.properties
try {    	
	PropertyValues properties = new PropertyValues(SimulationParameter.PROPERTIES_FILENAME);
	
	traceln("Production Stage Statistics: " + properties.ProductionStageStatistics);			
	simParams.setProdStageStatistics(Integer.parseInt(properties.ProductionStageStatistics));
	
	traceln("CF Segments: " + properties.CFSegments);			
	simParams.setCFSegments(Integer.parseInt(properties.CFSegments));
	
	traceln("CF External Capacity used: " + properties.ExternalCapacity);			
	simParams.setExternalCapacity(Integer.parseInt(properties.ExternalCapacity));
		
	traceln("Write Results per Replication: " + properties.WriteResultsPerReplicationToDb);
	WriteResultsPerReplicationToDb = Integer.parseInt(properties.WriteResultsPerReplicationToDb);
	
	traceln("Random Optimizationparameter: " + properties.RandomOptimizationParameter);
	simParams.setRandomOptimizationParameter(Integer.parseInt(properties.RandomOptimizationParameter));
	
	traceln("Location Energy Prices Input Excel: " + properties.LocationEnergyPricesInputExcel);
	simParams.setLocationEnergyPricesInputExcel(properties.LocationEnergyPricesInputExcel);

	traceln("Energy Based Release: " + properties.EnergyPriceBasedRelease);
	simParams.setEnergyBasedRelease(Integer.parseInt(properties.EnergyPriceBasedRelease));

	traceln("Safety Stock at Begining: " + properties.SafetyStockAtBeginning);
	simParams.setSafetyStockAtBeginning(Integer.parseInt(properties.SafetyStockAtBeginning));

	if(simParams.getEnergyBasedRelease() == 1) {								
		if(simParams.getLocationEnergyPricesInputExcel() != null && simParams.getLocationEnergyPricesInputExcel().length() > 0){
			EnergyPrice.GetEnergyPrices(this);
			EnergyPrice.GetEnergyPricesPerMonth(this);
		}
	}
	
	if(properties.ForecastInputFile.length() > 0){
		traceln("Forecast Input File: " + properties.ForecastInputFile);
		simParams.setInputFileLocation(properties.ForecastInputFile);
	}
	
	if(properties.OverallCostsLimit.length() > 0){
		traceln("Overall Costs Limit: " + properties.OverallCostsLimit);
		simParams.setOverallCostsLimit(Integer.parseInt(properties.OverallCostsLimit));	
	}
	
	if(properties.OverallCostsCheckRecurrenceTime.length() > 0){
		traceln("Overall Costs Check Recurrence Time: " + properties.OverallCostsCheckRecurrenceTime);
		simParams.setOverallCostsCheckRecurrenceTime(Integer.parseInt(properties.OverallCostsCheckRecurrenceTime));
	}
	
	if(properties.OverallCostsFirstOccurenceTime.length() > 0){
		traceln("Overall Costs First Occurence Time: " + properties.OverallCostsFirstOccurenceTime);
		simParams.setOverallCostsFirstOccurenceTime(Integer.parseInt(properties.OverallCostsFirstOccurenceTime));
	}
	if(simParams.getOverallCostsFirstOccurenceTime() < 0){
		checkOverallCostLimit.reset();	
	}
							
}catch(Exception ex) {
	traceln(ex.getMessage());    		
}

if(time() == 0) {

	if(simParams.getDemandGeneration().equals(SimulationParameter.DEMAND_GENERATION_CUSTOMER_REQUIRED_LEADTIME)){

	for(OrderFuture of : orderFuture){			
			double irt = OrderFuture.GetInterArrivalTime(of, time(), var_random_arrivalRate,mrpFileNameSuffix);
			create_dynEvnt(irt, DAY,of,this);			
		}	
	}

	if(simParams.getDemandGeneration().equals(SimulationParameter.DEMAND_GENERATION_INTERARRIVAL_TIME)){

			double sigmaIaT = simParams.getMeanInterArrivalTime() * simParams.getVarCoeInterArrivalTime();
			
			double iAt = Distribution.GetDistributionValue("LOGNORMAL", simParams.getMeanInterArrivalTime(), 
			sigmaIaT,"Interarrival Time ", var_random_InterArrivalTime, mrpFileNameSuffix,0,0);
			
			create_dynEventInterArrivalTime(iAt, DAY,this);			
	}

		//item.getSafetyStock(),		
		double ss = 0;
	for(Item item : items){
		StockBooking book = new StockBooking(
		item,
	    (simParams.getSafetyStockAtBeginning() == 0 && !item.getType().equalsIgnoreCase(Item.ITEM_TYPE_PURCHASE)) ? 0 : item.getSafetyStock(), 
	    time(),
		"Initialization",
		0,
		0,
		0);				

		stockBookings.add(book);			
			
		//Plot Demand per Item Sales Item
		if(item.getType().equals(Item.ITEM_TYPE_SALES) && item.getDataItemIndex() >= 0){		

			Chart2DPlot.Appearance o = new Chart2DPlot.Appearance(
			new Color((int)(Math.random() * 0x1000000)),
			true,
			false,
			 Chart.InterpolationType.INTERPOLATION_LINEAR,
				2,
			  Chart.PointStyle.POINT_TRIANGLE
			
			);
			
			DataSet x = new DataSet(1000);				
			kPIAgent.plotDemandPerItem.addDataSet(x, Integer.toString(item.getItem()), o);
		}		
	}
	
		
	for(Resource res : resources){	
		MachineAgent m = new MachineAgent();

		Chart2DPlot.Appearance o = new Chart2DPlot.Appearance(
		new Color((int)(Math.random() * 0x1000000)),
		true,
		false,
		 Chart.InterpolationType.INTERPOLATION_LINEAR,
			2,
		  Chart.PointStyle.POINT_TRIANGLE
		
		);
		
		DataSet x = new DataSet(1000);				
		kPIAgent.plotUtilizations.addDataSet(x, res.getName(), o);
		DataSet y = new DataSet(1000);				
		kPIAgent.plotJSIPerMachine.addDataSet(y, res.getName(), o);
														
		m.Resource = res;
		m.markParametersAreSet();			
		
		//todo: change to parameters form db
		add_machineAgents(null, res, 0.9, 15, 1);						
	}
}	

kPIAgent.eventResetStatistics.restartTo(simParams.getWarumUpTime());
kPIAgent.eventComputeKPIs.restartTo(simParams.getWarumUpTime());
traceln("CF Segment Identifier: " + simParams.getUseIdealCFLine());
cplex.ClearingFunctionSegments = ClearingFunctionSegments.GetClearingFunctionSegments(simParams.getUseIdealCFLine());
traceln("CFs selected at Starup Cnt: " + cplex.ClearingFunctionSegments.size());

if(varNormalSimulationRun || checkSingleOptimizationParameter > 0)
	Result.DeleteResultsFromDb("CF", simParams.getExperiment());
	]]></StartupCode>
			<Generic>false</Generic>
			<GenericParameter>
				<Id>1634127996026</Id>
				<Name><![CDATA[1634127996026]]></Name>
				<GenericParameterValue Class="CodeValue">
					<Code><![CDATA[T extends Agent]]></Code>
				</GenericParameterValue>
				<GenericParameterLabel><![CDATA[Generic parameter:]]></GenericParameterLabel>
			</GenericParameter>
			<FlowChartsUsage>ENTITY</FlowChartsUsage>
			<SamplesToKeep>100</SamplesToKeep>
			<LimitNumberOfArrayElements>false</LimitNumberOfArrayElements>
			<ElementsLimitValue>100</ElementsLimitValue>
			<MakeDefaultViewArea>true</MakeDefaultViewArea>
			<SceneGridColor/>
			<SceneBackgroundColor/>
			<SceneSkybox>null</SceneSkybox>
			<AgentProperties>
				<EnvironmentDefinesInitialLocation>true</EnvironmentDefinesInitialLocation>
				<RotateAnimationTowardsMovement>true</RotateAnimationTowardsMovement>
				<RotateAnimationVertically>false</RotateAnimationVertically>
				<VelocityCode Class="CodeUnitValue">
					<Code><![CDATA[10]]></Code>
					<Unit Class="SpeedUnits"><![CDATA[MPS]]></Unit>
				</VelocityCode>
				<PhysicalLength Class="CodeUnitValue">
					<Code><![CDATA[1]]></Code>
					<Unit Class="LengthUnits"><![CDATA[METER]]></Unit>
				</PhysicalLength>
				<PhysicalWidth Class="CodeUnitValue">
					<Code><![CDATA[1]]></Code>
					<Unit Class="LengthUnits"><![CDATA[METER]]></Unit>
				</PhysicalWidth>
				<PhysicalHeight Class="CodeUnitValue">
					<Code><![CDATA[1]]></Code>
					<Unit Class="LengthUnits"><![CDATA[METER]]></Unit>
				</PhysicalHeight>
			</AgentProperties>
			<EnvironmentProperties>
					<EnableSteps>false</EnableSteps>
					<StepDurationCode Class="CodeUnitValue">
						<Code><![CDATA[1.0]]></Code>
						<Unit Class="TimeUnits"><![CDATA[SECOND]]></Unit>
					</StepDurationCode>
					<SpaceType>CONTINUOUS</SpaceType>
					<WidthCode><![CDATA[500]]></WidthCode>
					<HeightCode><![CDATA[500]]></HeightCode>
					<ZHeightCode><![CDATA[0]]></ZHeightCode>
					<ColumnsCountCode><![CDATA[100]]></ColumnsCountCode>
					<RowsCountCode><![CDATA[100]]></RowsCountCode>
					<NeigborhoodType>MOORE</NeigborhoodType>
					<LayoutType>USER_DEF</LayoutType>
					<NetworkType>USER_DEF</NetworkType>
					<ConnectionsPerAgentCode><![CDATA[2]]></ConnectionsPerAgentCode>
					<ConnectionsRangeCode><![CDATA[50]]></ConnectionsRangeCode>
					<NeighborLinkFractionCode><![CDATA[0.95]]></NeighborLinkFractionCode>
					<MCode><![CDATA[10]]></MCode>
			</EnvironmentProperties>
			<DatasetsCreationProperties>
				<AutoCreate>true</AutoCreate>
					<OccurrenceAtTime>true</OccurrenceAtTime>
					<OccurrenceDate>1634198400000</OccurrenceDate>
					<OccurrenceTime Class="CodeUnitValue">
						<Code><![CDATA[0]]></Code>
						<Unit Class="TimeUnits"><![CDATA[DAY]]></Unit>
					</OccurrenceTime>
					<RecurrenceCode Class="CodeUnitValue">
						<Code><![CDATA[1]]></Code>
						<Unit Class="TimeUnits"><![CDATA[DAY]]></Unit>
					</RecurrenceCode>
			</DatasetsCreationProperties>
			<ScaleRuler>
				<Id>1634127996024</Id>
				<Name><![CDATA[scale]]></Name>
				<X>0</X><Y>-150</Y>
				<PublicFlag>false</PublicFlag>
				<PresentationFlag>false</PresentationFlag>
				<ShowLabel>false</ShowLabel>
				<DrawMode>SHAPE_DRAW_2D3D</DrawMode>
				<Length>100</Length>
				<Rotation>0</Rotation>
				<ScaleType>BASED_ON_LENGTH</ScaleType>
				<ModelLength>10</ModelLength>
				<LengthUnits>METER</LengthUnits>
				<Scale>10</Scale>
				<InheritedFromParentAgentType>true</InheritedFromParentAgentType>
			</ScaleRuler>
			<CurrentLevel>1634127996027</CurrentLevel>
			<ConnectionsId>1634127996011</ConnectionsId>
			<Variables>
				<Variable Class="PlainVariable">
					<Id>1636639894044</Id>
					<Name><![CDATA[items]]></Name>
					<X>360</X><Y>1840</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Properties SaveInSnapshot="true" Constant="false" AccessType="public" StaticVariable="false">
						<Type><![CDATA[List<Item>]]></Type>        
					</Properties>
				</Variable>
				<Variable Class="PlainVariable">
					<Id>1637004812290</Id>
					<Name><![CDATA[bom]]></Name>
					<X>360</X><Y>1810</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Properties SaveInSnapshot="true" Constant="false" AccessType="public" StaticVariable="false">
						<Type><![CDATA[List<BOM>]]></Type>        
					</Properties>
				</Variable>
				<Variable Class="PlainVariable">
					<Id>1637588001122</Id>
					<Name><![CDATA[resources]]></Name>
					<X>360</X><Y>1780</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Properties SaveInSnapshot="true" Constant="false" AccessType="public" StaticVariable="false">
						<Type><![CDATA[List<Resource>]]></Type>        
					</Properties>
				</Variable>
				<Variable Class="PlainVariable">
					<Id>1637591938892</Id>
					<Name><![CDATA[orderFuture]]></Name>
					<X>630</X><Y>1810</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Properties SaveInSnapshot="true" Constant="false" AccessType="public" StaticVariable="false">
						<Type><![CDATA[List<OrderFuture>]]></Type>        
					</Properties>
				</Variable>
				<Variable Class="PlainVariable">
					<Id>1638211243009</Id>
					<Name><![CDATA[bomMatrix]]></Name>
					<X>630</X><Y>1840</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Properties SaveInSnapshot="true" Constant="false" AccessType="public" StaticVariable="false">
						<Type><![CDATA[List<BOMMatrix>]]></Type>        
					</Properties>
				</Variable>
				<Variable Class="PlainVariable">
					<Id>1638352565163</Id>
					<Name><![CDATA[resourceConsumption]]></Name>
					<X>630</X><Y>1780</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Properties SaveInSnapshot="true" Constant="false" AccessType="public" StaticVariable="false">
						<Type><![CDATA[double[][]]]></Type>        
					</Properties>
				</Variable>
				<Variable Class="PlainVariable">
					<Id>1638353971159</Id>
					<Name><![CDATA[resourceCapacity]]></Name>
					<X>630</X><Y>1750</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Properties SaveInSnapshot="true" Constant="false" AccessType="public" StaticVariable="false">
						<Type><![CDATA[List<ResourceCapacity>]]></Type>        
					</Properties>
				</Variable>
				<Variable Class="PlainVariable">
					<Id>1638436070090</Id>
					<Name><![CDATA[componentAvailabilityProcessing]]></Name>
					<X>630</X><Y>1870</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Properties SaveInSnapshot="true" Constant="false" AccessType="public" StaticVariable="false">
						<Type><![CDATA[double[][]]]></Type>        
					</Properties>
				</Variable>
				<Variable Class="PlainVariable">
					<Id>1638804316189</Id>
					<Name><![CDATA[forecastMasterdata]]></Name>
					<X>630</X><Y>1890</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Properties SaveInSnapshot="true" Constant="false" AccessType="public" StaticVariable="false">
						<Type><![CDATA[List<Forecast>]]></Type>        
					</Properties>
				</Variable>
				<Variable Class="PlainVariable">
					<Id>1638804859087</Id>
					<Name><![CDATA[orderId]]></Name>
					<X>500</X><Y>1720</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Properties SaveInSnapshot="true" Constant="false" AccessType="public" StaticVariable="false">
						<Type><![CDATA[int]]></Type>        
						<InitialValue Class="CodeValue">
							<Code><![CDATA[1]]></Code>
						</InitialValue>
					</Properties>
				</Variable>
				<Variable Class="PlainVariable">
					<Id>1638805032664</Id>
					<Name><![CDATA[customerOrders]]></Name>
					<X>630</X><Y>1910</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Properties SaveInSnapshot="true" Constant="false" AccessType="public" StaticVariable="false">
						<Type><![CDATA[List<CustomerOrder>]]></Type>        
						<InitialValue Class="CodeValue">
							<Code><![CDATA[new ArrayList();]]></Code>
						</InitialValue>
					</Properties>
				</Variable>
				<Variable Class="PlainVariable">
					<Id>1639491511811</Id>
					<Name><![CDATA[grossReq]]></Name>
					<X>630</X><Y>1950</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Properties SaveInSnapshot="true" Constant="false" AccessType="public" StaticVariable="false">
						<Type><![CDATA[double]]></Type>        
						<InitialValue Class="CodeValue">
							<Code><![CDATA[0]]></Code>
						</InitialValue>
					</Properties>
				</Variable>
				<Variable Class="PlainVariable">
					<Id>1639644445947</Id>
					<Name><![CDATA[prodOrderId]]></Name>
					<X>500</X><Y>1750</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Properties SaveInSnapshot="true" Constant="false" AccessType="public" StaticVariable="false">
						<Type><![CDATA[int]]></Type>        
						<InitialValue Class="CodeValue">
							<Code><![CDATA[1]]></Code>
						</InitialValue>
					</Properties>
				</Variable>
				<Variable Class="PlainVariable">
					<Id>1639991171759</Id>
					<Name><![CDATA[routings]]></Name>
					<X>500</X><Y>1780</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Properties SaveInSnapshot="true" Constant="false" AccessType="public" StaticVariable="false">
						<Type><![CDATA[List<Routing>]]></Type>        
					</Properties>
				</Variable>
				<Variable Class="PlainVariable">
					<Id>1640078115998</Id>
					<Name><![CDATA[mrpTable]]></Name>
					<X>500</X><Y>1810</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Properties SaveInSnapshot="true" Constant="false" AccessType="public" StaticVariable="false">
						<Type><![CDATA[List<MRP>]]></Type>        
						<InitialValue Class="CodeValue">
							<Code><![CDATA[new ArrayList()]]></Code>
						</InitialValue>
					</Properties>
				</Variable>
				<Variable Class="PlainVariable">
					<Id>1640784177786</Id>
					<Name><![CDATA[productionOrders]]></Name>
					<X>630</X><Y>1720</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Properties SaveInSnapshot="true" Constant="false" AccessType="public" StaticVariable="false">
						<Type><![CDATA[List<ProductionOrder>]]></Type>        
						<InitialValue Class="CodeValue">
							<Code><![CDATA[new ArrayList();]]></Code>
						</InitialValue>
					</Properties>
				</Variable>
				<Variable Class="PlainVariable">
					<Id>1641212073862</Id>
					<Name><![CDATA[mrpCount]]></Name>
					<X>500</X><Y>1840</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Properties SaveInSnapshot="true" Constant="false" AccessType="public" StaticVariable="false">
						<Type><![CDATA[int]]></Type>        
						<InitialValue Class="CodeValue">
							<Code><![CDATA[0]]></Code>
						</InitialValue>
					</Properties>
				</Variable>
				<Variable Class="PlainVariable">
					<Id>1641305545623</Id>
					<Name><![CDATA[WIPQty]]></Name>
					<X>500</X><Y>1870</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Properties SaveInSnapshot="true" Constant="false" AccessType="public" StaticVariable="false">
						<Type><![CDATA[double]]></Type>        
					</Properties>
				</Variable>
				<Variable Class="PlainVariable">
					<Id>1643725990243</Id>
					<Name><![CDATA[routingTimeId]]></Name>
					<X>360</X><Y>1720</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Properties SaveInSnapshot="true" Constant="false" AccessType="public" StaticVariable="false">
						<Type><![CDATA[int]]></Type>        
						<InitialValue Class="CodeValue">
							<Code><![CDATA[1]]></Code>
						</InitialValue>
					</Properties>
				</Variable>
				<Variable Class="PlainVariable">
					<Id>1644155407410</Id>
					<Name><![CDATA[maxBomLevel]]></Name>
					<X>30</X><Y>1720</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Properties SaveInSnapshot="true" Constant="false" AccessType="public" StaticVariable="false">
						<Type><![CDATA[BOM]]></Type>        
					</Properties>
				</Variable>
				<Variable Class="PlainVariable">
					<Id>1646371717757</Id>
					<Name><![CDATA[var_tardiness_mean]]></Name>
					<X>450</X><Y>-170</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Properties SaveInSnapshot="true" Constant="false" AccessType="public" StaticVariable="false">
						<Type><![CDATA[double]]></Type>        
					</Properties>
				</Variable>
				<Variable Class="PlainVariable">
					<Id>1646371717766</Id>
					<Name><![CDATA[var_leadtime_sales_mean]]></Name>
					<X>610</X><Y>-180</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Properties SaveInSnapshot="true" Constant="false" AccessType="public" StaticVariable="false">
						<Type><![CDATA[double]]></Type>        
					</Properties>
				</Variable>
				<Variable Class="PlainVariable">
					<Id>1646371717769</Id>
					<Name><![CDATA[var_inventory_sales]]></Name>
					<X>1050</X><Y>-80</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Properties SaveInSnapshot="true" Constant="false" AccessType="public" StaticVariable="false">
						<Type><![CDATA[double]]></Type>        
					</Properties>
				</Variable>
				<Variable Class="PlainVariable">
					<Id>1646371717777</Id>
					<Name><![CDATA[var_leadtime_components_mean]]></Name>
					<X>610</X><Y>-60</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Properties SaveInSnapshot="true" Constant="false" AccessType="public" StaticVariable="false">
						<Type><![CDATA[double]]></Type>        
					</Properties>
				</Variable>
				<Variable Class="PlainVariable">
					<Id>1646371717783</Id>
					<Name><![CDATA[var_inventory_components]]></Name>
					<X>1050</X><Y>-60</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Properties SaveInSnapshot="true" Constant="false" AccessType="public" StaticVariable="false">
						<Type><![CDATA[double]]></Type>        
					</Properties>
				</Variable>
				<Variable Class="PlainVariable">
					<Id>1646371717787</Id>
					<Name><![CDATA[var_overall_costs]]></Name>
					<X>220</X><Y>-200</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Properties SaveInSnapshot="true" Constant="false" AccessType="public" StaticVariable="false">
						<Type><![CDATA[double]]></Type>        
					</Properties>
				</Variable>
				<Variable Class="PlainVariable">
					<Id>1646819732351</Id>
					<Name><![CDATA[var_random_forecast]]></Name>
					<X>30</X><Y>1880</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Properties SaveInSnapshot="true" Constant="false" AccessType="public" StaticVariable="false">
						<Type><![CDATA[Random]]></Type>        
						<InitialValue Class="CodeValue">
							<Code><![CDATA[new Random(currentReplicationCount + 10000)]]></Code>
						</InitialValue>
					</Properties>
				</Variable>
				<Variable Class="PlainVariable">
					<Id>1646820234276</Id>
					<Name><![CDATA[var_random_processingTime]]></Name>
					<X>30</X><Y>1910</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Properties SaveInSnapshot="true" Constant="false" AccessType="public" StaticVariable="false">
						<Type><![CDATA[Random]]></Type>        
						<InitialValue Class="CodeValue">
							<Code><![CDATA[new Random(currentReplicationCount + 10001)]]></Code>
						</InitialValue>
					</Properties>
				</Variable>
				<Variable Class="PlainVariable">
					<Id>1646820238212</Id>
					<Name><![CDATA[var_random_setupTime]]></Name>
					<X>30</X><Y>1940</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Properties SaveInSnapshot="true" Constant="false" AccessType="public" StaticVariable="false">
						<Type><![CDATA[Random]]></Type>        
						<InitialValue Class="CodeValue">
							<Code><![CDATA[new Random(currentReplicationCount + 10002)]]></Code>
						</InitialValue>
					</Properties>
				</Variable>
				<Variable Class="PlainVariable">
					<Id>1647937781951</Id>
					<Name><![CDATA[var_random_arrivalRate]]></Name>
					<X>30</X><Y>1970</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Properties SaveInSnapshot="true" Constant="false" AccessType="public" StaticVariable="false">
						<Type><![CDATA[Random]]></Type>        
						<InitialValue Class="CodeValue">
							<Code><![CDATA[new Random(currentReplicationCount + 10003)]]></Code>
						</InitialValue>
					</Properties>
				</Variable>
				<Variable Class="PlainVariable">
					<Id>1648201893595</Id>
					<Name><![CDATA[var_random_CustomerRequiredLeadtime]]></Name>
					<X>30</X><Y>2000</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Properties SaveInSnapshot="true" Constant="false" AccessType="public" StaticVariable="false">
						<Type><![CDATA[Random]]></Type>        
						<InitialValue Class="CodeValue">
							<Code><![CDATA[new Random(currentReplicationCount + 10004)]]></Code>
						</InitialValue>
					</Properties>
				</Variable>
				<Variable Class="PlainVariable">
					<Id>1648216414167</Id>
					<Name><![CDATA[var_random_CustomerRequiredOrderAmount]]></Name>
					<X>30</X><Y>2030</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Properties SaveInSnapshot="true" Constant="false" AccessType="public" StaticVariable="false">
						<Type><![CDATA[Random]]></Type>        
						<InitialValue Class="CodeValue">
							<Code><![CDATA[new Random(currentReplicationCount + 10005)]]></Code>
						</InitialValue>
					</Properties>
				</Variable>
				<Variable Class="PlainVariable">
					<Id>1648305216587</Id>
					<Name><![CDATA[var_wip_sales]]></Name>
					<X>850</X><Y>-100</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Properties SaveInSnapshot="true" Constant="false" AccessType="public" StaticVariable="false">
						<Type><![CDATA[double]]></Type>        
					</Properties>
				</Variable>
				<Variable Class="PlainVariable">
					<Id>1648305216591</Id>
					<Name><![CDATA[var_wip_components]]></Name>
					<X>850</X><Y>-60</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Properties SaveInSnapshot="true" Constant="false" AccessType="public" StaticVariable="false">
						<Type><![CDATA[double]]></Type>        
					</Properties>
				</Variable>
				<Variable Class="PlainVariable">
					<Id>1651555176922</Id>
					<Name><![CDATA[resourceGroups]]></Name>
					<X>360</X><Y>1750</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Properties SaveInSnapshot="true" Constant="false" AccessType="public" StaticVariable="false">
						<Type><![CDATA[List<ResourceGroup>]]></Type>        
					</Properties>
				</Variable>
				<Variable Class="PlainVariable">
					<Id>1654073112289</Id>
					<Name><![CDATA[statisticsMachines]]></Name>
					<X>30</X><Y>1750</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Properties SaveInSnapshot="true" Constant="false" AccessType="public" StaticVariable="false">
						<Type><![CDATA[List<KPI>]]></Type>        
						<InitialValue Class="CodeValue">
							<Code><![CDATA[new ArrayList();]]></Code>
						</InitialValue>
					</Properties>
				</Variable>
				<Variable Class="PlainVariable">
					<Id>1654764355112</Id>
					<Name><![CDATA[varSystemWIP]]></Name>
					<X>940</X><Y>-440</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Properties SaveInSnapshot="true" Constant="false" AccessType="public" StaticVariable="false">
						<Type><![CDATA[double]]></Type>        
						<InitialValue Class="CodeValue">
							<Code><![CDATA[0]]></Code>
						</InitialValue>
					</Properties>
				</Variable>
				<Variable Class="PlainVariable">
					<Id>1654776293639</Id>
					<Name><![CDATA[varSystemWIPComponents]]></Name>
					<X>940</X><Y>-380</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Properties SaveInSnapshot="true" Constant="false" AccessType="public" StaticVariable="false">
						<Type><![CDATA[double]]></Type>        
						<InitialValue Class="CodeValue">
							<Code><![CDATA[0]]></Code>
						</InitialValue>
					</Properties>
				</Variable>
				<Variable Class="PlainVariable">
					<Id>1657270525775</Id>
					<Name><![CDATA[componentAvailabilityReleased]]></Name>
					<X>30</X><Y>1800</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Properties SaveInSnapshot="true" Constant="false" AccessType="public" StaticVariable="false">
						<Type><![CDATA[double[][]]]></Type>        
					</Properties>
				</Variable>
				<Variable Class="PlainVariable">
					<Id>1658395942466</Id>
					<Name><![CDATA[ordersInFrozenZone]]></Name>
					<X>30</X><Y>1780</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Properties SaveInSnapshot="true" Constant="false" AccessType="public" StaticVariable="false">
						<Type><![CDATA[double[][]]]></Type>        
					</Properties>
				</Variable>
				<Variable Class="PlainVariable">
					<Id>1661926272070</Id>
					<Name><![CDATA[orderPasts]]></Name>
					<X>630</X><Y>1930</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Properties SaveInSnapshot="true" Constant="false" AccessType="public" StaticVariable="false">
						<Type><![CDATA[List<OrderPast>]]></Type>        
						<InitialValue Class="CodeValue">
							<Code><![CDATA[new ArrayList();]]></Code>
						</InitialValue>
					</Properties>
				</Variable>
				<Variable Class="PlainVariable">
					<Id>1662121820164</Id>
					<Name><![CDATA[optimizationResults]]></Name>
					<X>30</X><Y>1850</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Properties SaveInSnapshot="true" Constant="false" AccessType="public" StaticVariable="false">
						<Type><![CDATA[List<OptimizationResult>]]></Type>        
						<InitialValue Class="CodeValue">
							<Code><![CDATA[new ArrayList();]]></Code>
						</InitialValue>
					</Properties>
				</Variable>
				<Variable Class="PlainVariable">
					<Id>1664457786317</Id>
					<Name><![CDATA[demandVariationMeanArray]]></Name>
					<X>630</X><Y>2120</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Properties SaveInSnapshot="true" Constant="false" AccessType="public" StaticVariable="false">
						<Type><![CDATA[double[][]]]></Type>        
					</Properties>
				</Variable>
				<Variable Class="PlainVariable">
					<Id>1664972416494</Id>
					<Name><![CDATA[demandVariationCount]]></Name>
					<X>630</X><Y>2000</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Properties SaveInSnapshot="true" Constant="false" AccessType="public" StaticVariable="false">
						<Type><![CDATA[int[]]]></Type>        
					</Properties>
				</Variable>
				<Variable Class="PlainVariable">
					<Id>1666528887234</Id>
					<Name><![CDATA[var_demand]]></Name>
					<X>220</X><Y>-60</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Properties SaveInSnapshot="true" Constant="false" AccessType="public" StaticVariable="false">
						<Type><![CDATA[double]]></Type>        
					</Properties>
				</Variable>
				<Variable Class="PlainVariable">
					<Id>1666528897334</Id>
					<Name><![CDATA[var_number_of_customer_orders]]></Name>
					<X>220</X><Y>-150</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Properties SaveInSnapshot="true" Constant="false" AccessType="public" StaticVariable="false">
						<Type><![CDATA[double]]></Type>        
					</Properties>
				</Variable>
				<Variable Class="PlainVariable">
					<Id>1666613527199</Id>
					<Name><![CDATA[var_lateness_mean]]></Name>
					<X>450</X><Y>-100</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Properties SaveInSnapshot="true" Constant="false" AccessType="public" StaticVariable="false">
						<Type><![CDATA[double]]></Type>        
					</Properties>
				</Variable>
				<Variable Class="PlainVariable">
					<Id>1666613555054</Id>
					<Name><![CDATA[var_lateness_variance]]></Name>
					<X>450</X><Y>-70</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Properties SaveInSnapshot="true" Constant="false" AccessType="public" StaticVariable="false">
						<Type><![CDATA[double]]></Type>        
					</Properties>
				</Variable>
				<Variable Class="PlainVariable">
					<Id>1666614452350</Id>
					<Name><![CDATA[var_leadtime_sales_variance]]></Name>
					<X>610</X><Y>-160</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Properties SaveInSnapshot="true" Constant="false" AccessType="public" StaticVariable="false">
						<Type><![CDATA[double]]></Type>        
					</Properties>
				</Variable>
				<Variable Class="PlainVariable">
					<Id>1666614515096</Id>
					<Name><![CDATA[var_leadtime_components_variance]]></Name>
					<X>610</X><Y>-110</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Properties SaveInSnapshot="true" Constant="false" AccessType="public" StaticVariable="false">
						<Type><![CDATA[double]]></Type>        
					</Properties>
				</Variable>
				<Variable Class="PlainVariable">
					<Id>1666635770098</Id>
					<Name><![CDATA[var_inventory]]></Name>
					<X>1050</X><Y>-40</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Properties SaveInSnapshot="true" Constant="false" AccessType="public" StaticVariable="false">
						<Type><![CDATA[double]]></Type>        
					</Properties>
				</Variable>
				<Variable Class="PlainVariable">
					<Id>1666636696617</Id>
					<Name><![CDATA[var_number_of_production_orders]]></Name>
					<X>220</X><Y>-170</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Properties SaveInSnapshot="true" Constant="false" AccessType="public" StaticVariable="false">
						<Type><![CDATA[int]]></Type>        
					</Properties>
				</Variable>
				<Variable Class="PlainVariable">
					<Id>1666668774932</Id>
					<Name><![CDATA[var_ontime_percentage]]></Name>
					<X>1550</X><Y>-90</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Properties SaveInSnapshot="true" Constant="false" AccessType="public" StaticVariable="false">
						<Type><![CDATA[double]]></Type>        
					</Properties>
				</Variable>
				<Variable Class="PlainVariable">
					<Id>1666669113291</Id>
					<Name><![CDATA[var_production_start_waiting_time_mean]]></Name>
					<X>1240</X><Y>-70</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Properties SaveInSnapshot="true" Constant="false" AccessType="public" StaticVariable="false">
						<Type><![CDATA[double]]></Type>        
					</Properties>
				</Variable>
				<Variable Class="PlainVariable">
					<Id>1666669399780</Id>
					<Name><![CDATA[var_production_start_waiting_time_variance]]></Name>
					<X>1240</X><Y>-50</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Properties SaveInSnapshot="true" Constant="false" AccessType="public" StaticVariable="false">
						<Type><![CDATA[double]]></Type>        
					</Properties>
				</Variable>
				<Variable Class="PlainVariable">
					<Id>1667367228427</Id>
					<Name><![CDATA[mrpFileNameSuffix]]></Name>
					<X>30</X><Y>1830</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Properties SaveInSnapshot="true" Constant="false" AccessType="public" StaticVariable="false">
						<Type><![CDATA[String]]></Type>        
					</Properties>
				</Variable>
				<Variable Class="PlainVariable">
					<Id>1667640798893</Id>
					<Name><![CDATA[var_productionLotSizes]]></Name>
					<X>220</X><Y>-230</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Properties SaveInSnapshot="true" Constant="false" AccessType="public" StaticVariable="false">
						<Type><![CDATA[List<KPI>]]></Type>        
						<InitialValue Class="CodeValue">
							<Code><![CDATA[new ArrayList();]]></Code>
						</InitialValue>
					</Properties>
				</Variable>
				<Variable Class="PlainVariable">
					<Id>1668085273697</Id>
					<Name><![CDATA[var_internal_lateness_components_mean]]></Name>
					<X>230</X><Y>-370</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Properties SaveInSnapshot="true" Constant="false" AccessType="public" StaticVariable="false">
						<Type><![CDATA[double]]></Type>        
					</Properties>
				</Variable>
				<Variable Class="PlainVariable">
					<Id>1668085284259</Id>
					<Name><![CDATA[var_internal_lateness_components_variance]]></Name>
					<X>230</X><Y>-340</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Properties SaveInSnapshot="true" Constant="false" AccessType="public" StaticVariable="false">
						<Type><![CDATA[double]]></Type>        
					</Properties>
				</Variable>
				<Variable Class="PlainVariable">
					<Id>1668085343131</Id>
					<Name><![CDATA[var_internal_lateness_sales_items_mean]]></Name>
					<X>560</X><Y>-370</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Properties SaveInSnapshot="true" Constant="false" AccessType="public" StaticVariable="false">
						<Type><![CDATA[double]]></Type>        
					</Properties>
				</Variable>
				<Variable Class="PlainVariable">
					<Id>1668085362188</Id>
					<Name><![CDATA[var_internal_lateness_sales_items_variance]]></Name>
					<X>560</X><Y>-340</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Properties SaveInSnapshot="true" Constant="false" AccessType="public" StaticVariable="false">
						<Type><![CDATA[double]]></Type>        
					</Properties>
				</Variable>
				<Variable Class="PlainVariable">
					<Id>1670245420055</Id>
					<Name><![CDATA[var_tardiness_variance]]></Name>
					<X>450</X><Y>-220</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Properties SaveInSnapshot="true" Constant="false" AccessType="public" StaticVariable="false">
						<Type><![CDATA[double]]></Type>        
					</Properties>
				</Variable>
				<Variable Class="PlainVariable">
					<Id>1680007216413</Id>
					<Name><![CDATA[productionStageOrders]]></Name>
					<X>630</X><Y>1970</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Properties SaveInSnapshot="true" Constant="false" AccessType="public" StaticVariable="false">
						<Type><![CDATA[List<ProductionOrder>]]></Type>        
						<InitialValue Class="CodeValue">
							<Code><![CDATA[new ArrayList();]]></Code>
						</InitialValue>
					</Properties>
				</Variable>
				<Variable Class="PlainVariable">
					<Id>1685440033229</Id>
					<Name><![CDATA[var_avg_planned_leadtime_mean_PS1]]></Name>
					<X>1470</X><Y>-270</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Properties SaveInSnapshot="true" Constant="false" AccessType="public" StaticVariable="false">
						<Type><![CDATA[double]]></Type>        
					</Properties>
				</Variable>
				<Variable Class="PlainVariable">
					<Id>1685440307013</Id>
					<Name><![CDATA[var_avg_planned_leadtime_variance_PS1]]></Name>
					<X>1470</X><Y>-300</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Properties SaveInSnapshot="true" Constant="false" AccessType="public" StaticVariable="false">
						<Type><![CDATA[double]]></Type>        
					</Properties>
				</Variable>
				<Variable Class="PlainVariable">
					<Id>1685452102258</Id>
					<Name><![CDATA[var_avg_planned_leadtime_mean_PS2]]></Name>
					<X>1470</X><Y>-330</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Properties SaveInSnapshot="true" Constant="false" AccessType="public" StaticVariable="false">
						<Type><![CDATA[double]]></Type>        
					</Properties>
				</Variable>
				<Variable Class="PlainVariable">
					<Id>1685452102265</Id>
					<Name><![CDATA[var_avg_planned_leadtime_variance_PS2]]></Name>
					<X>1470</X><Y>-360</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Properties SaveInSnapshot="true" Constant="false" AccessType="public" StaticVariable="false">
						<Type><![CDATA[double]]></Type>        
					</Properties>
				</Variable>
				<Variable Class="PlainVariable">
					<Id>1685452109002</Id>
					<Name><![CDATA[var_avg_planned_leadtime_mean_PS3]]></Name>
					<X>1470</X><Y>-390</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Properties SaveInSnapshot="true" Constant="false" AccessType="public" StaticVariable="false">
						<Type><![CDATA[double]]></Type>        
					</Properties>
				</Variable>
				<Variable Class="PlainVariable">
					<Id>1685452109004</Id>
					<Name><![CDATA[var_avg_planned_leadtime_variance_PS3]]></Name>
					<X>1474.693</X><Y>-419.63</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Properties SaveInSnapshot="true" Constant="false" AccessType="public" StaticVariable="false">
						<Type><![CDATA[double]]></Type>        
					</Properties>
				</Variable>
				<Variable Class="PlainVariable">
					<Id>1685452116482</Id>
					<Name><![CDATA[var_avg_planned_leadtime_mean_PS4]]></Name>
					<X>1470</X><Y>-450</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Properties SaveInSnapshot="true" Constant="false" AccessType="public" StaticVariable="false">
						<Type><![CDATA[double]]></Type>        
					</Properties>
				</Variable>
				<Variable Class="PlainVariable">
					<Id>1685452116484</Id>
					<Name><![CDATA[var_avg_planned_leadtime_variance_PS4]]></Name>
					<X>1470</X><Y>-480</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Properties SaveInSnapshot="true" Constant="false" AccessType="public" StaticVariable="false">
						<Type><![CDATA[double]]></Type>        
					</Properties>
				</Variable>
				<Variable Class="PlainVariable">
					<Id>1685618767280</Id>
					<Name><![CDATA[var_tardiness_open_orders_mean]]></Name>
					<X>1750</X><Y>-90</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Properties SaveInSnapshot="true" Constant="false" AccessType="public" StaticVariable="false">
						<Type><![CDATA[double]]></Type>        
					</Properties>
				</Variable>
				<Variable Class="PlainVariable">
					<Id>1685618798490</Id>
					<Name><![CDATA[var_tardiness_open_orders_variance]]></Name>
					<X>1750</X><Y>-110</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Properties SaveInSnapshot="true" Constant="false" AccessType="public" StaticVariable="false">
						<Type><![CDATA[double]]></Type>        
					</Properties>
				</Variable>
				<Variable Class="PlainVariable">
					<Id>1693921342446</Id>
					<Name><![CDATA[var_random_TTF]]></Name>
					<X>30</X><Y>2060</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Properties SaveInSnapshot="true" Constant="false" AccessType="public" StaticVariable="false">
						<Type><![CDATA[Random]]></Type>        
						<InitialValue Class="CodeValue">
							<Code><![CDATA[new Random(currentReplicationCount + 10006)]]></Code>
						</InitialValue>
					</Properties>
				</Variable>
				<Variable Class="PlainVariable">
					<Id>1693921367449</Id>
					<Name><![CDATA[var_random_TTR]]></Name>
					<X>30</X><Y>2090</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Properties SaveInSnapshot="true" Constant="false" AccessType="public" StaticVariable="false">
						<Type><![CDATA[Random]]></Type>        
						<InitialValue Class="CodeValue">
							<Code><![CDATA[new Random(currentReplicationCount + 10007)]]></Code>
						</InitialValue>
					</Properties>
				</Variable>
				<Variable Class="PlainVariable">
					<Id>1710419588549</Id>
					<Name><![CDATA[parentProdOrderId]]></Name>
					<X>500</X><Y>1900</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Properties SaveInSnapshot="true" Constant="false" AccessType="public" StaticVariable="false">
						<Type><![CDATA[int]]></Type>        
						<InitialValue Class="CodeValue">
							<Code><![CDATA[1]]></Code>
						</InitialValue>
					</Properties>
				</Variable>
				<Variable Class="PlainVariable">
					<Id>1710493064617</Id>
					<Name><![CDATA[varSystemWorkload]]></Name>
					<X>500</X><Y>1930</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Properties SaveInSnapshot="true" Constant="false" AccessType="public" StaticVariable="false">
						<Type><![CDATA[double]]></Type>        
						<InitialValue Class="CodeValue">
							<Code><![CDATA[0]]></Code>
						</InitialValue>
					</Properties>
				</Variable>
				<Variable Class="PlainVariable">
					<Id>1711011959217</Id>
					<Name><![CDATA[orderIdMPSCustomerOrders]]></Name>
					<X>1024</X><Y>511</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Properties SaveInSnapshot="true" Constant="false" AccessType="public" StaticVariable="false">
						<Type><![CDATA[int]]></Type>        
						<InitialValue Class="CodeValue">
							<Code><![CDATA[1]]></Code>
						</InitialValue>
					</Properties>
				</Variable>
				<Variable Class="PlainVariable">
					<Id>1712382625085</Id>
					<Name><![CDATA[var_demand_delivered]]></Name>
					<X>220</X><Y>-60</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Properties SaveInSnapshot="true" Constant="false" AccessType="public" StaticVariable="false">
						<Type><![CDATA[double]]></Type>        
					</Properties>
				</Variable>
				<Variable Class="PlainVariable">
					<Id>1712382627103</Id>
					<Name><![CDATA[var_demand_not_delivered]]></Name>
					<X>220</X><Y>-60</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Properties SaveInSnapshot="true" Constant="false" AccessType="public" StaticVariable="false">
						<Type><![CDATA[double]]></Type>        
					</Properties>
				</Variable>
				<Variable Class="PlainVariable">
					<Id>1712650227513</Id>
					<Name><![CDATA[EnergyPrices]]></Name>
					<X>360</X><Y>1890</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Properties SaveInSnapshot="true" Constant="false" AccessType="public" StaticVariable="false">
						<Type><![CDATA[List<EnergyPrice>]]></Type>        
						<InitialValue Class="CodeValue">
							<Code><![CDATA[new ArrayList();]]></Code>
						</InitialValue>
					</Properties>
				</Variable>
				<Variable Class="PlainVariable">
					<Id>1713759643584</Id>
					<Name><![CDATA[EnergyPricesPerMonth]]></Name>
					<X>360</X><Y>1860</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Properties SaveInSnapshot="true" Constant="false" AccessType="public" StaticVariable="false">
						<Type><![CDATA[List<EnergyPrice>]]></Type>        
						<InitialValue Class="CodeValue">
							<Code><![CDATA[new ArrayList();]]></Code>
						</InitialValue>
					</Properties>
				</Variable>
				<Variable Class="PlainVariable">
					<Id>1713778571565</Id>
					<Name><![CDATA[sumEnergyCosts]]></Name>
					<X>500</X><Y>1960</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Properties SaveInSnapshot="true" Constant="false" AccessType="public" StaticVariable="false">
						<Type><![CDATA[double]]></Type>        
						<InitialValue Class="CodeValue">
							<Code><![CDATA[0]]></Code>
						</InitialValue>
					</Properties>
				</Variable>
				<Variable Class="PlainVariable">
					<Id>1714058031141</Id>
					<Name><![CDATA[countEnergyPriceBlock]]></Name>
					<X>630</X><Y>2070</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Properties SaveInSnapshot="true" Constant="false" AccessType="public" StaticVariable="false">
						<Type><![CDATA[int]]></Type>        
						<InitialValue Class="CodeValue">
							<Code><![CDATA[0]]></Code>
						</InitialValue>
					</Properties>
				</Variable>
				<Variable Class="PlainVariable">
					<Id>1714058066698</Id>
					<Name><![CDATA[countCapacityFactorBlock]]></Name>
					<X>630</X><Y>2050</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Properties SaveInSnapshot="true" Constant="false" AccessType="public" StaticVariable="false">
						<Type><![CDATA[int]]></Type>        
						<InitialValue Class="CodeValue">
							<Code><![CDATA[0]]></Code>
						</InitialValue>
					</Properties>
				</Variable>
				<Variable Class="PlainVariable">
					<Id>1719828753905</Id>
					<Name><![CDATA[interArrivalTimes]]></Name>
					<X>360</X><Y>1910</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Properties SaveInSnapshot="true" Constant="false" AccessType="public" StaticVariable="false">
						<Type><![CDATA[List<InterArrivalTime>]]></Type>        
						<InitialValue Class="CodeValue">
							<Code><![CDATA[new ArrayList();]]></Code>
						</InitialValue>
					</Properties>
				</Variable>
				<Variable Class="PlainVariable">
					<Id>1719831093393</Id>
					<Name><![CDATA[var_random_InterArrivalTime]]></Name>
					<X>30</X><Y>2120</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Properties SaveInSnapshot="true" Constant="false" AccessType="public" StaticVariable="false">
						<Type><![CDATA[Random]]></Type>        
						<InitialValue Class="CodeValue">
							<Code><![CDATA[new Random(currentReplicationCount + 10008)]]></Code>
						</InitialValue>
					</Properties>
				</Variable>
				<Variable Class="PlainVariable">
					<Id>1719831364082</Id>
					<Name><![CDATA[var_random_OrderAmount]]></Name>
					<X>30</X><Y>2150</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Properties SaveInSnapshot="true" Constant="false" AccessType="public" StaticVariable="false">
						<Type><![CDATA[Random]]></Type>        
						<InitialValue Class="CodeValue">
							<Code><![CDATA[new Random(currentReplicationCount + 10009)]]></Code>
						</InitialValue>
					</Properties>
				</Variable>
				<Variable Class="PlainVariable">
					<Id>1719832033334</Id>
					<Name><![CDATA[var_random_Item_Selection]]></Name>
					<X>30</X><Y>2180</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Properties SaveInSnapshot="true" Constant="false" AccessType="public" StaticVariable="false">
						<Type><![CDATA[Random]]></Type>        
						<InitialValue Class="CodeValue">
							<Code><![CDATA[new Random(currentReplicationCount + 10010)]]></Code>
						</InitialValue>
					</Properties>
				</Variable>
				<Variable Class="PlainVariable">
					<Id>1719840996856</Id>
					<Name><![CDATA[var_random_DueDateVariablePart]]></Name>
					<X>30</X><Y>2210</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Properties SaveInSnapshot="true" Constant="false" AccessType="public" StaticVariable="false">
						<Type><![CDATA[Random]]></Type>        
						<InitialValue Class="CodeValue">
							<Code><![CDATA[new Random(currentReplicationCount + 10011)]]></Code>
						</InitialValue>
					</Properties>
				</Variable>
				<Variable Class="PlainVariable">
					<Id>1723006634821</Id>
					<Name><![CDATA[itemRelaxedStatusList]]></Name>
					<X>500</X><Y>1990</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>false</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Properties SaveInSnapshot="true" Constant="false" AccessType="public" StaticVariable="false">
						<Type><![CDATA[List<ItemRelaxedStatus>]]></Type>        
						<InitialValue Class="CodeValue">
							<Code><![CDATA[new ArrayList();]]></Code>
						</InitialValue>
					</Properties>
				</Variable>
				<Variable Class="PlainVariable">
					<Id>1723110893846</Id>
					<Name><![CDATA[var_safetyStockRelaxationStartPeriod]]></Name>
					<X>630</X><Y>2100</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Properties SaveInSnapshot="true" Constant="false" AccessType="public" StaticVariable="false">
						<Type><![CDATA[int]]></Type>        
						<InitialValue Class="CodeValue">
							<Code><![CDATA[1]]></Code>
						</InitialValue>
					</Properties>
				</Variable>
				<Variable Class="PlainVariable">
					<Id>1728483023294</Id>
					<Name><![CDATA[varSystemWorkloadComponents]]></Name>
					<X>630</X><Y>-250</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Properties SaveInSnapshot="true" Constant="false" AccessType="public" StaticVariable="false">
						<Type><![CDATA[double]]></Type>        
						<InitialValue Class="CodeValue">
							<Code><![CDATA[0]]></Code>
						</InitialValue>
					</Properties>
				</Variable>
				<Variable Class="PlainVariable">
					<Id>1730360787637</Id>
					<Name><![CDATA[var_consumed_setup_time_mean]]></Name>
					<X>1240</X><Y>-170</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Properties SaveInSnapshot="true" Constant="false" AccessType="public" StaticVariable="false">
						<Type><![CDATA[double]]></Type>        
					</Properties>
				</Variable>
				<Variable Class="PlainVariable">
					<Id>1730360813762</Id>
					<Name><![CDATA[var_consumed_setup_time_variance]]></Name>
					<X>1240</X><Y>-150</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Properties SaveInSnapshot="true" Constant="false" AccessType="public" StaticVariable="false">
						<Type><![CDATA[double]]></Type>        
					</Properties>
				</Variable>
				<Variable Class="PlainVariable">
					<Id>1731443697755</Id>
					<Name><![CDATA[replicationStatus]]></Name>
					<X>30</X><Y>1700</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Properties SaveInSnapshot="true" Constant="false" AccessType="public" StaticVariable="false">
						<Type><![CDATA[int]]></Type>        
						<InitialValue Class="CodeValue">
							<Code><![CDATA[0]]></Code>
						</InitialValue>
					</Properties>
				</Variable>
				<Variable Class="PlainVariable">
					<Id>1731785620828</Id>
					<Name><![CDATA[currentOverallCosts]]></Name>
					<X>360</X><Y>1940</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Properties SaveInSnapshot="true" Constant="false" AccessType="public" StaticVariable="false">
						<Type><![CDATA[double]]></Type>        
						<InitialValue Class="CodeValue">
							<Code><![CDATA[0]]></Code>
						</InitialValue>
					</Properties>
				</Variable>
				<Variable Class="PlainVariable">
					<Id>1732530292463</Id>
					<Name><![CDATA[fallbackOverallCostValueInklNotDelivered]]></Name>
					<X>500</X><Y>2020</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Properties SaveInSnapshot="true" Constant="false" AccessType="public" StaticVariable="false">
						<Type><![CDATA[double]]></Type>        
						<InitialValue Class="CodeValue">
							<Code><![CDATA[0]]></Code>
						</InitialValue>
					</Properties>
				</Variable>
				<Variable Class="Parameter">
					<Id>1639651241059</Id>
					<Name><![CDATA[list_ForecastInputParameter]]></Name>
					<X>1430</X><Y>1780</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Properties SaveInSnapshot="true" ModificatorType="STATIC">
						<Type><![CDATA[List<ForecastInputParameter>]]></Type>
						<UnitType><![CDATA[NONE]]></UnitType>
						<SdArray>false</SdArray>
						<DefaultValue Class="CodeValue">
							<Code><![CDATA[new ArrayList<ForecastInputParameter>()]]></Code>
						</DefaultValue>
						<ParameterEditor>
							<Id>1639651241057</Id>
							<EditorContolType>TEXT_BOX</EditorContolType>
							<MinSliderValue><![CDATA[0]]></MinSliderValue>
							<MaxSliderValue><![CDATA[100]]></MaxSliderValue>
							<DelimeterType>NO_DELIMETER</DelimeterType>
						</ParameterEditor>
					</Properties>                 
				</Variable>
				<Variable Class="Parameter">
					<Id>1643118215806</Id>
					<Name><![CDATA[optimizationParameters]]></Name>
					<X>1430</X><Y>1900</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Properties SaveInSnapshot="true" ModificatorType="STATIC">
						<Type><![CDATA[OptimizationParameter]]></Type>
						<UnitType><![CDATA[NONE]]></UnitType>
						<SdArray>false</SdArray>
						<ParameterEditor>
							<Id>1643118215804</Id>
							<EditorContolType>TEXT_BOX</EditorContolType>
							<MinSliderValue><![CDATA[0]]></MinSliderValue>
							<MaxSliderValue><![CDATA[100]]></MaxSliderValue>
							<DelimeterType>NO_DELIMETER</DelimeterType>
						</ParameterEditor>
					</Properties>                 
				</Variable>
				<Variable Class="Parameter">
					<Id>1643118692841</Id>
					<Name><![CDATA[simParams]]></Name>
					<X>1430</X><Y>1940</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Properties SaveInSnapshot="true" ModificatorType="STATIC">
						<Type><![CDATA[SimulationParameter]]></Type>
						<UnitType><![CDATA[NONE]]></UnitType>
						<SdArray>false</SdArray>
						<DefaultValue Class="CodeValue">
							<Code><![CDATA[new SimulationParameter()]]></Code>
						</DefaultValue>
						<ParameterEditor>
							<Id>1643118692839</Id>
							<EditorContolType>TEXT_BOX</EditorContolType>
							<MinSliderValue><![CDATA[0]]></MinSliderValue>
							<MaxSliderValue><![CDATA[100]]></MaxSliderValue>
							<DelimeterType>NO_DELIMETER</DelimeterType>
						</ParameterEditor>
					</Properties>                 
				</Variable>
				<Variable Class="Parameter">
					<Id>1643199330836</Id>
					<Name><![CDATA[stockBookings]]></Name>
					<X>1430</X><Y>1970</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Properties SaveInSnapshot="true" ModificatorType="STATIC">
						<Type><![CDATA[List<StockBooking>]]></Type>
						<UnitType><![CDATA[NONE]]></UnitType>
						<SdArray>false</SdArray>
						<DefaultValue Class="CodeValue">
							<Code><![CDATA[new ArrayList()]]></Code>
						</DefaultValue>
						<ParameterEditor>
							<Id>1643199330834</Id>
							<Label><![CDATA[stockBookings]]></Label>
							<EditorContolType>TEXT_BOX</EditorContolType>
							<MinSliderValue><![CDATA[0]]></MinSliderValue>
							<MaxSliderValue><![CDATA[100]]></MaxSliderValue>
							<DelimeterType>NO_DELIMETER</DelimeterType>
						</ParameterEditor>
					</Properties>                 
				</Variable>
				<Variable Class="Parameter">
					<Id>1643405334788</Id>
					<Name><![CDATA[MachineList]]></Name>
					<X>1430</X><Y>1810</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Properties SaveInSnapshot="true" ModificatorType="STATIC">
						<Type><![CDATA[List<MachineAgent>]]></Type>
						<UnitType><![CDATA[NONE]]></UnitType>
						<SdArray>false</SdArray>
						<DefaultValue Class="CodeValue">
							<Code><![CDATA[new ArrayList()]]></Code>
						</DefaultValue>
						<ParameterEditor>
							<Id>1643405334786</Id>
							<EditorContolType>TEXT_BOX</EditorContolType>
							<MinSliderValue><![CDATA[0]]></MinSliderValue>
							<MaxSliderValue><![CDATA[100]]></MaxSliderValue>
							<DelimeterType>NO_DELIMETER</DelimeterType>
						</ParameterEditor>
					</Properties>                 
				</Variable>
				<Variable Class="Parameter">
					<Id>1643640921074</Id>
					<Name><![CDATA[RoutingTimesList]]></Name>
					<X>1430</X><Y>1840</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Properties SaveInSnapshot="true" ModificatorType="STATIC">
						<Type><![CDATA[List<RoutingTimes>]]></Type>
						<UnitType><![CDATA[NONE]]></UnitType>
						<SdArray>false</SdArray>
						<DefaultValue Class="CodeValue">
							<Code><![CDATA[new ArrayList()]]></Code>
						</DefaultValue>
						<ParameterEditor>
							<Id>1643640921072</Id>
							<EditorContolType>TEXT_BOX</EditorContolType>
							<MinSliderValue><![CDATA[0]]></MinSliderValue>
							<MaxSliderValue><![CDATA[100]]></MaxSliderValue>
							<DelimeterType>NO_DELIMETER</DelimeterType>
						</ParameterEditor>
					</Properties>                 
				</Variable>
				<Variable Class="Parameter">
					<Id>1645764624224</Id>
					<Name><![CDATA[simulationResults]]></Name>
					<X>1430</X><Y>2000</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Properties SaveInSnapshot="true" ModificatorType="STATIC">
						<Type><![CDATA[List<Result>]]></Type>
						<UnitType><![CDATA[NONE]]></UnitType>
						<SdArray>false</SdArray>
						<DefaultValue Class="CodeValue">
							<Code><![CDATA[ new ArrayList<Result>()]]></Code>
						</DefaultValue>
						<ParameterEditor>
							<Id>1645764624222</Id>
							<EditorContolType>TEXT_BOX</EditorContolType>
							<MinSliderValue><![CDATA[0]]></MinSliderValue>
							<MaxSliderValue><![CDATA[100]]></MaxSliderValue>
							<DelimeterType>NO_DELIMETER</DelimeterType>
						</ParameterEditor>
					</Properties>                 
				</Variable>
				<Variable Class="Parameter">
					<Id>1646143437023</Id>
					<Name><![CDATA[forecastHistoryList]]></Name>
					<X>1430</X><Y>1750</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Properties SaveInSnapshot="true" ModificatorType="STATIC">
						<Type><![CDATA[List<ForecastHistory>]]></Type>
						<UnitType><![CDATA[NONE]]></UnitType>
						<SdArray>false</SdArray>
						<DefaultValue Class="CodeValue">
							<Code><![CDATA[new ArrayList<ForecastHistory>()]]></Code>
						</DefaultValue>
						<ParameterEditor>
							<Id>1646143437021</Id>
							<EditorContolType>TEXT_BOX</EditorContolType>
							<MinSliderValue><![CDATA[0]]></MinSliderValue>
							<MaxSliderValue><![CDATA[100]]></MaxSliderValue>
							<DelimeterType>NO_DELIMETER</DelimeterType>
						</ParameterEditor>
					</Properties>                 
				</Variable>
				<Variable Class="Parameter">
					<Id>1646819915337</Id>
					<Name><![CDATA[currentReplicationCount]]></Name>
					<X>280</X><Y>220</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Properties SaveInSnapshot="true" ModificatorType="STATIC">
						<Type><![CDATA[int]]></Type>
						<UnitType><![CDATA[NONE]]></UnitType>
						<SdArray>false</SdArray>
						<DefaultValue Class="CodeValue">
							<Code><![CDATA[1]]></Code>
						</DefaultValue>
						<ParameterEditor>
							<Id>1646819915335</Id>
							<EditorContolType>TEXT_BOX</EditorContolType>
							<MinSliderValue><![CDATA[0]]></MinSliderValue>
							<MaxSliderValue><![CDATA[100]]></MaxSliderValue>
							<DelimeterType>NO_DELIMETER</DelimeterType>
						</ParameterEditor>
					</Properties>                 
				</Variable>
				<Variable Class="Parameter">
					<Id>1647439124689</Id>
					<Name><![CDATA[varNormalSimulationRun]]></Name>
					<X>1430</X><Y>1720</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Properties SaveInSnapshot="true" ModificatorType="STATIC">
						<Type><![CDATA[boolean]]></Type>
						<UnitType><![CDATA[NONE]]></UnitType>
						<SdArray>false</SdArray>
						<DefaultValue Class="CodeValue">
							<Code><![CDATA[true]]></Code>
						</DefaultValue>
						<ParameterEditor>
							<Id>1647439124687</Id>
							<EditorContolType>CHECK_BOX</EditorContolType>
							<MinSliderValue><![CDATA[0]]></MinSliderValue>
							<MaxSliderValue><![CDATA[100]]></MaxSliderValue>
							<DelimeterType>NO_DELIMETER</DelimeterType>
						</ParameterEditor>
					</Properties>                 
				</Variable>
				<Variable Class="Parameter">
					<Id>1671771926561</Id>
					<Name><![CDATA[pcName]]></Name>
					<X>1430</X><Y>1870</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Properties SaveInSnapshot="true" ModificatorType="STATIC">
						<Type><![CDATA[String]]></Type>
						<UnitType><![CDATA[NONE]]></UnitType>
						<SdArray>false</SdArray>
						<ParameterEditor>
							<Id>1671771926559</Id>
							<EditorContolType>TEXT_BOX</EditorContolType>
							<MinSliderValue><![CDATA[0]]></MinSliderValue>
							<MaxSliderValue><![CDATA[100]]></MaxSliderValue>
							<DelimeterType>NO_DELIMETER</DelimeterType>
						</ParameterEditor>
					</Properties>                 
				</Variable>
				<Variable Class="Parameter">
					<Id>1679494083638</Id>
					<Name><![CDATA[numberScenarios]]></Name>
					<X>1430</X><Y>2030</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Properties SaveInSnapshot="true" ModificatorType="STATIC">
						<Type><![CDATA[int]]></Type>
						<UnitType><![CDATA[NONE]]></UnitType>
						<SdArray>false</SdArray>
						<DefaultValue Class="CodeValue">
							<Code><![CDATA[20]]></Code>
						</DefaultValue>
						<ParameterEditor>
							<Id>1679494083636</Id>
							<EditorContolType>TEXT_BOX</EditorContolType>
							<MinSliderValue><![CDATA[0]]></MinSliderValue>
							<MaxSliderValue><![CDATA[100]]></MaxSliderValue>
							<DelimeterType>NO_DELIMETER</DelimeterType>
						</ParameterEditor>
					</Properties>                 
				</Variable>
				<Variable Class="Parameter">
					<Id>1684474491035</Id>
					<Name><![CDATA[WriteResultsPerReplicationToDb]]></Name>
					<X>1430</X><Y>2060</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Properties SaveInSnapshot="true" ModificatorType="STATIC">
						<Type><![CDATA[int]]></Type>
						<UnitType><![CDATA[NONE]]></UnitType>
						<SdArray>false</SdArray>
						<DefaultValue Class="CodeValue">
							<Code><![CDATA[0]]></Code>
						</DefaultValue>
						<ParameterEditor>
							<Id>1684474491033</Id>
							<EditorContolType>TEXT_BOX</EditorContolType>
							<MinSliderValue><![CDATA[0]]></MinSliderValue>
							<MaxSliderValue><![CDATA[100]]></MaxSliderValue>
							<DelimeterType>NO_DELIMETER</DelimeterType>
						</ParameterEditor>
					</Properties>                 
				</Variable>
				<Variable Class="Parameter">
					<Id>1693988659951</Id>
					<Name><![CDATA[UseIdealCFLine]]></Name>
					<X>280</X><Y>250</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Properties SaveInSnapshot="true" ModificatorType="STATIC">
						<Type><![CDATA[int]]></Type>
						<UnitType><![CDATA[NONE]]></UnitType>
						<SdArray>false</SdArray>
						<DefaultValue Class="CodeValue">
							<Code><![CDATA[0]]></Code>
						</DefaultValue>
						<ParameterEditor>
							<Id>1693988659949</Id>
							<EditorContolType>TEXT_BOX</EditorContolType>
							<MinSliderValue><![CDATA[0]]></MinSliderValue>
							<MaxSliderValue><![CDATA[100]]></MaxSliderValue>
							<DelimeterType>NO_DELIMETER</DelimeterType>
						</ParameterEditor>
					</Properties>                 
				</Variable>
				<Variable Class="Parameter">
					<Id>1694008060246</Id>
					<Name><![CDATA[MachineFailure]]></Name>
					<X>280</X><Y>280</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Properties SaveInSnapshot="true" ModificatorType="STATIC">
						<Type><![CDATA[int]]></Type>
						<UnitType><![CDATA[NONE]]></UnitType>
						<SdArray>false</SdArray>
						<DefaultValue Class="CodeValue">
							<Code><![CDATA[0]]></Code>
						</DefaultValue>
						<ParameterEditor>
							<Id>1694008060244</Id>
							<EditorContolType>TEXT_BOX</EditorContolType>
							<MinSliderValue><![CDATA[0]]></MinSliderValue>
							<MaxSliderValue><![CDATA[100]]></MaxSliderValue>
							<DelimeterType>NO_DELIMETER</DelimeterType>
						</ParameterEditor>
					</Properties>                 
				</Variable>
				<Variable Class="Parameter">
					<Id>1715850640098</Id>
					<Name><![CDATA[replicationStart]]></Name>
					<X>280</X><Y>310</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Properties SaveInSnapshot="true" ModificatorType="STATIC">
						<Type><![CDATA[LocalDateTime]]></Type>
						<UnitType><![CDATA[NONE]]></UnitType>
						<SdArray>false</SdArray>
						<ParameterEditor>
							<Id>1715850640096</Id>
							<EditorContolType>TEXT_BOX</EditorContolType>
							<MinSliderValue><![CDATA[0]]></MinSliderValue>
							<MaxSliderValue><![CDATA[100]]></MaxSliderValue>
							<DelimeterType>NO_DELIMETER</DelimeterType>
						</ParameterEditor>
					</Properties>                 
				</Variable>
				<Variable Class="Parameter">
					<Id>1718555911406</Id>
					<Name><![CDATA[checkSingleOptimizationParameter]]></Name>
					<X>280</X><Y>190</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Properties SaveInSnapshot="true" ModificatorType="STATIC">
						<Type><![CDATA[int]]></Type>
						<UnitType><![CDATA[NONE]]></UnitType>
						<SdArray>false</SdArray>
						<ParameterEditor>
							<Id>1718555911404</Id>
							<EditorContolType>TEXT_BOX</EditorContolType>
							<MinSliderValue><![CDATA[0]]></MinSliderValue>
							<MaxSliderValue><![CDATA[100]]></MaxSliderValue>
							<DelimeterType>NO_DELIMETER</DelimeterType>
						</ParameterEditor>
					</Properties>                 
				</Variable>
			</Variables>
			<Connectors>
				<Connector>
					<Id>1640610689360</Id>
					<Name><![CDATA[connector12]]></Name>
					<X>740</X><Y>100</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>false</ShowLabel>
					<SourceEmbeddedObjectReference>
						<PackageName><![CDATA[simopt]]></PackageName>
						<ClassName><![CDATA[Main]]></ClassName>
						<ItemName><![CDATA[Late]]></ItemName>
					</SourceEmbeddedObjectReference>
					<SourceConnectableItemReference>
						<PackageName><![CDATA[com.anylogic.libraries.processmodeling]]></PackageName>
						<ClassName><![CDATA[Sink]]></ClassName>
						<ItemName><![CDATA[in]]></ItemName>
					</SourceConnectableItemReference>
					<TargetEmbeddedObjectReference>
						<PackageName><![CDATA[simopt]]></PackageName>
						<ClassName><![CDATA[Main]]></ClassName>
						<ItemName><![CDATA[selectOutputLateOrOnTime]]></ItemName>
					</TargetEmbeddedObjectReference>
					<TargetConnectableItemReference>
						<PackageName><![CDATA[com.anylogic.libraries.processmodeling]]></PackageName>
						<ClassName><![CDATA[SelectOutput]]></ClassName>
						<ItemName><![CDATA[outT]]></ItemName>
					</TargetConnectableItemReference>
					<Points>
						<Point><X>0</X><Y>0</Y></Point>
						<Point><X>-80</X><Y>40</Y></Point>
					</Points>
				</Connector>
				<Connector>
					<Id>1640610693205</Id>
					<Name><![CDATA[connector13]]></Name>
					<X>740</X><Y>180</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>false</ShowLabel>
					<SourceEmbeddedObjectReference>
						<PackageName><![CDATA[simopt]]></PackageName>
						<ClassName><![CDATA[Main]]></ClassName>
						<ItemName><![CDATA[Ontime]]></ItemName>
					</SourceEmbeddedObjectReference>
					<SourceConnectableItemReference>
						<PackageName><![CDATA[com.anylogic.libraries.processmodeling]]></PackageName>
						<ClassName><![CDATA[Sink]]></ClassName>
						<ItemName><![CDATA[in]]></ItemName>
					</SourceConnectableItemReference>
					<TargetEmbeddedObjectReference>
						<PackageName><![CDATA[simopt]]></PackageName>
						<ClassName><![CDATA[Main]]></ClassName>
						<ItemName><![CDATA[selectOutputLateOrOnTime]]></ItemName>
					</TargetEmbeddedObjectReference>
					<TargetConnectableItemReference>
						<PackageName><![CDATA[com.anylogic.libraries.processmodeling]]></PackageName>
						<ClassName><![CDATA[SelectOutput]]></ClassName>
						<ItemName><![CDATA[outF]]></ItemName>
					</TargetConnectableItemReference>
					<Points>
						<Point><X>0</X><Y>0</Y></Point>
						<Point><X>-60</X><Y>-20</Y></Point>
						<Point><X>-90</X><Y>-30</Y></Point>
					</Points>
				</Connector>
				<Connector>
					<Id>1640692908334</Id>
					<Name><![CDATA[connector]]></Name>
					<X>290</X><Y>140</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>false</ShowLabel>
					<SourceEmbeddedObjectReference>
						<PackageName><![CDATA[simopt]]></PackageName>
						<ClassName><![CDATA[Main]]></ClassName>
						<ItemName><![CDATA[enter]]></ItemName>
					</SourceEmbeddedObjectReference>
					<SourceConnectableItemReference>
						<PackageName><![CDATA[com.anylogic.libraries.processmodeling]]></PackageName>
						<ClassName><![CDATA[Enter]]></ClassName>
						<ItemName><![CDATA[out]]></ItemName>
					</SourceConnectableItemReference>
					<TargetEmbeddedObjectReference>
						<PackageName><![CDATA[simopt]]></PackageName>
						<ClassName><![CDATA[Main]]></ClassName>
						<ItemName><![CDATA[delay_CurrentCustomerOrders]]></ItemName>
					</TargetEmbeddedObjectReference>
					<TargetConnectableItemReference>
						<PackageName><![CDATA[com.anylogic.libraries.processmodeling]]></PackageName>
						<ClassName><![CDATA[Delay]]></ClassName>
						<ItemName><![CDATA[in]]></ItemName>
					</TargetConnectableItemReference>
					<Points>
						<Point><X>0</X><Y>0</Y></Point>
						<Point><X>160</X><Y>0</Y></Point>
					</Points>
				</Connector>
				<Connector>
					<Id>1641300260953</Id>
					<Name><![CDATA[connector15]]></Name>
					<X>210</X><Y>130</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>false</ShowLabel>
					<SourceEmbeddedObjectReference>
						<PackageName><![CDATA[simopt]]></PackageName>
						<ClassName><![CDATA[Main]]></ClassName>
						<ItemName><![CDATA[sink]]></ItemName>
					</SourceEmbeddedObjectReference>
					<SourceConnectableItemReference>
						<PackageName><![CDATA[com.anylogic.libraries.processmodeling]]></PackageName>
						<ClassName><![CDATA[Sink]]></ClassName>
						<ItemName><![CDATA[in]]></ItemName>
					</SourceConnectableItemReference>
					<TargetEmbeddedObjectReference>
						<PackageName><![CDATA[simopt]]></PackageName>
						<ClassName><![CDATA[Main]]></ClassName>
						<ItemName><![CDATA[sourceCustomerOrderAgent]]></ItemName>
					</TargetEmbeddedObjectReference>
					<TargetConnectableItemReference>
						<PackageName><![CDATA[com.anylogic.libraries.processmodeling]]></PackageName>
						<ClassName><![CDATA[Source]]></ClassName>
						<ItemName><![CDATA[out]]></ItemName>
					</TargetConnectableItemReference>
					<Points>
						<Point><X>0</X><Y>0</Y></Point>
						<Point><X>-140</X><Y>0</Y></Point>
					</Points>
				</Connector>
				<Connector>
					<Id>1670337850994</Id>
					<Name><![CDATA[connector1]]></Name>
					<X>490</X><Y>140</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>false</ShowLabel>
					<SourceEmbeddedObjectReference>
						<PackageName><![CDATA[simopt]]></PackageName>
						<ClassName><![CDATA[Main]]></ClassName>
						<ItemName><![CDATA[delay_CurrentCustomerOrders]]></ItemName>
					</SourceEmbeddedObjectReference>
					<SourceConnectableItemReference>
						<PackageName><![CDATA[com.anylogic.libraries.processmodeling]]></PackageName>
						<ClassName><![CDATA[Delay]]></ClassName>
						<ItemName><![CDATA[out]]></ItemName>
					</SourceConnectableItemReference>
					<TargetEmbeddedObjectReference>
						<PackageName><![CDATA[simopt]]></PackageName>
						<ClassName><![CDATA[Main]]></ClassName>
						<ItemName><![CDATA[selectOutputLateOrOnTime]]></ItemName>
					</TargetEmbeddedObjectReference>
					<TargetConnectableItemReference>
						<PackageName><![CDATA[com.anylogic.libraries.processmodeling]]></PackageName>
						<ClassName><![CDATA[SelectOutput]]></ClassName>
						<ItemName><![CDATA[in]]></ItemName>
					</TargetConnectableItemReference>
					<Points>
						<Point><X>0</X><Y>0</Y></Point>
						<Point><X>150</X><Y>0</Y></Point>
					</Points>
				</Connector>
			</Connectors>
			<Events>
				<Event>
					<Id>1641301680457</Id>
					<Name><![CDATA[warumUpTime]]></Name>
					<X>50</X><Y>410</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Properties TriggerType="timeout" Mode="occuresOnce">
						<Timeout Class="CodeUnitValue">
							<Code><![CDATA[1]]></Code>
							<Unit Class="TimeUnits"><![CDATA[DAY]]></Unit>
						</Timeout>
						<Rate Class="CodeUnitValue">
							<Code><![CDATA[1]]></Code>
							<Unit Class="RateUnits"><![CDATA[PER_DAY]]></Unit>
						</Rate>
						<OccurrenceAtTime>true</OccurrenceAtTime>
						<OccurrenceDate>1641369600000</OccurrenceDate>
						<OccurrenceTime Class="CodeUnitValue">
							<Code><![CDATA[0]]></Code>
							<Unit Class="TimeUnits"><![CDATA[DAY]]></Unit>
						</OccurrenceTime>
						<RecurrenceCode Class="CodeUnitValue">
							<Code><![CDATA[1]]></Code>
							<Unit Class="TimeUnits"><![CDATA[DAY]]></Unit>
						</RecurrenceCode>
						<Condition><![CDATA[false]]></Condition>
					</Properties>
				</Event>
				<Event>
					<Id>1731422119750</Id>
					<Name><![CDATA[checkOverallCostLimit]]></Name>
					<X>50</X><Y>390</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Properties TriggerType="timeout" Mode="cyclic">
						<Timeout Class="CodeUnitValue">
							<Code><![CDATA[1]]></Code>
							<Unit Class="TimeUnits"><![CDATA[DAY]]></Unit>
						</Timeout>
						<Rate Class="CodeUnitValue">
							<Code><![CDATA[1]]></Code>
							<Unit Class="RateUnits"><![CDATA[PER_DAY]]></Unit>
						</Rate>
						<OccurrenceAtTime>true</OccurrenceAtTime>
						<OccurrenceDate>1641369600000</OccurrenceDate>
						<OccurrenceTime Class="CodeUnitValue">
							<Code><![CDATA[simParams.getOverallCostsFirstOccurenceTime()]]></Code>
							<Unit Class="TimeUnits"><![CDATA[DAY]]></Unit>
						</OccurrenceTime>
						<RecurrenceCode Class="CodeUnitValue">
							<Code><![CDATA[simParams.getOverallCostsCheckRecurrenceTime()]]></Code>
							<Unit Class="TimeUnits"><![CDATA[DAY]]></Unit>
						</RecurrenceCode>
						<Condition><![CDATA[false]]></Condition>
					</Properties>
					<Action><![CDATA[traceln("---- Check Overallcosts Limit at Time " +  time() + " -------------");

   	double overallcosts_inkl_not_Delivered = Result.overallcosts_inkl_not_Delivered(
   	KPI.GetInventorySales(this, time()),
   	KPI.GetInventoryComponents(this,time()),
   	KPI.GetWIPSales(this,time()), 
    KPI.GetWIPComponents(this,time()),
    KPI.GetTardinessMean(this,time()),
    KPI.GetDemandDelivered(this,time()),
    KPI.GetTardinessOpenOrdersMean(this,time()),
    KPI.GetDemandNotDelivered(this,time()),
    false,this);

	fallbackOverallCostValueInklNotDelivered = 0;
	traceln("Fallback in event: " + fallbackOverallCostValueInklNotDelivered );	


traceln("----------> Tmp Current overall Costs Incl Not Delivered: " + overallcosts_inkl_not_Delivered);

    	
if(overallcosts_inkl_not_Delivered > simParams.getOverallCostsLimit()) {
	fallbackOverallCostValueInklNotDelivered = overallcosts_inkl_not_Delivered;
 	traceln("Fallback in event: " + fallbackOverallCostValueInklNotDelivered );
	replicationStatus = -99;
	getEngine().stop();
	traceln("!!!!!!!!!!!!!!!!!!!!!!!!!!!  Stop Limit reached!!!!");
	
}

]]></Action>
				</Event>
				<Event>
					<Id>1732781669792</Id>
					<Name><![CDATA[writeConsumedSetupTimeToFile]]></Name>
					<ExcludeFromBuild>true</ExcludeFromBuild>
					<X>50</X><Y>390</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Properties TriggerType="timeout" Mode="cyclic">
						<Timeout Class="CodeUnitValue">
							<Code><![CDATA[1]]></Code>
							<Unit Class="TimeUnits"><![CDATA[DAY]]></Unit>
						</Timeout>
						<Rate Class="CodeUnitValue">
							<Code><![CDATA[1]]></Code>
							<Unit Class="RateUnits"><![CDATA[PER_DAY]]></Unit>
						</Rate>
						<OccurrenceAtTime>true</OccurrenceAtTime>
						<OccurrenceDate>1641369600000</OccurrenceDate>
						<OccurrenceTime Class="CodeUnitValue">
							<Code><![CDATA[0]]></Code>
							<Unit Class="TimeUnits"><![CDATA[DAY]]></Unit>
						</OccurrenceTime>
						<RecurrenceCode Class="CodeUnitValue">
							<Code><![CDATA[100]]></Code>
							<Unit Class="TimeUnits"><![CDATA[DAY]]></Unit>
						</RecurrenceCode>
						<Condition><![CDATA[false]]></Condition>
					</Properties>
					<Action><![CDATA[
StringBuilder text = new StringBuilder();

text.append(time() + ";");

String filePath = "C:\\1\\consumedSetupTime.txt";

//consumed setup time mean and variance
productionOrders.stream().filter(e-> e.getCreatedAt()>=simParams.getWarumUpTime()
&& e.getStatus()== ProductionOrder.PRODUCTION_ORDER_STATUS_PROCESSED).
forEach(e-> stat_consumed_setup_time.
add(e.getConsumedSetupTime()));

var_consumed_setup_time_mean = stat_consumed_setup_time.mean();
var_consumed_setup_time_variance = stat_consumed_setup_time.variance();

text.append(var_consumed_setup_time_mean + ";");
text.append(var_consumed_setup_time_variance + ";");            
text.append(System.lineSeparator());

//Tools.appendTextToFile(filePath, text.toString());

]]></Action>
				</Event>
			</Events>
			<DynamicEvents>
				<DynamicEventClass>
					<Id>1648198042660</Id>
					<Name><![CDATA[dynEvnt]]></Name>
					<X>50</X><Y>450</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Parameter>
						<Name><![CDATA[of]]></Name>
						<Type><![CDATA[OrderFuture]]></Type>
					</Parameter>
					<Parameter>
						<Name><![CDATA[root]]></Name>
						<Type><![CDATA[Main]]></Type>
					</Parameter>
					<Action><![CDATA[
CustomerOrder o = new CustomerOrder(new double[simParams.getDemandVariationHorizon()]);

o = OrderFuture.GenerateCustomerOrder(of, time(), orderId,
var_random_CustomerRequiredOrderAmount,
 var_random_CustomerRequiredLeadtime, simParams,
 mrpFileNameSuffix,bom,root
 );
 
orderId++;

customerOrders.add(o);

CustomerOrderAgent newOrder = new CustomerOrderAgent();
		newOrder.customerOrderFromAgent = o;
		newOrder.markParametersAreSet();																	
		enter.take(newOrder);

double irt = OrderFuture.GetInterArrivalTime(of, time(), var_random_arrivalRate, mrpFileNameSuffix);
//traceln(irt + " irt");
create_dynEvnt(irt, DAY,of,this);

if(simParams.getApplyConWip() == SimulationParameter.APPLY_CONWIP) {
        					ConWip conWip = new ConWip();
        					conWip.ApplyConWipPlanning(bom, simParams, null, null,root,time());        				         				         					
}
         	         	         	         	         			 

]]></Action>
				</DynamicEventClass>
				<DynamicEventClass>
					<Id>1719830485034</Id>
					<Name><![CDATA[dynEventInterArrivalTime]]></Name>
					<X>50</X><Y>480</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Parameter>
						<Name><![CDATA[root]]></Name>
						<Type><![CDATA[Main]]></Type>
					</Parameter>
					<Action><![CDATA[
CustomerOrder o = new CustomerOrder(new double[simParams.getDemandVariationHorizon()]);

customerOrders.add(o);

CustomerOrderAgent newOrder = new CustomerOrderAgent();
		newOrder.customerOrderFromAgent = o;
		newOrder.markParametersAreSet();																	
		enter.take(newOrder);


int selectedItem = ItemSelector();

Item iSelected = items.stream().filter(e -> e.getItem() == selectedItem).findFirst().orElse(null);
newOrder.customerOrderFromAgent.setItem(iSelected);
newOrder.customerOrderFromAgent.setOrderId(orderId);
orderId++;

InterArrivalTime iAtObj = interArrivalTimes.stream().filter(e -> e.getItem() == selectedItem).findFirst().orElse(null);

//get quantity
//double sigmaOrderAmount = iAtObj.getMeanOrderAmount() * iAtObj.getVarCoeOrderAmount();
double oderAmount = Distribution.GetDistributionValue("LOGNORMAL", iAtObj.getMeanOrderAmount(), 
iAtObj.getVarCoeOrderAmount(),"Interarrival Time ", var_random_OrderAmount, mrpFileNameSuffix,0,0);

newOrder.customerOrderFromAgent.setQuantity(Math.round(oderAmount));

//get due date
//double varCoeDueDate = iAtObj.getMeanLeadTimeVariablePart() * iAtObj.getVarCoeLeadTimeVariablePart();
double dueDateVariablePart = Distribution.GetDistributionValue("LOGNORMAL", iAtObj.getMeanLeadTimeVariablePart(), 
iAtObj.getVarCoeLeadTimeVariablePart(),"Interarrival Time ", var_random_DueDateVariablePart, mrpFileNameSuffix,0,0);

newOrder.customerOrderFromAgent.setCreatedAt(time());
newOrder.customerOrderFromAgent.setDueDate(Math.round(time()+iAtObj.getLeadTimeFixPart() + dueDateVariablePart));

//traceln("new Customer Order:");
//traceln(CustomerOrder.GetCSVString(newOrder.customerOrderFromAgent));

//get new time to start the event
//double sigmaIaT = simParams.getMeanInterArrivalTime() * simParams.getVarCoeInterArrivalTime();
double iAt = Distribution.GetDistributionValue("LOGNORMAL", simParams.getMeanInterArrivalTime(), 
simParams.getVarCoeInterArrivalTime(),"Interarrival Time ", var_random_InterArrivalTime, mrpFileNameSuffix,0,0);

//traceln("new event call should be at: " + iAt);
create_dynEventInterArrivalTime(iAt, DAY,this);	

if(simParams.getApplyConWip() == SimulationParameter.APPLY_CONWIP) {
        					ConWip conWip = new ConWip();
        					conWip.ApplyConWipPlanning(bom, simParams, null, null,root,time());        				         				         					
}
         	         	         	         	         			 ]]></Action>
				</DynamicEventClass>
			</DynamicEvents>
			<Functions>
				<Function AccessType="default" StaticFunction="false">
					<ReturnModificator>VOID</ReturnModificator>
					<ReturnType><![CDATA[double]]></ReturnType>
					<Id>1644646550124</Id>
					<Name><![CDATA[SimOptimization]]></Name>
					<ExcludeFromBuild>true</ExcludeFromBuild>
					<X>950</X><Y>2000</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Body><![CDATA[
if (simParams.getApplyOptimization() == 1) {

GsonBuilder builder  = new GsonBuilder();
builder.excludeFieldsWithoutExposeAnnotation();
Gson gson = builder.create();  		

traceln("###################################################################################################################");
traceln("############################################ Time = " + time()  + " ################################################");

    String simParamsJson = gson.toJson(simParams);
    
    String bomMatrixJson = new Gson().toJson(bomMatrix);   
    String resourcesString = new Gson().toJson(resources);    
    String resourceConsumptionJson = new Gson().toJson(resourceConsumption);
    
    String routingJson = gson.toJson(routings);        
    
    List < Item > itemsSorted = items.stream().filter(e -> e.getType()
        .equalsIgnoreCase(Item.ITEM_TYPE_COMPONENT)).sorted(Comparator.comparingInt(Item::getItem)).collect(Collectors.toList());

		/*
        itemsSorted = itemsSorted.stream()
            .sorted(new Comparator<Item>() {
                @Override
                public int compare(Item o1, Item o2) {
                    if (o1.getItem() == 40) return -1;
                    if (o2.getItem() == 40) return 1;
                    if (o1.getItem() >= 30 && o1.getItem() <= 33 && o2.getItem() >= 20 && o2.getItem() <= 27) return -1;
                    if (o2.getItem() >= 30 && o2.getItem() <= 33 && o1.getItem() >= 20 && o1.getItem() <= 27) return 1;
                    return Integer.compare(o1.getItem(), o2.getItem());
                }
            })
            .collect(Collectors.toList());
			*/

    List < Item > endItems = items.stream().filter(e -> e.getType()
        .equalsIgnoreCase(Item.ITEM_TYPE_SALES)).sorted(Comparator.comparingInt(Item::getItem)).collect(Collectors.toList());

    itemsSorted.addAll(endItems);    
    
    componentAvailabilityProcessing = ComponentAvailability.SetComponentAvailability(itemsSorted,simParams, productionOrders, stockBookings, time(), ProductionOrder.PRODUCTION_ORDER_STATUS_PROCESSING, true, customerOrders);        
    componentAvailabilityReleased = ComponentAvailability.SetComponentAvailability(itemsSorted,simParams, productionOrders, stockBookings, time(), ProductionOrder.PRODUCTION_ORDER_STATUS_RELEASED, true, customerOrders);        
	
	//Auftrag wird rollierend immer wieder bergeben, wenn in Frozen zone ist. Gleiche Struktur wie Component avaialiaby		
	//auf den start schauen (planned start)
	//wenn innerhalb in der frozen zone dann 
	// es wird nie den selben aufrag geben, daher muss auf simulation seite nicht kontollierte werden, ob ein auftrag zu lschen ist.
	
	if(simParams.getFrozenZone() >= 0){		
	    ordersInFrozenZone = ComponentAvailability.GetOrdersInFrozenZone(itemsSorted, simParams, productionOrders, time());
    }
    
    DBQueries db = new DBQueries();        
    List<ResourceCapacity> resourceCapacityNew = db.GetResourceCapacity(simParams);

	resourceCapacityNew = ResourceCapacity.SetAvailableCapacity(resources, simParams, productionOrders, resourceCapacityNew, routings, items, stockBookings, time(), RoutingTimesList);

    String componentAvailabilityProcessingJson = new Gson().toJson(componentAvailabilityProcessing);
    String componentAvailabilityReleasedJson = new Gson().toJson(componentAvailabilityReleased);    
    String ordersInFrozenZoneJson = new Gson().toJson(ordersInFrozenZone);    
    String resourceCapacityJson = new Gson().toJson(resourceCapacityNew);
    String itemsSortedJson = gson.toJson(itemsSorted);    

    String orderFutureJson = "";

    traceln("simparams: " + simParamsJson);
    traceln("bomMatrix: " + bomMatrixJson);
    traceln("components sorted: " + itemsSortedJson);
    traceln("resource consumption: " + resourceConsumptionJson);
    traceln("resource capacity: " + resourceCapacityJson);
    traceln("component availability processing and released: " + componentAvailabilityProcessingJson);
    traceln("component availability released: " + componentAvailabilityReleasedJson);
    traceln("orders in frozen Zone: " + ordersInFrozenZoneJson);
    traceln("Engine state: " + getEngine().getState());
    traceln("Routing: " + routingJson);
    traceln("Number Scenarios: " + numberScenarios);
    traceln("Setup Carry Over: " + simParams.getSetupCarryOver());
    traceln("Scenario Updates: " + simParams.getAvoidScenarioUpdates());    
            
    traceln("Fixed Periods for stochastic flexible optimizimer: " + simParams.getFixedPeriods());

    double residual = time() % simParams.getPlanningFrequency();

    traceln("----> Before OPTIMIZATION time " + time() + " horizon " + simParams.getSimOptHorizon() + " Residual " + residual + " PlanningFrequency " + simParams.getPlanningFrequency());
			
    if (simParams.getDemandGeneration().equalsIgnoreCase(SimulationParameter.DEMAND_GENERATION_FORECAST) &&
        residual == 0
    ) {
        traceln("************************* In Optimization AND Demands for Optimization at time " + time() + " ****************************************");
        traceln(CustomerOrder.GetCSVHeader(";"));
        //todo Zusammenfassen von Bedarfen nach Periode und Item
        //todo DemandVariation = Error von Forecast evolution
        List <OrderFuture> forecastDemand = new ArrayList();

        //todo sotierung nach item und periode checken	
        List <OrderFuture> demandAll = new ArrayList();
        List <CustomerOrder> relevantOrders = customerOrders.stream().filter(e -> e.getDueDate() >= time() && e.getDueDate() <= 
        (time() + simParams.getSimOptHorizon() + MRP.PERIOD_BALANCING)).collect(Collectors.toList());                
                							
		long countEndItems = items.stream().filter(e -> e.getType().equalsIgnoreCase(Item.ITEM_TYPE_SALES)).count();								
				
			int itemIndex = 0;
	        for (Item endItem : endItems) {	        	

	            for (int i = 0; i < simParams.getSimOptHorizon(); i++) {
	                OrderFuture item = new OrderFuture();
	                int check = i;
	                item.setItem(endItem);
					
					//Info: -1 so that the demand matches to period 12 as i(check) is from 0 to 11
	                CustomerOrder order = relevantOrders.stream().filter(e -> e.getItem().getItem() == item.getItem().getItem() && 
	                ((int) e.getDueDate() - (int) time()) == check).findAny().orElse(null);
	
	                if (order != null) {
	                    item.setEOrderAmount(Math.round(order.getQuantity()));	                    
	                    item.setId(order.getOrderId());
	                    item.setPreviousOrderQty(order.getPreviousOrderQty());
	                    
	                    item.setVarOrderAmount(demandVariationMeanArray[order.getItem().getDemandVariationIndex()][i]);                     	
	                    //item.setVarOrderAmount(0);                     	
	                    item.setMeanDemand(order.getMeanDemand());	  
	                                      
	                    item.setLongtermForecast(order.getLongtermForecast());
	                }
					
	                item.setPeriod(check);
	                demandAll.add(item);	                
	            }//i
	            itemIndex ++;
	        }//item	
	    	    	    
        orderFutureJson = gson.toJson(demandAll);

    } else {
        orderFutureJson = gson.toJson(orderFuture);
    }
    
    traceln("Demand: " + orderFutureJson);

    //Each time optimization is called we set the component availability based on the productionorders
		
    if (residual == 0) {
	traceln("Json for SimOpt: "+ simParamsJson);
        pyCommunicator.run("import simopt.Starter as Starter",
            "x = Starter.Starter('SimOpt-Input.txt'," +
            time() +
            ",'" + simParamsJson + "','" +
            orderFutureJson + "','" +
            bomMatrixJson + "','" +
            itemsSortedJson + "','" +
            resourceConsumptionJson + "','" +
            resourceCapacityJson + "','" +
            componentAvailabilityProcessingJson + "','" +
            componentAvailabilityReleasedJson + "','" + 
            ordersInFrozenZoneJson +  "','" + 
            numberScenarios + "','" +           
            simParams.getSetupCarryOver() + "','" +            
            simParams.getAvoidScenarioUpdates() + "','" +            
            simParams.getFixedPeriods() +          
            "')",
            "myString = x.myOptimizer()");

        //return handing from optimization					
        String optResult = pyCommunicator.runResults("myString").getFeedback(String.class);

        optResult = optResult.replace("],", ";");
        optResult = optResult.replace("]", "");
        optResult = optResult.replace("[", "");
        optResult = optResult.replace(" ", "");

        String[] m = optResult.split(";");
			
        productionOrders.removeIf(e -> e.getPlannedStart() > (time() - simParams.getPlanningFrequency()) + 1 + simParams.getFrozenZone());		
		
        for (int i = 0; i < m.length; i++) {
            String[] j = m[i].split(",");
            for (int k = 0; k < j.length; k++) {
                double quantity = Double.parseDouble(j[k]);

                if (quantity > 0.5) {
                    ProductionOrder order = new ProductionOrder();
                    
                    Item item = itemsSorted.get(i);
                    order.setOrderId(prodOrderId++);
                    order.setItem(item);
                                           
                    int minimumRoutingStep = Routing.GetMinimumStep(routings, order.getItem() , simParams);
					int maximumRoutingStep = Routing.GetMaximumStep(routings, order.getItem() , simParams);
			
					order.setMinimumRoutingStep(minimumRoutingStep);
					order.setMaximumRoutingStep(maximumRoutingStep);			
					order.setCurrentRoutingStep(minimumRoutingStep);                                                                                                    
                    
                    int qtyy = 0;                   
                    
                    int qtyyInt = (int) Double.parseDouble(j[k]);                   
                    
                    double qtyyDbl = Double.parseDouble(j[k]);                   
                    
                    if(qtyyDbl - qtyyInt < 0.0001){
						qtyy = (int) Math.round(Double.parseDouble(j[k]));                   
                    }else{
                    
                    	qtyy = (int) Math.ceil(Double.parseDouble(j[k]));                   
                    }                                        
                                        
                    order.setQuantity(qtyy);
                    order.setQuantityOriginal(Double.parseDouble(j[k]));
                                        
                    order.setCreatedAt(time());
                    order.setPlannedStart(time() + k);
                    order.setPlannedEnd(time() + k + item.getLeadTime());
                    
                    Routing routingObject = routings.stream().filter(e -> e.getItem().getItem() == order.getItem().getItem()).findFirst().get();			
					order.setRouting(routingObject);
					order.setPlannedCapacity(Routing.GetPlannedCapacityPerItem(routings, order.getItem(),
					 simParams, order));
					
					order.setStatus(ProductionOrder.PRODUCTION_ORDER_STATUS_UNPROCESSED);
                    productionOrders.add(order);
                    
					//traceln("r " + order.getOrderId() + " " + order.getRouting().getDescription() + " " + order.getRouting().getResource());
					
                    ProductionOrderAgent a = new ProductionOrderAgent();
                    a.prodOrderFromAgent = order;
                }
            }
        }

		//}
		
	    traceln("Production Orders BEFORE removing ~~~~~~~~~~~~~~~~~~~~~~~");		
        traceln(ProductionOrder.GetCSVHeader());
        for(ProductionOrder o : productionOrders){
			traceln(ProductionOrder.GetCSVString(o));
    	}			
    				
        productionOrders.removeIf(e -> e.getPlannedStart() > time()+simParams.getPlanningFrequency()-1 + simParams.getFrozenZone());

    }    
    
    
    //traceln("Production Orders AFTER removing ~~~~~~~~~~~~~~~~~~~~~~~");
    //traceln(ProductionOrder.GetCSVHeader());
	//for(ProductionOrder o : productionOrders){
	//	traceln(ProductionOrder.GetCSVString(o));
	//}
    
    
    //initiate production, continously independent of the planning frequency.
    for (Item item: items.stream().collect(Collectors.toList())){
        boolean skipRelease = false;

	List<ProductionOrder> selectedProdOrders = productionOrders.stream().filter(e->
    	((e.getPlannedStart() <= time() && e.getStatus() == ProductionOrder.PRODUCTION_ORDER_STATUS_UNPROCESSED) ||
    	 e.getStatus() == ProductionOrder.PRODUCTION_ORDER_WAITING_FOR_MATERIAL)
     && e.getItem().getItem() == item.getItem() && e.getPlannedStart() <= time()).sorted(Comparator.comparing(ProductionOrder::getOrderId)).collect(Collectors.toList());

for (ProductionOrder order : selectedProdOrders){

	if(!skipRelease){

            List <StockBooking> materialAvailable = StockBooking.CheckMaterialAvailability(order, stockBookings, bom, time());
                order.setStatus(ProductionOrder.PRODUCTION_ORDER_STATUS_RELEASED);
                stockBookings.addAll(materialAvailable);
              
               
                if(materialAvailable.size() > 0){
                	order.setStatus(ProductionOrder.PRODUCTION_ORDER_STATUS_RELEASED);
                	                           order.setMaterialAvailableDate(time());
                }else{
                	order.setStatus(ProductionOrder.PRODUCTION_ORDER_WAITING_FOR_MATERIAL);
                	                           order.setMaterialAvailableDate(time());
                	                           skipRelease=true;
                }                                 
                
                materialAvailable.stream().filter(e -> e.getItem().getType().equals(Item.ITEM_TYPE_COMPONENT)).
                forEach(e -> {
                	varSystemWIPComponents = varSystemWIPComponents + e.getQuantity();
		            statSystemWIPComponents.add(varSystemWIPComponents, time());
                	}
                );
                
            materialAvailable.clear();

            ProductionOrderAgent newOrder = new ProductionOrderAgent();
            newOrder.prodOrderFromAgent = order;
            newOrder.markParametersAreSet();

            //Pass Productionorder to Material Release
            // Material Release decides, if a production order can be passed to machine processing
            materialRelease.enter_from_MRP.take(newOrder);
            }//if
        } //for
    } //for
    
}
]]></Body>
				</Function>
				<Function AccessType="default" StaticFunction="false">
					<ReturnModificator>VOID</ReturnModificator>
					<ReturnType><![CDATA[double]]></ReturnType>
					<Id>1644648206844</Id>
					<Name><![CDATA[MRPStandard]]></Name>
					<X>950</X><Y>2020</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Body><![CDATA[//always run MRP after demands are generated
boolean createRPSProdOrders = false;

if (time() >= simParams.getWarumUpTime() && simParams.getProdStageStatistics() == 1) {
  FunctionUpdatePSStatistic();
}

if (simParams.getApplyMRP() == 1) {
  mrpCount = mrpCount + simParams.getMRPPlanningHorizon();
  mrpTable.clear();

  List <MRP> relaxedMRPItems = new ArrayList();
  
  for (int bomLevel = 0; bomLevel <= maxBomLevel.getLevel(); bomLevel++) {

    relaxedMRPItems.clear();

    List <MRP> mrpTMP = (MRP.ComputeGrossRequirements(simParams, customerOrders, time(), items,
      stockBookings, mrpCount, productionOrders, bomLevel, bom, mrpTable));

    mrpTable.addAll(mrpTMP);

    mrpTable = (MRP.Netting(simParams.getMRPPlanningHorizon(), mrpTable, time(), simParams, relaxedMRPItems, itemRelaxedStatusList, this));
    mrpTable = (MRP.LotSizing(simParams.getMRPPlanningHorizon(), mrpTable, time(), simParams, relaxedMRPItems, itemRelaxedStatusList, this));

    //SafetyStock Relaxation
    if (simParams.getOptimizationType().equalsIgnoreCase(SimulationParameter.ALGORITHMIC_OPTIMIZATION_TYPE_SAFETY_STOCK_RELAXATION)) {

      for (int var_safetyStockRelaxationStartPeriod = 1; var_safetyStockRelaxationStartPeriod <= simParams.getMRPPlanningHorizon(); var_safetyStockRelaxationStartPeriod++) {
        //if items with relaxed safety stock are passed back netting and lotsizing is done again
        relaxedMRPItems = MRPExtensions.Capacitating(mrpTable, time(), simParams, bomLevel,
          productionOrders, routings,
          resourceCapacity, 1, mrpFileNameSuffix, itemRelaxedStatusList, this);

        traceln("Size of relaxed Items List: " + relaxedMRPItems.size());
        //if(relaxedMRPItems.size() > 0){

        for (MRP mI: relaxedMRPItems) {
          MRP.GetCSVString(mI);
          ForecastHistory.AppendToFile(MRPExtensions.FILENAME_MRP_ITEMS_RELAXED + mrpFileNameSuffix + ".csv",
            MRP.GetCSVString(mI),
            MRP.class,
            MRPExtensions.LOG_MRP_ITEMS_RELAXED_DELETE_OUTPUTFILE);
        }

        //if the planned order receipts are set to 0 due to relaxation with sarety. no more netting, this can add new lots.
        //we are not allowed to create new lots. just add the relaxed safety to the next period.
        mrpTable = (MRP.Netting(simParams.getMRPPlanningHorizon(), mrpTable, time(), simParams, relaxedMRPItems, itemRelaxedStatusList, this));

        mrpTable = (MRP.LotSizing(simParams.getMRPPlanningHorizon(), mrpTable, time(), simParams, relaxedMRPItems, itemRelaxedStatusList, this));
      } // for mrp horizon			
      //}// if			
    } //for

    //ClearingFunctions
    if (simParams.getApplyClearingFunctions() && time() >= simParams.getClearingFunctionsInitPhase() && bomLevel >= 0) {
      //if(bomLevel < maxBomLevel.getLevel()){       	
      //If have changed the bom level from 0,1,2.... and set the items to purchase.
      //if(bomLevel <= 2 ){       	
      //perform CF release plan computation

      //Routing firstRoutingItem = main.routings.stream().filter(e -> e.getItem().getItem() == firstBomItem.getItem()).findFirst().get();	
      int bomLevelTmp = bomLevel;
      List <Resource> bomLevelResources = resources.stream().filter(e -> e.getStageNumber() == bomLevelTmp + 1).collect(Collectors.toList());;

      for (Resource r: bomLevelResources) {
        //Attention: If an nullpointer Exception occurs, the order of the machines is the problem, it should start with
        //1 and then 2 .... should be fixed in a further development cycle.						 
        traceln("*************************************** " + simParams.getExternalCapacity());

        if (simParams.getExternalCapacity() == 0) {
          cplex.Function_ClearingFunction_without_ct(StreamEx.of(mrpTMP).filter(e -> e.getItem().getRouting().getResource()
            .equalsIgnoreCase(r.getName())).distinct(MRP::getItem).toList(), bomLevel, r, mrpFileNameSuffix);
        } else if (simParams.getExternalCapacity() == 1 || simParams.getROFormulation() == 1) {
          cplex.Function_ClearingFunction(StreamEx.of(mrpTMP).filter(e -> e.getItem().getRouting().getResource()
            .equalsIgnoreCase(r.getName())).distinct(MRP::getItem).toList(), bomLevel, r, mrpFileNameSuffix);

          traceln("Applied CF with external capacity");

        } else if (simParams.getExternalCapacity() == 2 && simParams.getALCFormulation() == 1) {
          cplex.Function_ClearingFunction_ACF(StreamEx.of(mrpTMP).filter(e -> e.getItem().getRouting().getResource()
            .equalsIgnoreCase(r.getName())).distinct(MRP::getItem).toList(), bomLevel, r, mrpFileNameSuffix);
        }
      }

      mrpTable = MRP.TimePhasing(simParams.getMRPPlanningHorizon(), mrpTable, time(),
        simParams, MRP.SCHEDULING_TYPE_RELEASE_PLAN, productionOrders,
        StreamEx.of(mrpTMP).distinct(MRP::getItem).toList());
      //}

    } else if (simParams.getApplyConWip() == SimulationParameter.APPLY_CONWIP_MPS) {

      mrpTable = MRP.TimePhasing(simParams.getMRPPlanningHorizon(), mrpTable, time(),
        simParams, MRP.SCHEDULING_TYPE_BACKWARD, productionOrders,
        StreamEx.of(mrpTMP).distinct(MRP::getItem).toList());

    } else {
      mrpTable = (MRP.TimePhasing(simParams.getMRPPlanningHorizon(), mrpTable, time(), simParams,
        MRP.SCHEDULING_TYPE_BACKWARD, productionOrders, null));
    }

    if (simParams.getApplyRPS() == SimulationParameter.APPLY_RPS) {
      //bei rps legen wir gleich prod order an mit start und end datum	
      List <ProductionOrder> newProdOrders = RPS.CheckInventoryPositions(simParams, customerOrders, time(), items, stockBookings, bomLevel,
        bom, productionOrders, prodOrderId, mrpFileNameSuffix, routings);
      productionOrders.addAll(newProdOrders);
      prodOrderId = productionOrders.size() + 1;
    }
  }
  
  if (simParams.getApplyClearingFunctions() && time() >= simParams.getClearingFunctionsInitPhase()) {
    productionOrders.removeIf(e -> (e.getPlannedStart()
    							 - MRP.PERIOD_BALANCING) > time());

    if (true) {
      traceln("Production Orders from Optmization FOR SIMULATION AFTER REMOVIG PlannedStart > time " + time());
      traceln(ProductionOrder.GetCSVHeader());

      for (ProductionOrder order: productionOrders) {
        traceln(ProductionOrder.GetCSVString(order));
      }
      traceln("**************************");
    }

    //Function_OrderRelease("");
    Function_OrderRelease(SimulationParameter.RELEASE_ORIGIN_CF);
    
    /*
    	// only for components mrp
    	List<MRP> filteredList = mrpTable.stream()
    .filter(e -> e.getItem().getItem() >= 200)
    .collect(Collectors.toList());
    
        List <ProductionOrder> newProdOrders = MRP.CreateProductionOrders(filteredList, time(), prodOrderId, 
        routings, simParams, items);
        productionOrders.addAll(newProdOrders);
        prodOrderId = productionOrders.size() + 1;
        Function_OrderRelease("MRP");
    */
    
    
    
    
  } else {
    if (simParams.getApplyConWip() == 0 || simParams.getApplyRPS() == 1 || simParams.getApplyConWip() == 
    SimulationParameter.APPLY_CONWIP_MPS) {
      if (simParams.getApplyConWip() == SimulationParameter.APPLY_CONWIP_MPS) {
        ConWip conWip = new ConWip();
        conWip.CreateProductionOrdersConWip(mrpTable, time(), prodOrderId, routings, simParams, items, this);
        Function_OrderRelease("MRP");
      } else {
        List <ProductionOrder> newProdOrders = MRP.CreateProductionOrders(mrpTable, time(), prodOrderId, routings, simParams, items);
        productionOrders.addAll(newProdOrders);
        prodOrderId = productionOrders.size() + 1;
        Function_OrderRelease("MRP");
      }
    }
  }

  if (MRP.WRITE_MRP_TABLE_TO_FILE_TABLE_FORM) {
    for (MRP obj: mrpTable) {
      ForecastHistory.AppendToFile(MRP.FILENAME_MRP_TABLE + "_" + mrpFileNameSuffix + ".csv", MRP.GetCSVString(obj), MRP.class, MRP.MRP_DELETE_OUTPUTFILE);
    }
  }

  if (simParams.getWriteMRPTableToFile()) {
    MRP.GetMRPTableCSVString(mrpTable, time(), mrpFileNameSuffix, stockBookings);
  }
}]]></Body>
				</Function>
				<Function AccessType="default" StaticFunction="false">
					<ReturnModificator>VOID</ReturnModificator>
					<ReturnType><![CDATA[double]]></ReturnType>
					<Id>1656992676167</Id>
					<Name><![CDATA[Function_OrderReleaseItemBased]]></Name>
					<X>950</X><Y>1960</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Parameter>
						<Name><![CDATA[ReleaseOrigin]]></Name>
						<Type><![CDATA[String]]></Type>
					</Parameter>
					<Body><![CDATA[Tools t = new Tools();


List<Integer> itemsNoLongerCheck = new ArrayList<>();
itemsNoLongerCheck.clear();


/*The release time can have dramatical impacts on the order when wich production order is processed by the machine agent */


 List<Item> selectedItems = items.stream().filter(e -> e.getType().equalsIgnoreCase(Item.ITEM_TYPE_SALES) || e.getType().equalsIgnoreCase(Item.ITEM_TYPE_COMPONENT)).collect(Collectors.toList());
 
 if(ReleaseOrigin.equalsIgnoreCase("Machine")){
 	selectedItems = items.stream().filter(e -> e.getType().equalsIgnoreCase(Item.ITEM_TYPE_SALES)).collect(Collectors.toList());					
 }

t.log("Release Origin " + ReleaseOrigin + " Time: " + time(), Tools.LogReleases);

productionOrders.stream().filter(e -> e.getStatus() == ProductionOrder.PRODUCTION_ORDER_STATUS_UNPROCESSED ||
    	 e.getStatus() == ProductionOrder.PRODUCTION_ORDER_WAITING_FOR_MATERIAL).forEach(e -> e.setReleaseChecked(0)); 
    	  
for (Item item: selectedItems){
        boolean skipRelease = false;

	List<ProductionOrder> selectedProdOrders = new ArrayList();
	
	if(ReleaseOrigin.equalsIgnoreCase(SimulationParameter.RELEASE_ORIGIN_CF)){
		selectedProdOrders = productionOrders.stream().filter(e->
    	((e.getStatus() == ProductionOrder.PRODUCTION_ORDER_STATUS_UNPROCESSED) ||
    	 e.getStatus() == ProductionOrder.PRODUCTION_ORDER_WAITING_FOR_MATERIAL)
         && e.getPlannedStart() <= time() && e.getReleaseChecked() == 0).
		sorted(Comparator.comparing(ProductionOrder::getPlannedEnd)).collect(Collectors.toList());	
	}
	else if(ReleaseOrigin.equalsIgnoreCase("MRP")){
		selectedProdOrders = productionOrders.stream().filter(e -> (e.getStatus() == ProductionOrder.PRODUCTION_ORDER_STATUS_UNPROCESSED ||
		e.getStatus() == ProductionOrder.PRODUCTION_ORDER_WAITING_FOR_MATERIAL && e.getReleaseChecked() == 0)		
		).sorted(Comparator.comparing(ProductionOrder::getPlannedEnd)).collect(Collectors.toList());	     
			     
	}else if(ReleaseOrigin.equalsIgnoreCase("Machine")){
		selectedProdOrders = productionOrders.stream().filter(e -> (e.getStatus() == ProductionOrder.PRODUCTION_ORDER_STATUS_UNPROCESSED || 
		e.getStatus() == ProductionOrder.PRODUCTION_ORDER_WAITING_FOR_MATERIAL) &&		
		 e.getPlannedStart() <= time() && e.getReleaseChecked() == 0
		 ).sorted(Comparator.comparing(ProductionOrder::getPlannedEnd)).collect(Collectors.toList());	
	}
	else if(ReleaseOrigin.equalsIgnoreCase("Optimization")){
		selectedProdOrders = productionOrders.stream().filter(e -> e.getPlannedStart() <= time() 
	    && e.getStatus() == ProductionOrder.PRODUCTION_ORDER_STATUS_UNPROCESSED && e.getReleaseChecked() == 0
     	).sorted(Comparator.comparing(ProductionOrder::getOrderId)).collect(Collectors.toList());	
    } 	
 	else if(ReleaseOrigin.equalsIgnoreCase(SimulationParameter.RELEASE_ORIGIN_CONWIP)){
		selectedProdOrders = productionOrders.stream().filter(e -> e.getPlannedStart() <= time() 
    	&& e.getStatus() == ProductionOrder.PRODUCTION_ORDER_STATUS_UNPROCESSED && e.getReleaseChecked() == 0
 		).sorted(Comparator.comparing(ProductionOrder::getPlannedStart)).collect(Collectors.toList());	
	}else if(ReleaseOrigin.equalsIgnoreCase(SimulationParameter.RELEASE_ORIGIN_CONWIP_FROM_MACHINE)){
		selectedProdOrders = productionOrders.stream().filter(e -> (e.getStatus() == ProductionOrder.PRODUCTION_ORDER_STATUS_UNPROCESSED || 
		e.getStatus() == ProductionOrder.PRODUCTION_ORDER_WAITING_FOR_MATERIAL) &&		
		 e.getPlannedStart() <= time() && e.getReleaseChecked() == 0
		 ).sorted(Comparator.comparing(ProductionOrder::getActualStart)).collect(Collectors.toList());	
	}//for	

  //if the release for one item is skipped the remaining orders of the same items must be skipped.
  //but until enough material is available release for the same item is allowed
  
  for (ProductionOrder order: selectedProdOrders.stream().filter(e -> e.getItem().getItem() == item.getItem()).collect(Collectors.toList())) {
	t.log("+++++++", Tools.LogReleases);
	t.log("OrderId Release Check: " + order.getOrderId() + " item " + order.getItem().getItem() + " startdate " + order.getPlannedStart(), Tools.LogReleases);		
	
	
	//test if there exists an order of another item running with an earlier enddate, if yes take it,
	//otherwise process with the current entry of the item.
	AtomicReference<ProductionOrder> orderRef = new AtomicReference<>(order);
	 //selectedProdOrers.stream().filter(e -> e.getItem().getItem() != item.getItem()).
	  //if(ReleaseOrigin.equalsIgnoreCase(SimulationParameter.RELEASE_ORIGIN_CF)){	
	  traceln("In release check apply clearing functions: " + simParams.getApplyClearingFunctions());
	 
	  if(simParams.getApplyClearingFunctions()) {  
							
			// Optional<ProductionOrder> alternativeOrderExists = selectedProdOrders.stream()
            //.filter(e -> orderRef.get().getPlannedEnd() > e.getPlannedEnd() &&
             //e.getRouting().getResource() == orderRef.get().getRouting().getResource())
            //.findFirst();
            
            traceln("Consider machine: " + orderRef.get().getRouting().getResource());
            
            //items which run on the same machine
			List<Routing> itemsOnSameMachine = routings.stream()
    		.filter(e -> e.getResource().equalsIgnoreCase(orderRef.get().getRouting().getResource()))
    		.collect(Collectors.toList());
    		
    		for(Routing r : itemsOnSameMachine){
    			traceln(r.toString());
    		}
           
            traceln("All Orders");
            traceln(ProductionOrder.GetCSVHeader());
            for(ProductionOrder o : selectedProdOrders) {
            	traceln(ProductionOrder.GetCSVString(o));
            }                       
            
            //now we have to check if these items require the same machine
            
            t.log("Test for alternative order",Tools.LogReleases);
            traceln(ProductionOrder.GetCSVString(order));
            
             
             List<ProductionOrder> filteredProductionOrders = selectedProdOrders.stream()
    		.filter(po -> itemsOnSameMachine.stream()
            .anyMatch(r -> r.getItem().getItem() == po.getItem().getItem())) // Assuming ProductionOrder has getItem()
    		.sorted(Comparator.comparing(ProductionOrder::getPlannedEnd)) 
    		.collect(Collectors.toList());
             
			// Get the first (earliest) element from the sorted list
			Optional<ProductionOrder> earliestProductionOrder = filteredProductionOrders.stream().findFirst();
			
			// Check if the element exists and process it accordingly
			if (earliestProductionOrder.isPresent()) {
			    ProductionOrder earliestOrder = earliestProductionOrder.get();
			    // Now you can work with earliestOrder, the one with the earliest plannedEndDate
			    System.out.println("Earliest Production Order: " + earliestOrder);
			    t.log("Found alternative production order: ",Tools.LogReleases);
            	traceln(ProductionOrder.GetCSVString(earliestProductionOrder.get()));
    			order = earliestProductionOrder.get();
			} else {
			    System.out.println("No production orders found.");
			}
            
            traceln(ProductionOrder.GetCSVHeader());
            for(ProductionOrder o : filteredProductionOrders){
            	traceln(ProductionOrder.GetCSVString(o));
            }
		
		traceln("Process production order: " + order.getOrderId());	
		
		}
		
		order.setReleaseChecked(1);
		
		if (!skipRelease && !itemsNoLongerCheck.stream().anyMatch(n -> n == orderRef.get().getItem().getItem())) {
		    List<StockBooking> materialAvailable = StockBooking.CheckMaterialAvailability(order, stockBookings, bom, time());
		
		    if (materialAvailable.size() > 0) {
		        order.setStatus(ProductionOrder.PRODUCTION_ORDER_STATUS_RELEASED);
		        order.setMaterialAvailableDate(time());
		    } else {
		        order.setStatus(ProductionOrder.PRODUCTION_ORDER_WAITING_FOR_MATERIAL);
		        order.setMaterialAvailableDate(time());
		        skipRelease = true;
		        itemsNoLongerCheck.add(order.getItem().getItem());
		        break;
		    }
		
		    stockBookings.addAll(materialAvailable);
		
		    materialAvailable.stream().filter(e -> e.getItem().getType().equals(Item.ITEM_TYPE_COMPONENT))
		        .forEach(e -> {
		            varSystemWIPComponents += e.getQuantity();
		            statSystemWIPComponents.add(varSystemWIPComponents, time());
		        });
		
		    materialAvailable.clear();
		
		    ProductionOrderAgent newOrder = new ProductionOrderAgent();
		    newOrder.prodOrderFromAgent = order;
		    newOrder.markParametersAreSet();
		
		    // Pass Productionorder to Material Release
		    // Material Release decides, if a production order can be passed to machine processing
		    t.log("************* Release Order: " + order.getOrderId(), Tools.LogReleases);
		    materialRelease.enter_from_MRP.take(newOrder);
		}
      } //for
    } //for
    
    
    ]]></Body>
				</Function>
				<Function AccessType="default" StaticFunction="false">
					<ReturnModificator>VOID</ReturnModificator>
					<ReturnType><![CDATA[double]]></ReturnType>
					<Id>1664457696693</Id>
					<Name><![CDATA[Function_UpdateDemandVariationArray]]></Name>
					<X>950</X><Y>1940</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Parameter>
						<Name><![CDATA[customerOrder]]></Name>
						<Type><![CDATA[CustomerOrder]]></Type>
					</Parameter>
					<Body><![CDATA[
demandVariationCount[customerOrder.getItem().getDemandVariationIndex()]++;

double[] variationArray = new double[simParams.getDemandVariationHorizon()];

for(int i=1; i < simParams.getDemandVariationHorizon(); i++){
	
	double variation = Math.pow(
	(customerOrder.getPreviousDemandValues()[0]-
	customerOrder.getPreviousDemandValues()[i]),2);		
	variationArray[i] = variation;				
	
		double runningMean = (
		((demandVariationCount[customerOrder.getItem().getDemandVariationIndex()]-1)*
			demandVariationMeanArray[customerOrder.getItem().getDemandVariationIndex()][i]) + variation)
			/demandVariationCount[customerOrder.getItem().getDemandVariationIndex()];

		//traceln(demandVariationCount[customerOrder.getItem().getDemandVariationIndex()]-1 + "*" +demandVariationMeanArray[customerOrder.getItem().getDemandVariationIndex()][i] + "+" + variation + "/" + demandVariationCount[customerOrder.getItem().getDemandVariationIndex()]);
		//traceln(runningMean);
		
		if(time() <= simParams.getWarumUpTime()){					
			demandVariationMeanArray[customerOrder.getItem().getDemandVariationIndex()][i] = runningMean;			
		}
}

customerOrder.setDemandVariation(variationArray);

]]></Body>
				</Function>
				<Function AccessType="default" StaticFunction="false">
					<ReturnModificator>VOID</ReturnModificator>
					<ReturnType><![CDATA[double]]></ReturnType>
					<Id>1666332775428</Id>
					<Name><![CDATA[Function_ApplyOptimizationParameters]]></Name>
					<X>950</X><Y>2040</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Body><![CDATA[DBQueries db = new DBQueries();

/************************************* CF Experiments ***********************************************/

if (simParams.getOptimizationType().equalsIgnoreCase("CF1") && (!varNormalSimulationRun || checkSingleOptimizationParameter > 0)){
	traceln("Setting Optimization Parameters for " + optimizationParameters.getDescription());
	
	if((int)optimizationParameters.getX000() == 1){		
			simParams.setApplyClearingFunctions(true);
	}else{
			simParams.setApplyClearingFunctions(false);
	}

	//note: at the moment the same routing values are used for end items and components
	for(Routing r : routings){
		
		// sales items
		if(r.getItem().getType().equalsIgnoreCase(Item.ITEM_TYPE_SALES)) {				

			r.setEProcessingTime(optimizationParameters.getX001());
			r.setSProcessingTime(optimizationParameters.getX015());
						
			if(optimizationParameters.getX002() == 0){
				r.setDistProcessingTime(Distribution.DISTRIBUTION_TYPE_DETERMINISTIC);
			}else if(optimizationParameters.getX002() == 1){
				r.setDistProcessingTime(Distribution.DISTRIBUTION_TYPE_LOGNORMAL);
			}											

			r.setESetupTime(optimizationParameters.getX003());			
						
			if(optimizationParameters.getX004() == 0){
				r.setDistSetupTime(Distribution.DISTRIBUTION_TYPE_DETERMINISTIC);
			}else if(optimizationParameters.getX004() == 1){
				r.setDistSetupTime(Distribution.DISTRIBUTION_TYPE_LOGNORMAL);
			}																	
		}// end end item
		
		// components
		if(r.getItem().getType().equalsIgnoreCase(Item.ITEM_TYPE_COMPONENT)) {				

			r.setEProcessingTime(optimizationParameters.getX001());
			r.setSProcessingTime(optimizationParameters.getX016());
						
			if(optimizationParameters.getX002() == 0){
				r.setDistProcessingTime(Distribution.DISTRIBUTION_TYPE_DETERMINISTIC);
			}else if(optimizationParameters.getX002() == 1){
				r.setDistProcessingTime(Distribution.DISTRIBUTION_TYPE_LOGNORMAL);
			}											

			r.setESetupTime(optimizationParameters.getX003());			
						
			if(optimizationParameters.getX004() == 0){
				r.setDistSetupTime(Distribution.DISTRIBUTION_TYPE_DETERMINISTIC);
			}else if(optimizationParameters.getX004() == 1){
				r.setDistSetupTime(Distribution.DISTRIBUTION_TYPE_LOGNORMAL);
			}																	
																																		
		}// end components
		
	}

		
	for(Item i : items){		
			//note: at the moment the same leadtime and fop is used.
			if(i.getType().equalsIgnoreCase(Item.ITEM_TYPE_SALES)) {				
				i.setLeadTime((int)optimizationParameters.getX009());
				i.setFOPPeriod((int)optimizationParameters.getX010());
			}
							
			if(i.getType().equalsIgnoreCase(Item.ITEM_TYPE_COMPONENT)) {	
				i.setLeadTime((int)optimizationParameters.getX009());
				i.setFOPPeriod((int)optimizationParameters.getX010());			
			}						
			
			if(i.getItem() == 10 || i.getItem() == 20)	
				i.setSafetyStock((int)optimizationParameters.getX017());
				
			if(i.getItem() == 11 || i.getItem() == 21)	
				i.setSafetyStock((int)optimizationParameters.getX017());				
	}
	
	simParams.setLeadTimeHorizon((int)optimizationParameters.getX011());	
	simParams.setForecastScenario((int)optimizationParameters.getForecastScenario());										
	
	//set demands / forecast			
	Forecast f = forecastMasterdata.stream().filter(e -> e.getItem().getItem() == 10).findFirst().get();
	f.setLongtermForecast((int)optimizationParameters.getX012());
	f.setFrequency((int)optimizationParameters.getX014());
		
	f = forecastMasterdata.stream().filter(e -> e.getItem().getItem() == 11).findFirst().get();
	f.setLongtermForecast((int)optimizationParameters.getX013());
	f.setFrequency((int)optimizationParameters.getX014());
}
/************************************* OR extendend Experiments ***********************************************/
	else if(simParams.getOptimizationType().equals("ORExtended") && (!varNormalSimulationRun || checkSingleOptimizationParameter > 0)){
		Function_ApplyOptimizationParametersORExtended();
	}
/************************************* WSC22 Experiments ***********************************************/
	else if(simParams.getOptimizationType().equals("WSC22") && (!varNormalSimulationRun || checkSingleOptimizationParameter > 0)){
		Function_ApplyOptimizationParametersWSC22();
	}	
/************************************* SIMOPT Experiments ***********************************************/
	
else if ((simParams.getName().equalsIgnoreCase("SimOptV1") || simParams.getName().equalsIgnoreCase("SimOptV2") 
|| simParams.getName().equalsIgnoreCase("SimOptV3") || simParams.getName().equalsIgnoreCase("SimOptV4")) && (!varNormalSimulationRun || checkSingleOptimizationParameter > 0)){
	Function_ApplyOptimizationParametersSimOpt();
}
/************************************* WSC23 Experiments ***********************************************/	
else if(simParams.getOptimizationType().equals("WSC23") && (!varNormalSimulationRun || checkSingleOptimizationParameter > 0)){
	Function_ApplyOptimizationParametersWSC23();
}	
/************************************* CF Production Stage Utilizations Experiments ***********************************************/	
else if(simParams.getOptimizationType().equals("CFProdStageExperiments") && (!varNormalSimulationRun || checkSingleOptimizationParameter > 0)){
	Function_ApplyOptimizationParametersCFProdStages();
}	
/************************************* ASIM23 Experiments ***********************************************/	
else if(simParams.getOptimizationType().equals("ASIM23") && (!varNormalSimulationRun || checkSingleOptimizationParameter > 0)){
	Function_ApplyOptimizationParametersASIM23();
}
/************************************* WSC24_1 Production Planning Experiments ***********************************************/	
else if(simParams.getOptimizationType().equals("WSC24_1") && (!varNormalSimulationRun || checkSingleOptimizationParameter > 0)){
	Function_ApplyOptimizationParametersWSC24_1();
}	
/************************************* WSC24_2 Energy Based Release Planning ***********************************************/	
else if(simParams.getOptimizationType().equals("WSC24_2") && (!varNormalSimulationRun || checkSingleOptimizationParameter > 0)){
	Function_ApplyOptimizationParametersWSC24_2();
}	
/************************************* WSC24 Extension Production Planning ***********************************************/	
else if(simParams.getOptimizationType().equals("WSC24Extension") && (!varNormalSimulationRun || checkSingleOptimizationParameter > 0)){
	Function_ApplyOptimizationParametersWSC24Extension();
}	

]]></Body>
				</Function>
				<Function AccessType="default" StaticFunction="false">
					<ReturnModificator>VOID</ReturnModificator>
					<ReturnType><![CDATA[double]]></ReturnType>
					<Id>1666526678608</Id>
					<Name><![CDATA[FunctionCalculateKPIs]]></Name>
					<X>950</X><Y>1980</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Body><![CDATA[//Customer Demand
//validiert 6.11.22
customerOrders.stream().
filter(e->(e.getStatus() == CustomerOrder.ORDER_STATUS_DELAYED_AND_BOOKED 
|| e.getStatus() == CustomerOrder.ORDER_STATUS_FINISHED || e.getStatus() == CustomerOrder.ORDER_STATUS_DELAYED) 
&& e.getCreatedAt()>= simParams.getWarumUpTime()).
forEach(e->stat_demand.add(e.getQuantity()));
var_demand = stat_demand.sum();
traceln("Demand (Total all sales items): " + var_demand);

customerOrders.stream().
filter(e->(e.getStatus() == CustomerOrder.ORDER_STATUS_DELAYED_AND_BOOKED 
|| e.getStatus() == CustomerOrder.ORDER_STATUS_FINISHED) 
&& e.getCreatedAt()>= simParams.getWarumUpTime()).
forEach(e->stat_demand_delivered.add(e.getQuantity()));
var_demand_delivered = stat_demand_delivered.sum();
traceln("Demand (Total all sales items independent of delivery status): " + var_demand_delivered);


customerOrders.stream().
filter(e->(e.getStatus() == CustomerOrder.ORDER_STATUS_DELAYED) 
&& e.getCreatedAt()>= simParams.getWarumUpTime()).
forEach(e->stat_demand_not_delivered.add(e.getQuantity()));
var_demand_not_delivered = stat_demand_not_delivered.sum();
traceln("Demand (Total all sales items Not delivered): " + var_demand_not_delivered);


//number customer orders -> Only those which are "delivered" late, delayed or on time and 
//not only the generated number of customer ordeers
//validiert 6.11.22
var_number_of_customer_orders = stat_demand.count();
traceln("Number Customer Orders: " + var_number_of_customer_orders);

//Service Level
//validated 7.11.22 -> has own statistic element, filled by sink of customer orders.
//I have checked it also with the output excel and came to the same results.
traceln("Service Level: " + StatisticServiceLevel.mean() + " for "+ StatisticServiceLevel.count() + " customer orders");

//Tardiness
//validated 7.11.22
//Wir wollen alle Auftrge daher raus genommen -> && e.getActualEnd() > e.getDueDate()
customerOrders.stream().
filter(e->e.getStatus() != CustomerOrder.ORDER_STATUS_UNPROCESSED 
&& e.getCreatedAt()>=simParams.getWarumUpTime()).
forEach(e->stat_tardiness.add(max(0,e.getActualEnd()-e.getDueDate())));

var_tardiness_mean = stat_tardiness.mean();
traceln("Tardiness (Mean): " + var_tardiness_mean);
var_tardiness_variance = stat_tardiness.variance();
traceln("Tardiness (Variance): " + var_tardiness_variance);

//Tardiness Open Customer Orders
//Customer orders which are late at simulation end are evulated. Others with due date in the future meaning later
//than simulation end time are not considered

customerOrders.stream().
filter(e->e.getStatus() == CustomerOrder.ORDER_STATUS_DELAYED
&& e.getCreatedAt()>=simParams.getWarumUpTime()).
forEach(e->stat_tardiness_open_orders.add(max(0,time()-e.getDueDate())));

var_tardiness_open_orders_mean = stat_tardiness_open_orders.mean();
traceln("Tardiness Late Orders (Mean): " + var_tardiness_open_orders_mean);
var_tardiness_open_orders_variance = stat_tardiness_open_orders.variance();
traceln("Tardiness Late Orders (Variance): " + var_tardiness_open_orders_variance);

//Lateness
//validated 7.11.22
customerOrders.stream().
filter(e-> e.getStatus() != CustomerOrder.ORDER_STATUS_UNPROCESSED
&& e.getCreatedAt()>=simParams.getWarumUpTime()).
forEach(e->stat_lateness.add(e.getActualEnd()-e.getDueDate()));

var_lateness_mean = stat_lateness.mean();
traceln("Lateness (Mean): " + var_lateness_mean);
var_lateness_variance = stat_lateness.variance();
traceln("Lateness (Variance): " + var_lateness_variance);


//Lead_time_sales
//validated 8.11.22
productionOrders.stream().filter(e->e.getStatus()== 
ProductionOrder.PRODUCTION_ORDER_STATUS_PROCESSED 
&& e.getItem().getType().equals(Item.ITEM_TYPE_SALES) 
&& e.getCreatedAt()>=simParams.getWarumUpTime()).
forEach(e->stat_leadtime_sales.add(e.getActualEnd()-e.getPlannedStart()));

var_leadtime_sales_mean = stat_leadtime_sales.mean();
traceln("Lead time sales items (Mean): " + var_leadtime_sales_mean);

var_leadtime_sales_variance = stat_leadtime_sales.variance();
traceln("Lead time sales items (Variance): " + var_leadtime_sales_variance);

//Lead_time_components
//validated 8.11.22
productionOrders.stream().filter(e->e.getStatus()== 
ProductionOrder.PRODUCTION_ORDER_STATUS_PROCESSED 
&& e.getItem().getType().equals(Item.ITEM_TYPE_COMPONENT) 
&& e.getCreatedAt()>=simParams.getWarumUpTime()).
forEach(e->stat_leadtime_components.add(e.getActualEnd()-e.getPlannedStart()));

var_leadtime_components_mean=stat_leadtime_components.mean();
traceln("Lead time components (Mean): " + var_leadtime_components_mean);

var_leadtime_components_variance =stat_leadtime_components.variance();
traceln("Lead time components (Variance): " + var_leadtime_components_variance);

//todo: lead time per BOM level and for component and sales items 
//todo: Leadtime compoents nicht ber alle dispostufen machen, sondern je dispostufe auswertbar machen (wunsch)

//inventory sales items
//todo:siehe grafik klaus, es muss noch die Menge von der letzten Buchung in der WarumUp Time einflieen
//validiert 9.11.2022
for(Item item : items.stream().filter(e->e.getType().equals(Item.ITEM_TYPE_SALES)).collect(Collectors.toList())){

	stockBookings.stream().filter(e->e.getItem().getType().equals(Item.ITEM_TYPE_SALES) 
	&& e.getTime()>=simParams.getWarumUpTime()
	&& e.getItem().getItem() == item.getItem()).
	forEach(
		e-> stat_inventory_sales.
		add(e.getNewInventory() , e.getTime()));		
		
	var_inventory_sales = var_inventory_sales +
	stat_inventory_sales.integral(Double.valueOf(simParams.getSimulationRunTime()));	
		
	stat_inventory_sales.reset();
}

traceln("Inventory sales items (1): " + var_inventory_sales);

//Inventory_components
//validiert 9.11.2022
for(Item item : items.stream().filter(e->e.getType().equals(Item.ITEM_TYPE_COMPONENT)).collect(Collectors.toList())){
	stockBookings.stream().filter(e->e.getItem().getType().equals(Item.ITEM_TYPE_COMPONENT) 
	&& e.getTime()>=simParams.getWarumUpTime()
	&& e.getItem().getItem() == item.getItem()).
	forEach(e-> stat_inventory_components.
	add(e.getNewInventory() , e.getTime()));
	
	var_inventory_components = var_inventory_components +
	stat_inventory_components.integral(Double.valueOf(simParams.getSimulationRunTime()));	
	
	stat_inventory_components.reset();
}

traceln("Inventory Components (2): " + var_inventory_components);


//WIP_sales 
//max wird verwendet, um Auftrge korrekt zur WarmUpTime abzugrenzen bzw. zu bercksichtigen.
//validated 9.11.2022
productionOrders.stream().
filter(e->e.getItem().getType().equals(Item.ITEM_TYPE_SALES) 
&& e.getActualEnd()>=simParams.getWarumUpTime() 
&& e.getStatus()== ProductionOrder.PRODUCTION_ORDER_STATUS_PROCESSED).
forEach(e-> stat_wip_sales.add((e.getActualEnd()-max(simParams.getWarumUpTime(),e.getActualReleaseDate()))*e.getQuantity())); 

//second query as here the total simulation time is required
//max wird verwendet, um Auftrge korrekt zur WarmUpTime abzugrenzen bzw. zu bercksichtigen.
//validated 9.11.2022
productionOrders.stream().
filter(e->e.getItem().getType().equals(Item.ITEM_TYPE_SALES) 
&& e.getActualEnd()>=simParams.getWarumUpTime() 
&& (e.getStatus()== ProductionOrder.PRODUCTION_ORDER_STATUS_RELEASED 
|| e.getStatus()== ProductionOrder.PRODUCTION_ORDER_STATUS_PROCESSING)).
forEach(e-> stat_wip_sales.add((simParams.getSimulationRunTime()-max(simParams.getWarumUpTime(),e.getActualReleaseDate()))*e.getQuantity())); 

var_wip_sales = stat_wip_sales.sum();

traceln("WIP Sales Items (3): " + var_wip_sales);

//WIP_components
//max wird verwendet, um Auftrge korrekt zur WarmUpTime abzugrenzen bzw. zu bercksichtigen.
//validiert 9.11.2022
productionOrders.stream().filter(e->e.getItem().getType().equals(Item.ITEM_TYPE_COMPONENT) 
&& e.getActualEnd()>=simParams.getWarumUpTime()
&& e.getStatus()== ProductionOrder.PRODUCTION_ORDER_STATUS_PROCESSED).
forEach(e-> stat_wip_components.add((e.getActualEnd()-max(simParams.getWarumUpTime(),e.getActualReleaseDate()))*e.getQuantity())); 

//second query as here the total simulation time is required
//max wird verwendet, um Auftrge korrekt zur WarmUpTime abzugrenzen bzw. zu bercksichtigen.
//validiert 9.11.2022
productionOrders.stream().
filter(e->e.getItem().getType().equals(Item.ITEM_TYPE_COMPONENT) 
&& e.getActualEnd()>=simParams.getWarumUpTime() 
&& (e.getStatus()== ProductionOrder.PRODUCTION_ORDER_STATUS_RELEASED 
|| e.getStatus()== ProductionOrder.PRODUCTION_ORDER_STATUS_PROCESSING)).
forEach(e-> stat_wip_components.add((simParams.getSimulationRunTime()-max(simParams.getWarumUpTime(),e.getActualReleaseDate()))*e.getQuantity())); 

var_wip_components = stat_wip_components.sum();
traceln("WIP Components (4): " + var_wip_components);

//Inventory
//validiert 9.11.2022
var_inventory = 
var_wip_sales +
var_wip_components +
var_inventory_sales +
var_inventory_components;

traceln("Inventory (1+2+3+4): " + var_inventory);

//Number of production orders ... Those which are really passed to the shop floor and are not only generated
//validiert 6.11.22
var_number_of_production_orders = stat_wip_sales.count();
traceln("Number of Production Orders: " + var_number_of_production_orders);

//On-Time percentage for COMPONENTS
//validiert 6.11.22
productionOrders.stream().filter(e->e.getItem().getType().
equals(Item.ITEM_TYPE_COMPONENT) 
&& e.getCreatedAt()>=simParams.getWarumUpTime()
&& e.getStatus()== ProductionOrder.PRODUCTION_ORDER_STATUS_PROCESSED
&& e.getActualEnd()>e.getPlannedEnd()).
forEach(e-> stat_ontime_percentage.add(0));

productionOrders.stream().filter(e->e.getItem().getType().
equals(Item.ITEM_TYPE_COMPONENT) 
&& e.getCreatedAt()>=simParams.getWarumUpTime()
&& e.getStatus()== ProductionOrder.PRODUCTION_ORDER_STATUS_PROCESSED
&& e.getActualEnd()<=e.getPlannedEnd()).
forEach(e-> stat_ontime_percentage.add(1));

var_ontime_percentage = stat_ontime_percentage.mean();
traceln("Ontime Percentage Components: " + var_ontime_percentage);

//production start waiting time
// "interne tardiness for sales items"
//validiert 6.11.22
productionOrders.stream().filter(e->e.getItem().getType().
equals(Item.ITEM_TYPE_SALES) 
&& e.getCreatedAt()>=simParams.getWarumUpTime()
&& e.getStatus()== ProductionOrder.PRODUCTION_ORDER_STATUS_PROCESSED).
forEach(e-> stat_production_start_waiting_time.
add(e.getActualReleaseDate()-e.getPlannedStart()));

var_production_start_waiting_time_mean = stat_production_start_waiting_time.mean();
var_production_start_waiting_time_variance = stat_production_start_waiting_time.variance();

traceln("Production Start Wating Time Mean Sales Items: " + var_production_start_waiting_time_mean);
traceln("Production Start Wating Time Variance Sales Items: " + var_production_start_waiting_time_variance);

//internal lateness, soll negativ sein, wenn wir zu spt sind
productionOrders.stream().filter(e->e.getItem().getType().
equals(Item.ITEM_TYPE_SALES) 
&& e.getCreatedAt()>=simParams.getWarumUpTime()
&& e.getStatus()== ProductionOrder.PRODUCTION_ORDER_STATUS_PROCESSED).
forEach(e-> stat_production_start_waiting_time.
add(e.getActualEnd() - e.getPlannedEnd()));

var_internal_lateness_sales_items_mean = stat_internal_lateness_sales_items.mean();
var_internal_lateness_sales_items_variance = stat_internal_lateness_sales_items.variance();

traceln("Internal lateness Mean Sales Items: " + var_internal_lateness_sales_items_mean);
traceln("Internal lateness Variance Sales Items: " + var_internal_lateness_sales_items_variance);

productionOrders.stream().filter(e->e.getItem().getType().
equals(Item.ITEM_TYPE_COMPONENT) 
&& e.getCreatedAt()>=simParams.getWarumUpTime()
&& e.getStatus()== ProductionOrder.PRODUCTION_ORDER_STATUS_PROCESSED).
forEach(e-> stat_production_start_waiting_time.
add(e.getActualEnd() - e.getPlannedEnd()));

var_internal_lateness_components_mean = stat_internal_lateness_components.mean();
var_internal_lateness_components_variance = stat_internal_lateness_components.variance();

traceln("Internal lateness Mean Components: " + var_internal_lateness_components_mean);
traceln("Internal latness Variance Components: " + var_internal_lateness_components_variance);

//average production lotsize per item ... only those which are processed, EXCLUDED are the released production orders
//validiert 6.11.22
StatisticsDiscrete statistic = new StatisticsDiscrete();
for(Item i : items.stream().filter(e -> e.getType().equalsIgnoreCase(Item.ITEM_TYPE_SALES) || 
	e.getType().equalsIgnoreCase(Item.ITEM_TYPE_COMPONENT)).collect(Collectors.toList())							
	){
	productionOrders.stream().filter(e->
	e.getItem().getItem() == i.getItem() &&	
	e.getCreatedAt()>=simParams.getWarumUpTime()
	&& e.getStatus()== ProductionOrder.PRODUCTION_ORDER_STATUS_PROCESSED).
	forEach(e-> statistic.add(e.getQuantity()));	
		
	var_productionLotSizes.add(new KPI(i.getItem(), statistic.mean(), "Mean"));
	var_productionLotSizes.add(new KPI(i.getItem(), statistic.variance(), "Variance"));	
	
	statistic.reset();		
}

//consumed setup time mean and variance
productionOrders.stream().filter(e-> e.getCreatedAt()>=simParams.getWarumUpTime()
&& e.getStatus()== ProductionOrder.PRODUCTION_ORDER_STATUS_PROCESSED).
forEach(e-> stat_consumed_setup_time.
add(e.getConsumedSetupTime()));

var_consumed_setup_time_mean = stat_consumed_setup_time.mean();
var_consumed_setup_time_variance = stat_consumed_setup_time.variance();

traceln("Consumed Setup Time Mean: " + var_consumed_setup_time_mean);
traceln("Consumed Setup Time Variance: " + var_consumed_setup_time_variance);

//Average Planned Leadtime
for(int p=1; p <= 4; p++) {

		String productionStage = "Stage"+p;
		
		stat_avg_planned_lead_time.reset();
		
		productionOrders.stream().filter(e -> 
		e.getCreatedAt()>=simParams.getWarumUpTime()
		&& e.getStatus()== ProductionOrder.PRODUCTION_ORDER_STATUS_PROCESSED 
		&& e.getResource().getResourceGroup().equalsIgnoreCase(productionStage)).
		forEach(e-> stat_avg_planned_lead_time.
		add(e.getPlannedEnd() - e.getPlannedStart()));
		
		switch(p){
			case 1:
				var_avg_planned_leadtime_mean_PS1 = stat_avg_planned_lead_time.mean();
				var_avg_planned_leadtime_variance_PS1 = stat_avg_planned_lead_time.variance();
				traceln("Planned Leadtime Stage " + p + " Mean Sales Items: " + var_avg_planned_leadtime_mean_PS1);
				traceln("Planned Leadtime Stage " + p + " Variance Sales Items: " + var_avg_planned_leadtime_variance_PS1);
				break;
			case 2:
				var_avg_planned_leadtime_mean_PS2 = stat_avg_planned_lead_time.mean();
				var_avg_planned_leadtime_variance_PS2 = stat_avg_planned_lead_time.variance();
				traceln("Planned Leadtime Stage " + p + " Mean Sales Items: " + var_avg_planned_leadtime_mean_PS2);
				traceln("Planned Leadtime Stage " + p + " Variance Sales Items: " + var_avg_planned_leadtime_variance_PS2);
				break;
			case 3:
				var_avg_planned_leadtime_mean_PS3 = stat_avg_planned_lead_time.mean();
				var_avg_planned_leadtime_variance_PS3 = stat_avg_planned_lead_time.variance();
				traceln("Planned Leadtime Stage " + p + " Mean Sales Items: " + var_avg_planned_leadtime_mean_PS3);
				traceln("Planned Leadtime Stage " + p + " Variance Sales Items: " + var_avg_planned_leadtime_variance_PS3);
				break;
			case 4:
				var_avg_planned_leadtime_mean_PS4 = stat_avg_planned_lead_time.mean();
				var_avg_planned_leadtime_variance_PS4 = stat_avg_planned_lead_time.variance();
				traceln("Planned Leadtime Stage " + p + " Mean Sales Items: " + var_avg_planned_leadtime_mean_PS4);
				traceln("Planned Leadtime Stage " + p + " Variance Sales Items: " + var_avg_planned_leadtime_variance_PS4);						
				break;
		}
		

}//for p

for(int i = 0; i < machineAgents.size();i++){
		double val = machineAgents.get(i).delayProcessingTime.statsUtilization.mean();	
		traceln("Utilization: " + machineAgents.get(i).Resource.getName() + " " + val);		
}

traceln("Final System Utilization: " + kPIAgent.function_computeSystemUtilization(true).getValue());

traceln("Stage 1 SL Mean: " + (int)clearingFunctionAgent.statisticStage1.mean());
traceln("Stage 1 SL Integral: " + (int)clearingFunctionAgent.statisticStage1.integral());
traceln("Stage 1 PL Mean: " + (int)clearingFunctionAgent.statisticPLStage1.mean());
traceln();
traceln("Stage 2 SL Mean: " + (int)clearingFunctionAgent.statisticStage2.mean());
traceln("Stage 2 SL Integral: " + (int)clearingFunctionAgent.statisticStage2.integral());
traceln("Stage 2 PL Mean: " + (int)clearingFunctionAgent.statisticPLStage2.mean());
traceln();
traceln("Stage 3 SL Mean: " + (int)clearingFunctionAgent.statisticStage3.mean());
traceln("Stage 3 SL Integral: " + (int)clearingFunctionAgent.statisticStage3.integral());
traceln("Stage 3 PL Mean: " + (int)clearingFunctionAgent.statisticPLStage3.mean());
traceln();
traceln("Stage 4 SL Mean: " + (int)clearingFunctionAgent.statisticStage4.mean());
traceln("Stage 4 SL Integral: " + (int)clearingFunctionAgent.statisticStage4.integral());
traceln("Stage 4 PL Mean: " + (int)clearingFunctionAgent.statisticPLStage4.mean());

//for(int i = 0; i < clearingFunctionAgent.testDs.size(); i++){
	//traceln(i+";"+clearingFunctionAgent.testDs.getX(i)+";"+clearingFunctionAgent.testDs.getY(i));
//}

traceln("Sum of EnergyCosts " + sumEnergyCosts);


]]></Body>
				</Function>
				<Function AccessType="default" StaticFunction="false">
					<ReturnModificator>VOID</ReturnModificator>
					<ReturnType><![CDATA[double]]></ReturnType>
					<Id>1669272580802</Id>
					<Name><![CDATA[Function_ApplyOptimizationParametersORExtended]]></Name>
					<X>950</X><Y>1880</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Body><![CDATA[for(Item item : items.stream().filter(e -> e.getType().equalsIgnoreCase(Item.ITEM_TYPE_SALES) || e.getType().equalsIgnoreCase(Item.ITEM_TYPE_COMPONENT)).collect(Collectors.toList())){
			
			simParams.setDemandScenario((int)optimizationParameters.getX018());																
			simParams.setForecastScenario(optimizationParameters.getForecastScenario());																
							
			if(item.getType().equalsIgnoreCase(Item.ITEM_TYPE_SALES)) {
			
				//safety stock als faktor abhngig vom Periodenbedarf ndern
				DBQueries db = new DBQueries();
				forecastMasterdata = db.GetForecast(items,simParams,list_ForecastInputParameter);			
				Forecast f = forecastMasterdata.stream().filter(e -> e.getItem().getItem() == item.getItem()).findFirst().get();
				item.setSafetyStock(f.getLongtermForecast()*optimizationParameters.getX000());
						
				item.setLeadTime((int)optimizationParameters.getX001());																								
			
				switch((int)optimizationParameters.getX002()){
				case 1:
					item.setLotsizePolicy("FOP");			
					item.setFOPPeriod((int)optimizationParameters.getX003());			
					break;
				case 2:
					item.setLotsizePolicy("FOPBacklog");			
					item.setFOPPeriod((int)optimizationParameters.getX003());					
					break;
				case 3:
					item.setFOQQuantity((int)optimizationParameters.getX003());										
					item.setLotsizePolicy("FOQ");
					item.setFOQMinimumLotSize((int)optimizationParameters.getX003());		
					break;
				case 4:	
					item.setFOQQuantity((int)optimizationParameters.getX003());								
					item.setLotsizePolicy("FOQBacklog");			
					item.setFOQMinimumLotSize((int)optimizationParameters.getX003());
					break;
				}												
			}	
			else if(item.getType().equalsIgnoreCase(Item.ITEM_TYPE_COMPONENT)) {
					item.setLeadTime((int)optimizationParameters.getX004());																										
					item.setLotsizePolicy("FOQ");
					item.setFOQQuantity((int) Math.round((int)optimizationParameters.getX005()));
					item.setFOQMinimumLotSize((int) Math.round((int)optimizationParameters.getX005()));
					item.setSafetyStock((int)optimizationParameters.getX006());										
			}
		}//for
		
		for(Routing r : routings){
		
		// sales items
		if(r.getItem().getType().equalsIgnoreCase(Item.ITEM_TYPE_SALES)) {				

			r.setEProcessingTime(optimizationParameters.getX008());
			r.setSProcessingTime(optimizationParameters.getX009());
						
			if(optimizationParameters.getX016() == 0){
				r.setDistProcessingTime(Distribution.DISTRIBUTION_TYPE_DETERMINISTIC);
			}else if(optimizationParameters.getX016() == 1){
				r.setDistProcessingTime(Distribution.DISTRIBUTION_TYPE_LOGNORMAL);
			}											

			r.setESetupTime(optimizationParameters.getX010());
			r.setSSetupTime(optimizationParameters.getX011());			
						
			if(optimizationParameters.getX017() == 0){
				r.setDistSetupTime(Distribution.DISTRIBUTION_TYPE_DETERMINISTIC);
			}else if(optimizationParameters.getX017() == 1){
				r.setDistSetupTime(Distribution.DISTRIBUTION_TYPE_LOGNORMAL);
			}																	
		}// end end item
		
		// components
		if(r.getItem().getType().equalsIgnoreCase(Item.ITEM_TYPE_COMPONENT)) {				

			r.setEProcessingTime(optimizationParameters.getX012());
			r.setSProcessingTime(optimizationParameters.getX013());
						
			if(optimizationParameters.getX016() == 0){
				r.setDistProcessingTime(Distribution.DISTRIBUTION_TYPE_DETERMINISTIC);
			}else if(optimizationParameters.getX016() == 1){
				r.setDistProcessingTime(Distribution.DISTRIBUTION_TYPE_LOGNORMAL);
			}											

			r.setESetupTime(optimizationParameters.getX014());
			r.setSSetupTime(optimizationParameters.getX015());
									
			if(optimizationParameters.getX017() == 0){
				r.setDistSetupTime(Distribution.DISTRIBUTION_TYPE_DETERMINISTIC);
			}else if(optimizationParameters.getX017() == 1){
				r.setDistSetupTime(Distribution.DISTRIBUTION_TYPE_LOGNORMAL);
			}																	
																																		
		}// end components
		
		//set MRP PlanningHorizon ?????????????????????
		//int maxPlanungsHorizon = (int)(2*(optimizationParameters.getX003()+optimizationParameters.getX002()));
		//SimulationParameter.UpdateMRPPlanningHorizon(optimizationParameters,max(maxPlanungsHorizon,7));	
		//traceln("MRP-Horizon " + simParams.getMRPPlanningHorizon());				
		
	}//else if
	
	
]]></Body>
				</Function>
				<Function AccessType="default" StaticFunction="false">
					<ReturnModificator>VOID</ReturnModificator>
					<ReturnType><![CDATA[double]]></ReturnType>
					<Id>1669272796489</Id>
					<Name><![CDATA[Function_ApplyOptimizationParametersWSC22]]></Name>
					<X>950</X><Y>1910</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Body><![CDATA[
	List<Integer> leadTimes =  new ArrayList<Integer>();
	
	if(optimizationParameters.getId() > 0 && !varNormalSimulationRun){
		for(Item item : items){		
			if(item.getItem()==10){
				item.setSafetyStock(item.getSafetyStock() * optimizationParameters.getX000());
				item.setFOQMinimumLotSize((int)(optimizationParameters.getX001() * item.getFOQMinimumLotSize()));
				item.setLeadTime((int)optimizationParameters.getX002());
			}	
			if(item.getItem()==11){
				item.setSafetyStock(item.getSafetyStock() * optimizationParameters.getX003());
				item.setFOQMinimumLotSize((int)(optimizationParameters.getX004() * item.getFOQMinimumLotSize()));
				item.setLeadTime((int)optimizationParameters.getX005());
			}	
			if(item.getItem()==12){
				item.setSafetyStock(item.getSafetyStock() * optimizationParameters.getX006());
				item.setFOQMinimumLotSize((int)(optimizationParameters.getX007() * item.getFOQMinimumLotSize()));
				item.setLeadTime((int)optimizationParameters.getX008());
			}	
			if(item.getItem()==13){
				item.setSafetyStock(item.getSafetyStock() * optimizationParameters.getX009());
				item.setFOQMinimumLotSize((int)(optimizationParameters.getX010() * item.getFOQMinimumLotSize()));
				item.setLeadTime((int)optimizationParameters.getX011());
			}	
			
			if(item.getItem()==20){
				item.setSafetyStock(item.getSafetyStock() * optimizationParameters.getX012());
				item.setFOQMinimumLotSize((int)(optimizationParameters.getX013() * item.getFOQMinimumLotSize()));
				item.setLeadTime((int)optimizationParameters.getX014());
			}
			
			if(item.getItem()==21){
				item.setSafetyStock(item.getSafetyStock() * optimizationParameters.getX015());			
				item.setFOQMinimumLotSize((int)(optimizationParameters.getX016()*item.getFOQMinimumLotSize()));
				item.setLeadTime((int)optimizationParameters.getX017());
			}

			leadTimes.add(item.getLeadTime());
		}
		
		//set MRP PlanningHorizon

		int maxLeadTime = leadTimes.stream().collect(Collectors.summarizingInt(Integer::intValue)).getMax();				
		
		//int Fabiansmaximum = (int)(2*(optimizationParameters.getX003()+optimizationParameters.getX002()));
		//MRP-Planungshorizont = maxBomLevel * ( maxPLT + maxFOP)
				
		int maxMRPPlanningHorizon = (int)(((maxBomLevel.getLevel()) * maxLeadTime));
		traceln("MRP Planning Horizon: " + simParams.getMRPPlanningHorizon() + " Max Lead Time Planning Parameters: " + maxLeadTime);
		
		//todo: change to maxBom * maxLosGre + (Losgre/TagesBedarf) + 5 Perioden.
		
		SimulationParameter.UpdateMRPPlanningHorizon(optimizationParameters,max(maxMRPPlanningHorizon,7));	
		
		DBQueries db = new DBQueries();		
		simParams = db.GetSimulationParameters();
		}

]]></Body>
				</Function>
				<Function AccessType="default" StaticFunction="false">
					<ReturnModificator>VOID</ReturnModificator>
					<ReturnType><![CDATA[double]]></ReturnType>
					<Id>1669731959310</Id>
					<Name><![CDATA[Function_ApplyOptimizationParametersSimOpt]]></Name>
					<X>950</X><Y>1820</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Body><![CDATA[		traceln(" ------- Setting Optimization Parameters for " + optimizationParameters.getDescription() + " " + simParams.getName() + " -------");		
										
		simParams.setDemandGeneration(SimulationParameter.DEMAND_GENERATION_FORECAST);		
		simParams.setForecastScenario(optimizationParameters.getForecastScenario());
		simParams.setDemandScenario((int)optimizationParameters.getX000());
		traceln("Forecast Scenario: " + simParams.getForecastScenario());
		//simParams.setSetupCarryOver((int)optimizationParameters.getX018());
		simParams.setSetupCarryOver(0); // set to zero, as not applied in the simulation expriemtn any more.
		
		numberScenarios = ((int)optimizationParameters.getX019());
		simParams.setAvoidScenarioUpdates((int)optimizationParameters.getX020());								

		String sp000 = optimizationParameters.getSP000();
		int fixedPeriods = (sp000 == null) ? 0 : Integer.parseInt(sp000);

		simParams.setFixedPeriods(fixedPeriods);

				
		//0 = MRP, 1 = Apply Optimization				
		if(optimizationParameters.getX015()==0) {
			simParams.setApplyMRP(1);
			simParams.setApplyOptimization(0);
		}else {
			simParams.setApplyMRP(0);
			simParams.setApplyOptimization(1);
		}
		
		if(optimizationParameters.getX016()== 0){
			simParams.setOptimizationType(simParams.OPTIMIZATION_TYPE_DETERMINISTIC);
		}	
		else if(optimizationParameters.getX016()== 1){
			simParams.setOptimizationType(simParams.OPTIMIZATION_TYPE_STOCHASTIC);
		}				
		else if(optimizationParameters.getX016()== 2){
			simParams.setOptimizationType(simParams.OPTIMIZATION_TYPE_STOCHASTIC_FLEXIBLE);
		}				
		
		traceln("Optimization Type: " + simParams);
		
	for(Routing r : routings){
	
		if(r.getItem().getType().equalsIgnoreCase(Item.ITEM_TYPE_SALES)) {				
			//end item
			//processing time			
			
			if(!simParams.getExperiment().equalsIgnoreCase("ExpPS4")){
				r.setEProcessingTime(optimizationParameters.getX001());
			}
									
			if(optimizationParameters.getX002() == 0){
				r.setDistProcessingTime(Distribution.DISTRIBUTION_TYPE_DETERMINISTIC);
			}else if(optimizationParameters.getX002() == 1){
				r.setDistProcessingTime(Distribution.DISTRIBUTION_TYPE_LOGNORMAL);
				
				if(!simParams.getExperiment().equalsIgnoreCase("ExpPS4")){
					r.setSProcessingTime(optimizationParameters.getX003());
				}
			}											

			//setup time
			if(!simParams.getExperiment().equalsIgnoreCase("ExpPS4")){
				r.setESetupTime(optimizationParameters.getX004());	
			}	
										
			if(optimizationParameters.getX005() == 0){
				r.setDistSetupTime(Distribution.DISTRIBUTION_TYPE_DETERMINISTIC);
			}else if(optimizationParameters.getX005() == 1){
				r.setDistSetupTime(Distribution.DISTRIBUTION_TYPE_LOGNORMAL);
				
				if(!simParams.getExperiment().equalsIgnoreCase("ExpPS4")){
					r.setSSetupTime(optimizationParameters.getX006());
				}
			}																	
		}else if(r.getItem().getType().equalsIgnoreCase(Item.ITEM_TYPE_COMPONENT)) {				
			//components
				//processing time
				if(!simParams.getExperiment().equalsIgnoreCase("ExpPS4")){
					r.setEProcessingTime(optimizationParameters.getX007());		
				}	
							
				if(optimizationParameters.getX008() == 0){
					r.setDistProcessingTime(Distribution.DISTRIBUTION_TYPE_DETERMINISTIC);
				}else if(optimizationParameters.getX008() == 1){
					r.setDistProcessingTime(Distribution.DISTRIBUTION_TYPE_LOGNORMAL);
					
					if(!simParams.getExperiment().equalsIgnoreCase("ExpPS4")){
						r.setSProcessingTime(optimizationParameters.getX009());
					}
										
				}											
			
				//setup time
				if(!simParams.getExperiment().equalsIgnoreCase("ExpPS4")){
					r.setESetupTime(optimizationParameters.getX010());	
				}								
				if(optimizationParameters.getX011() == 0){
					r.setDistSetupTime(Distribution.DISTRIBUTION_TYPE_DETERMINISTIC);
				}else if(optimizationParameters.getX011() == 1){
					r.setDistSetupTime(Distribution.DISTRIBUTION_TYPE_LOGNORMAL);
					
					if(!simParams.getExperiment().equalsIgnoreCase("ExpPS4")){
						r.setSSetupTime(optimizationParameters.getX012());
					}
				}																	
			}
	}//for routing	
	

	for(Item i : items){		
		//note: at the moment the same leadtime and fop is used.								
		//i.setFOPPeriod((int)optimizationParameters.getX014());								
		
		if(i.getType().equalsIgnoreCase(Item.ITEM_TYPE_SALES) 
		|| i.getType().equalsIgnoreCase(Item.ITEM_TYPE_COMPONENT)){
						
			//safety stock als faktor abhngig vom Periodenbedarf ndern
			DBQueries db = new DBQueries();
			forecastMasterdata = db.GetForecast(items,simParams,list_ForecastInputParameter);			
						
			int selectedEndItem = i.getItem();			
			
			if(i.getType().equalsIgnoreCase(Item.ITEM_TYPE_COMPONENT)){							
																															
				BOM bomEndItem = bom.stream().filter(e -> e.getChild() != null && e.getChild().getItem() == i.getItem()).findFirst().get();
												
				selectedEndItem = bomEndItem.getItem().getItem();			
				
				traceln("Component: " + i.getItem() + " End Item: " + selectedEndItem);			
			}
			
			traceln("End Item for Component: " + selectedEndItem);
			int tmpSelectedEndItem = selectedEndItem;
			Forecast f = forecastMasterdata.stream().filter(e -> e.getItem().getItem() == tmpSelectedEndItem).findFirst().get();			
			
			i.setSafetyStock(Math.round(f.getLongtermForecast()*optimizationParameters.getX017() + 2));
			traceln("Item: " + i.getItem() +  " SS: " + i.getSafetyStock() + " Longterm Forecast:" + f.getLongtermForecast() + " SS Factor " + optimizationParameters.getX017());			
			
			i.setLeadTime((int)optimizationParameters.getX013());
			traceln("Item " + i.getItem() + " LT: " + i.getLeadTime());
						
			if(optimizationParameters.getX014() <= 5) {
				i.setLotsizePolicy("FOP");			
				i.setFOPPeriod((int)optimizationParameters.getX014());							
				traceln("Item: " + i.getItem() + " FOP: " + i.getFOPPeriod());				
			}else {
			//-5 is used to seperate it from the fop				
				int foqQty = (int)(f.getLongtermForecast()*(optimizationParameters.getX014()-5));
				i.setFOQQuantity(foqQty);										
				i.setLotsizePolicy("FOQ");
				i.setFOQMinimumLotSize(foqQty);						
				traceln("Item: " + i.getItem() + " FOQ: " + i.getFOQQuantity() + " Min Qty: " + i.getFOQMinimumLotSize());
			}									
		}				
		
	}//for items
	
]]></Body>
				</Function>
				<Function AccessType="default" StaticFunction="false">
					<ReturnModificator>VOID</ReturnModificator>
					<ReturnType><![CDATA[double]]></ReturnType>
					<Id>1673874896738</Id>
					<Name><![CDATA[Function_ApplyOptimizationParametersWSC23]]></Name>
					<X>950</X><Y>1850</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Body><![CDATA[	DBQueries db = new DBQueries();		
	simParams = db.GetSimulationParameters();
	simParams.setForecastScenario(optimizationParameters.getForecastScenario());	
	
	//x003 Demand Scenario
	simParams.setDemandScenario((int)optimizationParameters.getX003());																
	
		for(Item item : items.stream().filter(e -> e.getType().equals(Item.ITEM_TYPE_COMPONENT) ||
		 e.getType().equals(Item.ITEM_TYPE_SALES)).collect(Collectors.toList())		 
		  ){						 				 
		  	
        	if(simParams.getApplyRPS() == SimulationParameter.APPLY_RPS) {        
				item.setSafetyStock(optimizationParameters.getX004());
			}else {
				 item.setSafetyStock(optimizationParameters.getX000());
			}
			
			item.setRPSQty(optimizationParameters.getX004());
			
			item.setLotsizePolicy(optimizationParameters.getSP000());											
			
			item.setFOQQuantity(optimizationParameters.getX001());
			item.setFOQMinimumLotSize((int)optimizationParameters.getX001());	
			item.setFOPPeriod((int)optimizationParameters.getX005());
						
			item.setLeadTime((int)optimizationParameters.getX002());												
						
		}						
										
		int maxLeadTime = BOM.GetMaxLeadTime(items,simParams).getLeadTime();
				
		int maxMRPPlanningHorizon = (int)(((maxBomLevel.getLevel()) * maxLeadTime));
		traceln("MRP Planning Horizon: " + simParams.getMRPPlanningHorizon() + " Max Lead Time Planning Parameters: " + maxLeadTime);
				
		SimulationParameter.UpdateMRPPlanningHorizon(optimizationParameters,max(maxMRPPlanningHorizon,20));	

]]></Body>
				</Function>
				<Function AccessType="default" StaticFunction="false">
					<ReturnModificator>VOID</ReturnModificator>
					<ReturnType><![CDATA[double]]></ReturnType>
					<Id>1673876451106</Id>
					<Name><![CDATA[Function_ApplyOptimizationParametersCFProdStages]]></Name>
					<X>950</X><Y>1790</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Body><![CDATA[	DBQueries db = new DBQueries();		
	simParams = db.GetSimulationParameters();
	simParams.setForecastScenario(optimizationParameters.getForecastScenario());	
	simParams.setApplyOptimization(0);
		
	//0 = MRP, 1 = Apply CF Optimization				
	if(optimizationParameters.getX002()==0) {
		simParams.setApplyMRP(1);		
		simParams.setApplyClearingFunctions(false);
	}else {
		simParams.setApplyMRP(1);
		simParams.setApplyClearingFunctions(true);						
		simParams.setUseIdealCFLine((int)optimizationParameters.getX006());
	}
	
	traceln("CF Type set: " + simParams.getUseIdealCFLine());
	simParams.setALCFormulation(Integer.parseInt(optimizationParameters.getSP001()));
	simParams.setROFormulation(Integer.parseInt(optimizationParameters.getSP002()));
	
	traceln("Optimization Parameter Id in Apply Function: " + optimizationParameters.getId());

	simParams.setMachineFailure((int) optimizationParameters.getX007());

		for(Item item : items.stream().filter(e -> e.getType().equals(Item.ITEM_TYPE_COMPONENT) ||
		 e.getType().equals(Item.ITEM_TYPE_SALES)).collect(Collectors.toList())
		  ){
		  						 				 
			item.setLotsizePolicy(optimizationParameters.getSP000());
			item.setFOQQuantity(optimizationParameters.getX001());
			item.setFOQMinimumLotSize((int)optimizationParameters.getX001());
			item.setFOPPeriod((int)optimizationParameters.getX001());
			
			item.setSafetyStock(Math.round(optimizationParameters.getX000()*optimizationParameters.getX003()));						
			item.setLeadTime((int)optimizationParameters.getX004());
									
			item.setSafetyLeadTime((int)optimizationParameters.getX005());																								
		}
		
		for(Routing r : routings){	
			//only for Processing Time	
			if(optimizationParameters.getX008() == 0){
				r.setDistProcessingTime(Distribution.DISTRIBUTION_TYPE_DETERMINISTIC);
			}else if(optimizationParameters.getX008() == 1){
				r.setDistProcessingTime(Distribution.DISTRIBUTION_TYPE_LOGNORMAL);
			}
			
			//only for Setup Time
			if(optimizationParameters.getX009() == 0){
				r.setDistSetupTime(Distribution.DISTRIBUTION_TYPE_DETERMINISTIC);
			}else if(optimizationParameters.getX009() > 0){
				r.setDistSetupTime(Distribution.DISTRIBUTION_TYPE_LOGNORMAL);
				
				traceln("ESetupTime: " + r.getESetupTime());				
				r.setSSetupTime(optimizationParameters.getX009());
				traceln("SSetupTime: " + r.getSSetupTime());				
			}																
		}
										
		Forecast.UpdateForecast(optimizationParameters, simParams);		
																				
		int maxLeadTime = BOM.GetMaxLeadTime(items,simParams).getLeadTime();
				
		//int maxMRPPlanningHorizon = (int)(((maxBomLevel.getLevel()) * maxLeadTime));
		traceln("MRP Planning Horizon: " + simParams.getMRPPlanningHorizon() + " Max Lead Time Planning Parameters: " + maxLeadTime);
				
		//SimulationParameter.UpdateMRPPlanningHorizon(optimizationParameters,max(maxMRPPlanningHorizon,simParams.getMRPPlanningHorizon()));	
			]]></Body>
				</Function>
				<Function AccessType="default" StaticFunction="false">
					<ReturnModificator>VOID</ReturnModificator>
					<ReturnType><![CDATA[double]]></ReturnType>
					<Id>1676007107635</Id>
					<Name><![CDATA[Function_ApplyOptimizationParametersASIM23]]></Name>
					<X>950</X><Y>1760</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Body><![CDATA[	DBQueries db = new DBQueries();		
	simParams = db.GetSimulationParameters();
	simParams.setForecastScenario(optimizationParameters.getForecastScenario());	
	
	//x003 Demand Scenario
	simParams.setDemandScenario((int)optimizationParameters.getX003());																
	
	simParams.setForecastUpdateFrozenZone((int)optimizationParameters.getX004());
	
		for(Item item : items.stream().filter(e -> e.getType().equals(Item.ITEM_TYPE_COMPONENT) ||
		 e.getType().equals(Item.ITEM_TYPE_SALES)).collect(Collectors.toList())		 
		  ){						 				 
		  		  
			item.setSafetyStock(optimizationParameters.getX000());

			item.setLotsizePolicy(optimizationParameters.getSP000());											
			
			item.setFOQQuantity(optimizationParameters.getX001());
			item.setFOQMinimumLotSize((int)optimizationParameters.getX001());	
						
			item.setLeadTime((int)optimizationParameters.getX002());												
			
			//traceln(Item.GetCSVHeader());
			//traceln(Item.GetCSVString(item));
			
			
		}						
										
		int maxLeadTime = BOM.GetMaxLeadTime(items,simParams).getLeadTime();
				
		int maxMRPPlanningHorizon = (int)(((maxBomLevel.getLevel()) * maxLeadTime));
		traceln("MRP Planning Horizon: " + simParams.getMRPPlanningHorizon() + " Max Lead Time Planning Parameters: " + maxLeadTime);
				
		SimulationParameter.UpdateMRPPlanningHorizon(optimizationParameters,max(maxMRPPlanningHorizon,20));	

]]></Body>
				</Function>
				<Function AccessType="default" StaticFunction="false">
					<ReturnModificator>VOID</ReturnModificator>
					<ReturnType><![CDATA[double]]></ReturnType>
					<Id>1680007506060</Id>
					<Name><![CDATA[FunctionUpdatePSStatistic]]></Name>
					<X>950</X><Y>1730</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Body><![CDATA[Tools t = new Tools();

//traceln("PL/SL identifcation --------------- " + time());

//sl: vor planunglsauf, sl = gesamter arbeitsinhalt, den wollen wir wegschreiben, das abziehen machen wir fr die PL

//die summe aller abzge: ist PL:

//wertepaar: sl vor abzug : pl -> summe der abzge

DBQueries db = new DBQueries();

resources.stream().forEach(e -> e.setPL(0));

clearingFunctionAgent.statisticStage1.add(clearingFunctionAgent.varStage1, time());
clearingFunctionAgent.dataSetStage1.add(time(), clearingFunctionAgent.varStage1);		

int sumSlPs1 = 0;
int sumSlPs2 = 0;
int sumSlPs3 = 0;
int sumSlPs4 = 0;

//for(ProductionOrder order : productionStageOrders.stream().collect(Collectors.toList())){
for(ProductionOrder order : productionOrders.stream().filter(e -> e.getActualStart() > 0 && e.getCFFinished() != 1).collect(Collectors.toList())){
	t.log("~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", Tools.LogPLSLValues);
	String actualResource = order.getItem().getRouting().getResource();
	
	Resource resource = resources.stream().filter(e -> e.getName().equalsIgnoreCase(actualResource)).findFirst().get();
	
	//double newQuantity = order.getQuantity() * order.getItem().getRouting().getEProcessingTime() 
	//+ order.getItem().getRouting().getESetupTime();
	
	double newPL = 0;	
	
	double orderActualSetupTime = order.getTotalProcessingTime() - order.getNetProcessingTime();
	
	t.log("Planned SetupTime: " + order.getPlannedSetupTime(), Tools.LogPLSLValues);
	t.log("Actual SetupTime:" + (order.getTotalProcessingTime() - order.getNetProcessingTime()), Tools.LogPLSLValues);
	t.log("Planned ProcessingTime: " + order.getNetProcessingTime(), Tools.LogPLSLValues);
	t.log("Planned TotelTime: " + (order.getNetProcessingTime() + order.getPlannedSetupTime()), Tools.LogPLSLValues);
	t.log("Consumed SetupTime: " + order.getConsumedSetupTime(), Tools.LogPLSLValues);
	t.log("Consumed ProcessingTime: " + order.getConsumedProcessingTime(), Tools.LogPLSLValues);
		
	if(order.getActualEnd() <= 0){
		//laufender Auftrag
		//Fall 1: Start und Ende sind in einer Periode
	
		t.log("order pl " + order.getPL() + order.getPL()/1440, Tools.LogPLSLValues);
		
		double plAsDouble = order.getPL()/1440.0;
		t.log("+++> Running order" + time() + " -" + order.getActualStart() + " - " + plAsDouble, Tools.LogPLSLValues);
		
		//Test Rstzeitanteil
		t.log("---------------", Tools.LogPLSLValues);
		if((time() - order.getActualStart()) >= order.getPlannedSetupTime()/1440){						
			
			//newPL = order.getPlannedSetupTime();
			t.log("Setup Total selected: " + newPL, Tools.LogPLSLValues);			
									
			t.log("newPLST: " + newPL, Tools.LogPLSLValues);																		
			//Calculate Remaining part for processing time			
			t.log("Consumed Processing Time: " + order.getConsumedProcessingTime(), Tools.LogPLSLValues);
												
			double timeForProcessing = (time() - order.getActualStart() - order.getConsumedSetupTime()/1440)*1440;																									
			
			if(order.getConsumedSetupTime() == 0){
				t.log("Variant NO Setup time", Tools.LogPLSLValues);
				order.setConsumedSetupTime(order.getPlannedSetupTime());				
				newPL = order.getConsumedSetupTime();
				timeForProcessing = timeForProcessing - order.getConsumedSetupTime();
			}
			
			if(order.getConsumedSetupTime() < order.getPlannedSetupTime()){
				t.log("Varinate SETUP Part already consumed", Tools.LogPLSLValues);
				order.setConsumedSetupTime(order.getConsumedSetupTime() + (order.getPlannedSetupTime() - order.getConsumedSetupTime()));				
				newPL = order.getPlannedSetupTime() - order.getConsumedSetupTime();
				timeForProcessing = timeForProcessing - (order.getPlannedSetupTime() - order.getConsumedSetupTime());
			}			
			
			if(order.getConsumedSetupTime() > order.getPlannedSetupTime()) {
				newPL = 0;
				t.log("newPLST reduced to: " + newPL, Tools.LogPLSLValues);
			}
						
			t.log("Time For Processing: " + timeForProcessing, Tools.LogPLSLValues);					
						
			t.log("Consumed SetupTime: " + order.getConsumedSetupTime(), Tools.LogPLSLValues);												
			
			double selectedTimeForProcessing = timeForProcessing / 1440;
			
			t.log("selected Time For Processing: " + selectedTimeForProcessing, Tools.LogPLSLValues);
			
			double timeOverSetupTime = 0;
			
			if(selectedTimeForProcessing < 1){
				timeOverSetupTime = timeForProcessing;
			}else{
				timeOverSetupTime = 1440;
			}	
																							
			t.log("Processing Time Proportion: " + timeOverSetupTime, Tools.LogPLSLValues);						
			
			order.setConsumedProcessingTime(timeOverSetupTime);
									
			newPL += timeOverSetupTime;
			t.log("newPLPT: " + newPL, Tools.LogPLSLValues);																		
		}else{	//anteilige Rstzeit nur bei laufenden Auftrgen				
			//as not the total setuptime is consumed, we do not have to consider a processing time.
			double consumedSetupTime = (time() - order.getActualStart())*1440;
			double setupTimeProportion = (consumedSetupTime/orderActualSetupTime)*order.getPlannedSetupTime();
			t.log("consumedSetupTime: " + consumedSetupTime, Tools.LogPLSLValues);
			t.log("actualSetupTime: " + orderActualSetupTime, Tools.LogPLSLValues);
			t.log("plannedSetupTime: " + order.getPlannedSetupTime(), Tools.LogPLSLValues);
			t.log("Setup Proportion selected: " + setupTimeProportion, Tools.LogPLSLValues);
			newPL += setupTimeProportion;
			order.setConsumedSetupTime(order.getConsumedSetupTime() + newPL);			
			t.log("newPL: " + newPL, Tools.LogPLSLValues);
		}
								
	}else{
		t.log("--> Finished Order", Tools.LogPLSLValues);
		if(Math.floor(order.getActualEnd()) == Math.floor(order.getActualStart())){ //Start und Ende sind in der selben Periode
			t.log("In if", Tools.LogPLSLValues);
			//newPL = order.getPlannedCapacity();	
			
			double startDecimalPlaces = (order.getActualStart() - Math.floor(order.getActualStart()));			
			t.log("Start DecimalPlaces: " + startDecimalPlaces, Tools.LogPLSLValues);			
							
			double endDeciamlPlaces = (order.getActualEnd() - Math.floor(order.getActualEnd()));
			t.log("End Decimal Places: " + endDeciamlPlaces, Tools.LogPLSLValues);
			
			double finalDecimalPlaces = endDeciamlPlaces - startDecimalPlaces;
			t.log("Final Decimal Places: " + finalDecimalPlaces, Tools.LogPLSLValues);
			
			//newPL = finalDecimalPlaces * 1440;
			
			newPL = order.getPlannedCapacity(); //nach Gesprche mit Klaus auf die geplante Bearbeitungs und Rstzeit gestellt.
			
			t.log("newPL " + newPL, Tools.LogPLSLValues);
		}else{			
			// start schon eine periode vorher, oder genau die betrachtete periode, aber keine komma zahl 
			double deciamlPlaces = (order.getActualEnd() - Math.floor(order.getActualEnd()));
			t.log("decimal " + deciamlPlaces, Tools.LogPLSLValues);
			newPL = deciamlPlaces * 1440;
			t.log("was ist da los: " +  (deciamlPlaces * 1440), Tools.LogPLSLValues);						
				
			t.log("newQuanty from decimal places " + newPL, Tools.LogPLSLValues);
		}
		order.setCFFinished(1);		
	}

	double newProdOrderPL = order.getPL() + newPL;
	order.setPL(newProdOrderPL);	
	
	newPL = newPL;

	if(order.getPL() > order.getPlannedCapacity()){			
		t.log("PL was reduced due to planned capa lager actual processed load", Tools.LogPLSLValues);
		t.log("newPL" + newPL + " planned capa " + order.getPlannedCapacity(), Tools.LogPLSLValues);				
		double tmpPL = newPL;
		t.log(newPL + "- ("+ order.getPL() + " - " + order.getPlannedCapacity(), Tools.LogPLSLValues);
		newPL = newPL - (order.getPL() - order.getPlannedCapacity());
	}	

		
	t.log("Time: " + time() + " actual start " + order.getActualStart() + " actual end " + order.getActualEnd(), Tools.LogPLSLValues);
	t.log("Order Id: "  + order.getOrderId(), Tools.LogPLSLValues);
	t.log("Resource: " + resource.getName() + " new " + newPL, Tools.LogPLSLValues);
	t.log("processed PL: " + order.getPL(), Tools.LogPLSLValues);
	t.log("planned capa: " + order.getPlannedCapacity(), Tools.LogPLSLValues);
	
	double totalPL = resource.getPL() + newPL;	
	resource.setPL(totalPL);
	
	resource.setPLOrder(resource.getPLOrder() + "...(" + order.getOrderId() + "|" + order.getPL() + "|" + order.getStatus() + ");");
	
		if(resource.getResourceGroup().equalsIgnoreCase("Stage1")){
			sumSlPs1 = sumSlPs1 + (int)newPL;	
		}
		else if(resource.getResourceGroup().equalsIgnoreCase("Stage2")){
			sumSlPs2 = sumSlPs2 + (int)newPL;	
	
		}
		else if(resource.getResourceGroup().equalsIgnoreCase("Stage3")){
			sumSlPs3 = sumSlPs3 + (int)newPL;	
			
		}
		else if(resource.getResourceGroup().equalsIgnoreCase("Stage4")){
			sumSlPs4 = sumSlPs4 + (int)newPL;	
		}	
			
	productionStageOrders.removeIf(o -> o.getOrderId()==order.getOrderId() && o.getStatus()==ProductionOrder.PRODUCTION_ORDER_STATUS_PROCESSED);
}	

//PL Handling
if(sumSlPs1 > 0){
	clearingFunctionAgent.varPLStage1 = sumSlPs1;
	clearingFunctionAgent.statisticPLStage1.add(clearingFunctionAgent.varPLStage1);
	clearingFunctionAgent.dataSetPLStage1.add(time(),clearingFunctionAgent.varPLStage1);
	clearingFunctionAgent.testDs.add(clearingFunctionAgent.varStage1,clearingFunctionAgent.varPLStage1);
}

if(sumSlPs2 > 0){
	clearingFunctionAgent.varPLStage2 = sumSlPs2;
	clearingFunctionAgent.statisticPLStage2.add(clearingFunctionAgent.varPLStage2);
	clearingFunctionAgent.dataSetPLStage2.add(time(),clearingFunctionAgent.varPLStage2);
	clearingFunctionAgent.testDs2.add(clearingFunctionAgent.varStage2,clearingFunctionAgent.varPLStage2);
}

if(sumSlPs3 > 0){
	clearingFunctionAgent.varPLStage3 = sumSlPs3;
	clearingFunctionAgent.statisticPLStage3.add(clearingFunctionAgent.varPLStage3);
	clearingFunctionAgent.dataSetPLStage3.add(time(),clearingFunctionAgent.varPLStage3);
	clearingFunctionAgent.testDs3.add(clearingFunctionAgent.varStage3,clearingFunctionAgent.varPLStage3);
}

if(sumSlPs4 > 0){
	clearingFunctionAgent.varPLStage4 = sumSlPs4;
	clearingFunctionAgent.statisticPLStage4.add(clearingFunctionAgent.varPLStage4);
	clearingFunctionAgent.dataSetPLStage4.add(time(),clearingFunctionAgent.varPLStage4);
	clearingFunctionAgent.testDs4.add(clearingFunctionAgent.varStage4,clearingFunctionAgent.varPLStage4);
}

for(Resource r : resources){
	if(r.getPL() > 0) {
	
		db.WriteCFToDb(time(),simParams,
   		r.getName(), r.getSL(), r.getPL(), r.getResourceGroup(), currentReplicationCount, r.getPLOrder(), r.getSLValue(), optimizationParameters.getId()); 												
   		
		r.setSL(r.getSL()-r.getPL());
	}
}

//SL Handling
//double tt = clearingFunctionAgent.varStage1;
clearingFunctionAgent.varStage1 = clearingFunctionAgent.varStage1 - sumSlPs1;
//traceln("Stage 1 " + clearingFunctionAgent.varStage1);
clearingFunctionAgent.varStage2 = clearingFunctionAgent.varStage2 - sumSlPs2;
//traceln("Stage 2 " + clearingFunctionAgent.varStage2);
clearingFunctionAgent.varStage3 = clearingFunctionAgent.varStage3 - sumSlPs3;
//traceln("Stage 3 " + clearingFunctionAgent.varStage3);
clearingFunctionAgent.varStage4 = clearingFunctionAgent.varStage4 - sumSlPs4;
//traceln("Stage 4 " + clearingFunctionAgent.varStage4);


]]></Body>
				</Function>
				<Function AccessType="default" StaticFunction="false">
					<ReturnModificator>VOID</ReturnModificator>
					<ReturnType><![CDATA[double]]></ReturnType>
					<Id>1681278928677</Id>
					<Name><![CDATA[FunctionUpdatePSStatistic1]]></Name>
					<X>950</X><Y>1730</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Body><![CDATA[//sl: vor planunglsauf, sl = gesamter arbeitsinhalt, den wollen wir wegschreiben, das abziehen machen wir fr die PL

//die summe aller abzge: ist PL:

//wertepaar: sl vor abzug : pl -> summe der abzge

DBQueries db = new DBQueries();
resources.stream().forEach(e -> e.setPL(0));

clearingFunctionAgent.statisticStage1.add(clearingFunctionAgent.varStage1, time());
clearingFunctionAgent.dataSetStage1.add(time(), clearingFunctionAgent.varStage1);		

int sumSlPs1 = 0;
int sumSlPs2 = 0;
int sumSlPs3 = 0;
int sumSlPs4 = 0;

for(ProductionOrder order : productionStageOrders.stream().filter(e -> e.getStatus() == 
ProductionOrder.PRODUCTION_ORDER_STATUS_PROCESSED).collect(Collectors.toList())){
	
	String actualResource = order.getItem().getRouting().getResource();
	
	Resource resource = resources.stream().filter(e -> e.getName().equalsIgnoreCase(actualResource)).findFirst().get();
	
	double newQuantity = order.getQuantity() * order.getItem().getRouting().getEProcessingTime() 
	+ order.getItem().getRouting().getESetupTime();
	traceln(order. getOrderId());
	traceln(resource.getName() + " old " + resource.getPL());
	traceln(resource.getName() + " new " + (int)newQuantity);
	
	resource.setPL(resource.getPL()+(int)newQuantity);
		
	if(resource.getResourceGroup().equalsIgnoreCase("Stage1")){
		sumSlPs1 = sumSlPs1 + (int)newQuantity;	
	}
	else if(resource.getResourceGroup().equalsIgnoreCase("Stage2")){
		sumSlPs2 = sumSlPs2 + (int)newQuantity;	

	}
	else if(resource.getResourceGroup().equalsIgnoreCase("Stage3")){
		sumSlPs3 = sumSlPs3 + (int)newQuantity;	
		
	}
	else if(resource.getResourceGroup().equalsIgnoreCase("Stage4")){
		sumSlPs4 = sumSlPs4 + (int)newQuantity;	
	}		
	productionStageOrders.removeIf(o -> o.getOrderId()==order.getOrderId() && o.getStatus()==ProductionOrder.PRODUCTION_ORDER_STATUS_PROCESSED);
}	

//PL Handling
if(sumSlPs1 > 0){
	clearingFunctionAgent.varPLStage1 = sumSlPs1;
	clearingFunctionAgent.statisticPLStage1.add(clearingFunctionAgent.varPLStage1);
	clearingFunctionAgent.dataSetPLStage1.add(time(),clearingFunctionAgent.varPLStage1);
	clearingFunctionAgent.testDs.add(clearingFunctionAgent.varStage1,clearingFunctionAgent.varPLStage1);
}

if(sumSlPs2 > 0){
	clearingFunctionAgent.varPLStage2 = sumSlPs2;
	clearingFunctionAgent.statisticPLStage2.add(clearingFunctionAgent.varPLStage2);
	clearingFunctionAgent.dataSetPLStage2.add(time(),clearingFunctionAgent.varPLStage2);
	clearingFunctionAgent.testDs2.add(clearingFunctionAgent.varStage2,clearingFunctionAgent.varPLStage2);
}

if(sumSlPs3 > 0){
	clearingFunctionAgent.varPLStage3 = sumSlPs3;
	clearingFunctionAgent.statisticPLStage3.add(clearingFunctionAgent.varPLStage3);
	clearingFunctionAgent.dataSetPLStage3.add(time(),clearingFunctionAgent.varPLStage3);
	clearingFunctionAgent.testDs3.add(clearingFunctionAgent.varStage3,clearingFunctionAgent.varPLStage3);
}

if(sumSlPs4 > 0){
	clearingFunctionAgent.varPLStage4 = sumSlPs4;
	clearingFunctionAgent.statisticPLStage4.add(clearingFunctionAgent.varPLStage4);
	clearingFunctionAgent.dataSetPLStage4.add(time(),clearingFunctionAgent.varPLStage4);
	clearingFunctionAgent.testDs4.add(clearingFunctionAgent.varStage4,clearingFunctionAgent.varPLStage4);
}

for(Resource r : resources){
	if(r.getPL() > 0) {
		db.WriteCFToDb(time(),simParams,
   		r.getName(), r.getSL(), r.getPL(), r.getResourceGroup(), currentReplicationCount, r.getPLOrder(), r.getSLValue(), optimizationParameters.getId()); 												
		r.setSL(r.getSL()-r.getPL());
	}
}

//SL Handling
//double tt = clearingFunctionAgent.varStage1;
clearingFunctionAgent.varStage1 = clearingFunctionAgent.varStage1 - sumSlPs1;
traceln("Stage 1 " + clearingFunctionAgent.varStage1);
clearingFunctionAgent.varStage2 = clearingFunctionAgent.varStage2 - sumSlPs2;
traceln("Stage 2 " + clearingFunctionAgent.varStage2);
clearingFunctionAgent.varStage3 = clearingFunctionAgent.varStage3 - sumSlPs3;
traceln("Stage 3 " + clearingFunctionAgent.varStage3);
clearingFunctionAgent.varStage4 = clearingFunctionAgent.varStage4 - sumSlPs4;
traceln("Stage 4 " + clearingFunctionAgent.varStage4);


]]></Body>
				</Function>
				<Function AccessType="default" StaticFunction="false">
					<ReturnModificator>VOID</ReturnModificator>
					<ReturnType><![CDATA[double]]></ReturnType>
					<Id>1681973621302</Id>
					<Name><![CDATA[FunctionUpdatePSStatistic2]]></Name>
					<X>950</X><Y>1710</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Body><![CDATA[Tools t = new Tools();

//traceln("PL/SL identifcation --------------- " + time());

//sl: vor planunglsauf, sl = gesamter arbeitsinhalt, den wollen wir wegschreiben, das abziehen machen wir fr die PL

//die summe aller abzge: ist PL:

//wertepaar: sl vor abzug : pl -> summe der abzge

DBQueries db = new DBQueries();

resources.stream().forEach(e -> e.setPL(0));

clearingFunctionAgent.statisticStage1.add(clearingFunctionAgent.varStage1, time());
clearingFunctionAgent.dataSetStage1.add(time(), clearingFunctionAgent.varStage1);		

int sumSlPs1 = 0;
int sumSlPs2 = 0;
int sumSlPs3 = 0;
int sumSlPs4 = 0;

//for(ProductionOrder order : productionStageOrders.stream().collect(Collectors.toList())){
for(ProductionOrder order : productionOrders.stream().filter(e -> e.getActualStart() > 0 && e.getCFFinished() != 1).collect(Collectors.toList())){
	
	String actualResource = order.getItem().getRouting().getResource();
	
	Resource resource = resources.stream().filter(e -> e.getName().equalsIgnoreCase(actualResource)).findFirst().get();
	
	//double newQuantity = order.getQuantity() * order.getItem().getRouting().getEProcessingTime() 
	//+ order.getItem().getRouting().getESetupTime();
	
	double newQuantity = 0;	
	
	if(order.getActualEnd() <= 0){
		t.log("order pl " + order.getPL() + order.getPL()/14400, Tools.LogPLSLValues);
		double plAsDouble = order.getPL()/1440.0;
		t.log("Running order" + time() + " -" + order.getActualStart() + " - " + plAsDouble, Tools.LogPLSLValues);		
		newQuantity = time() - order.getActualStart() - plAsDouble;	
	}else{
		t.log("Finished Order", Tools.LogPLSLValues);
		if(order.getPlannedCapacity() <= -144000){
			//newQuantity = order.getPlannedCapacity()/1440;
			
			newQuantity = order.getActualEnd() - order.getActualStart();
			
		}else{			
			int decimalPlaces = 4;
			
			
			//if(order.getActualStart() > (time() - 1)) {
				//newQuantity = (order.getActualEnd() -order.getActualStart()) % 1;
			//}
			//else {// start schon eine periode vorher, oder genau die betrachtete periode, aber keine komma zahl 
				t.log("decimal " + (order.getActualEnd() - Math.floor(order.getActualEnd())), Tools.LogPLSLValues);
				newQuantity = order.getActualEnd() - Math.floor(order.getActualEnd());
			//}
				
			t.log("newQuanty from decimal places " + newQuantity, Tools.LogPLSLValues);
		}
		order.setCFFinished(1);		
	}

	//traceln(order.getOrderId()  + " old " + order.getPL());			
	double newProdOrderPL = order.getPL() + (int)(newQuantity * 1440);
	order.setPL(newProdOrderPL);	
	
	newQuantity = (int)(newQuantity * 1440);
		
	t.log("time: " + time() + " actual start " + order.getActualStart() + " actual end " + order.getActualEnd(), Tools.LogPLSLValues);
	t.log(order.getOrderId(), Tools.LogPLSLValues);
	t.log(resource.getName() + " new " + newQuantity, Tools.LogPLSLValues);
	t.log("processed PL: " + order.getPL(), Tools.LogPLSLValues);
	t.log("planned capa: " + order.getPlannedCapacity(), Tools.LogPLSLValues);
	
	double totalPL = resource.getPL() + (int)newQuantity;	
	resource.setPL(totalPL);
	
	resource.setPLOrder(resource.getPLOrder() + "...(" + order.getOrderId() + "|" + order.getPL() + "|" + order.getStatus() + ");");
	
		if(resource.getResourceGroup().equalsIgnoreCase("Stage1")){
			sumSlPs1 = sumSlPs1 + (int)newQuantity;	
		}
		else if(resource.getResourceGroup().equalsIgnoreCase("Stage2")){
			sumSlPs2 = sumSlPs2 + (int)newQuantity;	
	
		}
		else if(resource.getResourceGroup().equalsIgnoreCase("Stage3")){
			sumSlPs3 = sumSlPs3 + (int)newQuantity;	
			
		}
		else if(resource.getResourceGroup().equalsIgnoreCase("Stage4")){
			sumSlPs4 = sumSlPs4 + (int)newQuantity;	
		}	
			
	productionStageOrders.removeIf(o -> o.getOrderId()==order.getOrderId() && o.getStatus()==ProductionOrder.PRODUCTION_ORDER_STATUS_PROCESSED);
}	

//PL Handling
if(sumSlPs1 > 0){
	clearingFunctionAgent.varPLStage1 = sumSlPs1;
	clearingFunctionAgent.statisticPLStage1.add(clearingFunctionAgent.varPLStage1);
	clearingFunctionAgent.dataSetPLStage1.add(time(),clearingFunctionAgent.varPLStage1);
	clearingFunctionAgent.testDs.add(clearingFunctionAgent.varStage1,clearingFunctionAgent.varPLStage1);
}

if(sumSlPs2 > 0){
	clearingFunctionAgent.varPLStage2 = sumSlPs2;
	clearingFunctionAgent.statisticPLStage2.add(clearingFunctionAgent.varPLStage2);
	clearingFunctionAgent.dataSetPLStage2.add(time(),clearingFunctionAgent.varPLStage2);
	clearingFunctionAgent.testDs2.add(clearingFunctionAgent.varStage2,clearingFunctionAgent.varPLStage2);
}

if(sumSlPs3 > 0){
	clearingFunctionAgent.varPLStage3 = sumSlPs3;
	clearingFunctionAgent.statisticPLStage3.add(clearingFunctionAgent.varPLStage3);
	clearingFunctionAgent.dataSetPLStage3.add(time(),clearingFunctionAgent.varPLStage3);
	clearingFunctionAgent.testDs3.add(clearingFunctionAgent.varStage3,clearingFunctionAgent.varPLStage3);
}

if(sumSlPs4 > 0){
	clearingFunctionAgent.varPLStage4 = sumSlPs4;
	clearingFunctionAgent.statisticPLStage4.add(clearingFunctionAgent.varPLStage4);
	clearingFunctionAgent.dataSetPLStage4.add(time(),clearingFunctionAgent.varPLStage4);
	clearingFunctionAgent.testDs4.add(clearingFunctionAgent.varStage4,clearingFunctionAgent.varPLStage4);
}

for(Resource r : resources){
	if(r.getPL() > 0) {
	
		db.WriteCFToDb(time(),simParams,
   		r.getName(), r.getSL(), r.getPL(), r.getResourceGroup(), currentReplicationCount, r.getPLOrder(), r.getSLValue(), optimizationParameters.getId()); 												
   		
		r.setSL(r.getSL()-r.getPL());
	}
}

//SL Handling
//double tt = clearingFunctionAgent.varStage1;
clearingFunctionAgent.varStage1 = clearingFunctionAgent.varStage1 - sumSlPs1;
//traceln("Stage 1 " + clearingFunctionAgent.varStage1);
clearingFunctionAgent.varStage2 = clearingFunctionAgent.varStage2 - sumSlPs2;
//traceln("Stage 2 " + clearingFunctionAgent.varStage2);
clearingFunctionAgent.varStage3 = clearingFunctionAgent.varStage3 - sumSlPs3;
//traceln("Stage 3 " + clearingFunctionAgent.varStage3);
clearingFunctionAgent.varStage4 = clearingFunctionAgent.varStage4 - sumSlPs4;
//traceln("Stage 4 " + clearingFunctionAgent.varStage4);


]]></Body>
				</Function>
				<Function AccessType="default" StaticFunction="false">
					<ReturnModificator>VOID</ReturnModificator>
					<ReturnType><![CDATA[double]]></ReturnType>
					<Id>1708028807053</Id>
					<Name><![CDATA[Function_ApplyOptimizationParametersWSC24_1]]></Name>
					<X>950</X><Y>2060</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Body><![CDATA[		traceln("Setting Optimization Parameters for " + optimizationParameters.getDescription() + " " + simParams.getName() + " Simulation Parameter: " + optimizationParameters.getSimulationParameter());		
						
		simParams.setDemandGeneration(SimulationParameter.DEMAND_GENERATION_CUSTOMER_REQUIRED_LEADTIME);				
																		
		//0 = MRP, 1 = RPS, 2 = ConWip
		if(optimizationParameters.getX019()==0) {
			simParams.setApplyMRP(1);
			simParams.setApplyOptimization(0);
			simParams.setApplyRPS(0);
			simParams.setApplyConWip(0);
		}else if(optimizationParameters.getX019()==1) {
			simParams.setApplyMRP(1);
			simParams.setApplyOptimization(0);
			simParams.setApplyRPS(1);
			simParams.setApplyConWip(0);			
		}else if(optimizationParameters.getX019()==2) {
			simParams.setApplyMRP(1);
			simParams.setApplyOptimization(0);
			simParams.setApplyRPS(0);
			simParams.setApplyConWip(SimulationParameter.APPLY_CONWIP);
			simParams.setWaW(optimizationParameters.getX014());
			simParams.setWipCap(optimizationParameters.getX015());
		}else if(optimizationParameters.getX019()==3) {
			simParams.setApplyMRP(1);
			simParams.setApplyOptimization(0);
			simParams.setApplyRPS(0);
			simParams.setApplyConWip(SimulationParameter.APPLY_CONWIP_MPS);
			simParams.setWaW(optimizationParameters.getX014());
			simParams.setWipCap(optimizationParameters.getX015());
		}
					
	
	for(OrderFuture of : orderFuture) {
		of.setECustomerRequiredLeadTime((int)optimizationParameters.getX018());
		//of.setVarCustomerRequiredLeadTime(optimizationParameters.getX018() * 0.5);
		of.setVarCustomerRequiredLeadTime(5 * 0.5);		
	}

	orderFuture.removeIf(e -> e.getDemandScenario() != optimizationParameters.getX000());
	traceln("Order future size: " + orderFuture.size());

	OrderFuture emptyOf = new OrderFuture();
	
	for(Item i : items){				
		
		if(i.getType().equalsIgnoreCase(Item.ITEM_TYPE_SALES) 
		|| i.getType().equalsIgnoreCase(Item.ITEM_TYPE_COMPONENT)){
		
			double componentDemandSelected = 0;			
		
			OrderFuture f = orderFuture.stream().filter(e -> e.getItem().getItem() == i.getItem()).findFirst().orElse(emptyOf);			

			if(simParams.getApplyRPS() == 1) {				
				i.setPlanningType(Item.ITEM_PLANNINGTYPE_RPS);				
			}

			//Safety Stock End Items
			if(i.getType().equalsIgnoreCase(Item.ITEM_TYPE_SALES)) {				
				i.setSafetyStock(Math.round(f.getEOrderAmount()*optimizationParameters.getX001()));				
			}
			
			//Safety Stock Components
			if(i.getType().equalsIgnoreCase(Item.ITEM_TYPE_COMPONENT)){
									
				if(simParams.getExperiment().equalsIgnoreCase("WSC24_1")){
					
					if(optimizationParameters.getX000() == 95) {
						if(i.getItem() == 201 || i.getItem() == 202){
							componentDemandSelected = 212.06; //95% 201 202
						}else if(i.getItem() == 301){
							componentDemandSelected = 424.12; //95% 301
						}
					}
						
					if(optimizationParameters.getX000() == 90) {
						if(i.getItem() == 201 || i.getItem() == 202){
							componentDemandSelected = 199.58; //90 % 201 202
						}else if(i.getItem() == 301){
							componentDemandSelected = 399.17; //90% 301				
						}
					}	
								
					if(optimizationParameters.getX000() == 85) {										
						if(i.getItem() == 201 || i.getItem() == 202){						
							componentDemandSelected = 187.11; // 85 % 201,202
						}else if(i.getItem() == 301){
							componentDemandSelected = 374.22; // 85 % 301		
						}
					}	
				}
				
				if(simParams.getExperiment().equalsIgnoreCase("WSC24_2")){
				
					if(optimizationParameters.getX000() == 95) {
						if(i.getItem() == 201 || i.getItem() == 202){
							componentDemandSelected = 211.03; //95% 201 202
						}else if(i.getItem() == 301){
							componentDemandSelected = 422.07; //95% 201 202
						}
					}
				
					if(optimizationParameters.getX000() == 90) {
						if(i.getItem() == 201 || i.getItem() == 202){
							componentDemandSelected = 198.62; //90 % 201 202
						}else if(i.getItem() == 301){
							componentDemandSelected = 397.24; //90% 399.17
						}
					}
					
					if(optimizationParameters.getX000() == 85) {
						if(i.getItem() == 201 || i.getItem() == 202){
							componentDemandSelected = 186.21; // 85 % 201,202
						}else if(i.getItem() == 301){
							componentDemandSelected = 372.41; // 85 % 301	
						}
					}	
				}
					
				traceln("cs: " + componentDemandSelected);
				i.setSafetyStock(Math.round(componentDemandSelected*optimizationParameters.getX004()));

			}
			
			traceln("Item: " + i.getItem() +  " SS: " + i.getSafetyStock() + " EOrderAmount: " + f.getEOrderAmount() +
			" VarOrderAmount: " + f.getVarOrderAmount() + " ECRL: " + f.getECustomerRequiredLeadTime() + 
			" VarCRL: " + f.getVarCustomerRequiredLeadTime() + " SS Factor EI/Co: " + optimizationParameters.getX001() + "|" + optimizationParameters.getX004() + 
			" ComponentDemand: "  + " SS: " + i.getSafetyStock());			
			
			
			//Lead Time end item
			if(i.getType().equalsIgnoreCase(Item.ITEM_TYPE_SALES)){		
				i.setLeadTime((int)optimizationParameters.getX003());
				traceln("Item " + i.getItem() + " LT: " + i.getLeadTime());
			}
			
			//lead time component
			if(i.getType().equalsIgnoreCase(Item.ITEM_TYPE_COMPONENT)){		
				i.setLeadTime((int)optimizationParameters.getX006());
				traceln("Item " + i.getItem() + " LT: " + i.getLeadTime());
			}
			
			//Lotpolicy
			if(i.getType().equalsIgnoreCase(Item.ITEM_TYPE_SALES)){							
						
				if(optimizationParameters.getX002() <= 5) {
					i.setLotsizePolicy("FOP");			
					i.setFOPPeriod((int)optimizationParameters.getX002());							
					traceln("Item: " + i.getItem() + " FOP: " + i.getFOPPeriod());				
				}else {
				//-5 is used to seperate it from the fop				
					traceln(f.getEOrderAmount());
					
					int foqQty = (int)(f.getEOrderAmount()*(optimizationParameters.getX002()-5));
					
					i.setFOQQuantity(foqQty);										
					i.setLotsizePolicy("FOQ");
					i.setFOQMinimumLotSize(foqQty);
					
					int RopQty = (int)(f.getEOrderAmount()*(optimizationParameters.getX016()));
					i.setRPSQty(RopQty);						
					traceln("Item: " + i.getItem() + " FOQ: " + i.getFOQQuantity() + " Min Qty: " + i.getFOQMinimumLotSize() + " ROP Qty: " + i.getRPSQty());
				}	
			}// Lotpolicy enditem
			
			if(i.getType().equalsIgnoreCase(Item.ITEM_TYPE_COMPONENT)){							
						
				if(optimizationParameters.getX005() <= 5) {
					i.setLotsizePolicy("FOP");			
					i.setFOPPeriod((int)optimizationParameters.getX005());							
					traceln("Item: " + i.getItem() + " FOP: " + i.getFOPPeriod());				
				}else {
				//-5 is used to seperate it from the fop				
					int foqQty = (int)(componentDemandSelected * (optimizationParameters.getX005()-5));
					
					i.setFOQQuantity(foqQty);										
					i.setLotsizePolicy("FOQ");
					i.setFOQMinimumLotSize(foqQty);
					
					int RopQty = (int)(componentDemandSelected * (optimizationParameters.getX017()));						
					i.setRPSQty(RopQty);
					traceln("Item: " + i.getItem() + " FOQ: " + i.getFOQQuantity() + " Min Qty: " + i.getFOQMinimumLotSize() + " ROP Qty: " + i.getRPSQty());
				}	
			}// Lotpolicy component
										
		}//if sales or components				
		
	}//for items
	
]]></Body>
				</Function>
				<Function AccessType="default" StaticFunction="false">
					<ReturnModificator>VOID</ReturnModificator>
					<ReturnType><![CDATA[double]]></ReturnType>
					<Id>1712730885661</Id>
					<Name><![CDATA[Function_ApplyOptimizationParametersWSC24_2]]></Name>
					<X>950</X><Y>2080</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Body><![CDATA[		traceln("Setting Optimization Parameters for " + optimizationParameters.getDescription() + " " + simParams.getName() + " Simulation Parameter: " + optimizationParameters.getSimulationParameter());		
		traceln("Energy Planning for Winter Simulation Conference 2023");
						
		simParams.setDemandGeneration(SimulationParameter.DEMAND_GENERATION_CUSTOMER_REQUIRED_LEADTIME);				
																		
		//0 = MRP, 1 = RPS, 2 = ConWip
		if(optimizationParameters.getX019()==0) {
			simParams.setApplyMRP(1);
			simParams.setApplyOptimization(0);
			simParams.setApplyRPS(0);
			simParams.setApplyConWip(0);
		}else if(optimizationParameters.getX019()==1) {
			simParams.setApplyMRP(1);
			simParams.setApplyOptimization(0);
			simParams.setApplyRPS(1);
			simParams.setApplyConWip(0);			
		}else if(optimizationParameters.getX019()==2) {
			simParams.setApplyMRP(1);
			simParams.setApplyOptimization(0);
			simParams.setApplyRPS(0);
			simParams.setApplyConWip(SimulationParameter.APPLY_CONWIP);
			simParams.setWaW(optimizationParameters.getX014());
			simParams.setWipCap(optimizationParameters.getX015());
		}else if(optimizationParameters.getX019()==3) {
			simParams.setApplyMRP(1);
			simParams.setApplyOptimization(0);
			simParams.setApplyRPS(0);
			simParams.setApplyConWip(SimulationParameter.APPLY_CONWIP_MPS);
			simParams.setWaW(optimizationParameters.getX014());
			simParams.setWipCap(optimizationParameters.getX015());
		}
					
	
	for(OrderFuture of : orderFuture) {
		of.setECustomerRequiredLeadTime((int)optimizationParameters.getX018());
		//of.setVarCustomerRequiredLeadTime(optimizationParameters.getX018() * 0.5);
		of.setVarCustomerRequiredLeadTime(5 * 0.5);		
	}

	simParams.setEnergyPriceFactor(optimizationParameters.getX012());
	simParams.setCapacityFactor(optimizationParameters.getX013());

	orderFuture.removeIf(e -> e.getDemandScenario() != optimizationParameters.getX000());
	traceln("Order future size: " + orderFuture.size());

	OrderFuture emptyOf = new OrderFuture();
	
	for(Item i : items){				
		
		if(i.getType().equalsIgnoreCase(Item.ITEM_TYPE_SALES) 
		|| i.getType().equalsIgnoreCase(Item.ITEM_TYPE_COMPONENT)){
		
			double componentDemandSelected = 0;			
		
			OrderFuture f = orderFuture.stream().filter(e -> e.getItem().getItem() == i.getItem()).findFirst().orElse(emptyOf);			

			if(simParams.getApplyRPS() == 1) {				
				i.setPlanningType(Item.ITEM_PLANNINGTYPE_RPS);				
			}

			//Safety Stock End Items
			if(i.getType().equalsIgnoreCase(Item.ITEM_TYPE_SALES)) {				
				i.setSafetyStock(Math.round(f.getEOrderAmount()*optimizationParameters.getX001()));				
			}
			
			//Safety Stock Components
			if(i.getType().equalsIgnoreCase(Item.ITEM_TYPE_COMPONENT)){
									
				if(simParams.getExperiment().equalsIgnoreCase("WSC24_1")){
					
					if(optimizationParameters.getX000() == 95) {
						if(i.getItem() == 201 || i.getItem() == 202){
							componentDemandSelected = 212.06; //95% 201 202
						}else if(i.getItem() == 301){
							componentDemandSelected = 424.12; //95% 301
						}
					}
						
					if(optimizationParameters.getX000() == 90) {
						if(i.getItem() == 201 || i.getItem() == 202){
							componentDemandSelected = 199.58; //90 % 201 202
						}else if(i.getItem() == 301){
							componentDemandSelected = 399.17; //90% 301				
						}
					}	
								
					if(optimizationParameters.getX000() == 85) {										
						if(i.getItem() == 201 || i.getItem() == 202){						
							componentDemandSelected = 187.11; // 85 % 201,202
						}else if(i.getItem() == 301){
							componentDemandSelected = 374.22; // 85 % 301		
						}
					}	
				}
				
				if(simParams.getExperiment().equalsIgnoreCase("WSC24_2")){
				
					if(optimizationParameters.getX000() == 95) {
						if(i.getItem() == 201 || i.getItem() == 202){
							componentDemandSelected = 211.03; //95% 201 202
						}else if(i.getItem() == 301){
							componentDemandSelected = 422.07; //95% 201 202
						}
					}
				
					if(optimizationParameters.getX000() == 90) {
						if(i.getItem() == 201 || i.getItem() == 202){
							componentDemandSelected = 198.62; //90 % 201 202
						}else if(i.getItem() == 301){
							componentDemandSelected = 397.24; //90% 399.17
						}
					}
					
					if(optimizationParameters.getX000() == 85) {
						if(i.getItem() == 201 || i.getItem() == 202){
							componentDemandSelected = 186.21; // 85 % 201,202
						}else if(i.getItem() == 301){
							componentDemandSelected = 372.41; // 85 % 301	
						}
					}	
				}
					
				traceln("cs: " + componentDemandSelected);
				i.setSafetyStock(Math.round(componentDemandSelected*optimizationParameters.getX004()));

			}
			
			traceln("Item: " + i.getItem() +  " SS: " + i.getSafetyStock() + " EOrderAmount: " + f.getEOrderAmount() +
			" VarOrderAmount: " + f.getVarOrderAmount() + " ECRL: " + f.getECustomerRequiredLeadTime() + 
			" VarCRL: " + f.getVarCustomerRequiredLeadTime() + " SS Factor EI/Co: " + optimizationParameters.getX001() + "|" + optimizationParameters.getX004() + 
			" ComponentDemand: "  + " SS: " + i.getSafetyStock());			
			
			
			//Lead Time end item
			if(i.getType().equalsIgnoreCase(Item.ITEM_TYPE_SALES)){		
				i.setLeadTime((int)optimizationParameters.getX003());
				traceln("Item " + i.getItem() + " LT: " + i.getLeadTime());
			}
			
			//lead time component
			if(i.getType().equalsIgnoreCase(Item.ITEM_TYPE_COMPONENT)){		
				i.setLeadTime((int)optimizationParameters.getX006());
				traceln("Item " + i.getItem() + " LT: " + i.getLeadTime());
			}
			
			//Lotpolicy
			if(i.getType().equalsIgnoreCase(Item.ITEM_TYPE_SALES)){							
						
				if(optimizationParameters.getX002() <= 10) {
					i.setLotsizePolicy("FOP");			
					i.setFOPPeriod((int)optimizationParameters.getX002());							
					traceln("Item: " + i.getItem() + " FOP: " + i.getFOPPeriod());				
				}else {
				//-5 is used to seperate it from the fop				
					traceln(f.getEOrderAmount());
					
					int foqQty = (int)(f.getEOrderAmount()*(optimizationParameters.getX002()-5));
					
					i.setFOQQuantity(foqQty);										
					i.setLotsizePolicy("FOQ");
					i.setFOQMinimumLotSize(foqQty);
					
					int RopQty = (int)(f.getEOrderAmount()*(optimizationParameters.getX016()));
					i.setRPSQty(RopQty);						
					traceln("Item: " + i.getItem() + " FOQ: " + i.getFOQQuantity() + " Min Qty: " + i.getFOQMinimumLotSize() + " ROP Qty: " + i.getRPSQty());
				}	
			}// Lotpolicy enditem
			
			if(i.getType().equalsIgnoreCase(Item.ITEM_TYPE_COMPONENT)){							
						
				if(optimizationParameters.getX005() <= 10) {
					i.setLotsizePolicy("FOP");			
					i.setFOPPeriod((int)optimizationParameters.getX005());							
					traceln("Item: " + i.getItem() + " FOP: " + i.getFOPPeriod());				
				}else {
				//-5 is used to seperate it from the fop				
					int foqQty = (int)(componentDemandSelected * (optimizationParameters.getX005()-5));
					
					i.setFOQQuantity(foqQty);										
					i.setLotsizePolicy("FOQ");
					i.setFOQMinimumLotSize(foqQty);
					
					int RopQty = (int)(componentDemandSelected * (optimizationParameters.getX017()));						
					i.setRPSQty(RopQty);
					traceln("Item: " + i.getItem() + " FOQ: " + i.getFOQQuantity() + " Min Qty: " + i.getFOQMinimumLotSize() + " ROP Qty: " + i.getRPSQty());
				}	
			}// Lotpolicy component
										
		}//if sales or components				
		
	}//for items
	
]]></Body>
				</Function>
				<Function AccessType="default" StaticFunction="false">
					<ReturnModificator>RETURNS_VALUE</ReturnModificator>
					<ReturnType><![CDATA[int]]></ReturnType>
					<Id>1719831789010</Id>
					<Name><![CDATA[ItemSelector]]></Name>
					<X>950</X><Y>2110</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Body><![CDATA[
int[] itemNumbers = new int[interArrivalTimes.size()];;
double[] probabilityOfItems = new double[interArrivalTimes.size()];
 
//Zuweisung der Werte aus der Klasse Product Group welche von Excel Sheet abhngt
for (int i = 0; i < interArrivalTimes.size(); i++) {
 
	itemNumbers[i] = interArrivalTimes.get(i).getItem();
	probabilityOfItems[i] = interArrivalTimes.get(i).getProbabilityOfItem();
	
}
 
int item = RandomItemSelector.random(itemNumbers, probabilityOfItems,
 var_random_Item_Selection);
 
return item;]]></Body>
				</Function>
				<Function AccessType="default" StaticFunction="false">
					<ReturnModificator>VOID</ReturnModificator>
					<ReturnType><![CDATA[double]]></ReturnType>
					<Id>1724766149089</Id>
					<Name><![CDATA[Function_ApplyOptimizationParametersWSC24Extension]]></Name>
					<X>950</X><Y>2160</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Body><![CDATA[		traceln("Setting Optimization Parameters for " + optimizationParameters.getDescription() + " " + simParams.getName() + " Simulation Parameter: " + optimizationParameters.getSimulationParameter());
		traceln("WSC24 Extension");
		traceln("Current Optimizationparameter: " + optimizationParameters.toString());
		simParams.setDemandGeneration(SimulationParameter.DEMAND_GENERATION_INTERARRIVAL_TIME);
		simParams.setDemandScenario((int) optimizationParameters.getX018());

		//0 = MRP, 1 = RPS, 2 = ConWip
		if (optimizationParameters.getX019() == 0) {
		  simParams.setApplyMRP(1);
		  simParams.setApplyOptimization(0);
		  simParams.setApplyRPS(0);
		  simParams.setApplyConWip(0);
		} else if (optimizationParameters.getX019() == 1) {
		  simParams.setApplyMRP(1);
		  simParams.setApplyOptimization(0);
		  simParams.setApplyRPS(1);
		  simParams.setApplyConWip(0);
		} else if (optimizationParameters.getX019() == 2) {
		  simParams.setApplyMRP(1);
		  simParams.setApplyOptimization(0);
		  simParams.setApplyRPS(0);
		  simParams.setApplyConWip(SimulationParameter.APPLY_CONWIP);
		  simParams.setWaW(optimizationParameters.getV004()); //x014
		  simParams.setWipCap(optimizationParameters.getV003()); //x015
		  simParams.setWipCapComponents(optimizationParameters.getV008());
		} else if (optimizationParameters.getX019() == 3) {
		  simParams.setApplyMRP(1);
		  simParams.setApplyOptimization(0);
		  simParams.setApplyRPS(0);
		  simParams.setApplyConWip(SimulationParameter.APPLY_CONWIP_MPS);
		  
		  simParams.setWaW(optimizationParameters.getV004()); //x014
		  simParams.setWipCap(optimizationParameters.getV003()); //x015		  		 		  
		  simParams.setWipCapComponents(optimizationParameters.getV008());
		  		  
		  //simParams.setWipCap(11000); //x015		  
		  //simParams.setWipCapComponents(11000);		  
		  		  		  
		}
		
		traceln("WAW: " + simParams.getWaW());
		traceln("WipCap: " + simParams.getWipCap());
		traceln("WipCapComponents: " + simParams.getWipCapComponents());

		int demandScenarioInt = (int) optimizationParameters.getX018();
		String demandScenarioString = Integer.toString(demandScenarioInt);
		traceln("Demand Scenario: " + demandScenarioString);

		interArrivalTimes.removeIf(e -> !e.getDemandScenario().equals(demandScenarioString));

		interArrivalTimes.removeIf(e -> {
		  String demandScenario = e.getDemandScenario();
		  return demandScenario == null || !demandScenario.equals(demandScenarioString);
		});

		traceln("Interarrivaltime size: " + interArrivalTimes.size());

		//OrderFuture emptyOf = new OrderFuture();
		InterArrivalTime emptyOf = new InterArrivalTime();

		for (Item i: items) {

		  if (i.getType().equalsIgnoreCase(Item.ITEM_TYPE_SALES) ||
		    i.getType().equalsIgnoreCase(Item.ITEM_TYPE_COMPONENT)) {

		    double componentDemandSelected = 0;

		    InterArrivalTime f = interArrivalTimes.stream().filter(e -> e.getItem() == i.getItem()).findFirst().orElse(emptyOf);

			traceln("InterarrivalTime: " + f.getItem() + " MeanOrderAmount: " + f.getMeanOrderAmount());

		    if (simParams.getApplyRPS() == 1) {
		      i.setPlanningType(Item.ITEM_PLANNINGTYPE_RPS);
		    }

		    //Safety Stock End Items
		    if (i.getType().equalsIgnoreCase(Item.ITEM_TYPE_SALES)) {

		      double safetyStock = 0;

				if (i.getItem() == 101) {
				    safetyStock = optimizationParameters.getV002();
				}
				
				if (i.getItem() == 102) {
				    safetyStock = optimizationParameters.getV007();
				}
				
				if (i.getItem() == 103) {
				    safetyStock = optimizationParameters.getV012();
				}
				
				if (i.getItem() == 104) {
				    safetyStock = optimizationParameters.getV017();
				}
				
				if (i.getItem() == 105) {
				    safetyStock = optimizationParameters.getV022();
				}
				
				if (i.getItem() == 106) {
				    safetyStock = optimizationParameters.getV027();
				}
				
				if (i.getItem() == 107) {
				    safetyStock = optimizationParameters.getV032();
				}
				
				if (i.getItem() == 108) {
				    safetyStock = optimizationParameters.getV037();
				}

		      i.setSafetyStock(Math.round(f.getMeanOrderAmount() * safetyStock));
		      traceln("End Item SS: Factor " + safetyStock + " Qty: " + i.getSafetyStock() + " MeanOrderAmount: " + f.getMeanOrderAmount());
		    }

		    //Safety Stock Components
		    if (i.getType().equalsIgnoreCase(Item.ITEM_TYPE_COMPONENT)) {
		      boolean isMatching = simParams.getExperiment().substring(0, "WSC24_1".length()).equalsIgnoreCase("WSC24_1");

		      if (isMatching) {

		        if (optimizationParameters.getX000() == 95) {
		          if (i.getItem() == 201 || i.getItem() == 202) {
		            componentDemandSelected = 212.06; //95% 201 202
		          } else if (i.getItem() == 301) {
		            componentDemandSelected = 424.12; //95% 301
		          }
		        }

		        if (optimizationParameters.getX000() == 93) {
		          if (i.getItem() == 201 || i.getItem() == 202) {
		            componentDemandSelected = 206.07; //93 % 201 202
		          } else if (i.getItem() == 301) {
		            componentDemandSelected = 412.14; //93% 301				
		          }
		        }

		        if (optimizationParameters.getX000() == 90) {
		          if (i.getItem() == 201 || i.getItem() == 202) {
		            componentDemandSelected = 199.58; //90 % 201 202
		          } else if (i.getItem() == 301) {
		            componentDemandSelected = 399.17; //90% 301				
		          }
		        }

		        if (optimizationParameters.getX000() == 85) {
		          if (i.getItem() == 201 || i.getItem() == 202) {
		            componentDemandSelected = 187.11; // 85 % 201,202
		          } else if (i.getItem() == 301) {
		            componentDemandSelected = 374.22; // 85 % 301		
		          }
		        }
		      }

		      isMatching = simParams.getExperiment().substring(0, "WSC24_2".length()).equalsIgnoreCase("WSC24_2");

		      if (isMatching) {

		        if (optimizationParameters.getX000() == 95) {
		          if (i.getItem() == 201 || i.getItem() == 202) {
		            componentDemandSelected = 211.03; //95% 201 202
		          } else if (i.getItem() == 301) {
		            componentDemandSelected = 422.07; //95% 201 202
		          }
		        }

		        if (optimizationParameters.getX000() == 93) {
		          if (i.getItem() == 201 || i.getItem() == 202) {
		            componentDemandSelected = 206.07; //93 % 201 202
		          } else if (i.getItem() == 301) {
		            componentDemandSelected = 412.14; //93% 399.17
		          }
		        }

		        if (optimizationParameters.getX000() == 90) {
		          if (i.getItem() == 201 || i.getItem() == 202) {
		            componentDemandSelected = 198.62; //90 % 201 202
		          } else if (i.getItem() == 301) {
		            componentDemandSelected = 397.24; //90% 399.17
		          }
		        }

		        if (optimizationParameters.getX000() == 85) {
		          if (i.getItem() == 201 || i.getItem() == 202) {
		            componentDemandSelected = 186.21; // 85 % 201,202
		          } else if (i.getItem() == 301) {
		            componentDemandSelected = 372.41; // 85 % 301	
		          }
		        }
		      }

		      double safetyStock = 0;
				if (i.getItem() == 201) {
				    safetyStock = optimizationParameters.getV042();
				}
				
				if (i.getItem() == 202) {
				    safetyStock = optimizationParameters.getV047();
				}
				
				if (i.getItem() == 301) {
				    safetyStock = optimizationParameters.getV052();
				}

		      traceln("cs: " + componentDemandSelected);
		      i.setSafetyStock(Math.round(componentDemandSelected * safetyStock));
		    }

		    traceln("Item: " + i.getItem() + " SS: " + i.getSafetyStock() + " EOrderAmount: " + f.getMeanOrderAmount() +
		      " MeanOrderAmount: " + f.getMeanOrderAmount() + " " +
		      " CRL fixedpart: " + f.getLeadTimeFixPart() + " CRL variable part " + f.getMeanLeadTimeVariablePart());

		    //####################################### lead time END items ####################
		    if (i.getType().equalsIgnoreCase(Item.ITEM_TYPE_SALES)) {
		          if (101 == i.getItem()) {
		            i.setLeadTime((int) optimizationParameters.getV001());
		          } 
		          if (102 == i.getItem()) {
		            i.setLeadTime((int) optimizationParameters.getV006());	            
		          } 
		          if (103 == i.getItem()) {
		            i.setLeadTime((int) optimizationParameters.getV011());
		          } 
		          if (104 == i.getItem()) {
		            i.setLeadTime((int) optimizationParameters.getV016());
		          } 
		          if (105 == i.getItem()) {
		            i.setLeadTime((int) optimizationParameters.getV021());
		          } 
		           if (106 == i.getItem()) {
		            i.setLeadTime((int) optimizationParameters.getV026());
		          } 
		          if (107 == i.getItem()) {
		            i.setLeadTime((int) optimizationParameters.getV031());
		          } 
		          if (108 == i.getItem()) {
		            i.setLeadTime((int) optimizationParameters.getV036());
		          }

		    }

		    //####################################### lead time component ####################
		    if (i.getType().equalsIgnoreCase(Item.ITEM_TYPE_COMPONENT)) {

		          if (201 == i.getItem()) {
		            i.setLeadTime((int) optimizationParameters.getV041());
		          } 
		          if (202 == i.getItem()) {
		            i.setLeadTime((int) optimizationParameters.getV046());

		          } 
		          if (301 == i.getItem()) {
		            i.setLeadTime((int) optimizationParameters.getV051());
		          }   
		    }

		    traceln("Item " + i.getItem() + " LT: " + i.getLeadTime());

		    double lotPolicyValue = 0;
		    int rOPFactor = 0;

		    // ##################### Lotpolicy END Items amd ROP facotor
		    if (i.getType().equalsIgnoreCase(Item.ITEM_TYPE_SALES)) {
		          if (101 == i.getItem()) {
		            lotPolicyValue =  optimizationParameters.getV000();
		            rOPFactor = (int) optimizationParameters.getV001();
		          } 
		          if (102 == i.getItem()) {
		            lotPolicyValue = optimizationParameters.getV005();
		            rOPFactor = (int) optimizationParameters.getV006();

		          } 
		          if (103 == i.getItem()) {
		            lotPolicyValue = optimizationParameters.getV010();
		            rOPFactor = (int) optimizationParameters.getV011();

		          } 
		          if (104 == i.getItem()) {
		            lotPolicyValue = optimizationParameters.getV015();
		            rOPFactor = (int) optimizationParameters.getV016();

		          } 
		          if (105 == i.getItem()) {
		            lotPolicyValue = optimizationParameters.getV020();
		            rOPFactor = (int) optimizationParameters.getV021();

		          } 
		          if (106 == i.getItem()) {
		            lotPolicyValue = optimizationParameters.getV025();
		            rOPFactor = (int) optimizationParameters.getV026();

		          } 
		          if (107 == i.getItem()) {
		            lotPolicyValue = optimizationParameters.getV030();
		            rOPFactor = (int) optimizationParameters.getV031();

		          } 
		          if (108 == i.getItem()) {
		            lotPolicyValue = optimizationParameters.getV035();
		            rOPFactor = (int) optimizationParameters.getV036();

		          }
		      
			  traceln("Lotpolicy Value: " + lotPolicyValue);
		      if (lotPolicyValue <= 5) {
		        i.setLotsizePolicy("FOP");
		        i.setFOPPeriod((int)lotPolicyValue);
		        traceln("Item: " + i.getItem() + " FOP: " + i.getFOPPeriod());
		      } else {
		        //-5 is used to seperate it from the fop				
		        traceln(f.getMeanOrderAmount());

		        int foqQty = (int)(f.getMeanOrderAmount() * (lotPolicyValue - 5));

		        i.setFOQQuantity(foqQty);
		        i.setLotsizePolicy("FOQ");
		        i.setFOQMinimumLotSize(foqQty);

		        int RopQty = (int)(f.getMeanOrderAmount() * rOPFactor);
		        i.setRPSQty(RopQty);
		        traceln("Item: " + i.getItem() + " FOQ: " + i.getFOQQuantity() + " Min Qty: " + i.getFOQMinimumLotSize() + " ROP Qty: " + i.getRPSQty());
		      }
		    } // Lotpolicy enditem

		    //lot policy conponents and RPS Factor
		    lotPolicyValue = 0;
		    rOPFactor = 0;
		    
		    if (i.getType().equalsIgnoreCase(Item.ITEM_TYPE_COMPONENT)) {
		      
		          if (201 == i.getItem()) {
		            lotPolicyValue = optimizationParameters.getV040();
		            rOPFactor = (int) optimizationParameters.getV041();
		          } 
		          if (202 == i.getItem()) {
		            lotPolicyValue = optimizationParameters.getV045();
		            rOPFactor = (int) optimizationParameters.getV046();

		          } 
		          if (301 == i.getItem()) {
		            lotPolicyValue = optimizationParameters.getV050();
		            rOPFactor = (int) optimizationParameters.getV051();

		          }	      
			  traceln("Lotpolicy Value: " + lotPolicyValue);
		      if (lotPolicyValue <= 5) {
		        i.setLotsizePolicy("FOP");
		        i.setFOPPeriod((int) lotPolicyValue);
		        traceln("Item: " + i.getItem() + " FOP: " + i.getFOPPeriod());
		      } else {
		        //-5 is used to seperate it from the fop				
		        int foqQty = (int)(componentDemandSelected * (lotPolicyValue - 5));

		        i.setFOQQuantity(foqQty);
		        i.setLotsizePolicy("FOQ");
		        i.setFOQMinimumLotSize(foqQty);

		        int RopQty = (int)(componentDemandSelected * lotPolicyValue);
		        i.setRPSQty(RopQty);
		        traceln("Item: " + i.getItem() + " FOQ: " + i.getFOQQuantity() + " Min Qty: " + i.getFOQMinimumLotSize() + " ROP Qty: " + i.getRPSQty());
		      }
		    } // Lotpolicy component

		  } //if sales or components				

		} //for items]]></Body>
				</Function>
				<Function AccessType="default" StaticFunction="false">
					<ReturnModificator>VOID</ReturnModificator>
					<ReturnType><![CDATA[double]]></ReturnType>
					<Id>1725971529429</Id>
					<Name><![CDATA[Function_OrderRelease]]></Name>
					<X>950</X><Y>2130</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Parameter>
						<Name><![CDATA[ReleaseOrigin]]></Name>
						<Type><![CDATA[String]]></Type>
					</Parameter>
					<Body><![CDATA[Tools t = new Tools();

List<Integer> itemsNoLongerCheck = new ArrayList<>();
itemsNoLongerCheck.clear();

if(simParams.getApplyConWip() > 0) {
	Function_OrderRelease_ConWip(ReleaseOrigin);

}else {

 List<Item> selectedItems = items.stream().filter(e -> e.getType().equalsIgnoreCase(Item.ITEM_TYPE_SALES) || e.getType().equalsIgnoreCase(Item.ITEM_TYPE_COMPONENT)).collect(Collectors.toList());
 
 if(ReleaseOrigin.equalsIgnoreCase("Machine")){
 	selectedItems = items.stream().filter(e -> e.getType().equalsIgnoreCase(Item.ITEM_TYPE_SALES)).collect(Collectors.toList());					
 }

t.log("Release Origin " + ReleaseOrigin + " Time: " + time(), Tools.LogReleases);

productionOrders.stream().filter(e -> e.getStatus() == ProductionOrder.PRODUCTION_ORDER_STATUS_UNPROCESSED ||
    	 e.getStatus() == ProductionOrder.PRODUCTION_ORDER_WAITING_FOR_MATERIAL).forEach(e -> e.setReleaseChecked(0));     	  

	List<ProductionOrder> selectedProdOrders = new ArrayList();
		
	if(ReleaseOrigin.equalsIgnoreCase(SimulationParameter.RELEASE_ORIGIN_CF)){
		selectedProdOrders = productionOrders.stream().filter(e->
    	((e.getStatus() == ProductionOrder.PRODUCTION_ORDER_STATUS_UNPROCESSED) ||
    	 e.getStatus() == ProductionOrder.PRODUCTION_ORDER_WAITING_FOR_MATERIAL)
         && (e.getPlannedStart() - MRP.PERIOD_BALANCING) <= time() && e.getReleaseChecked() == 0).
		sorted(Comparator.comparing(ProductionOrder::getPlannedEnd)).collect(Collectors.toList());	
	}
	else if(ReleaseOrigin.equalsIgnoreCase("MRP")){
		selectedProdOrders = productionOrders.stream().filter(e -> (e.getStatus() == ProductionOrder.PRODUCTION_ORDER_STATUS_UNPROCESSED ||
		e.getStatus() == ProductionOrder.PRODUCTION_ORDER_WAITING_FOR_MATERIAL && e.getReleaseChecked() == 0)		
		).sorted(Comparator.comparing(ProductionOrder::getPlannedEnd)).collect(Collectors.toList());	     
				
		//ConWip MPS uses MRP logic 
		if(simParams.getApplyConWip() > 0){
		
			selectedProdOrders = productionOrders.stream()
    			.filter(e -> (e.getStatus() == ProductionOrder.PRODUCTION_ORDER_STATUS_UNPROCESSED || 
                  e.getStatus() == ProductionOrder.PRODUCTION_ORDER_WAITING_FOR_MATERIAL) &&
                 e.getReleaseChecked() == 0 &&
                 // If it's an end item (sales item), check PlannedStartEarliestRelease against time()
                 (e.getItem().getType().equalsIgnoreCase(Item.ITEM_TYPE_SALES) && e.getPlannedStartEarliestRelease() <= (time() + MRP.PERIOD_BALANCING )|| 
                 // If it's a component, check PlannedStart against time()
                 !e.getItem().getType().equalsIgnoreCase(Item.ITEM_TYPE_SALES) && e.getPlannedStart() <= (time()+ MRP.PERIOD_BALANCING)))
				    .sorted(Comparator.comparing(ProductionOrder::getPlannedEnd))
				    .collect(Collectors.toList());							    				    
		}
			     
	}else if(ReleaseOrigin.equalsIgnoreCase("Machine")){
		selectedProdOrders = productionOrders.stream().filter(e -> (e.getStatus() == ProductionOrder.PRODUCTION_ORDER_STATUS_UNPROCESSED || 
		e.getStatus() == ProductionOrder.PRODUCTION_ORDER_WAITING_FOR_MATERIAL) &&		
		 e.getPlannedStart() <= time() && e.getReleaseChecked() == 0
		 ).sorted(Comparator.comparing(ProductionOrder::getPlannedEnd)).collect(Collectors.toList());	
		 
		 //ConWip MPS uses MRP logic 
		 if(simParams.getApplyConWip() > 0){
			// if(item.getType().equalsIgnoreCase(item.ITEM_TYPE_SALES)){
			
			selectedProdOrders = productionOrders.stream()
			    .filter(e -> (e.getStatus() == ProductionOrder.PRODUCTION_ORDER_STATUS_UNPROCESSED || 
			                  e.getStatus() == ProductionOrder.PRODUCTION_ORDER_WAITING_FOR_MATERIAL) &&
			                 e.getReleaseChecked() == 0 &&
			                 // If it's an end item (sales item), check PlannedStartEarliestRelease against time()
			                 (e.getItem().getType().equalsIgnoreCase(Item.ITEM_TYPE_SALES) && e.getPlannedStartEarliestRelease() <= (time()+ MRP.PERIOD_BALANCING) || 
			                 // If it's a component, check PlannedStart against time()
			                 !e.getItem().getType().equalsIgnoreCase(Item.ITEM_TYPE_SALES) && e.getPlannedStart() <= (time() + + MRP.PERIOD_BALANCING)))
			    .sorted(Comparator.comparing(ProductionOrder::getPlannedEnd))
			    .collect(Collectors.toList());

			    
		 }		 
	}
	else if(ReleaseOrigin.equalsIgnoreCase("Optimization")){
		selectedProdOrders = productionOrders.stream().filter(e -> e.getPlannedStart() <= time() 
	    && e.getStatus() == ProductionOrder.PRODUCTION_ORDER_STATUS_UNPROCESSED && e.getReleaseChecked() == 0
     	).sorted(Comparator.comparing(ProductionOrder::getOrderId)).collect(Collectors.toList());	
    }

// Set to store all items that have been checked to avoid duplicate checks
Set<Integer> checkedItems = new HashSet<>();
long distinctItemCount = selectedProdOrders.stream().map(o -> o.getItem().getItem()).distinct().count();
    
    boolean skipRelease = false;
    
    for (ProductionOrder order : selectedProdOrders) {

    t.log("+++++++", Tools.LogReleases);
    t.log("OrderId Release Check: " + order.getOrderId() + " item " + order.getItem().getItem() + " startdate " + order.getPlannedStart(), Tools.LogReleases);

    // Test if there exists an order of another item running with an earlier end date
    // If yes, take it; otherwise, process with the current entry of the item.
    AtomicReference<ProductionOrder> orderRef = new AtomicReference<>(order);

    // Ensure that the item's availability is checked only if it hasn't been checked already
    if (!itemsNoLongerCheck.stream().anyMatch(n -> n == orderRef.get().getItem().getItem())) {

        // Check material availability for the specific item in the production order
        //double requiredQuantity = order.getQuantity();  // Quantity required for the current production order's item

        // Check if enough material is available in stock for the item
        List<StockBooking> materialAvailable = StockBooking.CheckMaterialAvailability(order, stockBookings, bom, time());

        if (materialAvailable.size() > 0) {
            // Enough material is available, release the order
            order.setStatus(ProductionOrder.PRODUCTION_ORDER_STATUS_RELEASED);
            order.setMaterialAvailableDate(time());
        } else {
            // Not enough material, set the order to waiting for material
            order.setStatus(ProductionOrder.PRODUCTION_ORDER_WAITING_FOR_MATERIAL);
            order.setMaterialAvailableDate(time());
            //skipRelease = true;

            // Add the item to the no longer check list to avoid re-checking in the future
            itemsNoLongerCheck.add(order.getItem().getItem());
            //break;
        }

        // If the material is available, make stock bookings
        stockBookings.addAll(materialAvailable);

        // Update WIP for the item (components)
        materialAvailable.stream()
            .filter(e -> e.getItem().getType().equals(Item.ITEM_TYPE_COMPONENT))
            .forEach(e -> {
                varSystemWIPComponents += e.getQuantity();
                statSystemWIPComponents.add(varSystemWIPComponents, time());
            });

        // Clear the material availability list after processing
        materialAvailable.clear();

        // Create a new ProductionOrderAgent to pass the production order to material release
        ProductionOrderAgent newOrder = new ProductionOrderAgent();
        newOrder.prodOrderFromAgent = order;
        newOrder.markParametersAreSet();

        // Log the release and pass the order to material release for machine processing
        t.log("************* Release Order: " + order.getOrderId(), Tools.LogReleases);
        materialRelease.enter_from_MRP.take(newOrder);
    }
    
    // If all unique items have been checked, set skipRelease to true
    if (checkedItems.size() == distinctItemCount) {
        skipRelease = true;
        t.log("All different items have been checked. Setting skipRelease to true.", Tools.LogReleases);
        break;
    } else {
        skipRelease = false;
    }
	}	
}//inf conwip      
    ]]></Body>
				</Function>
				<Function AccessType="default" StaticFunction="false">
					<ReturnModificator>VOID</ReturnModificator>
					<ReturnType><![CDATA[double]]></ReturnType>
					<Id>1729581267841</Id>
					<Name><![CDATA[Function_OrderRelease_ConWip]]></Name>
					<X>950</X><Y>2130</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Parameter>
						<Name><![CDATA[ReleaseOrigin]]></Name>
						<Type><![CDATA[String]]></Type>
					</Parameter>
					<Body><![CDATA[//traceln("Start Function_OrderRelease_ConWip");

//List<ProductionOrder> hallo = productionOrders.stream().filter(e -> (e.getStatus() == ProductionOrder.PRODUCTION_ORDER_STATUS_UNPROCESSED || 
	//		e.getStatus() == ProductionOrder.PRODUCTION_ORDER_WAITING_FOR_MATERIAL) &&	e.getItem().getType().equalsIgnoreCase(Item.ITEM_TYPE_SALES) &&
		//	e.getPlannedStartEarliestRelease() <= time() 
		//	 ).sorted(Comparator.comparing(ProductionOrder::getPlannedEnd)).collect(Collectors.toList());

 //traceln(ProductionOrder.GetCSVHeader());
 //for(ProductionOrder o : hallo){
// 	traceln(ProductionOrder.GetCSVString(o));
 //}   
  		
		if(simParams.getApplyConWip() > 0) {
        
        List<ProductionOrder> sortedconWipProdOrderList  = StreamEx.of(productionOrders).filter(e -> e.getConWipStatus() == 
        	ProductionOrder.PRODUCTION_ORDER_CONWIP_STATUS_NOT_RELEASED)
                .sorted(Comparator.comparing(ProductionOrder::getPlannedEnd)).toList();						
        
        
        //traceln("ProductinoOrder for ConWip Release:");
        //traceln(ProductionOrder.GetCSVHeader()); 
                
		//for(ProductionOrder o : sortedconWipProdOrderList) {
			//traceln(ProductionOrder.GetCSVString(o));			
		//}
        		
		for(ProductionOrder ordi : sortedconWipProdOrderList.stream().filter(e -> e.getItem().getType().equalsIgnoreCase(Item.ITEM_TYPE_SALES)).collect(Collectors.toList())) {
			//traceln(ProductionOrder.GetCSVHeader());
			//traceln(ProductionOrder.GetCSVString(ordi));									
			//traceln("time " + time() + " check for conwip prod order id " +  ordi.getOrderId() + " order load " + ordi.getWorkLoad() + " varSystemWorkload " + " wipstatus: " 
			//+ varSystemWorkload  +  " total new load: " + (ordi.getWorkLoad()  + varSystemWorkload) + " wicap " + simParams.getWipCap());						
						
			ordi.setConWipReleaseCheckAt(time());
			
				if((varSystemWorkload + ordi.getWorkLoad()) < simParams.getWipCap()) {
					varSystemWorkload += ordi.getWorkLoad();	
				 	StatisticSystemWorkLoad.add(varSystemWorkload);										
				 	ordi.setConWipStatus(ProductionOrder.PRODUCTION_ORDER_CONWIP_STATUS_RELEASED);					
					ordi.setStatus(ProductionOrder.PRODUCTION_ORDER_STATUS_UNPROCESSED);				 						
					ordi.setSystemWorkLoad(varSystemWorkload);
					ordi.setConWipReleasedAt(time());										
				}else{
					break;
				}									
			}//for end items		
		
		
		for(ProductionOrder ordi : sortedconWipProdOrderList.stream().filter(e -> e.getItem().getType().equalsIgnoreCase(Item.ITEM_TYPE_COMPONENT)).collect(Collectors.toList())) {
			//traceln(ProductionOrder.GetCSVHeader());
			//traceln(ProductionOrder.GetCSVString(ordi));
			
			//traceln("time " + time() + " check for conwip prod order id " +  ordi.getOrderId() + " order load " + ordi.getWorkLoad() + " varSystemWorkloadComponents " 
			//+ varSystemWorkloadComponents   +  " total new load: " + (ordi.getWorkLoad()  + varSystemWorkloadComponents) + " wicapcomponents " + simParams.getWipCapComponents());
						
			ordi.setConWipReleaseCheckAt(time());
			
				if((varSystemWorkloadComponents + ordi.getWorkLoad()) < simParams.getWipCapComponents()) {
					varSystemWorkloadComponents += ordi.getWorkLoad();	
				 	StatisticSystemWorkLoad.add(varSystemWorkloadComponents);										
				 	ordi.setConWipStatus(ProductionOrder.PRODUCTION_ORDER_CONWIP_STATUS_RELEASED);					
					ordi.setStatus(ProductionOrder.PRODUCTION_ORDER_STATUS_UNPROCESSED);				 						
					ordi.setComponentsWorkLoad(varSystemWorkloadComponents);
					ordi.setConWipReleasedAt(time());									 	
				}else{
					break;
				}									
				
			}//for end items	
		}// if conwip

Tools t = new Tools();

List<Integer> itemsNoLongerCheck = new ArrayList<>();
itemsNoLongerCheck.clear();

/*The release time can have dramatical impacts on the order when wich production order is processed by the machine agent */


 List<Item> selectedItems = items.stream().filter(e -> e.getType().equalsIgnoreCase(Item.ITEM_TYPE_SALES) || e.getType().equalsIgnoreCase(Item.ITEM_TYPE_COMPONENT)).collect(Collectors.toList());
 
 if(ReleaseOrigin.equalsIgnoreCase("Machine")){
 	//selectedItems = items.stream().filter(e -> e.getType().equalsIgnoreCase(Item.ITEM_TYPE_SALES)).collect(Collectors.toList());					
 }

t.log("Release Origin " + ReleaseOrigin + " Time: " + time(), Tools.LogReleases);

productionOrders.stream().filter(e -> e.getStatus() == ProductionOrder.PRODUCTION_ORDER_STATUS_UNPROCESSED ||
    	 e.getStatus() == ProductionOrder.PRODUCTION_ORDER_WAITING_FOR_MATERIAL).forEach(e -> e.setReleaseChecked(0)); 
    
//traceln("selecte items");
//traceln(Item.GetCSVHeader());

//for(Item i : selectedItems) {
//	traceln(Item.GetCSVString(i));
//}
//traceln("########");


//traceln("WAW for RELEASE: " + simParams.getWaW());
    	  
for (Item item: selectedItems){
	//traceln("selected item for release: " + item.getItem());
    boolean skipRelease = false;

	List<ProductionOrder> selectedProdOrders = new ArrayList();
	
	if(ReleaseOrigin.equalsIgnoreCase("MRP")){				
		if(item.getType().equalsIgnoreCase(item.ITEM_TYPE_SALES)){
			selectedProdOrders = productionOrders.stream().filter(e -> (e.getStatus() == ProductionOrder.PRODUCTION_ORDER_STATUS_UNPROCESSED || 
			e.getStatus() == ProductionOrder.PRODUCTION_ORDER_WAITING_FOR_MATERIAL) &&		
			e.getPlannedStartEarliestRelease() <= time() && e.getReleaseChecked() == 0
			 ).sorted(Comparator.comparing(ProductionOrder::getPlannedStartEarliestRelease)).collect(Collectors.toList());	
		 }else{
		 	selectedProdOrders = productionOrders.stream().filter(e -> (e.getStatus() == ProductionOrder.PRODUCTION_ORDER_STATUS_UNPROCESSED || 
			e.getStatus() == ProductionOrder.PRODUCTION_ORDER_WAITING_FOR_MATERIAL) &&		
			 e.getPlannedStart() <= time() && e.getReleaseChecked() == 0
			 ).sorted(Comparator.comparing(ProductionOrder::getPlannedStartEarliestRelease)).collect(Collectors.toList());			 		 		 
		 }
							     
	}else if(ReleaseOrigin.equalsIgnoreCase("Machine")){
		if(item.getType().equalsIgnoreCase(item.ITEM_TYPE_SALES)){
			selectedProdOrders = productionOrders.stream().filter(e -> (e.getStatus() == ProductionOrder.PRODUCTION_ORDER_STATUS_UNPROCESSED || 
			e.getStatus() == ProductionOrder.PRODUCTION_ORDER_WAITING_FOR_MATERIAL) &&		
			 e.getPlannedStartEarliestRelease() <= time() && e.getReleaseChecked() == 0
			 ).sorted(Comparator.comparing(ProductionOrder::getPlannedStartEarliestRelease)).collect(Collectors.toList());	
		 }else{
		 	selectedProdOrders = productionOrders.stream().filter(e -> (e.getStatus() == ProductionOrder.PRODUCTION_ORDER_STATUS_UNPROCESSED || 
			e.getStatus() == ProductionOrder.PRODUCTION_ORDER_WAITING_FOR_MATERIAL) &&		
			 e.getPlannedStart() <= time() && e.getReleaseChecked() == 0
			 ).sorted(Comparator.comparing(ProductionOrder::getPlannedStartEarliestRelease)).collect(Collectors.toList());			 		 		 
		 }
	}	
 	else if(ReleaseOrigin.equalsIgnoreCase(SimulationParameter.RELEASE_ORIGIN_CONWIP)){				
		if(item.getType().equalsIgnoreCase(item.ITEM_TYPE_SALES)){
			selectedProdOrders = productionOrders.stream().filter(e -> e.getPlannedStartEarliestRelease() <= time()
    		&& e.getStatus() == ProductionOrder.PRODUCTION_ORDER_STATUS_UNPROCESSED && e.getReleaseChecked() == 0
 			).sorted(Comparator.comparing(ProductionOrder::getPlannedStartEarliestRelease)).collect(Collectors.toList());	
 		}else{
 			selectedProdOrders = productionOrders.stream().filter(e -> e.getPlannedStart() <= time()
    		&& e.getStatus() == ProductionOrder.PRODUCTION_ORDER_STATUS_UNPROCESSED && e.getReleaseChecked() == 0
 			).sorted(Comparator.comparing(ProductionOrder::getPlannedStartEarliestRelease)).collect(Collectors.toList());	 		
 		}
 		
 		
	}else if(ReleaseOrigin.equalsIgnoreCase(SimulationParameter.RELEASE_ORIGIN_CONWIP_FROM_MACHINE)){
		//selectedProdOrders = productionOrders.stream().filter(e -> (e.getStatus() == ProductionOrder.PRODUCTION_ORDER_STATUS_UNPROCESSED || 
		//e.getStatus() == ProductionOrder.PRODUCTION_ORDER_WAITING_FOR_MATERIAL) &&		
		 //e.getPlannedStart() <= time() && e.getReleaseChecked() == 0
		 //).sorted(Comparator.comparing(ProductionOrder::getActualStart)).collect(Collectors.toList());	
		 
		 selectedProdOrders = productionOrders.stream().filter(e -> (e.getStatus() == ProductionOrder.PRODUCTION_ORDER_STATUS_UNPROCESSED ||
		e.getStatus() == ProductionOrder.PRODUCTION_ORDER_WAITING_FOR_MATERIAL && e.getReleaseChecked() == 0)		
		).sorted(Comparator.comparing(ProductionOrder::getPlannedStartEarliestRelease)).collect(Collectors.toList());	     
		 
		 
	}//for	

  //if the release for one item is skipped the remaining orders of the same items must be skipped.
  //but until enough material is available release for the same item is allowed



  
//traceln("-----------------------------------");  

 //traceln(ProductionOrder.GetCSVHeader());
 //for(ProductionOrder o : selectedProdOrders){
 	//traceln(ProductionOrder.GetCSVString(o));
 //}   
  

  for (ProductionOrder order: selectedProdOrders.stream().filter(e -> e.getItem().getItem() == item.getItem()).collect(Collectors.toList())) {
	t.log("+++++++", Tools.LogReleases);
	t.log("Time: " + time() + " OrderId Release Check: " + order.getOrderId() + " item " + order.getItem().getItem() + " startdate " + order.getPlannedStart(), Tools.LogReleases);		
	
	order.setReleaseChecked(1);

	if(!skipRelease && !itemsNoLongerCheck.stream().anyMatch(n -> n == order.getItem().getItem() && order.getStatus() == ProductionOrder.PRODUCTION_ORDER_CONWIP_STATUS_RELEASED)
	
	){
            List <StockBooking> materialAvailable = StockBooking.CheckMaterialAvailability(order, stockBookings, bom, time());
                //traceln(time() + "-------------------->" + order.getOrderId() + " planned start " + order.getPlannedStart() + " planned end " + order.getPlannedEnd());
                
                if(materialAvailable.size() > 0){
                	order.setStatus(ProductionOrder.PRODUCTION_ORDER_STATUS_RELEASED);
                	                           order.setMaterialAvailableDate(time());                	                                           	                                                  	                           
                }else{
                	order.setStatus(ProductionOrder.PRODUCTION_ORDER_WAITING_FOR_MATERIAL);
                	                           order.setMaterialAvailableDate(time());
                	                           skipRelease=true;
                	                           itemsNoLongerCheck.add(order.getItem().getItem());
                	                           
                	                           //traceln("item no longer check: " + order.getItem().getItem());
                	                           
                	                           break;
                }              
                
                
                stockBookings.addAll(materialAvailable);
                
                materialAvailable.stream().filter(e -> e.getItem().getType().equals(Item.ITEM_TYPE_COMPONENT)).
                forEach(e -> {
                	varSystemWIPComponents = varSystemWIPComponents + e.getQuantity();
		            statSystemWIPComponents.add(varSystemWIPComponents, time());
                	}
                );
                
            materialAvailable.clear();
            
   			ProductionOrderAgent newOrder = new ProductionOrderAgent();
            newOrder.prodOrderFromAgent = order;
            newOrder.markParametersAreSet();

            //Pass Productionorder to Material Release
            // Material Release decides, if a production order can be passed to machine processing
            //t.log("************* Release Order: " + order.getOrderId(), Tools.LogReleases);
            materialRelease.enter_from_MRP.take(newOrder);  
            //traceln("order released --> is there a next order?");

        }//if
      } //for
    } //for
    ]]></Body>
				</Function>
			</Functions>
			<AnalysisData>
    			<Statistics>
					<Id>1641301431910</Id>
					<Name><![CDATA[StatisticServiceLevel]]></Name>
					<X>940</X><Y>-260</Y>
					<Label><X>15</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<AutoUpdate>true</AutoUpdate>
					<OccurrenceAtTime>true</OccurrenceAtTime>
					<OccurrenceDate>1641369600000</OccurrenceDate>
					<OccurrenceTime Class="CodeUnitValue">
						<Code><![CDATA[0]]></Code>
						<Unit Class="TimeUnits"><![CDATA[DAY]]></Unit>
					</OccurrenceTime>
					<RecurrenceCode Class="CodeUnitValue">
						<Code><![CDATA[1]]></Code>
						<Unit Class="TimeUnits"><![CDATA[DAY]]></Unit>
					</RecurrenceCode>
					<Discrete>true</Discrete>
				</Statistics>
    			<Statistics>
					<Id>1641306074400</Id>
					<Name><![CDATA[StatisticWIP]]></Name>
					<X>940</X><Y>-230</Y>
					<Label><X>15</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<AutoUpdate>true</AutoUpdate>
					<OccurrenceAtTime>true</OccurrenceAtTime>
					<OccurrenceDate>1641369600000</OccurrenceDate>
					<OccurrenceTime Class="CodeUnitValue">
						<Code><![CDATA[0]]></Code>
						<Unit Class="TimeUnits"><![CDATA[DAY]]></Unit>
					</OccurrenceTime>
					<RecurrenceCode Class="CodeUnitValue">
						<Code><![CDATA[1]]></Code>
						<Unit Class="TimeUnits"><![CDATA[DAY]]></Unit>
					</RecurrenceCode>
					<Discrete>true</Discrete>
				</Statistics>
    			<Statistics>
					<Id>1646299710273</Id>
					<Name><![CDATA[statistics]]></Name>
					<X>940</X><Y>-290</Y>
					<Label><X>15</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<AutoUpdate>true</AutoUpdate>
					<OccurrenceAtTime>true</OccurrenceAtTime>
					<OccurrenceDate>1646380800000</OccurrenceDate>
					<OccurrenceTime Class="CodeUnitValue">
						<Code><![CDATA[0]]></Code>
						<Unit Class="TimeUnits"><![CDATA[DAY]]></Unit>
					</OccurrenceTime>
					<RecurrenceCode Class="CodeUnitValue">
						<Code><![CDATA[1]]></Code>
						<Unit Class="TimeUnits"><![CDATA[DAY]]></Unit>
					</RecurrenceCode>
					<Discrete>true</Discrete>
				</Statistics>
    			<Statistics>
					<Id>1646371717793</Id>
					<Name><![CDATA[stat_tardiness]]></Name>
					<X>450</X><Y>-190</Y>
					<Label><X>15</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<AutoUpdate>true</AutoUpdate>
					<OccurrenceAtTime>true</OccurrenceAtTime>
					<OccurrenceDate>1646380800000</OccurrenceDate>
					<OccurrenceTime Class="CodeUnitValue">
						<Code><![CDATA[0]]></Code>
						<Unit Class="TimeUnits"><![CDATA[DAY]]></Unit>
					</OccurrenceTime>
					<RecurrenceCode Class="CodeUnitValue">
						<Code><![CDATA[1]]></Code>
						<Unit Class="TimeUnits"><![CDATA[DAY]]></Unit>
					</RecurrenceCode>
					<Discrete>true</Discrete>
				</Statistics>
    			<Statistics>
					<Id>1646371717805</Id>
					<Name><![CDATA[stat_leadtime_sales]]></Name>
					<X>610</X><Y>-140</Y>
					<Label><X>15</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<AutoUpdate>true</AutoUpdate>
					<OccurrenceAtTime>true</OccurrenceAtTime>
					<OccurrenceDate>1646380800000</OccurrenceDate>
					<OccurrenceTime Class="CodeUnitValue">
						<Code><![CDATA[0]]></Code>
						<Unit Class="TimeUnits"><![CDATA[DAY]]></Unit>
					</OccurrenceTime>
					<RecurrenceCode Class="CodeUnitValue">
						<Code><![CDATA[1]]></Code>
						<Unit Class="TimeUnits"><![CDATA[DAY]]></Unit>
					</RecurrenceCode>
					<Discrete>true</Discrete>
				</Statistics>
    			<Statistics>
					<Id>1646371717816</Id>
					<Name><![CDATA[stat_inventory_sales]]></Name>
					<X>1050</X><Y>-140</Y>
					<Label><X>15</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<AutoUpdate>false</AutoUpdate>
					<OccurrenceAtTime>true</OccurrenceAtTime>
					<OccurrenceDate>1646380800000</OccurrenceDate>
					<OccurrenceTime Class="CodeUnitValue">
						<Code><![CDATA[0]]></Code>
						<Unit Class="TimeUnits"><![CDATA[DAY]]></Unit>
					</OccurrenceTime>
					<RecurrenceCode Class="CodeUnitValue">
						<Code><![CDATA[1]]></Code>
						<Unit Class="TimeUnits"><![CDATA[DAY]]></Unit>
					</RecurrenceCode>
					<Discrete>false</Discrete>
				</Statistics>
    			<Statistics>
					<Id>1646371717845</Id>
					<Name><![CDATA[stat_leadtime_components]]></Name>
					<X>610</X><Y>-80</Y>
					<Label><X>15</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<AutoUpdate>true</AutoUpdate>
					<OccurrenceAtTime>true</OccurrenceAtTime>
					<OccurrenceDate>1646380800000</OccurrenceDate>
					<OccurrenceTime Class="CodeUnitValue">
						<Code><![CDATA[0]]></Code>
						<Unit Class="TimeUnits"><![CDATA[DAY]]></Unit>
					</OccurrenceTime>
					<RecurrenceCode Class="CodeUnitValue">
						<Code><![CDATA[1]]></Code>
						<Unit Class="TimeUnits"><![CDATA[DAY]]></Unit>
					</RecurrenceCode>
					<Discrete>true</Discrete>
				</Statistics>
    			<Statistics>
					<Id>1646371717852</Id>
					<Name><![CDATA[stat_inventory_components]]></Name>
					<X>1050</X><Y>-110</Y>
					<Label><X>15</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<AutoUpdate>false</AutoUpdate>
					<OccurrenceAtTime>true</OccurrenceAtTime>
					<OccurrenceDate>1646380800000</OccurrenceDate>
					<OccurrenceTime Class="CodeUnitValue">
						<Code><![CDATA[0]]></Code>
						<Unit Class="TimeUnits"><![CDATA[DAY]]></Unit>
					</OccurrenceTime>
					<RecurrenceCode Class="CodeUnitValue">
						<Code><![CDATA[1]]></Code>
						<Unit Class="TimeUnits"><![CDATA[DAY]]></Unit>
					</RecurrenceCode>
					<Discrete>false</Discrete>
				</Statistics>
    			<Statistics>
					<Id>1648305216596</Id>
					<Name><![CDATA[stat_wip_sales]]></Name>
					<X>850</X><Y>-120</Y>
					<Label><X>15</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<AutoUpdate>true</AutoUpdate>
					<OccurrenceAtTime>true</OccurrenceAtTime>
					<OccurrenceDate>1646380800000</OccurrenceDate>
					<OccurrenceTime Class="CodeUnitValue">
						<Code><![CDATA[0]]></Code>
						<Unit Class="TimeUnits"><![CDATA[DAY]]></Unit>
					</OccurrenceTime>
					<RecurrenceCode Class="CodeUnitValue">
						<Code><![CDATA[1]]></Code>
						<Unit Class="TimeUnits"><![CDATA[DAY]]></Unit>
					</RecurrenceCode>
					<Discrete>true</Discrete>
				</Statistics>
    			<Statistics>
					<Id>1648305216603</Id>
					<Name><![CDATA[stat_wip_components]]></Name>
					<X>850</X><Y>-80</Y>
					<Label><X>15</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<AutoUpdate>true</AutoUpdate>
					<OccurrenceAtTime>true</OccurrenceAtTime>
					<OccurrenceDate>1646380800000</OccurrenceDate>
					<OccurrenceTime Class="CodeUnitValue">
						<Code><![CDATA[0]]></Code>
						<Unit Class="TimeUnits"><![CDATA[DAY]]></Unit>
					</OccurrenceTime>
					<RecurrenceCode Class="CodeUnitValue">
						<Code><![CDATA[1]]></Code>
						<Unit Class="TimeUnits"><![CDATA[DAY]]></Unit>
					</RecurrenceCode>
					<Discrete>true</Discrete>
				</Statistics>
    			<DataSet>
					<Id>1653396182099</Id>
					<Name><![CDATA[CFdataSet]]></Name>
					<X>940</X><Y>-320</Y>
					<Label><X>15</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<AutoUpdate>false</AutoUpdate>
					<OccurrenceAtTime>true</OccurrenceAtTime>
					<OccurrenceDate>1653465600000</OccurrenceDate>
					<OccurrenceTime Class="CodeUnitValue">
						<Code><![CDATA[0]]></Code>
						<Unit Class="TimeUnits"><![CDATA[DAY]]></Unit>
					</OccurrenceTime>
					<RecurrenceCode Class="CodeUnitValue">
						<Code><![CDATA[1]]></Code>
						<Unit Class="TimeUnits"><![CDATA[DAY]]></Unit>
					</RecurrenceCode>
					<FreezeXAxis>true</FreezeXAxis>
					<SamplesToKeep>100</SamplesToKeep>
				</DataSet>
    			<DataSet>
					<Id>1654585756316</Id>
					<Name><![CDATA[datasetSystemUtilization]]></Name>
					<X>940</X><Y>-470</Y>
					<Label><X>15</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<AutoUpdate>false</AutoUpdate>
					<OccurrenceAtTime>true</OccurrenceAtTime>
					<OccurrenceDate>1654588800000</OccurrenceDate>
					<OccurrenceTime Class="CodeUnitValue">
						<Code><![CDATA[0]]></Code>
						<Unit Class="TimeUnits"><![CDATA[DAY]]></Unit>
					</OccurrenceTime>
					<RecurrenceCode Class="CodeUnitValue">
						<Code><![CDATA[1]]></Code>
						<Unit Class="TimeUnits"><![CDATA[DAY]]></Unit>
					</RecurrenceCode>
					<FreezeXAxis>true</FreezeXAxis>
					<SamplesToKeep>100</SamplesToKeep>
				</DataSet>
    			<Statistics>
					<Id>1654764585524</Id>
					<Name><![CDATA[statSystemWIP]]></Name>
					<X>940</X><Y>-410</Y>
					<Label><X>15</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<AutoUpdate>false</AutoUpdate>
					<OccurrenceAtTime>true</OccurrenceAtTime>
					<OccurrenceDate>1654848000000</OccurrenceDate>
					<OccurrenceTime Class="CodeUnitValue">
						<Code><![CDATA[0]]></Code>
						<Unit Class="TimeUnits"><![CDATA[DAY]]></Unit>
					</OccurrenceTime>
					<RecurrenceCode Class="CodeUnitValue">
						<Code><![CDATA[1]]></Code>
						<Unit Class="TimeUnits"><![CDATA[DAY]]></Unit>
					</RecurrenceCode>
					<Discrete>false</Discrete>
				</Statistics>
    			<Statistics>
					<Id>1654841650019</Id>
					<Name><![CDATA[statSystemWIPComponents]]></Name>
					<X>940</X><Y>-350</Y>
					<Label><X>15</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<AutoUpdate>false</AutoUpdate>
					<OccurrenceAtTime>true</OccurrenceAtTime>
					<OccurrenceDate>1654848000000</OccurrenceDate>
					<OccurrenceTime Class="CodeUnitValue">
						<Code><![CDATA[0]]></Code>
						<Unit Class="TimeUnits"><![CDATA[DAY]]></Unit>
					</OccurrenceTime>
					<RecurrenceCode Class="CodeUnitValue">
						<Code><![CDATA[1]]></Code>
						<Unit Class="TimeUnits"><![CDATA[DAY]]></Unit>
					</RecurrenceCode>
					<Discrete>false</Discrete>
				</Statistics>
    			<Statistics>
					<Id>1666529012604</Id>
					<Name><![CDATA[stat_demand]]></Name>
					<X>220</X><Y>-30</Y>
					<Label><X>15</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<AutoUpdate>true</AutoUpdate>
					<OccurrenceAtTime>true</OccurrenceAtTime>
					<OccurrenceDate>1666598400000</OccurrenceDate>
					<OccurrenceTime Class="CodeUnitValue">
						<Code><![CDATA[0]]></Code>
						<Unit Class="TimeUnits"><![CDATA[DAY]]></Unit>
					</OccurrenceTime>
					<RecurrenceCode Class="CodeUnitValue">
						<Code><![CDATA[1]]></Code>
						<Unit Class="TimeUnits"><![CDATA[DAY]]></Unit>
					</RecurrenceCode>
					<Discrete>true</Discrete>
				</Statistics>
    			<Statistics>
					<Id>1666613465063</Id>
					<Name><![CDATA[stat_lateness]]></Name>
					<X>450</X><Y>-130</Y>
					<Label><X>15</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<AutoUpdate>true</AutoUpdate>
					<OccurrenceAtTime>true</OccurrenceAtTime>
					<OccurrenceDate>1666684800000</OccurrenceDate>
					<OccurrenceTime Class="CodeUnitValue">
						<Code><![CDATA[0]]></Code>
						<Unit Class="TimeUnits"><![CDATA[DAY]]></Unit>
					</OccurrenceTime>
					<RecurrenceCode Class="CodeUnitValue">
						<Code><![CDATA[1]]></Code>
						<Unit Class="TimeUnits"><![CDATA[DAY]]></Unit>
					</RecurrenceCode>
					<Discrete>true</Discrete>
				</Statistics>
    			<Statistics>
					<Id>1666668738103</Id>
					<Name><![CDATA[stat_ontime_percentage]]></Name>
					<X>1550</X><Y>-70</Y>
					<Label><X>15</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<AutoUpdate>false</AutoUpdate>
					<OccurrenceAtTime>true</OccurrenceAtTime>
					<OccurrenceDate>1646380800000</OccurrenceDate>
					<OccurrenceTime Class="CodeUnitValue">
						<Code><![CDATA[0]]></Code>
						<Unit Class="TimeUnits"><![CDATA[DAY]]></Unit>
					</OccurrenceTime>
					<RecurrenceCode Class="CodeUnitValue">
						<Code><![CDATA[1]]></Code>
						<Unit Class="TimeUnits"><![CDATA[DAY]]></Unit>
					</RecurrenceCode>
					<Discrete>true</Discrete>
				</Statistics>
    			<Statistics>
					<Id>1666669096693</Id>
					<Name><![CDATA[stat_production_start_waiting_time]]></Name>
					<X>1240</X><Y>-90</Y>
					<Label><X>15</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<AutoUpdate>true</AutoUpdate>
					<OccurrenceAtTime>true</OccurrenceAtTime>
					<OccurrenceDate>1666684800000</OccurrenceDate>
					<OccurrenceTime Class="CodeUnitValue">
						<Code><![CDATA[0]]></Code>
						<Unit Class="TimeUnits"><![CDATA[DAY]]></Unit>
					</OccurrenceTime>
					<RecurrenceCode Class="CodeUnitValue">
						<Code><![CDATA[1]]></Code>
						<Unit Class="TimeUnits"><![CDATA[DAY]]></Unit>
					</RecurrenceCode>
					<Discrete>true</Discrete>
				</Statistics>
    			<Statistics>
					<Id>1668085315181</Id>
					<Name><![CDATA[stat_internal_lateness_components]]></Name>
					<X>230</X><Y>-310</Y>
					<Label><X>15</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<AutoUpdate>true</AutoUpdate>
					<OccurrenceAtTime>true</OccurrenceAtTime>
					<OccurrenceDate>1668153600000</OccurrenceDate>
					<OccurrenceTime Class="CodeUnitValue">
						<Code><![CDATA[0]]></Code>
						<Unit Class="TimeUnits"><![CDATA[DAY]]></Unit>
					</OccurrenceTime>
					<RecurrenceCode Class="CodeUnitValue">
						<Code><![CDATA[1]]></Code>
						<Unit Class="TimeUnits"><![CDATA[DAY]]></Unit>
					</RecurrenceCode>
					<Discrete>true</Discrete>
				</Statistics>
    			<Statistics>
					<Id>1668085399413</Id>
					<Name><![CDATA[stat_internal_lateness_sales_items]]></Name>
					<X>560</X><Y>-310</Y>
					<Label><X>15</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<AutoUpdate>true</AutoUpdate>
					<OccurrenceAtTime>true</OccurrenceAtTime>
					<OccurrenceDate>1668153600000</OccurrenceDate>
					<OccurrenceTime Class="CodeUnitValue">
						<Code><![CDATA[0]]></Code>
						<Unit Class="TimeUnits"><![CDATA[DAY]]></Unit>
					</OccurrenceTime>
					<RecurrenceCode Class="CodeUnitValue">
						<Code><![CDATA[1]]></Code>
						<Unit Class="TimeUnits"><![CDATA[DAY]]></Unit>
					</RecurrenceCode>
					<Discrete>true</Discrete>
				</Statistics>
    			<Statistics>
					<Id>1685440033232</Id>
					<Name><![CDATA[stat_avg_planned_lead_time]]></Name>
					<X>1470</X><Y>-230</Y>
					<Label><X>15</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<AutoUpdate>false</AutoUpdate>
					<OccurrenceAtTime>true</OccurrenceAtTime>
					<OccurrenceDate>1646380800000</OccurrenceDate>
					<OccurrenceTime Class="CodeUnitValue">
						<Code><![CDATA[0]]></Code>
						<Unit Class="TimeUnits"><![CDATA[DAY]]></Unit>
					</OccurrenceTime>
					<RecurrenceCode Class="CodeUnitValue">
						<Code><![CDATA[1]]></Code>
						<Unit Class="TimeUnits"><![CDATA[DAY]]></Unit>
					</RecurrenceCode>
					<Discrete>true</Discrete>
				</Statistics>
    			<Statistics>
					<Id>1685618767291</Id>
					<Name><![CDATA[stat_tardiness_open_orders]]></Name>
					<X>1750</X><Y>-70</Y>
					<Label><X>15</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<AutoUpdate>false</AutoUpdate>
					<OccurrenceAtTime>true</OccurrenceAtTime>
					<OccurrenceDate>1646380800000</OccurrenceDate>
					<OccurrenceTime Class="CodeUnitValue">
						<Code><![CDATA[0]]></Code>
						<Unit Class="TimeUnits"><![CDATA[DAY]]></Unit>
					</OccurrenceTime>
					<RecurrenceCode Class="CodeUnitValue">
						<Code><![CDATA[1]]></Code>
						<Unit Class="TimeUnits"><![CDATA[DAY]]></Unit>
					</RecurrenceCode>
					<Discrete>true</Discrete>
				</Statistics>
    			<Statistics>
					<Id>1710955761575</Id>
					<Name><![CDATA[StatisticSystemWorkLoad]]></Name>
					<X>940</X><Y>-200</Y>
					<Label><X>15</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<AutoUpdate>true</AutoUpdate>
					<OccurrenceAtTime>true</OccurrenceAtTime>
					<OccurrenceDate>1711008000000</OccurrenceDate>
					<OccurrenceTime Class="CodeUnitValue">
						<Code><![CDATA[0]]></Code>
						<Unit Class="TimeUnits"><![CDATA[DAY]]></Unit>
					</OccurrenceTime>
					<RecurrenceCode Class="CodeUnitValue">
						<Code><![CDATA[1]]></Code>
						<Unit Class="TimeUnits"><![CDATA[DAY]]></Unit>
					</RecurrenceCode>
					<Discrete>true</Discrete>
				</Statistics>
    			<Statistics>
					<Id>1712382671255</Id>
					<Name><![CDATA[stat_demand_delivered]]></Name>
					<X>220</X><Y>-30</Y>
					<Label><X>15</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<AutoUpdate>true</AutoUpdate>
					<OccurrenceAtTime>true</OccurrenceAtTime>
					<OccurrenceDate>1666598400000</OccurrenceDate>
					<OccurrenceTime Class="CodeUnitValue">
						<Code><![CDATA[0]]></Code>
						<Unit Class="TimeUnits"><![CDATA[DAY]]></Unit>
					</OccurrenceTime>
					<RecurrenceCode Class="CodeUnitValue">
						<Code><![CDATA[1]]></Code>
						<Unit Class="TimeUnits"><![CDATA[DAY]]></Unit>
					</RecurrenceCode>
					<Discrete>true</Discrete>
				</Statistics>
    			<Statistics>
					<Id>1712382672200</Id>
					<Name><![CDATA[stat_demand_not_delivered]]></Name>
					<X>220</X><Y>-30</Y>
					<Label><X>15</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<AutoUpdate>true</AutoUpdate>
					<OccurrenceAtTime>true</OccurrenceAtTime>
					<OccurrenceDate>1666598400000</OccurrenceDate>
					<OccurrenceTime Class="CodeUnitValue">
						<Code><![CDATA[0]]></Code>
						<Unit Class="TimeUnits"><![CDATA[DAY]]></Unit>
					</OccurrenceTime>
					<RecurrenceCode Class="CodeUnitValue">
						<Code><![CDATA[1]]></Code>
						<Unit Class="TimeUnits"><![CDATA[DAY]]></Unit>
					</RecurrenceCode>
					<Discrete>true</Discrete>
				</Statistics>
    			<Statistics>
					<Id>1728483403480</Id>
					<Name><![CDATA[StatisticSystemWorkLoadComponents]]></Name>
					<X>660</X><Y>2180</Y>
					<Label><X>15</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<AutoUpdate>true</AutoUpdate>
					<OccurrenceAtTime>true</OccurrenceAtTime>
					<OccurrenceDate>1728547200000</OccurrenceDate>
					<OccurrenceTime Class="CodeUnitValue">
						<Code><![CDATA[0]]></Code>
						<Unit Class="TimeUnits"><![CDATA[DAY]]></Unit>
					</OccurrenceTime>
					<RecurrenceCode Class="CodeUnitValue">
						<Code><![CDATA[1]]></Code>
						<Unit Class="TimeUnits"><![CDATA[DAY]]></Unit>
					</RecurrenceCode>
					<Discrete>true</Discrete>
				</Statistics>
    			<Statistics>
					<Id>1730360755843</Id>
					<Name><![CDATA[stat_consumed_setup_time]]></Name>
					<X>1240</X><Y>-190</Y>
					<Label><X>15</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<AutoUpdate>true</AutoUpdate>
					<OccurrenceAtTime>true</OccurrenceAtTime>
					<OccurrenceDate>1666684800000</OccurrenceDate>
					<OccurrenceTime Class="CodeUnitValue">
						<Code><![CDATA[0]]></Code>
						<Unit Class="TimeUnits"><![CDATA[DAY]]></Unit>
					</OccurrenceTime>
					<RecurrenceCode Class="CodeUnitValue">
						<Code><![CDATA[1]]></Code>
						<Unit Class="TimeUnits"><![CDATA[DAY]]></Unit>
					</RecurrenceCode>
					<Discrete>true</Discrete>
				</Statistics>
			</AnalysisData>
			<AgentLinks>
				<AgentLink>
					<Id>1634127996011</Id>
					<Name><![CDATA[connections]]></Name>
					<X>50</X><Y>-50</Y>
					<Label><X>15</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<HandleReceiveInConnections>false</HandleReceiveInConnections>
					<AgentLinkType>COLLECTION_OF_LINKS</AgentLinkType>
					<AgentLinkBidirectional>true</AgentLinkBidirectional>
					<MessageType><![CDATA[Object]]></MessageType>
					<LineStyle>SOLID</LineStyle>
					<LineWidth>1</LineWidth>
					<LineColor>-16777216</LineColor>
					<LineZOrder>UNDER_AGENTS</LineZOrder>
					<LineArrow>NONE</LineArrow>
					<LineArrowPosition>END</LineArrowPosition>
				</AgentLink>
			</AgentLinks>

			<EmbeddedObjects>
				<EmbeddedObject>
					<Id>1634128544597</Id>
					<Name><![CDATA[sourceCustomerOrderAgent]]></Name>
					<X>40</X><Y>120</Y>
					<Label><X>-45</X><Y>-15</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<ActiveObjectClass>
						<PackageName><![CDATA[com.anylogic.libraries.processmodeling]]></PackageName>
						<ClassName><![CDATA[Source]]></ClassName>
					</ActiveObjectClass>
					<GenericParameterSubstitute>
						<GenericParameterSubstituteReference>
							<PackageName><![CDATA[com.anylogic.libraries.processmodeling]]></PackageName>
							<ClassName><![CDATA[Source]]></ClassName>
							<ItemName><![CDATA[1412336242928]]></ItemName>
						</GenericParameterSubstituteReference>
					</GenericParameterSubstitute>
					<Parameters>
						<Parameter>
							<Name><![CDATA[arrivalType]]></Name>
							<Value Class="CodeValue">
								<Code><![CDATA[self.INTERARRIVAL_TIME]]></Code>
							</Value>
						</Parameter>
						<Parameter>
							<Name><![CDATA[rate]]></Name>
							<Value Class="CodeUnitValue">
								<Code><![CDATA[1]]></Code>
								<Unit Class="RateUnits"><![CDATA[PER_DAY]]></Unit>
							</Value>
						</Parameter>
						<Parameter>
							<Name><![CDATA[interarrivalTime]]></Name>
							<Value Class="CodeUnitValue">
								<Code><![CDATA[1]]></Code>
								<Unit Class="TimeUnits"><![CDATA[DAY]]></Unit>
							</Value>
						</Parameter>
						<Parameter>
							<Name><![CDATA[firstArrivalMode]]></Name>
							<Value Class="CodeValue">
								<Code><![CDATA[self.AT_START]]></Code>
							</Value>
						</Parameter>
						<Parameter>
							<Name><![CDATA[firstArrivalTime]]></Name>
						</Parameter>
						<Parameter>
							<Name><![CDATA[rateSchedule]]></Name>
						</Parameter>
						<Parameter>
							<Name><![CDATA[modifyRate]]></Name>
						</Parameter>
						<Parameter>
							<Name><![CDATA[rateExpression]]></Name>
						</Parameter>
						<Parameter>
							<Name><![CDATA[arrivalSchedule]]></Name>
						</Parameter>
						<Parameter>
							<Name><![CDATA[setAgentParametersFromDB]]></Name>
						</Parameter>
						<Parameter>
							<Name><![CDATA[databaseTable]]></Name>
						</Parameter>
						<Parameter>
							<Name><![CDATA[arrivalDate]]></Name>
						</Parameter>
						<Parameter>
							<Name><![CDATA[multipleEntitiesPerArrival]]></Name>
						</Parameter>
						<Parameter>
							<Name><![CDATA[entitiesPerArrival]]></Name>
						</Parameter>
						<Parameter>
							<Name><![CDATA[limitArrivals]]></Name>
						</Parameter>
						<Parameter>
							<Name><![CDATA[maxArrivals]]></Name>
						</Parameter>
						<Parameter>
							<Name><![CDATA[locationType]]></Name>
						</Parameter>
						<Parameter>
							<Name><![CDATA[locationX]]></Name>
						</Parameter>
						<Parameter>
							<Name><![CDATA[locationY]]></Name>
						</Parameter>
						<Parameter>
							<Name><![CDATA[locationZ]]></Name>
						</Parameter>
						<Parameter>
							<Name><![CDATA[locationLatitude]]></Name>
						</Parameter>
						<Parameter>
							<Name><![CDATA[locationLongitude]]></Name>
						</Parameter>
						<Parameter>
							<Name><![CDATA[locationGeoPlaceName]]></Name>
						</Parameter>
						<Parameter>
							<Name><![CDATA[locationXYZInNetwork]]></Name>
						</Parameter>
						<Parameter>
							<Name><![CDATA[locationNetwork]]></Name>
						</Parameter>
						<Parameter>
							<Name><![CDATA[locationLevel]]></Name>
						</Parameter>
						<Parameter>
							<Name><![CDATA[locationNode]]></Name>
						</Parameter>
						<Parameter>
							<Name><![CDATA[locationAttractor]]></Name>
						</Parameter>
						<Parameter>
							<Name><![CDATA[speed]]></Name>
						</Parameter>
						<Parameter>
							<Name><![CDATA[newEntity]]></Name>
							<Value Class="EntityCodeValue">
								<IsAgentEntity>true</IsAgentEntity>
								<EntityEmbeddedObject>
									<ActiveObjectClass>
										<PackageName><![CDATA[simopt]]></PackageName>
										<ClassName><![CDATA[CustomerOrderAgent]]></ClassName>
									</ActiveObjectClass>
									<GenericParameterSubstitute>
										<GenericParameterSubstituteReference>
											<PackageName><![CDATA[simopt]]></PackageName>
											<ClassName><![CDATA[CustomerOrderAgent]]></ClassName>
											<ItemName><![CDATA[1638821428431]]></ItemName>
										</GenericParameterSubstituteReference>
									</GenericParameterSubstitute>
									<Parameters>
										<Parameter>
											<Name><![CDATA[customerOrderFromAgent]]></Name>
										</Parameter>
									</Parameters>
									<ReplicationFlag>true</ReplicationFlag>
									<Replication Class="CodeValue">
										<Code><![CDATA[100]]></Code>
									</Replication>
									<CollectionType>ARRAY_LIST_BASED</CollectionType>
									<InitialLocationType>AT_ANIMATION_POSITION</InitialLocationType>
									<XCode Class="CodeValue">
										<Code><![CDATA[0]]></Code>
									</XCode>
									<YCode Class="CodeValue">
										<Code><![CDATA[0]]></Code>
									</YCode>
									<ZCode Class="CodeValue">
										<Code><![CDATA[0]]></Code>
									</ZCode>
									<ColumnCode Class="CodeValue">
										<Code><![CDATA[0]]></Code>
									</ColumnCode>
									<RowCode Class="CodeValue">
										<Code><![CDATA[0]]></Code>
									</RowCode>
									<LatitudeCode Class="CodeValue">
										<Code><![CDATA[0]]></Code>
									</LatitudeCode>
									<LongitudeCode Class="CodeValue">
										<Code><![CDATA[0]]></Code>
									</LongitudeCode>
									<LocationNameCode Class="CodeValue">
										<Code><![CDATA[""]]></Code>
									</LocationNameCode>
									<InitializationType>LOAD_FROM_DATABASE</InitializationType>
									<InitializationDatabaseTableQuery>
										<TableReference>
										</TableReference>
									</InitializationDatabaseTableQuery>
									<InitializationDatabaseType>ONE_AGENT_PER_DATABASE_RECORD</InitializationDatabaseType>
									<QuantityColumn>
									</QuantityColumn>
								</EntityEmbeddedObject>
							</Value>
						</Parameter>
						<Parameter>
							<Name><![CDATA[changeDimensions]]></Name>
						</Parameter>
						<Parameter>
							<Name><![CDATA[length]]></Name>
						</Parameter>
						<Parameter>
							<Name><![CDATA[width]]></Name>
						</Parameter>
						<Parameter>
							<Name><![CDATA[height]]></Name>
						</Parameter>
						<Parameter>
							<Name><![CDATA[enableCustomStartTime]]></Name>
						</Parameter>
						<Parameter>
							<Name><![CDATA[startTime]]></Name>
						</Parameter>
						<Parameter>
							<Name><![CDATA[addToCustomPopulation]]></Name>
						</Parameter>
						<Parameter>
							<Name><![CDATA[population]]></Name>
						</Parameter>
						<Parameter>
							<Name><![CDATA[pushProtocol]]></Name>
						</Parameter>
						<Parameter>
							<Name><![CDATA[discardHangingEntities]]></Name>
						</Parameter>
						<Parameter>
							<Name><![CDATA[onBeforeArrival]]></Name>
						</Parameter>
						<Parameter>
							<Name><![CDATA[onAtExit]]></Name>
						</Parameter>
						<Parameter>
							<Name><![CDATA[onExit]]></Name>
							<Value Class="CodeValue">
								<Code><![CDATA[List <CustomerOrder> newOrders = new ArrayList();

if (simParams.getDemandGeneration().equals(SimulationParameter.DEMAND_GENERATION_FORECAST)) {
  double residualForecastUpdateFrequency = (time() - 1) % simParams.getForecastUpdateFrequency();
	
  newOrders = CustomerOrder.GenerateForecast(forecastMasterdata, time(), orderId, simParams, var_random_forecast);
  customerOrders.addAll(newOrders);

  orderId += newOrders.size();

  if (simParams.getApplyForecastUpdates() == 1 && residualForecastUpdateFrequency == 0) {
    customerOrders = Forecast.UpdateForecast(customerOrders,
      time(), simParams, list_ForecastInputParameter, forecastMasterdata,
      forecastHistoryList, var_random_forecast, mrpFileNameSuffix);                        
  }
    
  for (CustomerOrder o: customerOrders) {
    if (o.getLastForecastHistory() != null) {
      forecastHistoryList.add(o.getLastForecastHistory());
      o.setLastForecastHistory(null);
    }
  }

  for (CustomerOrder order: customerOrders.stream().filter(e -> e.getCreatedAt() == time()).sorted(Comparator.comparing(CustomerOrder::getOrderId)).collect(Collectors.toList())) {
    CustomerOrderAgent newOrder = new CustomerOrderAgent();
    newOrder.customerOrderFromAgent = order;
    newOrder.markParametersAreSet();
    enter.take(newOrder);
  }
  
}else if(simParams.getDemandGeneration().equalsIgnoreCase(SimulationParameter.DEMAND_GENERATION_ORDERPAST)
		&& time() == 0){

  newOrders = CustomerOrder.GenerateOrderPastCustomerOrders(orderPasts, time(), orderId, simParams);
  customerOrders.addAll(newOrders);

  orderId += newOrders.size();
  
  for (CustomerOrder order: customerOrders.stream().filter(e -> e.getCreatedAt() == time()).sorted(Comparator.comparing(CustomerOrder::getOrderId)).collect(Collectors.toList())) {
    CustomerOrderAgent newOrder = new CustomerOrderAgent();
    newOrder.customerOrderFromAgent = order;
    newOrder.markParametersAreSet();
    enter.take(newOrder);
  }

}

if (simParams.getApplyMRP() == 1 || simParams.getApplyRPS() == SimulationParameter.APPLY_RPS){
  MRPStandard();
}

if (simParams.getApplyOptimization() == 1) {
  //SimOptimization();
}]]></Code>
							</Value>
						</Parameter>
						<Parameter>
							<Name><![CDATA[onDiscard]]></Name>
						</Parameter>
					</Parameters>
					<ReplicationFlag>false</ReplicationFlag>
					<Replication Class="CodeValue">
						<Code><![CDATA[4]]></Code>
					</Replication>
					<CollectionType>ARRAY_LIST_BASED</CollectionType>
					<InitialLocationType>XYZ</InitialLocationType>
					<XCode Class="CodeValue">
						<Code><![CDATA[0]]></Code>
					</XCode>
					<YCode Class="CodeValue">
						<Code><![CDATA[0]]></Code>
					</YCode>
					<ZCode Class="CodeValue">
						<Code><![CDATA[0]]></Code>
					</ZCode>
					<ColumnCode Class="CodeValue">
						<Code><![CDATA[0]]></Code>
					</ColumnCode>
					<RowCode Class="CodeValue">
						<Code><![CDATA[0]]></Code>
					</RowCode>
					<LocationNameCode Class="CodeValue">
						<Code><![CDATA[""]]></Code>
					</LocationNameCode>
					<InitializationType>SPECIFIED_NUMBER</InitializationType>
					<InitializationDatabaseTableQuery>
						<TableReference>
						</TableReference>
					</InitializationDatabaseTableQuery>
					<InitializationDatabaseType>ONE_AGENT_PER_DATABASE_RECORD</InitializationDatabaseType>
					<QuantityColumn>
					</QuantityColumn>
				</EmbeddedObject>
				<EmbeddedObject>
					<Id>1640610656245</Id>
					<Name><![CDATA[selectOutputLateOrOnTime]]></Name>
					<X>630</X><Y>130</Y>
					<Label><X>-55</X><Y>-20</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<ActiveObjectClass>
						<PackageName><![CDATA[com.anylogic.libraries.processmodeling]]></PackageName>
						<ClassName><![CDATA[SelectOutput]]></ClassName>
					</ActiveObjectClass>
					<GenericParameterSubstitute>
						<GenericParameterSubstituteReference>
							<PackageName><![CDATA[com.anylogic.libraries.processmodeling]]></PackageName>
							<ClassName><![CDATA[SelectOutput]]></ClassName>
							<ItemName><![CDATA[1412336242931]]></ItemName>
						</GenericParameterSubstituteReference>
					</GenericParameterSubstitute>
					<Parameters>
						<Parameter>
							<Name><![CDATA[conditionIsProbabilistic]]></Name>
							<Value Class="CodeValue">
								<Code><![CDATA[false]]></Code>
							</Value>
						</Parameter>
						<Parameter>
							<Name><![CDATA[condition]]></Name>
							<Value Class="CodeValue">
								<Code><![CDATA[agent.customerOrderFromAgent.getStatus() == CustomerOrder.ORDER_STATUS_DELAYED]]></Code>
							</Value>
						</Parameter>
						<Parameter>
							<Name><![CDATA[probability]]></Name>
						</Parameter>
						<Parameter>
							<Name><![CDATA[onAtEnter]]></Name>
						</Parameter>
						<Parameter>
							<Name><![CDATA[onEnter]]></Name>
						</Parameter>
						<Parameter>
							<Name><![CDATA[onExitTrue]]></Name>
							<Value Class="CodeValue">
								<Code><![CDATA[//delayed
//traceln("Delay out late: " + agent.customerOrderFromAgent.getOrderId() + " " + agent.customerOrderFromAgent.getStatus());]]></Code>
							</Value>
						</Parameter>
						<Parameter>
							<Name><![CDATA[onExitFalse]]></Name>
							<Value Class="CodeValue">
								<Code><![CDATA[//onTime]]></Code>
							</Value>
						</Parameter>
					</Parameters>
					<ReplicationFlag>false</ReplicationFlag>
					<Replication Class="CodeValue">
						<Code><![CDATA[100]]></Code>
					</Replication>
					<CollectionType>ARRAY_LIST_BASED</CollectionType>
					<InitialLocationType>XYZ</InitialLocationType>
					<XCode Class="CodeValue">
						<Code><![CDATA[0]]></Code>
					</XCode>
					<YCode Class="CodeValue">
						<Code><![CDATA[0]]></Code>
					</YCode>
					<ZCode Class="CodeValue">
						<Code><![CDATA[0]]></Code>
					</ZCode>
					<ColumnCode Class="CodeValue">
						<Code><![CDATA[0]]></Code>
					</ColumnCode>
					<RowCode Class="CodeValue">
						<Code><![CDATA[0]]></Code>
					</RowCode>
					<LocationNameCode Class="CodeValue">
						<Code><![CDATA[""]]></Code>
					</LocationNameCode>
					<InitializationType>SPECIFIED_NUMBER</InitializationType>
					<InitializationDatabaseTableQuery>
						<TableReference>
						</TableReference>
					</InitializationDatabaseTableQuery>
					<InitializationDatabaseType>ONE_AGENT_PER_DATABASE_RECORD</InitializationDatabaseType>
					<QuantityColumn>
					</QuantityColumn>
				</EmbeddedObject>
				<EmbeddedObject>
					<Id>1640610687654</Id>
					<Name><![CDATA[Late]]></Name>
					<X>740</X><Y>90</Y>
					<Label><X>-10</X><Y>-20</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<ActiveObjectClass>
						<PackageName><![CDATA[com.anylogic.libraries.processmodeling]]></PackageName>
						<ClassName><![CDATA[Sink]]></ClassName>
					</ActiveObjectClass>
					<GenericParameterSubstitute>
						<GenericParameterSubstituteReference>
							<PackageName><![CDATA[com.anylogic.libraries.processmodeling]]></PackageName>
							<ClassName><![CDATA[Sink]]></ClassName>
							<ItemName><![CDATA[1412336242929]]></ItemName>
						</GenericParameterSubstituteReference>
					</GenericParameterSubstitute>
					<Parameters>
						<Parameter>
							<Name><![CDATA[onEnter]]></Name>
							<Value Class="CodeValue">
								<Code><![CDATA[agent.customerOrderFromAgent.setStatus(CustomerOrder.ORDER_STATUS_DELAYED);

if(agent.customerOrderFromAgent.getCreatedAt() >= simParams.getWarumUpTime())
	StatisticServiceLevel.add(0);


Function_UpdateDemandVariationArray(agent.customerOrderFromAgent);
]]></Code>
							</Value>
						</Parameter>
						<Parameter>
							<Name><![CDATA[destroyEntity]]></Name>
						</Parameter>
					</Parameters>
					<ReplicationFlag>false</ReplicationFlag>
					<Replication Class="CodeValue">
						<Code><![CDATA[100]]></Code>
					</Replication>
					<CollectionType>ARRAY_LIST_BASED</CollectionType>
					<InitialLocationType>XYZ</InitialLocationType>
					<XCode Class="CodeValue">
						<Code><![CDATA[0]]></Code>
					</XCode>
					<YCode Class="CodeValue">
						<Code><![CDATA[0]]></Code>
					</YCode>
					<ZCode Class="CodeValue">
						<Code><![CDATA[0]]></Code>
					</ZCode>
					<ColumnCode Class="CodeValue">
						<Code><![CDATA[0]]></Code>
					</ColumnCode>
					<RowCode Class="CodeValue">
						<Code><![CDATA[0]]></Code>
					</RowCode>
					<LocationNameCode Class="CodeValue">
						<Code><![CDATA[""]]></Code>
					</LocationNameCode>
					<InitializationType>SPECIFIED_NUMBER</InitializationType>
					<InitializationDatabaseTableQuery>
						<TableReference>
						</TableReference>
					</InitializationDatabaseTableQuery>
					<InitializationDatabaseType>ONE_AGENT_PER_DATABASE_RECORD</InitializationDatabaseType>
					<QuantityColumn>
					</QuantityColumn>
				</EmbeddedObject>
				<EmbeddedObject>
					<Id>1640610691321</Id>
					<Name><![CDATA[Ontime]]></Name>
					<X>740</X><Y>170</Y>
					<Label><X>-10</X><Y>-20</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<ActiveObjectClass>
						<PackageName><![CDATA[com.anylogic.libraries.processmodeling]]></PackageName>
						<ClassName><![CDATA[Sink]]></ClassName>
					</ActiveObjectClass>
					<GenericParameterSubstitute>
						<GenericParameterSubstituteReference>
							<PackageName><![CDATA[com.anylogic.libraries.processmodeling]]></PackageName>
							<ClassName><![CDATA[Sink]]></ClassName>
							<ItemName><![CDATA[1412336242929]]></ItemName>
						</GenericParameterSubstituteReference>
					</GenericParameterSubstitute>
					<Parameters>
						<Parameter>
							<Name><![CDATA[onEnter]]></Name>
							<Value Class="CodeValue">
								<Code><![CDATA[agent.customerOrderFromAgent.setStatus(CustomerOrder.ORDER_STATUS_FINISHED);

if(agent.customerOrderFromAgent.getCreatedAt() >= simParams.getWarumUpTime())
	StatisticServiceLevel.add(1);

Function_UpdateDemandVariationArray(agent.customerOrderFromAgent);
]]></Code>
							</Value>
						</Parameter>
						<Parameter>
							<Name><![CDATA[destroyEntity]]></Name>
						</Parameter>
					</Parameters>
					<ReplicationFlag>false</ReplicationFlag>
					<Replication Class="CodeValue">
						<Code><![CDATA[100]]></Code>
					</Replication>
					<CollectionType>ARRAY_LIST_BASED</CollectionType>
					<InitialLocationType>XYZ</InitialLocationType>
					<XCode Class="CodeValue">
						<Code><![CDATA[0]]></Code>
					</XCode>
					<YCode Class="CodeValue">
						<Code><![CDATA[0]]></Code>
					</YCode>
					<ZCode Class="CodeValue">
						<Code><![CDATA[0]]></Code>
					</ZCode>
					<ColumnCode Class="CodeValue">
						<Code><![CDATA[0]]></Code>
					</ColumnCode>
					<RowCode Class="CodeValue">
						<Code><![CDATA[0]]></Code>
					</RowCode>
					<LocationNameCode Class="CodeValue">
						<Code><![CDATA[""]]></Code>
					</LocationNameCode>
					<InitializationType>SPECIFIED_NUMBER</InitializationType>
					<InitializationDatabaseTableQuery>
						<TableReference>
						</TableReference>
					</InitializationDatabaseTableQuery>
					<InitializationDatabaseType>ONE_AGENT_PER_DATABASE_RECORD</InitializationDatabaseType>
					<QuantityColumn>
					</QuantityColumn>
				</EmbeddedObject>
				<EmbeddedObject>
					<Id>1640692905366</Id>
					<Name><![CDATA[enter]]></Name>
					<X>270</X><Y>130</Y>
					<Label><X>-10</X><Y>-20</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<ActiveObjectClass>
						<PackageName><![CDATA[com.anylogic.libraries.processmodeling]]></PackageName>
						<ClassName><![CDATA[Enter]]></ClassName>
					</ActiveObjectClass>
					<GenericParameterSubstitute>
						<GenericParameterSubstituteReference>
							<PackageName><![CDATA[com.anylogic.libraries.processmodeling]]></PackageName>
							<ClassName><![CDATA[Enter]]></ClassName>
							<ItemName><![CDATA[1412336242933]]></ItemName>
						</GenericParameterSubstituteReference>
						<GenericParameterSubstituteValue Class="CodeValue">
							<Code><![CDATA[CustomerOrderAgent]]></Code>
						</GenericParameterSubstituteValue>
					</GenericParameterSubstitute>
					<Parameters>
						<Parameter>
							<Name><![CDATA[locationType]]></Name>
						</Parameter>
						<Parameter>
							<Name><![CDATA[locationX]]></Name>
						</Parameter>
						<Parameter>
							<Name><![CDATA[locationY]]></Name>
						</Parameter>
						<Parameter>
							<Name><![CDATA[locationZ]]></Name>
						</Parameter>
						<Parameter>
							<Name><![CDATA[locationLatitude]]></Name>
						</Parameter>
						<Parameter>
							<Name><![CDATA[locationLongitude]]></Name>
						</Parameter>
						<Parameter>
							<Name><![CDATA[locationGeoPlaceName]]></Name>
						</Parameter>
						<Parameter>
							<Name><![CDATA[locationXYZInNetwork]]></Name>
						</Parameter>
						<Parameter>
							<Name><![CDATA[locationNetwork]]></Name>
						</Parameter>
						<Parameter>
							<Name><![CDATA[locationLevel]]></Name>
						</Parameter>
						<Parameter>
							<Name><![CDATA[locationNode]]></Name>
						</Parameter>
						<Parameter>
							<Name><![CDATA[locationAttractor]]></Name>
						</Parameter>
						<Parameter>
							<Name><![CDATA[speed]]></Name>
						</Parameter>
						<Parameter>
							<Name><![CDATA[changeDimensions]]></Name>
						</Parameter>
						<Parameter>
							<Name><![CDATA[length]]></Name>
						</Parameter>
						<Parameter>
							<Name><![CDATA[width]]></Name>
						</Parameter>
						<Parameter>
							<Name><![CDATA[height]]></Name>
						</Parameter>
						<Parameter>
							<Name><![CDATA[addToCustomPopulation]]></Name>
						</Parameter>
						<Parameter>
							<Name><![CDATA[population]]></Name>
						</Parameter>
						<Parameter>
							<Name><![CDATA[pushProtocol]]></Name>
						</Parameter>
						<Parameter>
							<Name><![CDATA[onEnter]]></Name>
						</Parameter>
						<Parameter>
							<Name><![CDATA[onRemove]]></Name>
						</Parameter>
						<Parameter>
							<Name><![CDATA[onAtEnter]]></Name>
						</Parameter>
					</Parameters>
					<ReplicationFlag>false</ReplicationFlag>
					<Replication Class="CodeValue">
						<Code><![CDATA[100]]></Code>
					</Replication>
					<CollectionType>ARRAY_LIST_BASED</CollectionType>
					<InitialLocationType>XYZ</InitialLocationType>
					<XCode Class="CodeValue">
						<Code><![CDATA[0]]></Code>
					</XCode>
					<YCode Class="CodeValue">
						<Code><![CDATA[0]]></Code>
					</YCode>
					<ZCode Class="CodeValue">
						<Code><![CDATA[0]]></Code>
					</ZCode>
					<ColumnCode Class="CodeValue">
						<Code><![CDATA[0]]></Code>
					</ColumnCode>
					<RowCode Class="CodeValue">
						<Code><![CDATA[0]]></Code>
					</RowCode>
					<LocationNameCode Class="CodeValue">
						<Code><![CDATA[""]]></Code>
					</LocationNameCode>
					<InitializationType>SPECIFIED_NUMBER</InitializationType>
					<InitializationDatabaseTableQuery>
						<TableReference>
						</TableReference>
					</InitializationDatabaseTableQuery>
					<InitializationDatabaseType>ONE_AGENT_PER_DATABASE_RECORD</InitializationDatabaseType>
					<QuantityColumn>
					</QuantityColumn>
				</EmbeddedObject>
				<EmbeddedObject>
					<Id>1641300260044</Id>
					<Name><![CDATA[sink]]></Name>
					<X>210</X><Y>120</Y>
					<Label><X>-10</X><Y>-20</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<ActiveObjectClass>
						<PackageName><![CDATA[com.anylogic.libraries.processmodeling]]></PackageName>
						<ClassName><![CDATA[Sink]]></ClassName>
					</ActiveObjectClass>
					<GenericParameterSubstitute>
						<GenericParameterSubstituteReference>
							<PackageName><![CDATA[com.anylogic.libraries.processmodeling]]></PackageName>
							<ClassName><![CDATA[Sink]]></ClassName>
							<ItemName><![CDATA[1412336242929]]></ItemName>
						</GenericParameterSubstituteReference>
					</GenericParameterSubstitute>
					<Parameters>
						<Parameter>
							<Name><![CDATA[onEnter]]></Name>
						</Parameter>
						<Parameter>
							<Name><![CDATA[destroyEntity]]></Name>
						</Parameter>
					</Parameters>
					<ReplicationFlag>false</ReplicationFlag>
					<Replication Class="CodeValue">
						<Code><![CDATA[100]]></Code>
					</Replication>
					<CollectionType>ARRAY_LIST_BASED</CollectionType>
					<InitialLocationType>XYZ</InitialLocationType>
					<XCode Class="CodeValue">
						<Code><![CDATA[0]]></Code>
					</XCode>
					<YCode Class="CodeValue">
						<Code><![CDATA[0]]></Code>
					</YCode>
					<ZCode Class="CodeValue">
						<Code><![CDATA[0]]></Code>
					</ZCode>
					<ColumnCode Class="CodeValue">
						<Code><![CDATA[0]]></Code>
					</ColumnCode>
					<RowCode Class="CodeValue">
						<Code><![CDATA[0]]></Code>
					</RowCode>
					<LocationNameCode Class="CodeValue">
						<Code><![CDATA[""]]></Code>
					</LocationNameCode>
					<InitializationType>SPECIFIED_NUMBER</InitializationType>
					<InitializationDatabaseTableQuery>
						<TableReference>
						</TableReference>
					</InitializationDatabaseTableQuery>
					<InitializationDatabaseType>ONE_AGENT_PER_DATABASE_RECORD</InitializationDatabaseType>
					<QuantityColumn>
					</QuantityColumn>
				</EmbeddedObject>
				<EmbeddedObject>
					<Id>1641360099077</Id>
					<Name><![CDATA[delay_CurrentCustomerOrders]]></Name>
					<X>450</X><Y>120</Y>
					<Label><X>-65</X><Y>-15</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<ActiveObjectClass>
						<PackageName><![CDATA[com.anylogic.libraries.processmodeling]]></PackageName>
						<ClassName><![CDATA[Delay]]></ClassName>
					</ActiveObjectClass>
					<GenericParameterSubstitute>
						<GenericParameterSubstituteReference>
							<PackageName><![CDATA[com.anylogic.libraries.processmodeling]]></PackageName>
							<ClassName><![CDATA[Delay]]></ClassName>
							<ItemName><![CDATA[1412336242930]]></ItemName>
						</GenericParameterSubstituteReference>
					</GenericParameterSubstitute>
					<Parameters>
						<Parameter>
							<Name><![CDATA[type]]></Name>
						</Parameter>
						<Parameter>
							<Name><![CDATA[delayTime]]></Name>
							<Value Class="CodeUnitValue">
								<Code><![CDATA[max(agent.customerOrderFromAgent.getDueDate()-time(),0)]]></Code>
								<Unit Class="TimeUnits"><![CDATA[DAY]]></Unit>
							</Value>
						</Parameter>
						<Parameter>
							<Name><![CDATA[capacity]]></Name>
							<Value Class="CodeValue">
								<Code><![CDATA[100]]></Code>
							</Value>
						</Parameter>
						<Parameter>
							<Name><![CDATA[maximumCapacity]]></Name>
							<Value Class="CodeValue">
								<Code><![CDATA[true]]></Code>
							</Value>
						</Parameter>
						<Parameter>
							<Name><![CDATA[entityLocation]]></Name>
						</Parameter>
						<Parameter>
							<Name><![CDATA[pushProtocol]]></Name>
						</Parameter>
						<Parameter>
							<Name><![CDATA[restoreEntityLocationOnExit]]></Name>
						</Parameter>
						<Parameter>
							<Name><![CDATA[forceStatisticsCollection]]></Name>
						</Parameter>
						<Parameter>
							<Name><![CDATA[onEnter]]></Name>
							<Value Class="CodeValue">
								<Code><![CDATA[agent.customerOrderFromAgent.setActualStart(time());

if(time() > simParams.getWarumUpTime()){
	kPIAgent.plotDemandPerItem
	.get(agent.customerOrderFromAgent.getItem().getDataItemIndex()).add(time(), agent.customerOrderFromAgent.getQuantity());
}
]]></Code>
							</Value>
						</Parameter>
						<Parameter>
							<Name><![CDATA[onAtExit]]></Name>
							<Value Class="CodeValue">
								<Code><![CDATA[StockBooking qty = StockBooking.GetStockItemQuantity(stockBookings, agent.customerOrderFromAgent.getItem());

List<CustomerOrder> existsDelayedOrder = customerOrders.stream().
filter(e -> e.getItem().getItem() == agent.customerOrderFromAgent.getItem().getItem() && e.getStatus()
 == CustomerOrder.ORDER_STATUS_DELAYED).collect(Collectors.toList());

//we also must check if the customer order already was book, therefore we look at the booking list

List<StockBooking> existingStockBookings = stockBookings.stream().filter(e -> e.getSource().
	equalsIgnoreCase(StockBooking.BOOKING_SOURCE_CUSTOMER_ORDER) && e.getSourceId() ==
	agent.customerOrderFromAgent.getOrderId() && 
	 e.getItem().getItem() ==
	agent.customerOrderFromAgent.getItem().getItem() && 
	(e.getQuantity() * -1) == agent.customerOrderFromAgent.getQuantity()).collect(Collectors.toList());
		
//if the customer order was already booked we no longer have to check it respecively book it.
//if(existingStockBooking != null && existingStockBooking.getQuantity() * -1 == agent.customerOrderFromAgent.getQuantity()){	
if(existingStockBookings.size() == 0){	
	if(qty.getQuantity() >= agent.customerOrderFromAgent.getQuantity() && existsDelayedOrder.size() == 0){
		StockBooking book = new StockBooking(
		agent.customerOrderFromAgent.getItem(),
		agent.customerOrderFromAgent.getQuantity() * -1,
		time(),
		StockBooking.BOOKING_SOURCE_CUSTOMER_ORDER,
		agent.customerOrderFromAgent.getOrderId(),
		qty.getQuantity(),
		qty.getTimeBetweenBookings());					
		
		stockBookings.add(book);
		
		agent.customerOrderFromAgent.setStatus(CustomerOrder.ORDER_STATUS_FINISHED);
		agent.customerOrderFromAgent.setActualEnd(time());				
		
	}else{
		//traceln("why delayed");
		//traceln("cu " + agent.customerOrderFromAgent.getOrderId());
		agent.customerOrderFromAgent.setStatus(CustomerOrder.ORDER_STATUS_DELAYED);
	}
}//if existingStockBooking]]></Code>
							</Value>
						</Parameter>
						<Parameter>
							<Name><![CDATA[onExit]]></Name>
						</Parameter>
						<Parameter>
							<Name><![CDATA[onRemove]]></Name>
						</Parameter>
					</Parameters>
					<ReplicationFlag>false</ReplicationFlag>
					<Replication Class="CodeValue">
						<Code><![CDATA[100]]></Code>
					</Replication>
					<CollectionType>ARRAY_LIST_BASED</CollectionType>
					<InitialLocationType>XYZ</InitialLocationType>
					<XCode Class="CodeValue">
						<Code><![CDATA[0]]></Code>
					</XCode>
					<YCode Class="CodeValue">
						<Code><![CDATA[0]]></Code>
					</YCode>
					<ZCode Class="CodeValue">
						<Code><![CDATA[0]]></Code>
					</ZCode>
					<ColumnCode Class="CodeValue">
						<Code><![CDATA[0]]></Code>
					</ColumnCode>
					<RowCode Class="CodeValue">
						<Code><![CDATA[0]]></Code>
					</RowCode>
					<LocationNameCode Class="CodeValue">
						<Code><![CDATA[""]]></Code>
					</LocationNameCode>
					<InitializationType>SPECIFIED_NUMBER</InitializationType>
					<InitializationDatabaseTableQuery>
						<TableReference>
						</TableReference>
					</InitializationDatabaseTableQuery>
					<InitializationDatabaseType>ONE_AGENT_PER_DATABASE_RECORD</InitializationDatabaseType>
					<QuantityColumn>
					</QuantityColumn>
				</EmbeddedObject>
				<EmbeddedObject>
					<Id>1643471226575</Id>
					<Name><![CDATA[machineAgents]]></Name>
					<X>140</X><Y>300</Y>
					<Label><X>-55</X><Y>-30</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<ActiveObjectClass>
						<PackageName><![CDATA[simopt]]></PackageName>
						<ClassName><![CDATA[MachineAgent]]></ClassName>
					</ActiveObjectClass>
					<GenericParameterSubstitute>
						<GenericParameterSubstituteReference>
							<PackageName><![CDATA[simopt]]></PackageName>
							<ClassName><![CDATA[MachineAgent]]></ClassName>
							<ItemName><![CDATA[1643198210441]]></ItemName>
						</GenericParameterSubstituteReference>
					</GenericParameterSubstitute>
					<Parameters>
						<Parameter>
							<Name><![CDATA[prodOrderFromAgent]]></Name>
						</Parameter>
						<Parameter>
							<Name><![CDATA[Resource]]></Name>
						</Parameter>
						<Parameter>
							<Name><![CDATA[parStationAvailability]]></Name>
						</Parameter>
						<Parameter>
							<Name><![CDATA[parStationMTTR]]></Name>
						</Parameter>
						<Parameter>
							<Name><![CDATA[parResourceCapacity]]></Name>
						</Parameter>
					</Parameters>
					<ReplicationFlag>true</ReplicationFlag>
					<Replication Class="CodeValue">
						<Code><![CDATA[100]]></Code>
					</Replication>
					<CollectionType>ARRAY_LIST_BASED</CollectionType>
					<InEnvironment>true</InEnvironment>	
					<InitialLocationType>XYZ</InitialLocationType>
					<XCode Class="CodeValue">
						<Code><![CDATA[0]]></Code>
					</XCode>
					<YCode Class="CodeValue">
						<Code><![CDATA[0]]></Code>
					</YCode>
					<ZCode Class="CodeValue">
						<Code><![CDATA[0]]></Code>
					</ZCode>
					<ColumnCode Class="CodeValue">
						<Code><![CDATA[0]]></Code>
					</ColumnCode>
					<RowCode Class="CodeValue">
						<Code><![CDATA[0]]></Code>
					</RowCode>
					<LocationNameCode Class="CodeValue">
						<Code><![CDATA[""]]></Code>
					</LocationNameCode>
					<InitializationType>EMPTY</InitializationType>
					<InitializationDatabaseTableQuery>
						<TableReference>
						</TableReference>
					</InitializationDatabaseTableQuery>
					<InitializationDatabaseType>ONE_AGENT_PER_DATABASE_RECORD</InitializationDatabaseType>
					<QuantityColumn>
					</QuantityColumn>
				</EmbeddedObject>
				<EmbeddedObject>
					<Id>1644308404925</Id>
					<Name><![CDATA[materialRelease]]></Name>
					<X>160</X><Y>230</Y>
					<Label><X>-65</X><Y>-30</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<ActiveObjectClass>
						<PackageName><![CDATA[simopt]]></PackageName>
						<ClassName><![CDATA[MaterialRelease]]></ClassName>
					</ActiveObjectClass>
					<GenericParameterSubstitute>
						<GenericParameterSubstituteReference>
							<PackageName><![CDATA[simopt]]></PackageName>
							<ClassName><![CDATA[MaterialRelease]]></ClassName>
							<ItemName><![CDATA[1644220982690]]></ItemName>
						</GenericParameterSubstituteReference>
					</GenericParameterSubstitute>
					<Parameters>
						<Parameter>
							<Name><![CDATA[prodOrderFromAgent]]></Name>
						</Parameter>
					</Parameters>
					<ReplicationFlag>false</ReplicationFlag>
					<Replication Class="CodeValue">
						<Code><![CDATA[100]]></Code>
					</Replication>
					<CollectionType>ARRAY_LIST_BASED</CollectionType>
					<InEnvironment>true</InEnvironment>	
					<InitialLocationType>XYZ</InitialLocationType>
					<XCode Class="CodeValue">
						<Code><![CDATA[0]]></Code>
					</XCode>
					<YCode Class="CodeValue">
						<Code><![CDATA[0]]></Code>
					</YCode>
					<ZCode Class="CodeValue">
						<Code><![CDATA[0]]></Code>
					</ZCode>
					<ColumnCode Class="CodeValue">
						<Code><![CDATA[0]]></Code>
					</ColumnCode>
					<RowCode Class="CodeValue">
						<Code><![CDATA[0]]></Code>
					</RowCode>
					<LocationNameCode Class="CodeValue">
						<Code><![CDATA[""]]></Code>
					</LocationNameCode>
					<InitializationType>SPECIFIED_NUMBER</InitializationType>
					<InitializationDatabaseTableQuery>
						<TableReference>
						</TableReference>
					</InitializationDatabaseTableQuery>
					<InitializationDatabaseType>ONE_AGENT_PER_DATABASE_RECORD</InitializationDatabaseType>
					<QuantityColumn>
					</QuantityColumn>
				</EmbeddedObject>
				<EmbeddedObject>
					<Id>1648060675566</Id>
					<Name><![CDATA[orderFutureAgent]]></Name>
					<X>160</X><Y>180</Y>
					<Label><X>-70</X><Y>-30</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<ActiveObjectClass>
						<PackageName><![CDATA[simopt]]></PackageName>
						<ClassName><![CDATA[OrderFutureAgent]]></ClassName>
					</ActiveObjectClass>
					<GenericParameterSubstitute>
						<GenericParameterSubstituteReference>
							<PackageName><![CDATA[simopt]]></PackageName>
							<ClassName><![CDATA[OrderFutureAgent]]></ClassName>
							<ItemName><![CDATA[1648060485062]]></ItemName>
						</GenericParameterSubstituteReference>
					</GenericParameterSubstitute>
					<Parameters>
						<Parameter>
							<Name><![CDATA[orderFutureFromAgent]]></Name>
						</Parameter>
					</Parameters>
					<ReplicationFlag>false</ReplicationFlag>
					<Replication Class="CodeValue">
						<Code><![CDATA[100]]></Code>
					</Replication>
					<CollectionType>ARRAY_LIST_BASED</CollectionType>
					<InEnvironment>true</InEnvironment>	
					<InitialLocationType>XYZ</InitialLocationType>
					<XCode Class="CodeValue">
						<Code><![CDATA[0]]></Code>
					</XCode>
					<YCode Class="CodeValue">
						<Code><![CDATA[0]]></Code>
					</YCode>
					<ZCode Class="CodeValue">
						<Code><![CDATA[0]]></Code>
					</ZCode>
					<ColumnCode Class="CodeValue">
						<Code><![CDATA[0]]></Code>
					</ColumnCode>
					<RowCode Class="CodeValue">
						<Code><![CDATA[0]]></Code>
					</RowCode>
					<LocationNameCode Class="CodeValue">
						<Code><![CDATA[""]]></Code>
					</LocationNameCode>
					<InitializationType>SPECIFIED_NUMBER</InitializationType>
					<InitializationDatabaseTableQuery>
						<TableReference>
						</TableReference>
					</InitializationDatabaseTableQuery>
					<InitializationDatabaseType>ONE_AGENT_PER_DATABASE_RECORD</InitializationDatabaseType>
					<QuantityColumn>
					</QuantityColumn>
				</EmbeddedObject>
				<EmbeddedObject>
					<Id>1654489516377</Id>
					<Name><![CDATA[kPIAgent]]></Name>
					<X>60</X><Y>240</Y>
					<Label><X>-30</X><Y>-30</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<ActiveObjectClass>
						<PackageName><![CDATA[simopt]]></PackageName>
						<ClassName><![CDATA[KPIAgent]]></ClassName>
					</ActiveObjectClass>
					<GenericParameterSubstitute>
						<GenericParameterSubstituteReference>
							<PackageName><![CDATA[simopt]]></PackageName>
							<ClassName><![CDATA[KPIAgent]]></ClassName>
							<ItemName><![CDATA[1654071868016]]></ItemName>
						</GenericParameterSubstituteReference>
					</GenericParameterSubstitute>
					<Parameters>
					</Parameters>
					<ReplicationFlag>false</ReplicationFlag>
					<Replication Class="CodeValue">
						<Code><![CDATA[100]]></Code>
					</Replication>
					<CollectionType>ARRAY_LIST_BASED</CollectionType>
					<InEnvironment>true</InEnvironment>	
					<InitialLocationType>XYZ</InitialLocationType>
					<XCode Class="CodeValue">
						<Code><![CDATA[0]]></Code>
					</XCode>
					<YCode Class="CodeValue">
						<Code><![CDATA[0]]></Code>
					</YCode>
					<ZCode Class="CodeValue">
						<Code><![CDATA[0]]></Code>
					</ZCode>
					<ColumnCode Class="CodeValue">
						<Code><![CDATA[0]]></Code>
					</ColumnCode>
					<RowCode Class="CodeValue">
						<Code><![CDATA[0]]></Code>
					</RowCode>
					<LocationNameCode Class="CodeValue">
						<Code><![CDATA[""]]></Code>
					</LocationNameCode>
					<InitializationType>SPECIFIED_NUMBER</InitializationType>
					<InitializationDatabaseTableQuery>
						<TableReference>
						</TableReference>
					</InitializationDatabaseTableQuery>
					<InitializationDatabaseType>ONE_AGENT_PER_DATABASE_RECORD</InitializationDatabaseType>
					<QuantityColumn>
					</QuantityColumn>
				</EmbeddedObject>
				<EmbeddedObject>
					<Id>1655207883215</Id>
					<Name><![CDATA[cplex]]></Name>
					<X>50</X><Y>300</Y>
					<Label><X>-20</X><Y>-30</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<ActiveObjectClass>
						<PackageName><![CDATA[simopt]]></PackageName>
						<ClassName><![CDATA[Cplex]]></ClassName>
					</ActiveObjectClass>
					<GenericParameterSubstitute>
						<GenericParameterSubstituteReference>
							<PackageName><![CDATA[simopt]]></PackageName>
							<ClassName><![CDATA[Cplex]]></ClassName>
							<ItemName><![CDATA[1652788218458]]></ItemName>
						</GenericParameterSubstituteReference>
					</GenericParameterSubstitute>
					<Parameters>
						<Parameter>
							<Name><![CDATA[ClearingFunctionSegments]]></Name>
						</Parameter>
					</Parameters>
					<ReplicationFlag>false</ReplicationFlag>
					<Replication Class="CodeValue">
						<Code><![CDATA[100]]></Code>
					</Replication>
					<CollectionType>ARRAY_LIST_BASED</CollectionType>
					<InEnvironment>true</InEnvironment>	
					<InitialLocationType>XYZ</InitialLocationType>
					<XCode Class="CodeValue">
						<Code><![CDATA[0]]></Code>
					</XCode>
					<YCode Class="CodeValue">
						<Code><![CDATA[0]]></Code>
					</YCode>
					<ZCode Class="CodeValue">
						<Code><![CDATA[0]]></Code>
					</ZCode>
					<ColumnCode Class="CodeValue">
						<Code><![CDATA[0]]></Code>
					</ColumnCode>
					<RowCode Class="CodeValue">
						<Code><![CDATA[0]]></Code>
					</RowCode>
					<LocationNameCode Class="CodeValue">
						<Code><![CDATA[""]]></Code>
					</LocationNameCode>
					<InitializationType>SPECIFIED_NUMBER</InitializationType>
					<InitializationDatabaseTableQuery>
						<TableReference>
						</TableReference>
					</InitializationDatabaseTableQuery>
					<InitializationDatabaseType>ONE_AGENT_PER_DATABASE_RECORD</InitializationDatabaseType>
					<QuantityColumn>
					</QuantityColumn>
				</EmbeddedObject>
				<EmbeddedObject>
					<Id>1671861031001</Id>
					<Name><![CDATA[clearingFunctionAgent]]></Name>
					<X>120</X><Y>370</Y>
					<Label><X>-90</X><Y>-30</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<PresentationId>1671861033401</PresentationId>
					<ActiveObjectClass>
						<PackageName><![CDATA[simopt]]></PackageName>
						<ClassName><![CDATA[ClearingFunctionAgent]]></ClassName>
					</ActiveObjectClass>
					<GenericParameterSubstitute>
						<GenericParameterSubstituteReference>
							<PackageName><![CDATA[simopt]]></PackageName>
							<ClassName><![CDATA[ClearingFunctionAgent]]></ClassName>
							<ItemName><![CDATA[1653365883862]]></ItemName>
						</GenericParameterSubstituteReference>
					</GenericParameterSubstitute>
					<Parameters>
					</Parameters>
					<ReplicationFlag>false</ReplicationFlag>
					<Replication Class="CodeValue">
						<Code><![CDATA[100]]></Code>
					</Replication>
					<CollectionType>ARRAY_LIST_BASED</CollectionType>
					<InEnvironment>true</InEnvironment>	
					<InitialLocationType>XYZ</InitialLocationType>
					<ColumnCode Class="CodeValue">
						<Code><![CDATA[0]]></Code>
					</ColumnCode>
					<RowCode Class="CodeValue">
						<Code><![CDATA[0]]></Code>
					</RowCode>
					<LocationNameCode Class="CodeValue">
						<Code><![CDATA[""]]></Code>
					</LocationNameCode>
					<InitializationType>SPECIFIED_NUMBER</InitializationType>
					<InitializationDatabaseTableQuery>
						<TableReference>
						</TableReference>
					</InitializationDatabaseTableQuery>
					<InitializationDatabaseType>ONE_AGENT_PER_DATABASE_RECORD</InitializationDatabaseType>
					<QuantityColumn>
					</QuantityColumn>
				</EmbeddedObject>
				<EmbeddedObject>
					<Id>1699355399199</Id>
					<Name><![CDATA[pyCommunicator]]></Name>
					<ExcludeFromBuild>true</ExcludeFromBuild>
					<X>70</X><Y>520</Y>
					<Label><X>-35</X><Y>-10</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<ActiveObjectClass>
						<PackageName><![CDATA[com.anylogic.libraries.pypeline]]></PackageName>
						<ClassName><![CDATA[PyCommunicator]]></ClassName>
					</ActiveObjectClass>
					<GenericParameterSubstitute>
						<GenericParameterSubstituteReference>
							<PackageName><![CDATA[com.anylogic.libraries.pypeline]]></PackageName>
							<ClassName><![CDATA[PyCommunicator]]></ClassName>
							<ItemName><![CDATA[1569858524853]]></ItemName>
						</GenericParameterSubstituteReference>
					</GenericParameterSubstitute>
					<Parameters>
						<Parameter>
							<Name><![CDATA[enable]]></Name>
						</Parameter>
						<Parameter>
							<Name><![CDATA[loadLastWorkingConfig]]></Name>
						</Parameter>
						<Parameter>
							<Name><![CDATA[pythonCommandType]]></Name>
						</Parameter>
						<Parameter>
							<Name><![CDATA[pythonCommand]]></Name>
						</Parameter>
						<Parameter>
							<Name><![CDATA[pythonExecPath]]></Name>
							<Value Class="CodeValue">
								<Code><![CDATA["C:\\Users\\p42413\\AppData\\Local\\Programs\\Python\\Python38\\python.exe"]]></Code>
							</Value>
						</Parameter>
						<Parameter>
							<Name><![CDATA[throwErrorOnFailedAttempt]]></Name>
						</Parameter>
						<Parameter>
							<Name><![CDATA[redirectPyOutput]]></Name>
							<Value Class="CodeValue">
								<Code><![CDATA[false]]></Code>
							</Value>
						</Parameter>
						<Parameter>
							<Name><![CDATA[isBlacklistMode]]></Name>
						</Parameter>
						<Parameter>
							<Name><![CDATA[isCustomConfiguration]]></Name>
						</Parameter>
						<Parameter>
							<Name><![CDATA[includeAutogeneratedsBL]]></Name>
						</Parameter>
						<Parameter>
							<Name><![CDATA[includeAutogeneratedsWL]]></Name>
						</Parameter>
						<Parameter>
							<Name><![CDATA[includedPackagesBL]]></Name>
						</Parameter>
						<Parameter>
							<Name><![CDATA[includedPackagesWL]]></Name>
						</Parameter>
						<Parameter>
							<Name><![CDATA[includedClassesBL]]></Name>
						</Parameter>
						<Parameter>
							<Name><![CDATA[includedClassesWL]]></Name>
						</Parameter>
						<Parameter>
							<Name><![CDATA[includedNamesBL]]></Name>
						</Parameter>
						<Parameter>
							<Name><![CDATA[includedNamesWL]]></Name>
						</Parameter>
					</Parameters>
					<ReplicationFlag>false</ReplicationFlag>
					<Replication Class="CodeValue">
						<Code><![CDATA[100]]></Code>
					</Replication>
					<CollectionType>ARRAY_LIST_BASED</CollectionType>
					<InitialLocationType>XYZ</InitialLocationType>
					<XCode Class="CodeValue">
						<Code><![CDATA[0]]></Code>
					</XCode>
					<YCode Class="CodeValue">
						<Code><![CDATA[0]]></Code>
					</YCode>
					<ZCode Class="CodeValue">
						<Code><![CDATA[0]]></Code>
					</ZCode>
					<ColumnCode Class="CodeValue">
						<Code><![CDATA[0]]></Code>
					</ColumnCode>
					<RowCode Class="CodeValue">
						<Code><![CDATA[0]]></Code>
					</RowCode>
					<LocationNameCode Class="CodeValue">
						<Code><![CDATA[""]]></Code>
					</LocationNameCode>
					<InitializationType>SPECIFIED_NUMBER</InitializationType>
					<InitializationDatabaseTableQuery>
						<TableReference>
						</TableReference>
					</InitializationDatabaseTableQuery>
					<InitializationDatabaseType>ONE_AGENT_PER_DATABASE_RECORD</InitializationDatabaseType>
					<QuantityColumn>
					</QuantityColumn>
				</EmbeddedObject>
			</EmbeddedObjects>

			<Presentation>
				<Level>
					<Id>1634127996027</Id>
					<Name><![CDATA[level]]></Name>
					<X>0</X><Y>0</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>true</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>false</ShowLabel>
					<DrawMode>SHAPE_DRAW_2D3D</DrawMode>
					<Z>0</Z>
					<LevelVisibility>DIM_NON_CURRENT</LevelVisibility>

			<Presentation>
				<Text>
					<Id>1642325780453</Id>
					<Name><![CDATA[textPlannedUtilization]]></Name>
					<ExcludeFromBuild>true</ExcludeFromBuild>
					<X>270</X><Y>10</Y>
					<Label><X>0</X><Y>-10</Y></Label>
					<PublicFlag>true</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>false</ShowLabel>
					<DrawMode>SHAPE_DRAW_2D</DrawMode>
					<EmbeddedIcon>false</EmbeddedIcon>
					<Z>0</Z>
					<Rotation>0.0</Rotation>
					<Color>-16777216</Color>
					<Text><![CDATA[Utilization]]></Text>
					<Font>
						<Name>SansSerif</Name>
						<Size>20</Size>
						<Style>0</Style>
					</Font>
					<Alignment>LEFT</Alignment>
				</Text>
				<Text>
					<Id>1642415845193</Id>
					<Name><![CDATA[textSimulationExperiment]]></Name>
					<X>30</X><Y>60</Y>
					<Label><X>0</X><Y>-10</Y></Label>
					<PublicFlag>true</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>false</ShowLabel>
					<DrawMode>SHAPE_DRAW_2D</DrawMode>
					<EmbeddedIcon>false</EmbeddedIcon>
					<Z>0</Z>
					<Rotation>0.0</Rotation>
					<Color>-16777216</Color>
					<Text><![CDATA[Simulation Experiment]]></Text>
					<Font>
						<Name>SansSerif</Name>
						<Size>20</Size>
						<Style>0</Style>
					</Font>
					<Alignment>LEFT</Alignment>
				</Text>
				<Text>
					<Id>1653967936369</Id>
					<Name><![CDATA[textSimulatedTimePeriod]]></Name>
					<X>30</X><Y>10</Y>
					<Label><X>0</X><Y>-10</Y></Label>
					<PublicFlag>true</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>false</ShowLabel>
					<DrawMode>SHAPE_DRAW_2D</DrawMode>
					<EmbeddedIcon>false</EmbeddedIcon>
					<Z>0</Z>
					<Rotation>0.0</Rotation>
					<Color>-16777216</Color>
					<Text><![CDATA[Simulated time period]]></Text>
					<Font>
						<Name>SansSerif</Name>
						<Size>20</Size>
						<Style>0</Style>
					</Font>
					<Alignment>LEFT</Alignment>
				</Text>
				<Text>
					<Id>1653970567056</Id>
					<Name><![CDATA[textWarumUpTime]]></Name>
					<X>30</X><Y>34</Y>
					<Label><X>0</X><Y>-10</Y></Label>
					<PublicFlag>true</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>false</ShowLabel>
					<DrawMode>SHAPE_DRAW_2D</DrawMode>
					<EmbeddedIcon>false</EmbeddedIcon>
					<Z>0</Z>
					<Rotation>0.0</Rotation>
					<Color>-16777216</Color>
					<Text><![CDATA[WarumUp Time]]></Text>
					<Font>
						<Name>SansSerif</Name>
						<Size>20</Size>
						<Style>0</Style>
					</Font>
					<Alignment>LEFT</Alignment>
				</Text>
				<EmbeddedObjectPresentation>
					<Id>1671861033401</Id>
					<Name><![CDATA[clearingFunctionAgent_presentation]]></Name>
					<X>780</X><Y>40</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>true</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>false</ShowLabel>
					<DrawMode>SHAPE_DRAW_2D3D</DrawMode>
					<EmbeddedIcon>false</EmbeddedIcon>
					<Z>0</Z>
					<Rotation>0.0</Rotation>
					<ScaleType>AUTOMATICALLY_CALCULATED</ScaleType>
					<GISScaleForRealEmbeddedObjectPresentationSize>1000</GISScaleForRealEmbeddedObjectPresentationSize>
					<GISScaleForFixedEmbeddedObjectPresentationSize>1000000000</GISScaleForFixedEmbeddedObjectPresentationSize>
					<Latitude>0.0</Latitude>
					<Longitude>0.0</Longitude>
				</EmbeddedObjectPresentation>
    			<TimePlot>
					<Id>1710955883101</Id>
					<Name><![CDATA[plot]]></Name>
					<X>130</X><Y>1040</Y>
					<Label><X>0</X><Y>-10</Y></Label>
					<PublicFlag>true</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>false</ShowLabel>
					<DrawMode>SHAPE_DRAW_2D3D</DrawMode>
					<AutoUpdate>true</AutoUpdate>
					<OccurrenceAtTime>true</OccurrenceAtTime>
					<OccurrenceDate>1711008000000</OccurrenceDate>
					<OccurrenceTime Class="CodeUnitValue">
						<Code><![CDATA[0]]></Code>
						<Unit Class="TimeUnits"><![CDATA[DAY]]></Unit>
					</OccurrenceTime>
					<RecurrenceCode Class="CodeUnitValue">
						<Code><![CDATA[1]]></Code>
						<Unit Class="TimeUnits"><![CDATA[DAY]]></Unit>
					</RecurrenceCode>
					<EmbeddedIcon>false</EmbeddedIcon>
					<Width>580</Width>
					<Height>470</Height>
					<BackgroundColor/>
					<BorderColor/>
					<ChartArea>
						<XOffset>50</XOffset>
						<YOffset>30</YOffset>
						<Width>500</Width>
						<Height>380</Height>
						<BackgroundColor>-1</BackgroundColor>
						<BorderColor>-16777216</BorderColor>
						<GridColor>-12566464</GridColor>
					</ChartArea>
					<Legend>
						<Place>SOUTH</Place>
						<TextColor>-16777216</TextColor>
						<Size>30</Size>
					</Legend>
					<Labels>
						<HorLabelsPosition>DEFAULT</HorLabelsPosition>
						<VerLabelsPosition>DEFAULT</VerLabelsPosition>
						<TextColor>-12566464</TextColor>
					</Labels>
					<ShowLegend>true</ShowLegend>
					<TimeWindowsMovementType>MOVEMENT_WITH_TIME</TimeWindowsMovementType>		
					<TimeWindowUnits>MODEL_TIME_UNIT</TimeWindowUnits>
					<VerScaleFromExpression><![CDATA[0]]></VerScaleFromExpression>
					<VerScaleToExpression><![CDATA[1]]></VerScaleToExpression>
					<VerScaleType>AUTO</VerScaleType>
					<DrawLine>true</DrawLine>
					<Interpolation>LINEAR</Interpolation>
					<DatasetExpression>  
						<Title><![CDATA[Title]]></Title>
					<Id>1710955884053</Id>
					<Expression><![CDATA[my_dataset]]></Expression>
					<Color>-4343957</Color>
					<Expression2><![CDATA[varSystemWorkload]]></Expression2>
					<Expression2Flag>true</Expression2Flag>
						<PointStyle>NONE</PointStyle>
						<LineWidth>1.0</LineWidth>
					</DatasetExpression>
					<SamplesToKeep>100</SamplesToKeep>
					<TimeWindowExpression><![CDATA[100]]></TimeWindowExpression>
					<FillAreaUnderLine>false</FillAreaUnderLine>
					<LabelFormat>MODEL_TIME_UNITS</LabelFormat>
    			</TimePlot>
				<Group>
					<Id>1718548369983</Id>
					<Name><![CDATA[clock]]></Name>
					<X>320</X><Y>430</Y>
					<Label><X>16.747</X><Y>0</Y></Label>
					<PublicFlag>true</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>false</ShowLabel>
					<DrawMode>SHAPE_DRAW_2D3D</DrawMode>
					<EmbeddedIcon>false</EmbeddedIcon>
					<Z>0</Z>
					<Rotation>0.0</Rotation>

			<Presentation>
				<Oval>
					<Id>1718548369985</Id>
					<Name><![CDATA[face]]></Name>
					<X>0</X><Y>0</Y>
					<Label><X>-50</X><Y>-60</Y></Label>
					<PublicFlag>true</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>false</ShowLabel>
					<DrawMode>SHAPE_DRAW_2D3D</DrawMode>
					<EmbeddedIcon>false</EmbeddedIcon>
					<Z>0</Z>
					<ZHeight>1</ZHeight>
					<LineWidth>1</LineWidth>
					<LineColor>-12156236</LineColor>
					<LineMaterial>null</LineMaterial>
					<LineStyle>SOLID</LineStyle>
					<RadiusX>66.988</RadiusX>
					<RadiusY>40</RadiusY>
					<Rotation>0.0</Rotation>
					<FillColor>-460545</FillColor>
					<FillMaterial>null</FillMaterial>
				</Oval>
				<Text>
					<Id>1718548369987</Id>
					<Name><![CDATA[weekdayText]]></Name>
					<X>0</X><Y>-41.867</Y>
					<Label><X>70</X><Y>0</Y></Label>
					<PublicFlag>true</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>false</ShowLabel>
					<DrawMode>SHAPE_DRAW_2D3D</DrawMode>
					<EmbeddedIcon>false</EmbeddedIcon>
					<Z>2</Z>
					<Rotation>0.0</Rotation>
					<Color>-12156236</Color>
					<ColorCode><![CDATA[getDayOfWeek() == SATURDAY || getDayOfWeek() == SUNDAY ?
	red : steelBlue]]></ColorCode>
					<Text><![CDATA[TUE]]></Text>
					<TextCode><![CDATA[formatDayOfWeek(getDayOfWeek(), false)]]></TextCode>
					<Font>
						<Name>SansSerif</Name>
						<Size>10</Size>
						<Style>0</Style>
					</Font>
					<Alignment>CENTER</Alignment>
				</Text>
				<Text>
					<Id>1718548369989</Id>
					<Name><![CDATA[dateText]]></Name>
					<X>0</X><Y>-25.12</Y>
					<Label><X>70</X><Y>0</Y></Label>
					<PublicFlag>true</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>false</ShowLabel>
					<DrawMode>SHAPE_DRAW_2D3D</DrawMode>
					<EmbeddedIcon>false</EmbeddedIcon>
					<Z>2</Z>
					<ZCode><![CDATA[1.01]]></ZCode>
					<Rotation>0.0</Rotation>
					<Color>-12156236</Color>
					<Text><![CDATA[02 Nov]]></Text>
					<TextCode><![CDATA[String.format("%02d", getDayOfMonth())
 + " " + formatMonth(getMonth(), false)]]></TextCode>
					<Font>
						<Name>SansSerif</Name>
						<Size>10</Size>
						<Style>0</Style>
					</Font>
					<Alignment>CENTER</Alignment>
				</Text>
				<Text>
					<Id>1718548369991</Id>
					<Name><![CDATA[timeText]]></Name>
					<X>0</X><Y>16.747</Y>
					<Label><X>70</X><Y>0</Y></Label>
					<PublicFlag>true</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>false</ShowLabel>
					<DrawMode>SHAPE_DRAW_2D3D</DrawMode>
					<EmbeddedIcon>false</EmbeddedIcon>
					<Z>2</Z>
					<ZCode><![CDATA[1.01]]></ZCode>
					<Rotation>0.0</Rotation>
					<Color>-12156236</Color>
					<Text><![CDATA[18:23]]></Text>
					<TextCode><![CDATA[String.format("%02d:%02d", 
 getHourOfDay(), getMinute())]]></TextCode>
					<Font>
						<Name>SansSerif</Name>
						<Size>10</Size>
						<Style>0</Style>
					</Font>
					<Alignment>CENTER</Alignment>
				</Text>
				<Group>
					<Id>1718548369993</Id>
					<Name><![CDATA[hourMarks]]></Name>
					<X>0</X><Y>0</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>true</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>false</ShowLabel>
					<DrawMode>SHAPE_DRAW_2D3D</DrawMode>
					<ReplicationCode Class="CodeValue">
						<Code><![CDATA[12]]></Code>
					</ReplicationCode>
					<EmbeddedIcon>false</EmbeddedIcon>
					<Z>1</Z>
					<Rotation>0.0</Rotation>
					<RotationCode><![CDATA[( index / 12. ) * 2 * PI]]></RotationCode>

			<Presentation>
				<Oval>
					<Id>1718548369995</Id>
					<Name><![CDATA[oval1]]></Name>
					<X>0</X><Y>-60.289</Y>
					<Label><X>0</X><Y>0</Y></Label>
					<PublicFlag>true</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>false</ShowLabel>
					<DrawMode>SHAPE_DRAW_2D3D</DrawMode>
					<EmbeddedIcon>false</EmbeddedIcon>
					<Z>0</Z>
					<ZHeight>1</ZHeight>
					<LineWidth>1</LineWidth>
					<LineColor/>
					<LineMaterial>null</LineMaterial>
					<LineStyle>SOLID</LineStyle>
					<RadiusX>3.3495</RadiusX>
					<RadiusY>2</RadiusY>
					<Rotation>0.0</Rotation>
					<FillColor>-5192482</FillColor>
					<FillMaterial>null</FillMaterial>
				</Oval>
			</Presentation>

				</Group>
				<Group>
					<Id>1718548369997</Id>
					<Name><![CDATA[minuteGroup]]></Name>
					<X>0</X><Y>0</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>true</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>false</ShowLabel>
					<DrawMode>SHAPE_DRAW_2D3D</DrawMode>
					<EmbeddedIcon>false</EmbeddedIcon>
					<Z>2</Z>
					<Rotation>0.0</Rotation>
					<RotationCode><![CDATA[( getMinute() / 60. ) * 2 * PI]]></RotationCode>

			<Presentation>
				<Polyline>
					<Id>1718548369999</Id>
					<Name><![CDATA[minutes]]></Name>
					<X>-3.349</X><Y>11.723</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>true</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>false</ShowLabel>
					<DrawMode>SHAPE_DRAW_2D3D</DrawMode>
					<EmbeddedIcon>false</EmbeddedIcon>
					<Z>0</Z>
					<ZHeight>1</ZHeight>
					<LineWidth>1</LineWidth>
					<LineColor/>
					<LineMaterial>null</LineMaterial>
					<LineStyle>SOLID</LineStyle>
					<BeginArrowSize>1</BeginArrowSize>
					<BeginArrowStyle>0</BeginArrowStyle>
					<EndArrowSize>1</EndArrowSize>
					<EndArrowStyle>0</EndArrowStyle>
					<FillColor>-16777216</FillColor>
					<FillMaterial>null</FillMaterial>
					<Points>
					   <Point><X>0</X><Y>0</Y><Z>0</Z></Point>
					   <Point><X>3.349</X><Y>-70.337</Y><Z>0</Z></Point>
					   <Point><X>6.699</X><Y>0</Y><Z>0</Z></Point>
					</Points>
					<Closed>false</Closed>
				</Polyline>
			</Presentation>

				</Group>
				<Group>
					<Id>1718548370001</Id>
					<Name><![CDATA[hourGroup]]></Name>
					<X>0</X><Y>0</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>true</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>false</ShowLabel>
					<DrawMode>SHAPE_DRAW_2D3D</DrawMode>
					<EmbeddedIcon>false</EmbeddedIcon>
					<Z>1</Z>
					<Rotation>0.0</Rotation>
					<RotationCode><![CDATA[( ( getHourOfDay() + getMinute() / 60. ) / 12. ) * 2 * PI]]></RotationCode>

			<Presentation>
				<Polyline>
					<Id>1718548370003</Id>
					<Name><![CDATA[hours]]></Name>
					<X>-3.349</X><Y>11.723</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>true</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>false</ShowLabel>
					<DrawMode>SHAPE_DRAW_2D3D</DrawMode>
					<EmbeddedIcon>false</EmbeddedIcon>
					<Z>0</Z>
					<ZHeight>1</ZHeight>
					<LineWidth>1</LineWidth>
					<LineColor/>
					<LineMaterial>null</LineMaterial>
					<LineStyle>SOLID</LineStyle>
					<BeginArrowSize>1</BeginArrowSize>
					<BeginArrowStyle>0</BeginArrowStyle>
					<EndArrowSize>1</EndArrowSize>
					<EndArrowStyle>0</EndArrowStyle>
					<FillColor>-16777216</FillColor>
					<FillMaterial>null</FillMaterial>
					<Points>
					   <Point><X>0</X><Y>0</Y><Z>0</Z></Point>
					   <Point><X>1.675</X><Y>-41.867</Y><Z>0</Z></Point>
					   <Point><X>3.349</X><Y>-46.892</Y><Z>0</Z></Point>
					   <Point><X>5.024</X><Y>-41.867</Y><Z>0</Z></Point>
					   <Point><X>6.699</X><Y>0</Y><Z>0</Z></Point>
					</Points>
					<Closed>false</Closed>
				</Polyline>
			</Presentation>

				</Group>
				<Oval>
					<Id>1718548370005</Id>
					<Name><![CDATA[center]]></Name>
					<X>0</X><Y>0</Y>
					<Label><X>0</X><Y>0</Y></Label>
					<PublicFlag>true</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>false</ShowLabel>
					<DrawMode>SHAPE_DRAW_2D3D</DrawMode>
					<EmbeddedIcon>false</EmbeddedIcon>
					<Z>1</Z>
					<ZHeight>4</ZHeight>
					<LineWidth>1</LineWidth>
					<LineColor/>
					<LineMaterial>null</LineMaterial>
					<LineStyle>SOLID</LineStyle>
					<RadiusX>1.6745</RadiusX>
					<RadiusY>1</RadiusY>
					<Rotation>0.0</Rotation>
					<FillColor>-1</FillColor>
					<FillMaterial>null</FillMaterial>
				</Oval>
			</Presentation>

				</Group>
			</Presentation>

				</Level>
			</Presentation>

		</ActiveObjectClass>
		<!--   =========   Active Object Class   ========  -->
		<ActiveObjectClass>
			<Id>1638821428433</Id>
			<Name><![CDATA[CustomerOrderAgent]]></Name>
			<Generic>false</Generic>
			<GenericParameter>
				<Id>1638821428431</Id>
				<Name><![CDATA[1638821428431]]></Name>
				<GenericParameterValue Class="CodeValue">
					<Code><![CDATA[T extends Agent]]></Code>
				</GenericParameterValue>
				<GenericParameterLabel><![CDATA[Generic parameter:]]></GenericParameterLabel>
			</GenericParameter>
			<FlowChartsUsage>ENTITY</FlowChartsUsage>
			<SamplesToKeep>100</SamplesToKeep>
			<LimitNumberOfArrayElements>false</LimitNumberOfArrayElements>
			<ElementsLimitValue>100</ElementsLimitValue>
			<MakeDefaultViewArea>true</MakeDefaultViewArea>
			<SceneGridColor/>
			<SceneBackgroundColor/>
			<SceneSkybox>null</SceneSkybox>
			<AgentProperties>
				<EnvironmentDefinesInitialLocation>true</EnvironmentDefinesInitialLocation>
				<RotateAnimationTowardsMovement>true</RotateAnimationTowardsMovement>
				<RotateAnimationVertically>false</RotateAnimationVertically>
				<VelocityCode Class="CodeUnitValue">
					<Code><![CDATA[10]]></Code>
					<Unit Class="SpeedUnits"><![CDATA[MPS]]></Unit>
				</VelocityCode>
				<PhysicalLength Class="CodeUnitValue">
					<Code><![CDATA[1]]></Code>
					<Unit Class="LengthUnits"><![CDATA[METER]]></Unit>
				</PhysicalLength>
				<PhysicalWidth Class="CodeUnitValue">
					<Code><![CDATA[1]]></Code>
					<Unit Class="LengthUnits"><![CDATA[METER]]></Unit>
				</PhysicalWidth>
				<PhysicalHeight Class="CodeUnitValue">
					<Code><![CDATA[1]]></Code>
					<Unit Class="LengthUnits"><![CDATA[METER]]></Unit>
				</PhysicalHeight>
			</AgentProperties>
			<EnvironmentProperties>
					<EnableSteps>false</EnableSteps>
					<StepDurationCode Class="CodeUnitValue">
						<Code><![CDATA[1.0]]></Code>
						<Unit Class="TimeUnits"><![CDATA[SECOND]]></Unit>
					</StepDurationCode>
					<SpaceType>CONTINUOUS</SpaceType>
					<WidthCode><![CDATA[500]]></WidthCode>
					<HeightCode><![CDATA[500]]></HeightCode>
					<ZHeightCode><![CDATA[0]]></ZHeightCode>
					<ColumnsCountCode><![CDATA[100]]></ColumnsCountCode>
					<RowsCountCode><![CDATA[100]]></RowsCountCode>
					<NeigborhoodType>MOORE</NeigborhoodType>
					<LayoutType>USER_DEF</LayoutType>
					<NetworkType>USER_DEF</NetworkType>
					<ConnectionsPerAgentCode><![CDATA[2]]></ConnectionsPerAgentCode>
					<ConnectionsRangeCode><![CDATA[50]]></ConnectionsRangeCode>
					<NeighborLinkFractionCode><![CDATA[0.95]]></NeighborLinkFractionCode>
					<MCode><![CDATA[10]]></MCode>
			</EnvironmentProperties>
			<DatasetsCreationProperties>
				<AutoCreate>true</AutoCreate>
					<OccurrenceAtTime>true</OccurrenceAtTime>
					<OccurrenceDate>1638864000000</OccurrenceDate>
					<OccurrenceTime Class="CodeUnitValue">
						<Code><![CDATA[0]]></Code>
						<Unit Class="TimeUnits"><![CDATA[DAY]]></Unit>
					</OccurrenceTime>
					<RecurrenceCode Class="CodeUnitValue">
						<Code><![CDATA[1]]></Code>
						<Unit Class="TimeUnits"><![CDATA[DAY]]></Unit>
					</RecurrenceCode>
			</DatasetsCreationProperties>
			<ScaleRuler>
				<Id>1638821428429</Id>
				<Name><![CDATA[scale]]></Name>
				<X>0</X><Y>-150</Y>
				<PublicFlag>false</PublicFlag>
				<PresentationFlag>false</PresentationFlag>
				<ShowLabel>false</ShowLabel>
				<DrawMode>SHAPE_DRAW_2D3D</DrawMode>
				<Length>100</Length>
				<Rotation>0</Rotation>
				<ScaleType>BASED_ON_LENGTH</ScaleType>
				<ModelLength>10</ModelLength>
				<LengthUnits>METER</LengthUnits>
				<Scale>10</Scale>
				<InheritedFromParentAgentType>true</InheritedFromParentAgentType>
			</ScaleRuler>
			<CurrentLevel>1638821428432</CurrentLevel>
			<ConnectionsId>1638821428428</ConnectionsId>
			<Variables>
				<Variable Class="Parameter">
					<Id>1640609176307</Id>
					<Name><![CDATA[customerOrderFromAgent]]></Name>
					<X>60</X><Y>50</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Properties SaveInSnapshot="true" ModificatorType="STATIC">
						<Type><![CDATA[CustomerOrder]]></Type>
						<UnitType><![CDATA[NONE]]></UnitType>
						<SdArray>false</SdArray>
						<ParameterEditor>
							<Id>1640609176305</Id>
							<EditorContolType>TEXT_BOX</EditorContolType>
							<MinSliderValue><![CDATA[0]]></MinSliderValue>
							<MaxSliderValue><![CDATA[100]]></MaxSliderValue>
							<DelimeterType>NO_DELIMETER</DelimeterType>
						</ParameterEditor>
					</Properties>                 
				</Variable>
			</Variables>
			<AgentLinks>
				<AgentLink>
					<Id>1638821428428</Id>
					<Name><![CDATA[connections]]></Name>
					<X>50</X><Y>-50</Y>
					<Label><X>15</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<HandleReceiveInConnections>false</HandleReceiveInConnections>
					<AgentLinkType>COLLECTION_OF_LINKS</AgentLinkType>
					<AgentLinkBidirectional>true</AgentLinkBidirectional>
					<MessageType><![CDATA[Object]]></MessageType>
					<LineStyle>SOLID</LineStyle>
					<LineWidth>1</LineWidth>
					<LineColor>-16777216</LineColor>
					<LineZOrder>UNDER_AGENTS</LineZOrder>
					<LineArrow>NONE</LineArrow>
					<LineArrowPosition>END</LineArrowPosition>
				</AgentLink>
			</AgentLinks>


			<Presentation>
				<Level>
					<Id>1638821428432</Id>
					<Name><![CDATA[level]]></Name>
					<X>0</X><Y>0</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>true</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>false</ShowLabel>
					<DrawMode>SHAPE_DRAW_2D3D</DrawMode>
					<Z>0</Z>
					<LevelVisibility>DIM_NON_CURRENT</LevelVisibility>


				</Level>
			</Presentation>

		</ActiveObjectClass>
		<!--   =========   Active Object Class   ========  -->
		<ActiveObjectClass>
			<Id>1639832339640</Id>
			<Name><![CDATA[ResourceAgent]]></Name>
			<StartupCode><![CDATA[traceln("---> at resource ...........................................");]]></StartupCode>
			<Generic>false</Generic>
			<GenericParameter>
				<Id>1639832339638</Id>
				<Name><![CDATA[1639832339638]]></Name>
				<GenericParameterValue Class="CodeValue">
					<Code><![CDATA[T extends Agent]]></Code>
				</GenericParameterValue>
				<GenericParameterLabel><![CDATA[Generic parameter:]]></GenericParameterLabel>
			</GenericParameter>
			<FlowChartsUsage>ENTITY</FlowChartsUsage>
			<SamplesToKeep>100</SamplesToKeep>
			<LimitNumberOfArrayElements>false</LimitNumberOfArrayElements>
			<ElementsLimitValue>100</ElementsLimitValue>
			<MakeDefaultViewArea>true</MakeDefaultViewArea>
			<SceneGridColor/>
			<SceneBackgroundColor/>
			<SceneSkybox>null</SceneSkybox>
			<AgentProperties>
				<EnvironmentDefinesInitialLocation>true</EnvironmentDefinesInitialLocation>
				<RotateAnimationTowardsMovement>true</RotateAnimationTowardsMovement>
				<RotateAnimationVertically>false</RotateAnimationVertically>
				<VelocityCode Class="CodeUnitValue">
					<Code><![CDATA[10]]></Code>
					<Unit Class="SpeedUnits"><![CDATA[MPS]]></Unit>
				</VelocityCode>
				<PhysicalLength Class="CodeUnitValue">
					<Code><![CDATA[1]]></Code>
					<Unit Class="LengthUnits"><![CDATA[METER]]></Unit>
				</PhysicalLength>
				<PhysicalWidth Class="CodeUnitValue">
					<Code><![CDATA[1]]></Code>
					<Unit Class="LengthUnits"><![CDATA[METER]]></Unit>
				</PhysicalWidth>
				<PhysicalHeight Class="CodeUnitValue">
					<Code><![CDATA[1]]></Code>
					<Unit Class="LengthUnits"><![CDATA[METER]]></Unit>
				</PhysicalHeight>
			</AgentProperties>
			<EnvironmentProperties>
					<EnableSteps>false</EnableSteps>
					<StepDurationCode Class="CodeUnitValue">
						<Code><![CDATA[1.0]]></Code>
						<Unit Class="TimeUnits"><![CDATA[SECOND]]></Unit>
					</StepDurationCode>
					<SpaceType>CONTINUOUS</SpaceType>
					<WidthCode><![CDATA[500]]></WidthCode>
					<HeightCode><![CDATA[500]]></HeightCode>
					<ZHeightCode><![CDATA[0]]></ZHeightCode>
					<ColumnsCountCode><![CDATA[100]]></ColumnsCountCode>
					<RowsCountCode><![CDATA[100]]></RowsCountCode>
					<NeigborhoodType>MOORE</NeigborhoodType>
					<LayoutType>USER_DEF</LayoutType>
					<NetworkType>USER_DEF</NetworkType>
					<ConnectionsPerAgentCode><![CDATA[2]]></ConnectionsPerAgentCode>
					<ConnectionsRangeCode><![CDATA[50]]></ConnectionsRangeCode>
					<NeighborLinkFractionCode><![CDATA[0.95]]></NeighborLinkFractionCode>
					<MCode><![CDATA[10]]></MCode>
			</EnvironmentProperties>
			<DatasetsCreationProperties>
				<AutoCreate>true</AutoCreate>
					<OccurrenceAtTime>true</OccurrenceAtTime>
					<OccurrenceDate>1639900800000</OccurrenceDate>
					<OccurrenceTime Class="CodeUnitValue">
						<Code><![CDATA[0]]></Code>
						<Unit Class="TimeUnits"><![CDATA[DAY]]></Unit>
					</OccurrenceTime>
					<RecurrenceCode Class="CodeUnitValue">
						<Code><![CDATA[1]]></Code>
						<Unit Class="TimeUnits"><![CDATA[DAY]]></Unit>
					</RecurrenceCode>
			</DatasetsCreationProperties>
			<ScaleRuler>
				<Id>1639832339636</Id>
				<Name><![CDATA[scale]]></Name>
				<X>0</X><Y>-150</Y>
				<PublicFlag>false</PublicFlag>
				<PresentationFlag>false</PresentationFlag>
				<ShowLabel>false</ShowLabel>
				<DrawMode>SHAPE_DRAW_2D3D</DrawMode>
				<Length>100</Length>
				<Rotation>0</Rotation>
				<ScaleType>BASED_ON_LENGTH</ScaleType>
				<ModelLength>10</ModelLength>
				<LengthUnits>METER</LengthUnits>
				<Scale>10</Scale>
				<InheritedFromParentAgentType>true</InheritedFromParentAgentType>
			</ScaleRuler>
			<CurrentLevel>1639832339639</CurrentLevel>
			<ConnectionsId>1639832339635</ConnectionsId>
			<Variables>
				<Variable Class="Parameter">
					<Id>1639986482215</Id>
					<Name><![CDATA[processingTime]]></Name>
					<X>150</X><Y>250</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Properties SaveInSnapshot="true" ModificatorType="STATIC">
						<Type><![CDATA[double]]></Type>
						<UnitType><![CDATA[NONE]]></UnitType>
						<SdArray>false</SdArray>
						<ParameterEditor>
							<Id>1639986482213</Id>
							<EditorContolType>TEXT_BOX</EditorContolType>
							<MinSliderValue><![CDATA[0]]></MinSliderValue>
							<MaxSliderValue><![CDATA[100]]></MaxSliderValue>
							<DelimeterType>NO_DELIMETER</DelimeterType>
						</ParameterEditor>
					</Properties>                 
				</Variable>
				<Variable Class="Parameter">
					<Id>1639986516051</Id>
					<Name><![CDATA[productionOrders]]></Name>
					<X>290</X><Y>250</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Properties SaveInSnapshot="true" ModificatorType="STATIC">
						<Type><![CDATA[List<ProductionOrder>]]></Type>
						<UnitType><![CDATA[NONE]]></UnitType>
						<SdArray>false</SdArray>
						<DefaultValue Class="CodeValue">
							<Code><![CDATA[new ArrayList()]]></Code>
						</DefaultValue>
						<ParameterEditor>
							<Id>1639986516049</Id>
							<EditorContolType>TEXT_BOX</EditorContolType>
							<MinSliderValue><![CDATA[0]]></MinSliderValue>
							<MaxSliderValue><![CDATA[100]]></MaxSliderValue>
							<DelimeterType>NO_DELIMETER</DelimeterType>
						</ParameterEditor>
					</Properties>                 
				</Variable>
			</Variables>
			<Ports>
				<Port>
					<Id>1640180148115</Id>
					<Name><![CDATA[PortInput]]></Name>
					<X>190</X><Y>100</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>true</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<IncomingMessageType><![CDATA[Object]]></IncomingMessageType>
					<OutgoingMessageType><![CDATA[Object]]></OutgoingMessageType>
					<CustomPort><![CDATA[false]]></CustomPort>
				</Port>
				<Port>
					<Id>1640180455085</Id>
					<Name><![CDATA[portOutpt]]></Name>
					<X>540</X><Y>100</Y>
					<Label><X>20</X><Y>0</Y></Label>
					<PublicFlag>true</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<IncomingMessageType><![CDATA[Object]]></IncomingMessageType>
					<OutgoingMessageType><![CDATA[Object]]></OutgoingMessageType>
					<CustomPort><![CDATA[false]]></CustomPort>
				</Port>
			</Ports>
			<Connectors>
				<Connector>
					<Id>1639985130308</Id>
					<Name><![CDATA[connector5]]></Name>
					<X>230</X><Y>200</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>false</ShowLabel>
					<SourceEmbeddedObjectReference>
						<PackageName><![CDATA[simopt]]></PackageName>
						<ClassName><![CDATA[ResourceAgent]]></ClassName>
						<ItemName><![CDATA[prodOrders]]></ItemName>
					</SourceEmbeddedObjectReference>
					<SourceConnectableItemReference>
						<PackageName><![CDATA[com.anylogic.libraries.processmodeling]]></PackageName>
						<ClassName><![CDATA[Queue]]></ClassName>
						<ItemName><![CDATA[out]]></ItemName>
					</SourceConnectableItemReference>
					<TargetEmbeddedObjectReference>
						<PackageName><![CDATA[simopt]]></PackageName>
						<ClassName><![CDATA[ResourceAgent]]></ClassName>
						<ItemName><![CDATA[restrictedAreaStart]]></ItemName>
					</TargetEmbeddedObjectReference>
					<TargetConnectableItemReference>
						<PackageName><![CDATA[com.anylogic.libraries.processmodeling]]></PackageName>
						<ClassName><![CDATA[RestrictedAreaStart]]></ClassName>
						<ItemName><![CDATA[in]]></ItemName>
					</TargetConnectableItemReference>
					<Points>
						<Point><X>0</X><Y>0</Y></Point>
						<Point><X>80</X><Y>0</Y></Point>
					</Points>
				</Connector>
				<Connector>
					<Id>1639985130312</Id>
					<Name><![CDATA[connector7]]></Name>
					<X>420</X><Y>200</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>false</ShowLabel>
					<SourceEmbeddedObjectReference>
						<PackageName><![CDATA[simopt]]></PackageName>
						<ClassName><![CDATA[ResourceAgent]]></ClassName>
						<ItemName><![CDATA[process]]></ItemName>
					</SourceEmbeddedObjectReference>
					<SourceConnectableItemReference>
						<PackageName><![CDATA[com.anylogic.libraries.processmodeling]]></PackageName>
						<ClassName><![CDATA[Delay]]></ClassName>
						<ItemName><![CDATA[in]]></ItemName>
					</SourceConnectableItemReference>
					<TargetEmbeddedObjectReference>
						<PackageName><![CDATA[simopt]]></PackageName>
						<ClassName><![CDATA[ResourceAgent]]></ClassName>
						<ItemName><![CDATA[restrictedAreaStart]]></ItemName>
					</TargetEmbeddedObjectReference>
					<TargetConnectableItemReference>
						<PackageName><![CDATA[com.anylogic.libraries.processmodeling]]></PackageName>
						<ClassName><![CDATA[RestrictedAreaStart]]></ClassName>
						<ItemName><![CDATA[out]]></ItemName>
					</TargetConnectableItemReference>
					<Points>
						<Point><X>0</X><Y>0</Y></Point>
						<Point><X>-90</X><Y>0</Y></Point>
					</Points>
				</Connector>
				<Connector>
					<Id>1639985130314</Id>
					<Name><![CDATA[connector8]]></Name>
					<X>520</X><Y>200</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>false</ShowLabel>
					<SourceEmbeddedObjectReference>
						<PackageName><![CDATA[simopt]]></PackageName>
						<ClassName><![CDATA[ResourceAgent]]></ClassName>
						<ItemName><![CDATA[restrictedAreaEnd]]></ItemName>
					</SourceEmbeddedObjectReference>
					<SourceConnectableItemReference>
						<PackageName><![CDATA[com.anylogic.libraries.processmodeling]]></PackageName>
						<ClassName><![CDATA[RestrictedAreaEnd]]></ClassName>
						<ItemName><![CDATA[in]]></ItemName>
					</SourceConnectableItemReference>
					<TargetEmbeddedObjectReference>
						<PackageName><![CDATA[simopt]]></PackageName>
						<ClassName><![CDATA[ResourceAgent]]></ClassName>
						<ItemName><![CDATA[process]]></ItemName>
					</TargetEmbeddedObjectReference>
					<TargetConnectableItemReference>
						<PackageName><![CDATA[com.anylogic.libraries.processmodeling]]></PackageName>
						<ClassName><![CDATA[Delay]]></ClassName>
						<ItemName><![CDATA[out]]></ItemName>
					</TargetConnectableItemReference>
					<Points>
						<Point><X>0</X><Y>0</Y></Point>
						<Point><X>-60</X><Y>0</Y></Point>
					</Points>
				</Connector>
				<Connector>
					<Id>1640180185912</Id>
					<Name><![CDATA[connector]]></Name>
					<X>190</X><Y>100</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>false</ShowLabel>
					<SourceId>1640180148115</SourceId>
					<TargetEmbeddedObjectReference>
						<PackageName><![CDATA[simopt]]></PackageName>
						<ClassName><![CDATA[ResourceAgent]]></ClassName>
						<ItemName><![CDATA[prodOrders]]></ItemName>
					</TargetEmbeddedObjectReference>
					<TargetConnectableItemReference>
						<PackageName><![CDATA[com.anylogic.libraries.processmodeling]]></PackageName>
						<ClassName><![CDATA[Queue]]></ClassName>
						<ItemName><![CDATA[in]]></ItemName>
					</TargetConnectableItemReference>
					<Points>
						<Point><X>0</X><Y>0</Y></Point>
						<Point><X>0</X><Y>100</Y></Point>
					</Points>
				</Connector>
				<Connector>
					<Id>1640180470346</Id>
					<Name><![CDATA[connector1]]></Name>
					<X>540</X><Y>100</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>false</ShowLabel>
					<SourceId>1640180455085</SourceId>
					<TargetEmbeddedObjectReference>
						<PackageName><![CDATA[simopt]]></PackageName>
						<ClassName><![CDATA[ResourceAgent]]></ClassName>
						<ItemName><![CDATA[restrictedAreaEnd]]></ItemName>
					</TargetEmbeddedObjectReference>
					<TargetConnectableItemReference>
						<PackageName><![CDATA[com.anylogic.libraries.processmodeling]]></PackageName>
						<ClassName><![CDATA[RestrictedAreaEnd]]></ClassName>
						<ItemName><![CDATA[out]]></ItemName>
					</TargetConnectableItemReference>
					<Points>
						<Point><X>0</X><Y>0</Y></Point>
						<Point><X>0</X><Y>100</Y></Point>
					</Points>
				</Connector>
			</Connectors>
			<AgentLinks>
				<AgentLink>
					<Id>1639832339635</Id>
					<Name><![CDATA[connections]]></Name>
					<X>50</X><Y>-50</Y>
					<Label><X>15</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<HandleReceiveInConnections>false</HandleReceiveInConnections>
					<AgentLinkType>COLLECTION_OF_LINKS</AgentLinkType>
					<AgentLinkBidirectional>true</AgentLinkBidirectional>
					<MessageType><![CDATA[Object]]></MessageType>
					<LineStyle>SOLID</LineStyle>
					<LineWidth>1</LineWidth>
					<LineColor>-16777216</LineColor>
					<LineZOrder>UNDER_AGENTS</LineZOrder>
					<LineArrow>NONE</LineArrow>
					<LineArrowPosition>END</LineArrowPosition>
				</AgentLink>
			</AgentLinks>

			<EmbeddedObjects>
				<EmbeddedObject>
					<Id>1639985130239</Id>
					<Name><![CDATA[restrictedAreaStart]]></Name>
					<X>310</X><Y>180</Y>
					<Label><X>-65</X><Y>-20</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<ActiveObjectClass>
						<PackageName><![CDATA[com.anylogic.libraries.processmodeling]]></PackageName>
						<ClassName><![CDATA[RestrictedAreaStart]]></ClassName>
					</ActiveObjectClass>
					<GenericParameterSubstitute>
						<GenericParameterSubstituteReference>
							<PackageName><![CDATA[com.anylogic.libraries.processmodeling]]></PackageName>
							<ClassName><![CDATA[RestrictedAreaStart]]></ClassName>
							<ItemName><![CDATA[1412336243130]]></ItemName>
						</GenericParameterSubstituteReference>
					</GenericParameterSubstitute>
					<Parameters>
						<Parameter>
							<Name><![CDATA[capacity]]></Name>
						</Parameter>
						<Parameter>
							<Name><![CDATA[onEnter]]></Name>
							<Value Class="CodeValue">
								<Code><![CDATA[traceln(time());]]></Code>
							</Value>
						</Parameter>
					</Parameters>
					<ReplicationFlag>false</ReplicationFlag>
					<Replication Class="CodeValue">
						<Code><![CDATA[100]]></Code>
					</Replication>
					<CollectionType>ARRAY_LIST_BASED</CollectionType>
					<InitialLocationType>XYZ</InitialLocationType>
					<XCode Class="CodeValue">
						<Code><![CDATA[0]]></Code>
					</XCode>
					<YCode Class="CodeValue">
						<Code><![CDATA[0]]></Code>
					</YCode>
					<ZCode Class="CodeValue">
						<Code><![CDATA[0]]></Code>
					</ZCode>
					<ColumnCode Class="CodeValue">
						<Code><![CDATA[0]]></Code>
					</ColumnCode>
					<RowCode Class="CodeValue">
						<Code><![CDATA[0]]></Code>
					</RowCode>
					<LocationNameCode Class="CodeValue">
						<Code><![CDATA[""]]></Code>
					</LocationNameCode>
					<InitializationType>SPECIFIED_NUMBER</InitializationType>
					<InitializationDatabaseTableQuery>
						<TableReference>
						</TableReference>
					</InitializationDatabaseTableQuery>
					<InitializationDatabaseType>ONE_AGENT_PER_DATABASE_RECORD</InitializationDatabaseType>
					<QuantityColumn>
					</QuantityColumn>
				</EmbeddedObject>
				<EmbeddedObject>
					<Id>1639985130262</Id>
					<Name><![CDATA[prodOrders]]></Name>
					<X>190</X><Y>180</Y>
					<Label><X>-5</X><Y>-15</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<ActiveObjectClass>
						<PackageName><![CDATA[com.anylogic.libraries.processmodeling]]></PackageName>
						<ClassName><![CDATA[Queue]]></ClassName>
					</ActiveObjectClass>
					<GenericParameterSubstitute>
						<GenericParameterSubstituteReference>
							<PackageName><![CDATA[com.anylogic.libraries.processmodeling]]></PackageName>
							<ClassName><![CDATA[Queue]]></ClassName>
							<ItemName><![CDATA[1412336242932]]></ItemName>
						</GenericParameterSubstituteReference>
						<GenericParameterSubstituteValue Class="CodeValue">
							<Code><![CDATA[CustomerOrderAgent]]></Code>
						</GenericParameterSubstituteValue>
					</GenericParameterSubstitute>
					<Parameters>
						<Parameter>
							<Name><![CDATA[capacity]]></Name>
						</Parameter>
						<Parameter>
							<Name><![CDATA[maximumCapacity]]></Name>
						</Parameter>
						<Parameter>
							<Name><![CDATA[entityLocation]]></Name>
						</Parameter>
						<Parameter>
							<Name><![CDATA[queuing]]></Name>
						</Parameter>
						<Parameter>
							<Name><![CDATA[priority]]></Name>
						</Parameter>
						<Parameter>
							<Name><![CDATA[comparison]]></Name>
						</Parameter>
						<Parameter>
							<Name><![CDATA[enableTimeout]]></Name>
						</Parameter>
						<Parameter>
							<Name><![CDATA[timeout]]></Name>
						</Parameter>
						<Parameter>
							<Name><![CDATA[enablePreemption]]></Name>
						</Parameter>
						<Parameter>
							<Name><![CDATA[restoreEntityLocationOnExit]]></Name>
						</Parameter>
						<Parameter>
							<Name><![CDATA[forceStatisticsCollection]]></Name>
						</Parameter>
						<Parameter>
							<Name><![CDATA[onEnter]]></Name>
							<Value Class="CodeValue">
								<Code><![CDATA[//traceln("---> at resource ...........................................");]]></Code>
							</Value>
						</Parameter>
						<Parameter>
							<Name><![CDATA[onAtExit]]></Name>
						</Parameter>
						<Parameter>
							<Name><![CDATA[onExit]]></Name>
						</Parameter>
						<Parameter>
							<Name><![CDATA[onExitTimeout]]></Name>
						</Parameter>
						<Parameter>
							<Name><![CDATA[onExitPreempted]]></Name>
						</Parameter>
						<Parameter>
							<Name><![CDATA[onRemove]]></Name>
						</Parameter>
					</Parameters>
					<ReplicationFlag>true</ReplicationFlag>
					<Replication Class="CodeValue">
						<Code><![CDATA[100]]></Code>
					</Replication>
					<CollectionType>ARRAY_LIST_BASED</CollectionType>
					<InitialLocationType>XYZ</InitialLocationType>
					<XCode Class="CodeValue">
						<Code><![CDATA[0]]></Code>
					</XCode>
					<YCode Class="CodeValue">
						<Code><![CDATA[0]]></Code>
					</YCode>
					<ZCode Class="CodeValue">
						<Code><![CDATA[0]]></Code>
					</ZCode>
					<ColumnCode Class="CodeValue">
						<Code><![CDATA[0]]></Code>
					</ColumnCode>
					<RowCode Class="CodeValue">
						<Code><![CDATA[0]]></Code>
					</RowCode>
					<LocationNameCode Class="CodeValue">
						<Code><![CDATA[""]]></Code>
					</LocationNameCode>
					<InitializationType>SPECIFIED_NUMBER</InitializationType>
					<InitializationDatabaseTableQuery>
						<TableReference>
						</TableReference>
					</InitializationDatabaseTableQuery>
					<InitializationDatabaseType>ONE_AGENT_PER_DATABASE_RECORD</InitializationDatabaseType>
					<QuantityColumn>
					</QuantityColumn>
				</EmbeddedObject>
				<EmbeddedObject>
					<Id>1639985130280</Id>
					<Name><![CDATA[process]]></Name>
					<X>420</X><Y>180</Y>
					<Label><X>-5</X><Y>-15</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<ActiveObjectClass>
						<PackageName><![CDATA[com.anylogic.libraries.processmodeling]]></PackageName>
						<ClassName><![CDATA[Delay]]></ClassName>
					</ActiveObjectClass>
					<GenericParameterSubstitute>
						<GenericParameterSubstituteReference>
							<PackageName><![CDATA[com.anylogic.libraries.processmodeling]]></PackageName>
							<ClassName><![CDATA[Delay]]></ClassName>
							<ItemName><![CDATA[1412336242930]]></ItemName>
						</GenericParameterSubstituteReference>
					</GenericParameterSubstitute>
					<Parameters>
						<Parameter>
							<Name><![CDATA[type]]></Name>
						</Parameter>
						<Parameter>
							<Name><![CDATA[delayTime]]></Name>
						</Parameter>
						<Parameter>
							<Name><![CDATA[capacity]]></Name>
						</Parameter>
						<Parameter>
							<Name><![CDATA[maximumCapacity]]></Name>
						</Parameter>
						<Parameter>
							<Name><![CDATA[entityLocation]]></Name>
						</Parameter>
						<Parameter>
							<Name><![CDATA[pushProtocol]]></Name>
						</Parameter>
						<Parameter>
							<Name><![CDATA[restoreEntityLocationOnExit]]></Name>
						</Parameter>
						<Parameter>
							<Name><![CDATA[forceStatisticsCollection]]></Name>
						</Parameter>
						<Parameter>
							<Name><![CDATA[onEnter]]></Name>
						</Parameter>
						<Parameter>
							<Name><![CDATA[onAtExit]]></Name>
						</Parameter>
						<Parameter>
							<Name><![CDATA[onExit]]></Name>
						</Parameter>
						<Parameter>
							<Name><![CDATA[onRemove]]></Name>
						</Parameter>
					</Parameters>
					<ReplicationFlag>false</ReplicationFlag>
					<Replication Class="CodeValue">
						<Code><![CDATA[100]]></Code>
					</Replication>
					<CollectionType>ARRAY_LIST_BASED</CollectionType>
					<InitialLocationType>XYZ</InitialLocationType>
					<XCode Class="CodeValue">
						<Code><![CDATA[0]]></Code>
					</XCode>
					<YCode Class="CodeValue">
						<Code><![CDATA[0]]></Code>
					</YCode>
					<ZCode Class="CodeValue">
						<Code><![CDATA[0]]></Code>
					</ZCode>
					<ColumnCode Class="CodeValue">
						<Code><![CDATA[0]]></Code>
					</ColumnCode>
					<RowCode Class="CodeValue">
						<Code><![CDATA[0]]></Code>
					</RowCode>
					<LocationNameCode Class="CodeValue">
						<Code><![CDATA[""]]></Code>
					</LocationNameCode>
					<InitializationType>SPECIFIED_NUMBER</InitializationType>
					<InitializationDatabaseTableQuery>
						<TableReference>
						</TableReference>
					</InitializationDatabaseTableQuery>
					<InitializationDatabaseType>ONE_AGENT_PER_DATABASE_RECORD</InitializationDatabaseType>
					<QuantityColumn>
					</QuantityColumn>
				</EmbeddedObject>
				<EmbeddedObject>
					<Id>1639985130289</Id>
					<Name><![CDATA[restrictedAreaEnd]]></Name>
					<X>520</X><Y>180</Y>
					<Label><X>-65</X><Y>-20</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<ActiveObjectClass>
						<PackageName><![CDATA[com.anylogic.libraries.processmodeling]]></PackageName>
						<ClassName><![CDATA[RestrictedAreaEnd]]></ClassName>
					</ActiveObjectClass>
					<GenericParameterSubstitute>
						<GenericParameterSubstituteReference>
							<PackageName><![CDATA[com.anylogic.libraries.processmodeling]]></PackageName>
							<ClassName><![CDATA[RestrictedAreaEnd]]></ClassName>
							<ItemName><![CDATA[1412336243129]]></ItemName>
						</GenericParameterSubstituteReference>
					</GenericParameterSubstitute>
					<Parameters>
						<Parameter>
							<Name><![CDATA[restrictedAreaStart]]></Name>
							<Value Class="CodeValue">
								<Code><![CDATA[restrictedAreaStart]]></Code>
							</Value>
						</Parameter>
						<Parameter>
							<Name><![CDATA[onEnter]]></Name>
						</Parameter>
					</Parameters>
					<ReplicationFlag>false</ReplicationFlag>
					<Replication Class="CodeValue">
						<Code><![CDATA[100]]></Code>
					</Replication>
					<CollectionType>ARRAY_LIST_BASED</CollectionType>
					<InitialLocationType>XYZ</InitialLocationType>
					<XCode Class="CodeValue">
						<Code><![CDATA[0]]></Code>
					</XCode>
					<YCode Class="CodeValue">
						<Code><![CDATA[0]]></Code>
					</YCode>
					<ZCode Class="CodeValue">
						<Code><![CDATA[0]]></Code>
					</ZCode>
					<ColumnCode Class="CodeValue">
						<Code><![CDATA[0]]></Code>
					</ColumnCode>
					<RowCode Class="CodeValue">
						<Code><![CDATA[0]]></Code>
					</RowCode>
					<LocationNameCode Class="CodeValue">
						<Code><![CDATA[""]]></Code>
					</LocationNameCode>
					<InitializationType>SPECIFIED_NUMBER</InitializationType>
					<InitializationDatabaseTableQuery>
						<TableReference>
						</TableReference>
					</InitializationDatabaseTableQuery>
					<InitializationDatabaseType>ONE_AGENT_PER_DATABASE_RECORD</InitializationDatabaseType>
					<QuantityColumn>
					</QuantityColumn>
				</EmbeddedObject>
			</EmbeddedObjects>

			<Presentation>
				<Level>
					<Id>1639832339639</Id>
					<Name><![CDATA[level]]></Name>
					<X>0</X><Y>0</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>true</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>false</ShowLabel>
					<DrawMode>SHAPE_DRAW_2D3D</DrawMode>
					<Z>0</Z>
					<LevelVisibility>DIM_NON_CURRENT</LevelVisibility>

			<Presentation>
				<Rectangle>
					<Id>1640179912279</Id>
					<Name><![CDATA[rectangle]]></Name>
					<X>190</X><Y>40</Y>
					<Label><X>10</X><Y>10</Y></Label>
					<PublicFlag>true</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>false</ShowLabel>
					<DrawMode>SHAPE_DRAW_2D3D</DrawMode>
					<EmbeddedIcon>false</EmbeddedIcon>
					<Z>0</Z>
					<ZHeight>10</ZHeight>
					<LineWidth>1</LineWidth>
					<LineColor>-16777216</LineColor>
					<LineMaterial>null</LineMaterial>
					<LineStyle>SOLID</LineStyle>
					<Width>350</Width>
					<Height>60</Height>
					<Rotation>0.0</Rotation>
					<FillColor>-1644806</FillColor>
					<FillMaterial>null</FillMaterial>
				</Rectangle>
			</Presentation>

				</Level>
			</Presentation>

		</ActiveObjectClass>
		<!--   =========   Active Object Class   ========  -->
		<ActiveObjectClass>
			<Id>1640202599506</Id>
			<Name><![CDATA[ProductionOrderAgent]]></Name>
			<Generic>false</Generic>
			<GenericParameter>
				<Id>1640202599504</Id>
				<Name><![CDATA[1640202599504]]></Name>
				<GenericParameterValue Class="CodeValue">
					<Code><![CDATA[T extends Agent]]></Code>
				</GenericParameterValue>
				<GenericParameterLabel><![CDATA[Generic parameter:]]></GenericParameterLabel>
			</GenericParameter>
			<FlowChartsUsage>ENTITY</FlowChartsUsage>
			<SamplesToKeep>100</SamplesToKeep>
			<LimitNumberOfArrayElements>false</LimitNumberOfArrayElements>
			<ElementsLimitValue>100</ElementsLimitValue>
			<MakeDefaultViewArea>true</MakeDefaultViewArea>
			<SceneGridColor/>
			<SceneBackgroundColor/>
			<SceneSkybox>null</SceneSkybox>
			<AgentProperties>
				<EnvironmentDefinesInitialLocation>true</EnvironmentDefinesInitialLocation>
				<RotateAnimationTowardsMovement>true</RotateAnimationTowardsMovement>
				<RotateAnimationVertically>false</RotateAnimationVertically>
				<VelocityCode Class="CodeUnitValue">
					<Code><![CDATA[10]]></Code>
					<Unit Class="SpeedUnits"><![CDATA[MPS]]></Unit>
				</VelocityCode>
				<PhysicalLength Class="CodeUnitValue">
					<Code><![CDATA[1]]></Code>
					<Unit Class="LengthUnits"><![CDATA[METER]]></Unit>
				</PhysicalLength>
				<PhysicalWidth Class="CodeUnitValue">
					<Code><![CDATA[1]]></Code>
					<Unit Class="LengthUnits"><![CDATA[METER]]></Unit>
				</PhysicalWidth>
				<PhysicalHeight Class="CodeUnitValue">
					<Code><![CDATA[1]]></Code>
					<Unit Class="LengthUnits"><![CDATA[METER]]></Unit>
				</PhysicalHeight>
			</AgentProperties>
			<EnvironmentProperties>
					<EnableSteps>false</EnableSteps>
					<StepDurationCode Class="CodeUnitValue">
						<Code><![CDATA[1.0]]></Code>
						<Unit Class="TimeUnits"><![CDATA[SECOND]]></Unit>
					</StepDurationCode>
					<SpaceType>CONTINUOUS</SpaceType>
					<WidthCode><![CDATA[500]]></WidthCode>
					<HeightCode><![CDATA[500]]></HeightCode>
					<ZHeightCode><![CDATA[0]]></ZHeightCode>
					<ColumnsCountCode><![CDATA[100]]></ColumnsCountCode>
					<RowsCountCode><![CDATA[100]]></RowsCountCode>
					<NeigborhoodType>MOORE</NeigborhoodType>
					<LayoutType>USER_DEF</LayoutType>
					<NetworkType>USER_DEF</NetworkType>
					<ConnectionsPerAgentCode><![CDATA[2]]></ConnectionsPerAgentCode>
					<ConnectionsRangeCode><![CDATA[50]]></ConnectionsRangeCode>
					<NeighborLinkFractionCode><![CDATA[0.95]]></NeighborLinkFractionCode>
					<MCode><![CDATA[10]]></MCode>
			</EnvironmentProperties>
			<DatasetsCreationProperties>
				<AutoCreate>true</AutoCreate>
					<OccurrenceAtTime>true</OccurrenceAtTime>
					<OccurrenceDate>1640246400000</OccurrenceDate>
					<OccurrenceTime Class="CodeUnitValue">
						<Code><![CDATA[0]]></Code>
						<Unit Class="TimeUnits"><![CDATA[DAY]]></Unit>
					</OccurrenceTime>
					<RecurrenceCode Class="CodeUnitValue">
						<Code><![CDATA[1]]></Code>
						<Unit Class="TimeUnits"><![CDATA[DAY]]></Unit>
					</RecurrenceCode>
			</DatasetsCreationProperties>
			<ScaleRuler>
				<Id>1640202599502</Id>
				<Name><![CDATA[scale]]></Name>
				<X>0</X><Y>-150</Y>
				<PublicFlag>false</PublicFlag>
				<PresentationFlag>false</PresentationFlag>
				<ShowLabel>false</ShowLabel>
				<DrawMode>SHAPE_DRAW_2D3D</DrawMode>
				<Length>100</Length>
				<Rotation>0</Rotation>
				<ScaleType>BASED_ON_LENGTH</ScaleType>
				<ModelLength>10</ModelLength>
				<LengthUnits>METER</LengthUnits>
				<Scale>10</Scale>
				<InheritedFromParentAgentType>true</InheritedFromParentAgentType>
			</ScaleRuler>
			<CurrentLevel>1640202599505</CurrentLevel>
			<ConnectionsId>1640202599501</ConnectionsId>
			<Variables>
				<Variable Class="Parameter">
					<Id>1640203310138</Id>
					<Name><![CDATA[prodOrderFromAgent]]></Name>
					<X>80</X><Y>90</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Properties SaveInSnapshot="true" ModificatorType="STATIC">
						<Type><![CDATA[ProductionOrder]]></Type>
						<UnitType><![CDATA[NONE]]></UnitType>
						<SdArray>false</SdArray>
						<ParameterEditor>
							<Id>1640203310136</Id>
							<EditorContolType>TEXT_BOX</EditorContolType>
							<MinSliderValue><![CDATA[0]]></MinSliderValue>
							<MaxSliderValue><![CDATA[100]]></MaxSliderValue>
							<DelimeterType>NO_DELIMETER</DelimeterType>
						</ParameterEditor>
					</Properties>                 
				</Variable>
			</Variables>
			<Functions>
				<Function AccessType="public" StaticFunction="false">
					<ReturnModificator>RETURNS_VALUE</ReturnModificator>
					<ReturnType><![CDATA[String]]></ReturnType>
					<Id>1644910912186</Id>
					<Name><![CDATA[toString]]></Name>
					<X>-100</X><Y>50</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Body><![CDATA[return
	"prodOrderFromAgent = " + prodOrderFromAgent;]]></Body>
				</Function>
			</Functions>
			<AgentLinks>
				<AgentLink>
					<Id>1640202599501</Id>
					<Name><![CDATA[connections]]></Name>
					<X>50</X><Y>-50</Y>
					<Label><X>15</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<HandleReceiveInConnections>false</HandleReceiveInConnections>
					<AgentLinkType>COLLECTION_OF_LINKS</AgentLinkType>
					<AgentLinkBidirectional>true</AgentLinkBidirectional>
					<MessageType><![CDATA[Object]]></MessageType>
					<LineStyle>SOLID</LineStyle>
					<LineWidth>1</LineWidth>
					<LineColor>-16777216</LineColor>
					<LineZOrder>UNDER_AGENTS</LineZOrder>
					<LineArrow>NONE</LineArrow>
					<LineArrowPosition>END</LineArrowPosition>
				</AgentLink>
			</AgentLinks>


			<Presentation>
				<Level>
					<Id>1640202599505</Id>
					<Name><![CDATA[level]]></Name>
					<X>0</X><Y>0</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>true</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>false</ShowLabel>
					<DrawMode>SHAPE_DRAW_2D3D</DrawMode>
					<Z>0</Z>
					<LevelVisibility>DIM_NON_CURRENT</LevelVisibility>


				</Level>
			</Presentation>

		</ActiveObjectClass>
		<!--   =========   Active Object Class   ========  -->
		<ActiveObjectClass>
			<Id>1643198210443</Id>
			<Name><![CDATA[MachineAgent]]></Name>
			<Import><![CDATA[import java.util.stream.*;
import org.eclipse.jetty.util.thread.strategy.ProduceConsume;]]></Import>
			<Generic>false</Generic>
			<GenericParameter>
				<Id>1643198210441</Id>
				<Name><![CDATA[1643198210441]]></Name>
				<GenericParameterValue Class="CodeValue">
					<Code><![CDATA[T extends Agent]]></Code>
				</GenericParameterValue>
				<GenericParameterLabel><![CDATA[Generic parameter:]]></GenericParameterLabel>
			</GenericParameter>
			<FlowChartsUsage>ENTITY</FlowChartsUsage>
			<SamplesToKeep>100</SamplesToKeep>
			<LimitNumberOfArrayElements>false</LimitNumberOfArrayElements>
			<ElementsLimitValue>100</ElementsLimitValue>
			<MakeDefaultViewArea>true</MakeDefaultViewArea>
			<SceneGridColor/>
			<SceneBackgroundColor/>
			<SceneSkybox>null</SceneSkybox>
			<AgentProperties>
				<EnvironmentDefinesInitialLocation>true</EnvironmentDefinesInitialLocation>
				<RotateAnimationTowardsMovement>true</RotateAnimationTowardsMovement>
				<RotateAnimationVertically>false</RotateAnimationVertically>
				<VelocityCode Class="CodeUnitValue">
					<Code><![CDATA[10]]></Code>
					<Unit Class="SpeedUnits"><![CDATA[MPS]]></Unit>
				</VelocityCode>
				<PhysicalLength Class="CodeUnitValue">
					<Code><![CDATA[1]]></Code>
					<Unit Class="LengthUnits"><![CDATA[METER]]></Unit>
				</PhysicalLength>
				<PhysicalWidth Class="CodeUnitValue">
					<Code><![CDATA[1]]></Code>
					<Unit Class="LengthUnits"><![CDATA[METER]]></Unit>
				</PhysicalWidth>
				<PhysicalHeight Class="CodeUnitValue">
					<Code><![CDATA[1]]></Code>
					<Unit Class="LengthUnits"><![CDATA[METER]]></Unit>
				</PhysicalHeight>
			</AgentProperties>
			<EnvironmentProperties>
					<EnableSteps>false</EnableSteps>
					<StepDurationCode Class="CodeUnitValue">
						<Code><![CDATA[1.0]]></Code>
						<Unit Class="TimeUnits"><![CDATA[SECOND]]></Unit>
					</StepDurationCode>
					<SpaceType>CONTINUOUS</SpaceType>
					<WidthCode><![CDATA[500]]></WidthCode>
					<HeightCode><![CDATA[500]]></HeightCode>
					<ZHeightCode><![CDATA[0]]></ZHeightCode>
					<ColumnsCountCode><![CDATA[100]]></ColumnsCountCode>
					<RowsCountCode><![CDATA[100]]></RowsCountCode>
					<NeigborhoodType>MOORE</NeigborhoodType>
					<LayoutType>USER_DEF</LayoutType>
					<NetworkType>USER_DEF</NetworkType>
					<ConnectionsPerAgentCode><![CDATA[2]]></ConnectionsPerAgentCode>
					<ConnectionsRangeCode><![CDATA[50]]></ConnectionsRangeCode>
					<NeighborLinkFractionCode><![CDATA[0.95]]></NeighborLinkFractionCode>
					<MCode><![CDATA[10]]></MCode>
			</EnvironmentProperties>
			<DatasetsCreationProperties>
				<AutoCreate>true</AutoCreate>
					<OccurrenceAtTime>true</OccurrenceAtTime>
					<OccurrenceDate>1643270400000</OccurrenceDate>
					<OccurrenceTime Class="CodeUnitValue">
						<Code><![CDATA[0]]></Code>
						<Unit Class="TimeUnits"><![CDATA[DAY]]></Unit>
					</OccurrenceTime>
					<RecurrenceCode Class="CodeUnitValue">
						<Code><![CDATA[1]]></Code>
						<Unit Class="TimeUnits"><![CDATA[DAY]]></Unit>
					</RecurrenceCode>
			</DatasetsCreationProperties>
			<ScaleRuler>
				<Id>1643198210439</Id>
				<Name><![CDATA[scale]]></Name>
				<X>0</X><Y>-150</Y>
				<PublicFlag>false</PublicFlag>
				<PresentationFlag>false</PresentationFlag>
				<ShowLabel>false</ShowLabel>
				<DrawMode>SHAPE_DRAW_2D3D</DrawMode>
				<Length>100</Length>
				<Rotation>0</Rotation>
				<ScaleType>BASED_ON_LENGTH</ScaleType>
				<ModelLength>10</ModelLength>
				<LengthUnits>METER</LengthUnits>
				<Scale>10</Scale>
				<InheritedFromParentAgentType>true</InheritedFromParentAgentType>
			</ScaleRuler>
			<CurrentLevel>1643198210442</CurrentLevel>
			<ConnectionsId>1643198210438</ConnectionsId>
			<Variables>
				<Variable Class="PlainVariable">
					<Id>1643710194228</Id>
					<Name><![CDATA[RoutingTime]]></Name>
					<X>460</X><Y>110</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Properties SaveInSnapshot="true" Constant="false" AccessType="public" StaticVariable="false">
						<Type><![CDATA[RoutingTimes]]></Type>        
						<InitialValue Class="CodeValue">
							<Code><![CDATA[new RoutingTimes()]]></Code>
						</InitialValue>
					</Properties>
				</Variable>
				<Variable Class="PlainVariable">
					<Id>1655193189068</Id>
					<Name><![CDATA[varJSIperMachine]]></Name>
					<X>90</X><Y>150</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Properties SaveInSnapshot="true" Constant="false" AccessType="public" StaticVariable="false">
						<Type><![CDATA[double]]></Type>        
					</Properties>
				</Variable>
				<Variable Class="PlainVariable">
					<Id>1669906608195</Id>
					<Name><![CDATA[rtId]]></Name>
					<X>90</X><Y>180</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Properties SaveInSnapshot="true" Constant="false" AccessType="public" StaticVariable="false">
						<Type><![CDATA[int]]></Type>        
					</Properties>
				</Variable>
				<Variable Class="PlainVariable">
					<Id>1693557495280</Id>
					<Name><![CDATA[TTR]]></Name>
					<X>410</X><Y>520</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Properties SaveInSnapshot="true" Constant="false" AccessType="public" StaticVariable="false">
						<Type><![CDATA[double]]></Type>        
						<InitialValue Class="CodeValue">
							<Code><![CDATA[0]]></Code>
						</InitialValue>
					</Properties>
				</Variable>
				<Variable Class="PlainVariable">
					<Id>1693557509840</Id>
					<Name><![CDATA[TTF]]></Name>
					<X>410</X><Y>490</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Properties SaveInSnapshot="true" Constant="false" AccessType="public" StaticVariable="false">
						<Type><![CDATA[double]]></Type>        
						<InitialValue Class="CodeValue">
							<Code><![CDATA[0]]></Code>
						</InitialValue>
					</Properties>
				</Variable>
				<Variable Class="PlainVariable">
					<Id>1713509091435</Id>
					<Name><![CDATA[varJobShopLoadPerMachine]]></Name>
					<X>90</X><Y>240</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Properties SaveInSnapshot="true" Constant="false" AccessType="public" StaticVariable="false">
						<Type><![CDATA[double]]></Type>        
					</Properties>
				</Variable>
				<Variable Class="Parameter">
					<Id>1643199889788</Id>
					<Name><![CDATA[prodOrderFromAgent]]></Name>
					<X>260</X><Y>150</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Properties SaveInSnapshot="true" ModificatorType="STATIC">
						<Type><![CDATA[ProductionOrder]]></Type>
						<UnitType><![CDATA[NONE]]></UnitType>
						<SdArray>false</SdArray>
						<ParameterEditor>
							<Id>1643199889786</Id>
							<EditorContolType>TEXT_BOX</EditorContolType>
							<MinSliderValue><![CDATA[0]]></MinSliderValue>
							<MaxSliderValue><![CDATA[100]]></MaxSliderValue>
							<DelimeterType>NO_DELIMETER</DelimeterType>
						</ParameterEditor>
					</Properties>                 
				</Variable>
				<Variable Class="Parameter">
					<Id>1643401006229</Id>
					<Name><![CDATA[Resource]]></Name>
					<X>260</X><Y>120</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Properties SaveInSnapshot="true" ModificatorType="STATIC">
						<Type><![CDATA[Resource]]></Type>
						<UnitType><![CDATA[NONE]]></UnitType>
						<SdArray>false</SdArray>
						<ParameterEditor>
							<Id>1643401006227</Id>
							<EditorContolType>TEXT_BOX</EditorContolType>
							<MinSliderValue><![CDATA[0]]></MinSliderValue>
							<MaxSliderValue><![CDATA[100]]></MaxSliderValue>
							<DelimeterType>NO_DELIMETER</DelimeterType>
						</ParameterEditor>
					</Properties>                 
				</Variable>
				<Variable Class="Parameter">
					<Id>1693558079463</Id>
					<Name><![CDATA[parStationAvailability]]></Name>
					<Description><![CDATA[Availabilility of the station.
[-]]]></Description>
					<X>540</X><Y>460</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Properties SaveInSnapshot="true" ModificatorType="STATIC">
						<Type><![CDATA[double]]></Type>
						<UnitType><![CDATA[NONE]]></UnitType>
						<SdArray>false</SdArray>
						<DefaultValue Class="CodeValue">
							<Code><![CDATA[0.9]]></Code>
						</DefaultValue>
						<ParameterEditor>
							<Id>1693558079461</Id>
							<EditorContolType>TEXT_BOX</EditorContolType>
							<MinSliderValue><![CDATA[0]]></MinSliderValue>
							<MaxSliderValue><![CDATA[100]]></MaxSliderValue>
							<DelimeterType>NO_DELIMETER</DelimeterType>
						</ParameterEditor>
					</Properties>                 
				</Variable>
				<Variable Class="Parameter">
					<Id>1693558125749</Id>
					<Name><![CDATA[parStationMTTR]]></Name>
					<Description><![CDATA[MTTR - Mean Time To Repair.  
[Time Units]]]></Description>
					<X>540</X><Y>490</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Properties SaveInSnapshot="true" ModificatorType="STATIC">
						<Type><![CDATA[double]]></Type>
						<UnitType><![CDATA[NONE]]></UnitType>
						<SdArray>false</SdArray>
						<DefaultValue Class="CodeValue">
							<Code><![CDATA[15]]></Code>
						</DefaultValue>
						<ParameterEditor>
							<Id>1693558125747</Id>
							<EditorContolType>TEXT_BOX</EditorContolType>
							<MinSliderValue><![CDATA[0]]></MinSliderValue>
							<MaxSliderValue><![CDATA[100]]></MaxSliderValue>
							<DelimeterType>NO_DELIMETER</DelimeterType>
						</ParameterEditor>
					</Properties>                 
				</Variable>
				<Variable Class="Parameter">
					<Id>1693558427526</Id>
					<Name><![CDATA[parResourceCapacity]]></Name>
					<Description><![CDATA[Number of machines per station. 
[-]]]></Description>
					<X>540</X><Y>520</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Properties SaveInSnapshot="true" ModificatorType="STATIC">
						<Type><![CDATA[int]]></Type>
						<UnitType><![CDATA[NONE]]></UnitType>
						<SdArray>false</SdArray>
						<DefaultValue Class="CodeValue">
							<Code><![CDATA[1]]></Code>
						</DefaultValue>
						<ParameterEditor>
							<Id>1693558427524</Id>
							<EditorContolType>TEXT_BOX</EditorContolType>
							<MinSliderValue><![CDATA[0]]></MinSliderValue>
							<MaxSliderValue><![CDATA[100]]></MaxSliderValue>
							<DelimeterType>NO_DELIMETER</DelimeterType>
						</ParameterEditor>
					</Properties>                 
				</Variable>
			</Variables>
			<Connectors>
				<Connector>
					<Id>1643198233997</Id>
					<Name><![CDATA[connector]]></Name>
					<X>180</X><Y>60</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>false</ShowLabel>
					<SourceEmbeddedObjectReference>
						<PackageName><![CDATA[simopt]]></PackageName>
						<ClassName><![CDATA[MachineAgent]]></ClassName>
						<ItemName><![CDATA[queueProductionOrders]]></ItemName>
					</SourceEmbeddedObjectReference>
					<SourceConnectableItemReference>
						<PackageName><![CDATA[com.anylogic.libraries.processmodeling]]></PackageName>
						<ClassName><![CDATA[Queue]]></ClassName>
						<ItemName><![CDATA[in]]></ItemName>
					</SourceConnectableItemReference>
					<TargetEmbeddedObjectReference>
						<PackageName><![CDATA[simopt]]></PackageName>
						<ClassName><![CDATA[MachineAgent]]></ClassName>
						<ItemName><![CDATA[enterFromMaterialRelease]]></ItemName>
					</TargetEmbeddedObjectReference>
					<TargetConnectableItemReference>
						<PackageName><![CDATA[com.anylogic.libraries.processmodeling]]></PackageName>
						<ClassName><![CDATA[Enter]]></ClassName>
						<ItemName><![CDATA[out]]></ItemName>
					</TargetConnectableItemReference>
					<Points>
						<Point><X>0</X><Y>0</Y></Point>
						<Point><X>-90</X><Y>0</Y></Point>
					</Points>
				</Connector>
				<Connector>
					<Id>1643706406396</Id>
					<Name><![CDATA[connector2]]></Name>
					<X>520</X><Y>60</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>false</ShowLabel>
					<SourceEmbeddedObjectReference>
						<PackageName><![CDATA[simopt]]></PackageName>
						<ClassName><![CDATA[MachineAgent]]></ClassName>
						<ItemName><![CDATA[delayRepair]]></ItemName>
					</SourceEmbeddedObjectReference>
					<SourceConnectableItemReference>
						<PackageName><![CDATA[com.anylogic.libraries.processmodeling]]></PackageName>
						<ClassName><![CDATA[Delay]]></ClassName>
						<ItemName><![CDATA[in]]></ItemName>
					</SourceConnectableItemReference>
					<TargetEmbeddedObjectReference>
						<PackageName><![CDATA[simopt]]></PackageName>
						<ClassName><![CDATA[MachineAgent]]></ClassName>
						<ItemName><![CDATA[delayProcessingTime]]></ItemName>
					</TargetEmbeddedObjectReference>
					<TargetConnectableItemReference>
						<PackageName><![CDATA[com.anylogic.libraries.processmodeling]]></PackageName>
						<ClassName><![CDATA[Delay]]></ClassName>
						<ItemName><![CDATA[out]]></ItemName>
					</TargetConnectableItemReference>
					<Points>
						<Point><X>0</X><Y>0</Y></Point>
						<Point><X>-100</X><Y>0</Y></Point>
					</Points>
				</Connector>
				<Connector>
					<Id>1693556920954</Id>
					<Name><![CDATA[connector1]]></Name>
					<X>560</X><Y>60</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>false</ShowLabel>
					<SourceEmbeddedObjectReference>
						<PackageName><![CDATA[simopt]]></PackageName>
						<ClassName><![CDATA[MachineAgent]]></ClassName>
						<ItemName><![CDATA[delayRepair]]></ItemName>
					</SourceEmbeddedObjectReference>
					<SourceConnectableItemReference>
						<PackageName><![CDATA[com.anylogic.libraries.processmodeling]]></PackageName>
						<ClassName><![CDATA[Delay]]></ClassName>
						<ItemName><![CDATA[out]]></ItemName>
					</SourceConnectableItemReference>
					<TargetEmbeddedObjectReference>
						<PackageName><![CDATA[simopt]]></PackageName>
						<ClassName><![CDATA[MachineAgent]]></ClassName>
						<ItemName><![CDATA[exitAccordingRouting]]></ItemName>
					</TargetEmbeddedObjectReference>
					<TargetConnectableItemReference>
						<PackageName><![CDATA[com.anylogic.libraries.processmodeling]]></PackageName>
						<ClassName><![CDATA[Exit]]></ClassName>
						<ItemName><![CDATA[in]]></ItemName>
					</TargetConnectableItemReference>
					<Points>
						<Point><X>0</X><Y>0</Y></Point>
						<Point><X>110</X><Y>0</Y></Point>
					</Points>
				</Connector>
				<Connector>
					<Id>1712983849503</Id>
					<Name><![CDATA[connector4]]></Name>
					<X>290</X><Y>60</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>false</ShowLabel>
					<SourceEmbeddedObjectReference>
						<PackageName><![CDATA[simopt]]></PackageName>
						<ClassName><![CDATA[MachineAgent]]></ClassName>
						<ItemName><![CDATA[hold]]></ItemName>
					</SourceEmbeddedObjectReference>
					<SourceConnectableItemReference>
						<PackageName><![CDATA[com.anylogic.libraries.processmodeling]]></PackageName>
						<ClassName><![CDATA[Hold]]></ClassName>
						<ItemName><![CDATA[in]]></ItemName>
					</SourceConnectableItemReference>
					<TargetEmbeddedObjectReference>
						<PackageName><![CDATA[simopt]]></PackageName>
						<ClassName><![CDATA[MachineAgent]]></ClassName>
						<ItemName><![CDATA[queueProductionOrders]]></ItemName>
					</TargetEmbeddedObjectReference>
					<TargetConnectableItemReference>
						<PackageName><![CDATA[com.anylogic.libraries.processmodeling]]></PackageName>
						<ClassName><![CDATA[Queue]]></ClassName>
						<ItemName><![CDATA[out]]></ItemName>
					</TargetConnectableItemReference>
					<Points>
						<Point><X>0</X><Y>0</Y></Point>
						<Point><X>-70</X><Y>0</Y></Point>
					</Points>
				</Connector>
				<Connector>
					<Id>1712983862243</Id>
					<Name><![CDATA[connector5]]></Name>
					<X>380</X><Y>60</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>false</ShowLabel>
					<SourceEmbeddedObjectReference>
						<PackageName><![CDATA[simopt]]></PackageName>
						<ClassName><![CDATA[MachineAgent]]></ClassName>
						<ItemName><![CDATA[delayProcessingTime]]></ItemName>
					</SourceEmbeddedObjectReference>
					<SourceConnectableItemReference>
						<PackageName><![CDATA[com.anylogic.libraries.processmodeling]]></PackageName>
						<ClassName><![CDATA[Delay]]></ClassName>
						<ItemName><![CDATA[in]]></ItemName>
					</SourceConnectableItemReference>
					<TargetEmbeddedObjectReference>
						<PackageName><![CDATA[simopt]]></PackageName>
						<ClassName><![CDATA[MachineAgent]]></ClassName>
						<ItemName><![CDATA[hold]]></ItemName>
					</TargetEmbeddedObjectReference>
					<TargetConnectableItemReference>
						<PackageName><![CDATA[com.anylogic.libraries.processmodeling]]></PackageName>
						<ClassName><![CDATA[Hold]]></ClassName>
						<ItemName><![CDATA[out]]></ItemName>
					</TargetConnectableItemReference>
					<Points>
						<Point><X>0</X><Y>0</Y></Point>
						<Point><X>-70</X><Y>0</Y></Point>
					</Points>
				</Connector>
			</Connectors>
			<Events>
				<Event>
					<Id>1693554391962</Id>
					<Name><![CDATA[TTF_start]]></Name>
					<X>410</X><Y>550</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Properties TriggerType="timeout" Mode="occuresOnce">
						<Timeout Class="CodeUnitValue">
							<Code><![CDATA[1]]></Code>
							<Unit Class="TimeUnits"><![CDATA[MINUTE]]></Unit>
						</Timeout>
						<Rate Class="CodeUnitValue">
							<Code><![CDATA[1]]></Code>
							<Unit Class="RateUnits"><![CDATA[PER_MINUTE]]></Unit>
						</Rate>
						<OccurrenceAtTime>true</OccurrenceAtTime>
						<OccurrenceDate>1329218080236</OccurrenceDate>
						<OccurrenceTime Class="CodeUnitValue">
							<Code><![CDATA[0]]></Code>
							<Unit Class="TimeUnits"><![CDATA[MINUTE]]></Unit>
						</OccurrenceTime>
						<RecurrenceCode Class="CodeUnitValue">
							<Code><![CDATA[1]]></Code>
							<Unit Class="TimeUnits"><![CDATA[MINUTE]]></Unit>
						</RecurrenceCode>
						<Condition><![CDATA[false]]></Condition>
					</Properties>
					<Action><![CDATA[TTF = TTF_calculation()]]></Action>
				</Event>
				<Event>
					<Id>1713512802259</Id>
					<Name><![CDATA[eventTriggerEnergyDispatching]]></Name>
					<X>510</X><Y>240</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Properties TriggerType="timeout" Mode="cyclic">
						<Timeout Class="CodeUnitValue">
							<Code><![CDATA[1]]></Code>
							<Unit Class="TimeUnits"><![CDATA[DAY]]></Unit>
						</Timeout>
						<Rate Class="CodeUnitValue">
							<Code><![CDATA[1]]></Code>
							<Unit Class="RateUnits"><![CDATA[PER_DAY]]></Unit>
						</Rate>
						<OccurrenceAtTime>true</OccurrenceAtTime>
						<OccurrenceDate>1713513600000</OccurrenceDate>
						<OccurrenceTime Class="CodeUnitValue">
							<Code><![CDATA[0]]></Code>
							<Unit Class="TimeUnits"><![CDATA[HOUR]]></Unit>
						</OccurrenceTime>
						<RecurrenceCode Class="CodeUnitValue">
							<Code><![CDATA[1]]></Code>
							<Unit Class="TimeUnits"><![CDATA[HOUR]]></Unit>
						</RecurrenceCode>
						<Condition><![CDATA[false]]></Condition>
					</Properties>
					<Action><![CDATA[if(main.simParams.getEnergyBasedRelease() == 1){

	if(queueProductionOrders.size() > 0){
	
		double capacityThreshold = 1440 *  main.simParams.getCapacityFactor();
		
		boolean releaseToMachine = false;
		releaseToMachine = EnergyRelease.EnergyBasedReleasesBlockIt(main, time());
		
		if(releaseToMachine == true){
			hold.unblock();	
		}else{
			main.countEnergyPriceBlock++;
			if(varJobShopLoadPerMachine < capacityThreshold){
			//traceln("showload per machine: " + varJobShopLoadPerMachine + "th: " + capacityThreshold);
			//	traceln("capacity based block hold");
				hold.block();	
				main.countCapacityFactorBlock++;
			}else{
				//traceln("NO Capacity based block hold");
				hold.unblock();	
			}
		}
	}
}]]></Action>
				</Event>
			</Events>
			<DynamicEvents>
				<DynamicEventClass>
					<Id>1724074464734</Id>
					<Name><![CDATA[piecewiseBooking]]></Name>
					<X>510</X><Y>190</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Parameter>
						<Name><![CDATA[prodOrderIn]]></Name>
						<Type><![CDATA[ProductionOrder]]></Type>
					</Parameter>
					<Action><![CDATA[	
	
	traceln(" Create Event for BOOK ProdOrder " + prodOrderIn.getOrderId() + " Status " + prodOrderIn.getStatus());
	
	if(SimulationParameter.MRP_PRODUCTION_ORDER_BOOKING_BEHAVIOR_PIECEWISE == 1 && prodOrderIn != null &&
		prodOrderIn.getStatus() == ProductionOrder.PRODUCTION_ORDER_STATUS_PROCESSING ){
		
		
		StockBooking currentInventory = StockBooking.GetStockItemQuantity(get_Main().stockBookings, 
		prodOrderIn.getItem());
		
		
		//Add the quantity on stock	
		StockBooking book = new StockBooking(	
			prodOrderIn.getItem(),
			1,
			time(),
			StockBooking.BOOKING_SOURCE_PRODUCTION_ORDER,
			prodOrderIn.getOrderId(),
			currentInventory.getQuantity(),
			currentInventory.getTimeBetweenBookings());
			
		get_Main().stockBookings.add(book);
		
		create_piecewiseBooking(prodOrderIn.getNetProcessingTime()/prodOrderIn.getQuantity(),MINUTE,
		  prodOrderIn);	
	
		traceln("*************** BOOK ProdOrder " + prodOrderIn.getOrderId() +
		 " status " + prodOrderIn.getStatus() + " time: " + time() + " netProcessingTiume " + prodOrderIn.getNetProcessingTime());
						
		 //piecewiseBooking.restartTo(time() + prodOrderFromAgent.getNetProcessingTime());		 
		 
	}]]></Action>
				</DynamicEventClass>
			</DynamicEvents>
			<Functions>
				<Function AccessType="public" StaticFunction="false">
					<ReturnModificator>RETURNS_VALUE</ReturnModificator>
					<ReturnType><![CDATA[String]]></ReturnType>
					<Id>1644911299192</Id>
					<Name><![CDATA[toString]]></Name>
					<X>260</X><Y>180</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Body><![CDATA[return
	"RoutingTime = " + RoutingTime + ", " +
	"prodOrderFromAgent = " + prodOrderFromAgent.getOrderId() + ", " +
	"Resource = " + Resource;]]></Body>
				</Function>
				<Function AccessType="default" StaticFunction="false">
					<ReturnModificator>RETURNS_VALUE</ReturnModificator>
					<ReturnType><![CDATA[double]]></ReturnType>
					<Id>1693557538948</Id>
					<Name><![CDATA[TTF_calculation]]></Name>
					<X>410</X><Y>460</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Body><![CDATA[//A=TTF/(TTF+TTR)

//traceln("parStationAvailability " + parStationAvailability + " parStationMTTR " + parStationMTTR);

double exponentialParameter =  1.0 / (parStationAvailability / (1.0 - parStationAvailability) * parStationMTTR);

double result = Distribution.GetDistributionValue(Distribution.DISTRIBUTION_TYPE_EXP
			,(0.1/parStationMTTR), 0, "Machine TTR", get_Main().var_random_TTR, main.mrpFileNameSuffix, 0, 0);	
//double result = exponential(exponentialParameter);

traceln("TTF: " + result + " Parameter: " + exponentialParameter);

return result;
]]></Body>
				</Function>
			</Functions>
			<AnalysisData>
    			<Statistics>
					<Id>1655193180391</Id>
					<Name><![CDATA[statJSIperMachine]]></Name>
					<X>90</X><Y>120</Y>
					<Label><X>15</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<AutoUpdate>false</AutoUpdate>
					<OccurrenceAtTime>true</OccurrenceAtTime>
					<OccurrenceDate>1655193600000</OccurrenceDate>
					<OccurrenceTime Class="CodeUnitValue">
						<Code><![CDATA[0]]></Code>
						<Unit Class="TimeUnits"><![CDATA[DAY]]></Unit>
					</OccurrenceTime>
					<RecurrenceCode Class="CodeUnitValue">
						<Code><![CDATA[1]]></Code>
						<Unit Class="TimeUnits"><![CDATA[DAY]]></Unit>
					</RecurrenceCode>
					<Discrete>false</Discrete>
				</Statistics>
    			<Statistics>
					<Id>1713508998393</Id>
					<Name><![CDATA[statJobShopLoadPerMachine]]></Name>
					<X>90</X><Y>210</Y>
					<Label><X>15</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<AutoUpdate>false</AutoUpdate>
					<OccurrenceAtTime>true</OccurrenceAtTime>
					<OccurrenceDate>1655193600000</OccurrenceDate>
					<OccurrenceTime Class="CodeUnitValue">
						<Code><![CDATA[0]]></Code>
						<Unit Class="TimeUnits"><![CDATA[DAY]]></Unit>
					</OccurrenceTime>
					<RecurrenceCode Class="CodeUnitValue">
						<Code><![CDATA[1]]></Code>
						<Unit Class="TimeUnits"><![CDATA[DAY]]></Unit>
					</RecurrenceCode>
					<Discrete>true</Discrete>
				</Statistics>
			</AnalysisData>
			<AgentLinks>
				<AgentLink>
					<Id>1643198210438</Id>
					<Name><![CDATA[connections]]></Name>
					<X>50</X><Y>-50</Y>
					<Label><X>15</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<HandleReceiveInConnections>false</HandleReceiveInConnections>
					<AgentLinkType>COLLECTION_OF_LINKS</AgentLinkType>
					<AgentLinkBidirectional>true</AgentLinkBidirectional>
					<MessageType><![CDATA[Object]]></MessageType>
					<LineStyle>SOLID</LineStyle>
					<LineWidth>1</LineWidth>
					<LineColor>-16777216</LineColor>
					<LineZOrder>UNDER_AGENTS</LineZOrder>
					<LineArrow>NONE</LineArrow>
					<LineArrowPosition>END</LineArrowPosition>
				</AgentLink>
			</AgentLinks>

			<ContainerLinks>
				<ContainerLink>
					<Id>1643200837042</Id>
					<Name><![CDATA[main]]></Name>
					<X>50</X><Y>-100</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<ActiveObjectClass>
						<PackageName><![CDATA[simopt]]></PackageName>
						<ClassName><![CDATA[Main]]></ClassName>
					</ActiveObjectClass>
				</ContainerLink>
			</ContainerLinks>
			<EmbeddedObjects>
				<EmbeddedObject>
					<Id>1643198223686</Id>
					<Name><![CDATA[enterFromMaterialRelease]]></Name>
					<X>70</X><Y>50</Y>
					<Label><X>-55</X><Y>-15</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<ActiveObjectClass>
						<PackageName><![CDATA[com.anylogic.libraries.processmodeling]]></PackageName>
						<ClassName><![CDATA[Enter]]></ClassName>
					</ActiveObjectClass>
					<GenericParameterSubstitute>
						<GenericParameterSubstituteReference>
							<PackageName><![CDATA[com.anylogic.libraries.processmodeling]]></PackageName>
							<ClassName><![CDATA[Enter]]></ClassName>
							<ItemName><![CDATA[1412336242933]]></ItemName>
						</GenericParameterSubstituteReference>
					</GenericParameterSubstitute>
					<Parameters>
						<Parameter>
							<Name><![CDATA[locationType]]></Name>
						</Parameter>
						<Parameter>
							<Name><![CDATA[locationX]]></Name>
						</Parameter>
						<Parameter>
							<Name><![CDATA[locationY]]></Name>
						</Parameter>
						<Parameter>
							<Name><![CDATA[locationZ]]></Name>
						</Parameter>
						<Parameter>
							<Name><![CDATA[locationLatitude]]></Name>
						</Parameter>
						<Parameter>
							<Name><![CDATA[locationLongitude]]></Name>
						</Parameter>
						<Parameter>
							<Name><![CDATA[locationGeoPlaceName]]></Name>
						</Parameter>
						<Parameter>
							<Name><![CDATA[locationXYZInNetwork]]></Name>
						</Parameter>
						<Parameter>
							<Name><![CDATA[locationNetwork]]></Name>
						</Parameter>
						<Parameter>
							<Name><![CDATA[locationLevel]]></Name>
						</Parameter>
						<Parameter>
							<Name><![CDATA[locationNode]]></Name>
						</Parameter>
						<Parameter>
							<Name><![CDATA[locationAttractor]]></Name>
						</Parameter>
						<Parameter>
							<Name><![CDATA[speed]]></Name>
						</Parameter>
						<Parameter>
							<Name><![CDATA[changeDimensions]]></Name>
						</Parameter>
						<Parameter>
							<Name><![CDATA[length]]></Name>
						</Parameter>
						<Parameter>
							<Name><![CDATA[width]]></Name>
						</Parameter>
						<Parameter>
							<Name><![CDATA[height]]></Name>
						</Parameter>
						<Parameter>
							<Name><![CDATA[addToCustomPopulation]]></Name>
						</Parameter>
						<Parameter>
							<Name><![CDATA[population]]></Name>
						</Parameter>
						<Parameter>
							<Name><![CDATA[pushProtocol]]></Name>
						</Parameter>
						<Parameter>
							<Name><![CDATA[onEnter]]></Name>
							<Value Class="CodeValue">
								<Code><![CDATA[
//if(prodOrderFromAgent != null){	
	//if(prodOrderFromAgent.getCurrentRoutingStep() == prodOrderFromAgent.getMinimumRoutingStep()){	
		//traceln("Warum da drinnen " + prodOrderFromAgent.getOrderId() + "item " + prodOrderFromAgent.getItem().getItem());
		//prodOrderFromAgent.setStatus(ProductionOrder.PRODUCTION_ORDER_STATUS_RELEASED);		
	//}	
//}
]]></Code>
							</Value>
						</Parameter>
						<Parameter>
							<Name><![CDATA[onRemove]]></Name>
						</Parameter>
						<Parameter>
							<Name><![CDATA[onAtEnter]]></Name>
						</Parameter>
					</Parameters>
					<ReplicationFlag>false</ReplicationFlag>
					<Replication Class="CodeValue">
						<Code><![CDATA[100]]></Code>
					</Replication>
					<CollectionType>ARRAY_LIST_BASED</CollectionType>
					<InitialLocationType>XYZ</InitialLocationType>
					<XCode Class="CodeValue">
						<Code><![CDATA[0]]></Code>
					</XCode>
					<YCode Class="CodeValue">
						<Code><![CDATA[0]]></Code>
					</YCode>
					<ZCode Class="CodeValue">
						<Code><![CDATA[0]]></Code>
					</ZCode>
					<ColumnCode Class="CodeValue">
						<Code><![CDATA[0]]></Code>
					</ColumnCode>
					<RowCode Class="CodeValue">
						<Code><![CDATA[0]]></Code>
					</RowCode>
					<LocationNameCode Class="CodeValue">
						<Code><![CDATA[""]]></Code>
					</LocationNameCode>
					<InitializationType>SPECIFIED_NUMBER</InitializationType>
					<InitializationDatabaseTableQuery>
						<TableReference>
						</TableReference>
					</InitializationDatabaseTableQuery>
					<InitializationDatabaseType>ONE_AGENT_PER_DATABASE_RECORD</InitializationDatabaseType>
					<QuantityColumn>
					</QuantityColumn>
				</EmbeddedObject>
				<EmbeddedObject>
					<Id>1643198232350</Id>
					<Name><![CDATA[queueProductionOrders]]></Name>
					<X>180</X><Y>40</Y>
					<Label><X>-20</X><Y>-15</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<ActiveObjectClass>
						<PackageName><![CDATA[com.anylogic.libraries.processmodeling]]></PackageName>
						<ClassName><![CDATA[Queue]]></ClassName>
					</ActiveObjectClass>
					<GenericParameterSubstitute>
						<GenericParameterSubstituteReference>
							<PackageName><![CDATA[com.anylogic.libraries.processmodeling]]></PackageName>
							<ClassName><![CDATA[Queue]]></ClassName>
							<ItemName><![CDATA[1412336242932]]></ItemName>
						</GenericParameterSubstituteReference>
						<GenericParameterSubstituteValue Class="CodeValue">
							<Code><![CDATA[ProductionOrderAgent]]></Code>
						</GenericParameterSubstituteValue>
					</GenericParameterSubstitute>
					<Parameters>
						<Parameter>
							<Name><![CDATA[capacity]]></Name>
							<Value Class="CodeValue">
								<Code><![CDATA[1]]></Code>
							</Value>
						</Parameter>
						<Parameter>
							<Name><![CDATA[maximumCapacity]]></Name>
							<Value Class="CodeValue">
								<Code><![CDATA[true]]></Code>
							</Value>
						</Parameter>
						<Parameter>
							<Name><![CDATA[entityLocation]]></Name>
						</Parameter>
						<Parameter>
							<Name><![CDATA[queuing]]></Name>
						</Parameter>
						<Parameter>
							<Name><![CDATA[priority]]></Name>
							<Value Class="CodeValue">
								<Code><![CDATA[agent.prodOrderFromAgent.getPlannedStart()]]></Code>
							</Value>
						</Parameter>
						<Parameter>
							<Name><![CDATA[comparison]]></Name>
						</Parameter>
						<Parameter>
							<Name><![CDATA[enableTimeout]]></Name>
						</Parameter>
						<Parameter>
							<Name><![CDATA[timeout]]></Name>
						</Parameter>
						<Parameter>
							<Name><![CDATA[enablePreemption]]></Name>
						</Parameter>
						<Parameter>
							<Name><![CDATA[restoreEntityLocationOnExit]]></Name>
						</Parameter>
						<Parameter>
							<Name><![CDATA[forceStatisticsCollection]]></Name>
						</Parameter>
						<Parameter>
							<Name><![CDATA[onEnter]]></Name>
							<Value Class="CodeValue">
								<Code><![CDATA[double oldWip = get_Main().varSystemWIP;


get_Main().varSystemWIP = oldWip +  agent.prodOrderFromAgent.getQuantity();
get_Main().statSystemWIP.add(get_Main().varSystemWIP, time());

varJSIperMachine += agent.prodOrderFromAgent.getQuantity();
statJSIperMachine.add(varJSIperMachine,time());

//compute the shopload per machine when it enters the delay
//traceln("time " + time() + " planned capacity before " +  varJobShopLoadPerMachine + "machine " + Resource.getName()); 
double addShopLoadForMachine = Routing.GetPlannedCapacityPerItemAndMachine(main, agent.prodOrderFromAgent, Resource.getName());
varJobShopLoadPerMachine += addShopLoadForMachine;
//traceln("time " + time() + " planned capacity after " +  varJobShopLoadPerMachine + " machine " + Resource.getName());

//statJobShopLoadPerMachine.add();

//traceln("############### " + time () + " ###############");

if(time() >= main.simParams.getWarumUpTime() && main.simParams.getProdStageStatistics()==1){
	
	String actualResource = agent.prodOrderFromAgent.getItem().getRouting().getResource();
	Resource resource = main.resources.stream().filter(e -> e.getName().equalsIgnoreCase(actualResource)).findFirst().get();
	
	double newQuantity = agent.prodOrderFromAgent.getQuantity() * agent.prodOrderFromAgent.getItem().getRouting().getEProcessingTime() 
	+ agent.prodOrderFromAgent.getItem().getRouting().getESetupTime();
	
	double oldValue = 0; 
	double newValue = 0; 
	
	if(resource.getResourceGroup().equalsIgnoreCase("Stage1")){
		oldValue = main.clearingFunctionAgent.varStage1;
		newValue = oldValue + newQuantity;
		main.clearingFunctionAgent.varStage1 = newValue;
		main.clearingFunctionAgent.statisticStage1.add(newValue, time());
		main.clearingFunctionAgent.dataSetStage1.add(time(), newValue);
	}
	else if(resource.getResourceGroup().equalsIgnoreCase("Stage2")){
		oldValue = main.clearingFunctionAgent.varStage2;
		newValue = oldValue + newQuantity;
		main.clearingFunctionAgent.varStage2 = newValue;
		main.clearingFunctionAgent.statisticStage2.add(newValue, time());
		main.clearingFunctionAgent.dataSetStage2.add(time(), newValue);
	}
	else if(resource.getResourceGroup().equalsIgnoreCase("Stage3")){
		oldValue = main.clearingFunctionAgent.varStage3;
		newValue = oldValue + newQuantity;
		main.clearingFunctionAgent.varStage3 = newValue;
		main.clearingFunctionAgent.statisticStage3.add(newValue, time());
		main.clearingFunctionAgent.dataSetStage3.add(time(), newValue);	
	}
	else if(resource.getResourceGroup().equalsIgnoreCase("Stage4")){
		oldValue = main.clearingFunctionAgent.varStage4;
		newValue = oldValue + newQuantity;
		main.clearingFunctionAgent.varStage4 = newValue;
		main.clearingFunctionAgent.statisticStage4.add(newValue, time());
		main.clearingFunctionAgent.dataSetStage4.add(time(), newValue);		
	}
	
	if(newValue > 0){
		double newSL = resource.getSL() + newQuantity;
		resource.setSL(newSL);
		resource.setSLValue(resource.getSLValue() + ";" + time() + "|" + agent.prodOrderFromAgent.getOrderId() + "|" + (int)newQuantity + ";");
		//traceln("Resource " + resource.getName() + " SL " + resource.getSL());
	}
}
]]></Code>
							</Value>
						</Parameter>
						<Parameter>
							<Name><![CDATA[onAtExit]]></Name>
							<Value Class="CodeValue">
								<Code><![CDATA[//traceln(time() + " On at exit queue Order-Id " + prodOrderFromAgent.getOrderId());

]]></Code>
							</Value>
						</Parameter>
						<Parameter>
							<Name><![CDATA[onExit]]></Name>
							<Value Class="CodeValue">
								<Code><![CDATA[
if(main.simParams.getEnergyBasedRelease() == 1){
	EnergyPrice priceToCompare = main.EnergyPrices.stream().filter(e -> e.getMonth() == (main.getMonth() + 1) && e.getHour() == main.getHourOfDay()).findFirst().get();
}
           	    
//	traceln(time() + " On exit queue Order-Id (Release to machine) order " + agent.prodOrderFromAgent.getOrderId() 
//	+ " item " + agent.prodOrderFromAgent.getItem().getItem() + " current step "
//	 + agent.prodOrderFromAgent.getCurrentRoutingStep() + " max step "
//	  + agent.prodOrderFromAgent.getMaximumRoutingStep() + " Hold is Blocked " + hold.isBlocked() + 
//	  " Resource name " + Resource.getName() +
//	  "Months " +( main.getMonth() + 1)+ " hours " + main.getHourOfDay() + "Price to compare: " + priceToCompare.getPrice() + " < " + main.simParams.getEnergyPriceFactor()
//	  );
	
	Routing actualRoutingPosition = get_Main().routings.stream().
	filter(e -> e.getItem().getItem() == agent.prodOrderFromAgent.getItem().
	getItem() && e.getStep() == agent.prodOrderFromAgent.getCurrentRoutingStep()).findFirst().orElse(null);
	
	//traceln("Processing Time Values: " + actualRoutingPosition.getDistProcessingTime() + " " + 		
	//actualRoutingPosition.getEProcessingTime() + " " +
	//actualRoutingPosition.getSProcessingTime()); 
	
	double processingTime = Distribution.GetDistributionValue(
		actualRoutingPosition.getDistProcessingTime(),
		actualRoutingPosition.getEProcessingTime() * agent.prodOrderFromAgent.getQuantity(),
		actualRoutingPosition.getSProcessingTime() / Math.sqrt(agent.prodOrderFromAgent.getQuantity()), //CV for Lot!!!
		"Processing Time " + actualRoutingPosition.getItem().getItem(),
		 get_Main().var_random_processingTime,
		 main.mrpFileNameSuffix,0,0
	);
	
		//traceln("Processing Time from Distribution: " + processingTime);
	 	//traceln("Setup Time Values " + actualRoutingPosition.getDistSetupTime() + " " + 		
		//actualRoutingPosition.getESetupTime() + " " +
		//actualRoutingPosition.getSSetupTime());  
 
	double setupTime = Distribution.GetDistributionValue(
		actualRoutingPosition.getDistSetupTime(),
		actualRoutingPosition.getESetupTime() ,
		actualRoutingPosition.getSSetupTime(), 
		"Setup Time " + actualRoutingPosition.getItem().getItem(),
		get_Main().var_random_setupTime,
		main.mrpFileNameSuffix,0,0
	);

//traceln("ssssssssss: " + actualRoutingPosition.getSSetupTime() * actualRoutingPosition.getESetupTime());
	
	//traceln("Setup Time from Distribution: " + setupTime);
				
	agent.prodOrderFromAgent.setConsumedSetupTime(setupTime);
	agent.prodOrderFromAgent.setConsumedProcessingTime(processingTime);
			
	agent.prodOrderFromAgent.setTotalProcessingTime(processingTime + setupTime);
	//traceln("Consumed SetupTime: " + setupTime  + " Consumed ProcessingTime " + processingTime + " Prod Order: " + agent.prodOrderFromAgent.getOrderId() + " TotalProcessingTime: " + agent.prodOrderFromAgent.getTotalProcessingTime());
	agent.prodOrderFromAgent.setNetProcessingTime(processingTime);
	]]></Code>
							</Value>
						</Parameter>
						<Parameter>
							<Name><![CDATA[onExitTimeout]]></Name>
						</Parameter>
						<Parameter>
							<Name><![CDATA[onExitPreempted]]></Name>
						</Parameter>
						<Parameter>
							<Name><![CDATA[onRemove]]></Name>
						</Parameter>
					</Parameters>
					<ReplicationFlag>false</ReplicationFlag>
					<Replication Class="CodeValue">
						<Code><![CDATA[100]]></Code>
					</Replication>
					<CollectionType>ARRAY_LIST_BASED</CollectionType>
					<InitialLocationType>XYZ</InitialLocationType>
					<XCode Class="CodeValue">
						<Code><![CDATA[0]]></Code>
					</XCode>
					<YCode Class="CodeValue">
						<Code><![CDATA[0]]></Code>
					</YCode>
					<ZCode Class="CodeValue">
						<Code><![CDATA[0]]></Code>
					</ZCode>
					<ColumnCode Class="CodeValue">
						<Code><![CDATA[0]]></Code>
					</ColumnCode>
					<RowCode Class="CodeValue">
						<Code><![CDATA[0]]></Code>
					</RowCode>
					<LocationNameCode Class="CodeValue">
						<Code><![CDATA[""]]></Code>
					</LocationNameCode>
					<InitializationType>SPECIFIED_NUMBER</InitializationType>
					<InitializationDatabaseTableQuery>
						<TableReference>
						</TableReference>
					</InitializationDatabaseTableQuery>
					<InitializationDatabaseType>ONE_AGENT_PER_DATABASE_RECORD</InitializationDatabaseType>
					<QuantityColumn>
					</QuantityColumn>
				</EmbeddedObject>
				<EmbeddedObject>
					<Id>1643198236964</Id>
					<Name><![CDATA[delayProcessingTime]]></Name>
					<X>380</X><Y>40</Y>
					<Label><X>-30</X><Y>-20</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<ActiveObjectClass>
						<PackageName><![CDATA[com.anylogic.libraries.processmodeling]]></PackageName>
						<ClassName><![CDATA[Delay]]></ClassName>
					</ActiveObjectClass>
					<GenericParameterSubstitute>
						<GenericParameterSubstituteReference>
							<PackageName><![CDATA[com.anylogic.libraries.processmodeling]]></PackageName>
							<ClassName><![CDATA[Delay]]></ClassName>
							<ItemName><![CDATA[1412336242930]]></ItemName>
						</GenericParameterSubstituteReference>
					</GenericParameterSubstitute>
					<Parameters>
						<Parameter>
							<Name><![CDATA[type]]></Name>
						</Parameter>
						<Parameter>
							<Name><![CDATA[delayTime]]></Name>
							<Value Class="CodeUnitValue">
								<Code><![CDATA[agent.prodOrderFromAgent.getTotalProcessingTime();]]></Code>
								<Unit Class="TimeUnits"><![CDATA[MINUTE]]></Unit>
							</Value>
						</Parameter>
						<Parameter>
							<Name><![CDATA[capacity]]></Name>
							<Value Class="CodeValue">
								<Code><![CDATA[parResourceCapacity]]></Code>
							</Value>
						</Parameter>
						<Parameter>
							<Name><![CDATA[maximumCapacity]]></Name>
						</Parameter>
						<Parameter>
							<Name><![CDATA[entityLocation]]></Name>
						</Parameter>
						<Parameter>
							<Name><![CDATA[pushProtocol]]></Name>
						</Parameter>
						<Parameter>
							<Name><![CDATA[restoreEntityLocationOnExit]]></Name>
						</Parameter>
						<Parameter>
							<Name><![CDATA[forceStatisticsCollection]]></Name>
						</Parameter>
						<Parameter>
							<Name><![CDATA[onEnter]]></Name>
							<Value Class="CodeValue">
								<Code><![CDATA[
//traceln(time() + "******************** At enter delay " + agent.prodOrderFromAgent.getOrderId());

RoutingTimes rt = new RoutingTimes();

rt.setId(get_Main().routingTimeId++);
rtId=rt.getId();
rt.setCreatedAt(time());
rt.setStart(time());
rt.setProductionOrder(agent.prodOrderFromAgent);
rt.setResource(Resource);
rt.setStatus(RoutingTimes.ROUTING_TIME_PROCESSING);
rt.setProcessingTime(agent.prodOrderFromAgent.getTotalProcessingTime()/1440);
rt.setRoutingType(RoutingTime.ROUTING_TYPE_PRODUCTIONORDER);

if(main.simParams.getEnergyBasedRelease() == 1){
	rt.setUsedEnergyPriceAtEnterDelay(EnergyPrice.GetEnergyPrice(main));
}

get_Main().RoutingTimesList.add(rt);

if(agent.prodOrderFromAgent.getCurrentRoutingStep() == agent.prodOrderFromAgent.getMinimumRoutingStep()){	
	agent.prodOrderFromAgent.setActualStart(time());
	agent.prodOrderFromAgent.setStatus(ProductionOrder.PRODUCTION_ORDER_STATUS_PROCESSING);					
}


	agent.prodOrderFromAgent.setResource(Resource);

	if(SimulationParameter.MRP_PRODUCTION_ORDER_BOOKING_BEHAVIOR_PIECEWISE == 1){
		traceln("order out of quue: " + agent.prodOrderFromAgent.getOrderId() + " time " + time() + " actual start: " + agent.prodOrderFromAgent.getActualStart());	
		create_piecewiseBooking(0, MINUTE,agent.prodOrderFromAgent);
	}

]]></Code>
							</Value>
						</Parameter>
						<Parameter>
							<Name><![CDATA[onAtExit]]></Name>
							<Value Class="CodeValue">
								<Code><![CDATA[RoutingTime.setStatus(RoutingTime.ROUTING_TIME_PROCESSING);
ProductionOrder prodOrder = get_Main().productionOrders.stream().filter(e -> e.getOrderId() == agent.prodOrderFromAgent.getOrderId()).findFirst().orElse(null);
prodOrder.setStatus(ProductionOrder.PRODUCTION_ORDER_STATUS_PROCESSING);
agent.prodOrderFromAgent.setStatus(ProductionOrder.PRODUCTION_ORDER_STATUS_PROCESSING);
]]></Code>
							</Value>
						</Parameter>
						<Parameter>
							<Name><![CDATA[onExit]]></Name>
							<Value Class="CodeValue">
								<Code><![CDATA[
if(get_Main().simParams.getMachineFailure()==1){
	TTF -= agent.prodOrderFromAgent.getTotalProcessingTime();
	if (TTF <= 0){	
		//TTR = exponential(0.1 / parStationMTTR); //original war 1
		TTR = Distribution.GetDistributionValue(Distribution.DISTRIBUTION_TYPE_EXP
				,(1.0/parStationMTTR), 0, "Machine TTR", get_Main().var_random_TTR, main.mrpFileNameSuffix, 0, 0);		
		double tTF = TTF_calculation();	
		TTF += tTF;
		agent.prodOrderFromAgent.setTTF(tTF);	
	}else{
		TTR = 0;
	}
}

agent.prodOrderFromAgent.setTTR(TTR);

//traceln("TTR: " + TTR);

//agent.prodOrderFromAgent.setActualEnd(time());
RoutingTimes actRouting = get_Main().RoutingTimesList.stream().filter(e -> e.getId() == rtId).findFirst().get();
actRouting.setEnd(time());
actRouting.setStatus(RoutingTimes.ROUTING_TIME_FINISHED);

main.sumEnergyCosts += actRouting.getUsedEnergyPriceAtEnterDelay() * ((actRouting.getEnd() - actRouting.getStart())*24);

double oldWip = get_Main().varSystemWIP;
get_Main().varSystemWIP = oldWip - agent.prodOrderFromAgent.getQuantity();
get_Main().statSystemWIP.add(get_Main().varSystemWIP, time());

varJSIperMachine -= agent.prodOrderFromAgent.getQuantity();
statJSIperMachine.add(varJSIperMachine,time());

//traceln("time" + time() + "++++++++++++++++++++++++++++++ 1 Release Check at Delay Machine " +  Resource.getDescription() + " Resource name " + Resource.getName());
//traceln("time " + time() + " planned capacity before " +  varJobShopLoadPerMachine + "machine " + Resource.getName()); 
double removeShopLoadForMachine = Routing.GetPlannedCapacityPerItemAndMachine(main, agent.prodOrderFromAgent, Resource.getName());
varJobShopLoadPerMachine -= removeShopLoadForMachine;
//traceln("time " + time() + " planned capacity after " +  varJobShopLoadPerMachine + " machine " + Resource.getName());

//traceln("========================================================== START");

//traceln("Act finsiehd step: " + actRouting.getProductionOrder().getOrderId());

//traceln(ProductionOrder.GetCSVHeader());

if(main.simParams.getEnergyBasedRelease() == 1){
	double maxEnddate = 0;
	for(ProductionOrderAgent o : queueProductionOrders){	
		//traceln(ProductionOrder.GetCSVString(o.prodOrderFromAgent));
		
		if(o.prodOrderFromAgent.getPlannedEnd() > maxEnddate)
			maxEnddate = o.prodOrderFromAgent.getPlannedEnd();
		
	}
	//double tt = (maxEnddate - time())*1440;
	//traceln(tt + " =  + ((" + maxEnddate + " + ) - " + time() + ")*1440)");
	
	//V1: double capacityThreshold = (max((maxEnddate - time()),1)*1440) *  main.simParams.getCapacityFactor();
	
	if(queueProductionOrders.size() > 0){
	
		double capacityThreshold = 1440 *  main.simParams.getCapacityFactor();
		
		//traceln("========================================================== END");
		
		//traceln("ForComparison ShoploadPerMachine " + varJobShopLoadPerMachine + "CapacityThrashold " + capacityThreshold);
		
		//traceln("Before Release: " + Resource.getDescription() + " " + hold.isBlocked());
		
		boolean releaseToMachine = false;
		releaseToMachine = EnergyRelease.EnergyBasedReleasesBlockIt(main, time());
		
		if(releaseToMachine == true){
			hold.unblock();	
		}else{
			main.countEnergyPriceBlock++;
			if(varJobShopLoadPerMachine < capacityThreshold){
			//	traceln("capacity based block hold");
				hold.block();	
				main.countCapacityFactorBlock++;
			}else{
				//traceln("NO Capacity based block hold");
				hold.unblock();	
			}
		}
	}
	//traceln("After Release: " + Resource.getDescription() + " " + hold.isBlocked() + " Resource name " + Resource.getName());
	//traceln("------------------------------ 1 Release Check at Delay Machine " +  Resource.getName() + " END");
}
]]></Code>
							</Value>
						</Parameter>
						<Parameter>
							<Name><![CDATA[onRemove]]></Name>
						</Parameter>
					</Parameters>
					<ReplicationFlag>false</ReplicationFlag>
					<Replication Class="CodeValue">
						<Code><![CDATA[100]]></Code>
					</Replication>
					<CollectionType>ARRAY_LIST_BASED</CollectionType>
					<InitialLocationType>XYZ</InitialLocationType>
					<XCode Class="CodeValue">
						<Code><![CDATA[0]]></Code>
					</XCode>
					<YCode Class="CodeValue">
						<Code><![CDATA[0]]></Code>
					</YCode>
					<ZCode Class="CodeValue">
						<Code><![CDATA[0]]></Code>
					</ZCode>
					<ColumnCode Class="CodeValue">
						<Code><![CDATA[0]]></Code>
					</ColumnCode>
					<RowCode Class="CodeValue">
						<Code><![CDATA[0]]></Code>
					</RowCode>
					<LocationNameCode Class="CodeValue">
						<Code><![CDATA[""]]></Code>
					</LocationNameCode>
					<InitializationType>SPECIFIED_NUMBER</InitializationType>
					<InitializationDatabaseTableQuery>
						<TableReference>
						</TableReference>
					</InitializationDatabaseTableQuery>
					<InitializationDatabaseType>ONE_AGENT_PER_DATABASE_RECORD</InitializationDatabaseType>
					<QuantityColumn>
					</QuantityColumn>
				</EmbeddedObject>
				<EmbeddedObject>
					<Id>1643202628049</Id>
					<Name><![CDATA[exitAccordingRouting]]></Name>
					<X>670</X><Y>50</Y>
					<Label><X>-10</X><Y>-20</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<ActiveObjectClass>
						<PackageName><![CDATA[com.anylogic.libraries.processmodeling]]></PackageName>
						<ClassName><![CDATA[Exit]]></ClassName>
					</ActiveObjectClass>
					<GenericParameterSubstitute>
						<GenericParameterSubstituteReference>
							<PackageName><![CDATA[com.anylogic.libraries.processmodeling]]></PackageName>
							<ClassName><![CDATA[Exit]]></ClassName>
							<ItemName><![CDATA[1412336242934]]></ItemName>
						</GenericParameterSubstituteReference>
					</GenericParameterSubstitute>
					<Parameters>
						<Parameter>
							<Name><![CDATA[onExit]]></Name>
							<Value Class="CodeValue">
								<Code><![CDATA[
if(agent.prodOrderFromAgent.getCurrentRoutingStep() == 
	agent.prodOrderFromAgent.getMaximumRoutingStep()){
	
	//if(SimulationParameter.MRP_PRODUCTION_ORDER_BOOKING_BEHAVIOR_PIECEWISE == 0){
	
		StockBooking currentInventory = StockBooking.GetStockItemQuantity(get_Main().stockBookings, 
		agent.prodOrderFromAgent.getItem());
		
		//Add the quantity on stock	
		StockBooking book = new StockBooking(	
			agent.prodOrderFromAgent.getItem(),
			agent.prodOrderFromAgent.getQuantity(),
			time(),
			StockBooking.BOOKING_SOURCE_PRODUCTION_ORDER,
			agent.prodOrderFromAgent.getOrderId(),
			currentInventory.getQuantity(),
			currentInventory.getTimeBetweenBookings());
			
		get_Main().stockBookings.add(book);
		
		//Component WIP acutalization. 
		if(book.getItem().getType().equals(Item.ITEM_TYPE_COMPONENT)){
			get_Main().varSystemWIPComponents = get_Main().varSystemWIPComponents + book.getQuantity();
			get_Main().statSystemWIPComponents.add(get_Main().varSystemWIPComponents, time());
		}	
	//}
	
		
	agent.prodOrderFromAgent.setStatus(ProductionOrder.PRODUCTION_ORDER_STATUS_PROCESSED);		
	agent.prodOrderFromAgent.setActualEnd(time());
	agent.prodOrderFromAgent.setConWipStatus(ProductionOrder.PRODUCTION_ORDER_CONWIP_STATUS_RELEASED);
			
	
		if(main.simParams.getApplyConWip()==SimulationParameter.APPLY_CONWIP || main.simParams.getApplyConWip()==SimulationParameter.APPLY_CONWIP_MPS){		
				 
		 int countUnfinished = 0;
       		        		        		 		 		 
		 if(countUnfinished == 0){
		 
		 	if(agent.prodOrderFromAgent.getItem().getType().equalsIgnoreCase(Item.ITEM_TYPE_SALES)){
		 		
		 		main.varSystemWorkload = main.varSystemWorkload - agent.prodOrderFromAgent.getWorkLoad();
		 	
			 	main.StatisticSystemWorkLoad.add(main.varSystemWorkload);
		 				 	
		 	}else if(agent.prodOrderFromAgent.getItem().getType().equalsIgnoreCase(Item.ITEM_TYPE_COMPONENT)){
		 		main.varSystemWorkloadComponents = main.varSystemWorkloadComponents - agent.prodOrderFromAgent.getWorkLoad();
		 	
			 	main.StatisticSystemWorkLoadComponents.add(main.varSystemWorkloadComponents);
		 	
		 	}
		 			 	
		 	//this is only done for the "normal" Conwip, the other MPS conWip uses the MRP logic
		 	
		 	if(main.simParams.getApplyConWip()==SimulationParameter.APPLY_CONWIP){
		 	//we now set the assocaited customer order as finished
		 	CustomerOrder customerOrderToFinish = 
			 	main.customerOrders.stream().filter(e -> e.getOrderId() == agent.prodOrderFromAgent.getCustomerOrderId()).
			 	findFirst().get();			 	
			 				 	
			 	StockBooking qty = StockBooking.GetStockItemQuantity(main.stockBookings, customerOrderToFinish.getItem());
				
				if(qty.getQuantity() >= customerOrderToFinish.getQuantity()){
					StockBooking bookCustOrder = new StockBooking(
					customerOrderToFinish.getItem(),
					customerOrderToFinish.getQuantity() * -1,
					time(),
					StockBooking.BOOKING_SOURCE_CUSTOMER_ORDER,
					customerOrderToFinish.getOrderId(),
					qty.getQuantity(),
					qty.getTimeBetweenBookings());										
					
					if(time() <= customerOrderToFinish.getDueDate()){						
						customerOrderToFinish.setStatus(CustomerOrder.ORDER_STATUS_FINISHED);
					}else{											
						customerOrderToFinish.setStatus(CustomerOrder.ORDER_STATUS_DELAYED_AND_BOOKED);
					}
					
					customerOrderToFinish.setActualEnd(time());				
					
					main.stockBookings.add(bookCustOrder);
					
					
				}else{
					customerOrderToFinish.setStatus(CustomerOrder.ORDER_STATUS_DELAYED);
				}			 				 			 	
				ConWip conWip = new ConWip();
		 		conWip.ApplyConWipPlanning(main.bom, main.simParams, null, null,main,time());  								
		 	}// if(main.simParams.getApplyConWip()==SimulationParameter.APPLY_CONWIP){		 		 		 						 		 				 			 			 		 			 			 	
		 }// if(main.simParams.getApplyConWip()==SimulationParameter.APPLY_CONWIP){		 		 		 						 		 		
		 		 		 		 		 		 
	}// if(main.simParams.getApplyConWip()==SimulationParameter.APPLY_CONWIP || main.simParams.getApplyConWip()==SimulationParameter.APPLY_CONWIP_MPS){		
	
			
	//add ProductionOrders to List, they are later removed as the wip is substracted
	if(time() >= main.simParams.getWarumUpTime() && main.simParams.getProdStageStatistics()==1){
		main.productionStageOrders.add(ProductionOrder.Copy(agent.prodOrderFromAgent));
	}
	

//Availability Check
if(main.simParams.getApplyConWip() == 1 || main.simParams.getApplyConWip() == SimulationParameter.APPLY_CONWIP_MPS){
	//main.Function_OrderRelease(SimulationParameter.RELEASE_ORIGIN_CONWIP_FROM_MACHINE);
	main.Function_OrderRelease("Machine");
}else{
	main.Function_OrderRelease("Machine");
}
	
	//update delayed customer orders and book material	
	if(agent.prodOrderFromAgent.getItem().getType().equals(Item.ITEM_TYPE_SALES)){
	
		//this version already considers delayed customer orders
		List<CustomerOrder> delayedCustomerOrders = get_Main().customerOrders.stream().
		filter(e -> e.getItem().getItem() == agent.prodOrderFromAgent.getItem().getItem() 
		&& e.getStatus() == CustomerOrder.ORDER_STATUS_DELAYED).sorted(Comparator.comparing(CustomerOrder::getDueDate)).collect(Collectors.toList());
		
		for(CustomerOrder custOrder : delayedCustomerOrders){
		
				StockBooking qty = StockBooking.GetStockItemQuantity(get_Main().stockBookings, custOrder.getItem());
				
				if(qty.getQuantity() >= custOrder.getQuantity()){
					StockBooking bookCo = new StockBooking(				
					custOrder.getItem(),
					custOrder.getQuantity()*-1,
					time(),
					StockBooking.BOOKING_SOURCE_CUSTOMER_ORDER,
					custOrder.getOrderId(),					
					qty.getQuantity(),
					qty.getTimeBetweenBookings());					
										
					get_Main().stockBookings.add(bookCo);
					
					custOrder.setActualEnd(time());			
					custOrder.setStatus(CustomerOrder.ORDER_STATUS_DELAYED_AND_BOOKED);	
					}else{
						break;
					}						
			}//for				
	}//sales items			
}else{

	int nextStep = agent.prodOrderFromAgent.getCurrentRoutingStep();
	nextStep++;
	
	Routing nextRoutingStep = Routing.GetResourceForRoutingStep(get_Main().routings, agent.prodOrderFromAgent.getItem(), nextStep, get_Main().simParams);
		
	MachineAgent  mm = 	get_Main().machineAgents.stream().filter(e -> e.Resource.getName().equalsIgnoreCase(nextRoutingStep.getResource())).findFirst().orElseGet(null);						
	
	agent.prodOrderFromAgent.setCurrentRoutingStep(nextStep);
	agent.markParametersAreSet();
	
	mm.prodOrderFromAgent = agent.prodOrderFromAgent;	
	mm.enterFromMaterialRelease.take(agent);	
							
}

]]></Code>
							</Value>
						</Parameter>
					</Parameters>
					<ReplicationFlag>false</ReplicationFlag>
					<Replication Class="CodeValue">
						<Code><![CDATA[100]]></Code>
					</Replication>
					<CollectionType>ARRAY_LIST_BASED</CollectionType>
					<InitialLocationType>XYZ</InitialLocationType>
					<XCode Class="CodeValue">
						<Code><![CDATA[0]]></Code>
					</XCode>
					<YCode Class="CodeValue">
						<Code><![CDATA[0]]></Code>
					</YCode>
					<ZCode Class="CodeValue">
						<Code><![CDATA[0]]></Code>
					</ZCode>
					<ColumnCode Class="CodeValue">
						<Code><![CDATA[0]]></Code>
					</ColumnCode>
					<RowCode Class="CodeValue">
						<Code><![CDATA[0]]></Code>
					</RowCode>
					<LocationNameCode Class="CodeValue">
						<Code><![CDATA[""]]></Code>
					</LocationNameCode>
					<InitializationType>SPECIFIED_NUMBER</InitializationType>
					<InitializationDatabaseTableQuery>
						<TableReference>
						</TableReference>
					</InitializationDatabaseTableQuery>
					<InitializationDatabaseType>ONE_AGENT_PER_DATABASE_RECORD</InitializationDatabaseType>
					<QuantityColumn>
					</QuantityColumn>
				</EmbeddedObject>
				<EmbeddedObject>
					<Id>1644310951322</Id>
					<Name><![CDATA[materialRelease]]></Name>
					<X>460</X><Y>140</Y>
					<Label><X>15</X><Y>-5</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<ActiveObjectClass>
						<PackageName><![CDATA[simopt]]></PackageName>
						<ClassName><![CDATA[MaterialRelease]]></ClassName>
					</ActiveObjectClass>
					<GenericParameterSubstitute>
						<GenericParameterSubstituteReference>
							<PackageName><![CDATA[simopt]]></PackageName>
							<ClassName><![CDATA[MaterialRelease]]></ClassName>
							<ItemName><![CDATA[1644220982690]]></ItemName>
						</GenericParameterSubstituteReference>
					</GenericParameterSubstitute>
					<Parameters>
						<Parameter>
							<Name><![CDATA[prodOrderFromAgent]]></Name>
						</Parameter>
					</Parameters>
					<ReplicationFlag>false</ReplicationFlag>
					<Replication Class="CodeValue">
						<Code><![CDATA[100]]></Code>
					</Replication>
					<CollectionType>ARRAY_LIST_BASED</CollectionType>
					<InEnvironment>true</InEnvironment>	
					<InitialLocationType>XYZ</InitialLocationType>
					<XCode Class="CodeValue">
						<Code><![CDATA[0]]></Code>
					</XCode>
					<YCode Class="CodeValue">
						<Code><![CDATA[0]]></Code>
					</YCode>
					<ZCode Class="CodeValue">
						<Code><![CDATA[0]]></Code>
					</ZCode>
					<ColumnCode Class="CodeValue">
						<Code><![CDATA[0]]></Code>
					</ColumnCode>
					<RowCode Class="CodeValue">
						<Code><![CDATA[0]]></Code>
					</RowCode>
					<LocationNameCode Class="CodeValue">
						<Code><![CDATA[""]]></Code>
					</LocationNameCode>
					<InitializationType>SPECIFIED_NUMBER</InitializationType>
					<InitializationDatabaseTableQuery>
						<TableReference>
						</TableReference>
					</InitializationDatabaseTableQuery>
					<InitializationDatabaseType>ONE_AGENT_PER_DATABASE_RECORD</InitializationDatabaseType>
					<QuantityColumn>
					</QuantityColumn>
				</EmbeddedObject>
				<EmbeddedObject>
					<Id>1693556903148</Id>
					<Name><![CDATA[delayRepair]]></Name>
					<X>520</X><Y>40</Y>
					<Label><X>0</X><Y>-10</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<ActiveObjectClass>
						<PackageName><![CDATA[com.anylogic.libraries.processmodeling]]></PackageName>
						<ClassName><![CDATA[Delay]]></ClassName>
					</ActiveObjectClass>
					<GenericParameterSubstitute>
						<GenericParameterSubstituteReference>
							<PackageName><![CDATA[com.anylogic.libraries.processmodeling]]></PackageName>
							<ClassName><![CDATA[Delay]]></ClassName>
							<ItemName><![CDATA[1412336242930]]></ItemName>
						</GenericParameterSubstituteReference>
						<GenericParameterSubstituteValue Class="CodeValue">
							<Code><![CDATA[ProductionOrderAgent]]></Code>
						</GenericParameterSubstituteValue>
					</GenericParameterSubstitute>
					<Parameters>
						<Parameter>
							<Name><![CDATA[type]]></Name>
						</Parameter>
						<Parameter>
							<Name><![CDATA[delayTime]]></Name>
							<Value Class="CodeUnitValue">
								<Code><![CDATA[TTR]]></Code>
								<Unit Class="TimeUnits"><![CDATA[MINUTE]]></Unit>
							</Value>
						</Parameter>
						<Parameter>
							<Name><![CDATA[capacity]]></Name>
							<Value Class="CodeValue">
								<Code><![CDATA[parResourceCapacity]]></Code>
							</Value>
						</Parameter>
						<Parameter>
							<Name><![CDATA[maximumCapacity]]></Name>
						</Parameter>
						<Parameter>
							<Name><![CDATA[entityLocation]]></Name>
						</Parameter>
						<Parameter>
							<Name><![CDATA[pushProtocol]]></Name>
						</Parameter>
						<Parameter>
							<Name><![CDATA[restoreEntityLocationOnExit]]></Name>
						</Parameter>
						<Parameter>
							<Name><![CDATA[forceStatisticsCollection]]></Name>
						</Parameter>
						<Parameter>
							<Name><![CDATA[onEnter]]></Name>
							<Value Class="CodeValue">
								<Code><![CDATA[//traceln("Enter Delay Repair: " + TTR + " time " + time());
//traceln(time() + "At enter delay " + agent.prodOrderFromAgent.getOrderId() + "ttpt: " +agent.prodOrderFromAgent.getTotalProcessingTime());
]]></Code>
							</Value>
						</Parameter>
						<Parameter>
							<Name><![CDATA[onAtExit]]></Name>
						</Parameter>
						<Parameter>
							<Name><![CDATA[onExit]]></Name>
							<Value Class="CodeValue">
								<Code><![CDATA[//traceln("On Exit Delay Repair: " + TTR + " time " + time());
//traceln(time() + "At enter delay " + agent.prodOrderFromAgent.getOrderId() + "ttpt: " +agent.prodOrderFromAgent.getTotalProcessingTime());
]]></Code>
							</Value>
						</Parameter>
						<Parameter>
							<Name><![CDATA[onRemove]]></Name>
						</Parameter>
					</Parameters>
					<ReplicationFlag>false</ReplicationFlag>
					<Replication Class="CodeValue">
						<Code><![CDATA[100]]></Code>
					</Replication>
					<CollectionType>ARRAY_LIST_BASED</CollectionType>
					<InitialLocationType>XYZ</InitialLocationType>
					<XCode Class="CodeValue">
						<Code><![CDATA[0]]></Code>
					</XCode>
					<YCode Class="CodeValue">
						<Code><![CDATA[0]]></Code>
					</YCode>
					<ZCode Class="CodeValue">
						<Code><![CDATA[0]]></Code>
					</ZCode>
					<ColumnCode Class="CodeValue">
						<Code><![CDATA[0]]></Code>
					</ColumnCode>
					<RowCode Class="CodeValue">
						<Code><![CDATA[0]]></Code>
					</RowCode>
					<LocationNameCode Class="CodeValue">
						<Code><![CDATA[""]]></Code>
					</LocationNameCode>
					<InitializationType>SPECIFIED_NUMBER</InitializationType>
					<InitializationDatabaseTableQuery>
						<TableReference>
						</TableReference>
					</InitializationDatabaseTableQuery>
					<InitializationDatabaseType>ONE_AGENT_PER_DATABASE_RECORD</InitializationDatabaseType>
					<QuantityColumn>
					</QuantityColumn>
				</EmbeddedObject>
				<EmbeddedObject>
					<Id>1712983680091</Id>
					<Name><![CDATA[hold]]></Name>
					<X>290</X><Y>50</Y>
					<Label><X>-10</X><Y>-20</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<ActiveObjectClass>
						<PackageName><![CDATA[com.anylogic.libraries.processmodeling]]></PackageName>
						<ClassName><![CDATA[Hold]]></ClassName>
					</ActiveObjectClass>
					<GenericParameterSubstitute>
						<GenericParameterSubstituteReference>
							<PackageName><![CDATA[com.anylogic.libraries.processmodeling]]></PackageName>
							<ClassName><![CDATA[Hold]]></ClassName>
							<ItemName><![CDATA[1412336242940]]></ItemName>
						</GenericParameterSubstituteReference>
					</GenericParameterSubstitute>
					<Parameters>
						<Parameter>
							<Name><![CDATA[mode]]></Name>
						</Parameter>
						<Parameter>
							<Name><![CDATA[nEntitiesForSelfBlock]]></Name>
							<Value Class="CodeValue">
								<Code><![CDATA[5]]></Code>
							</Value>
						</Parameter>
						<Parameter>
							<Name><![CDATA[condition]]></Name>
							<Value Class="CodeValue">
								<Code><![CDATA[blockIt]]></Code>
							</Value>
						</Parameter>
						<Parameter>
							<Name><![CDATA[initiallyBlocked]]></Name>
						</Parameter>
						<Parameter>
							<Name><![CDATA[onEnter]]></Name>
							<Value Class="CodeValue">
								<Code><![CDATA[//MachineAgent  mm = 	main.machineAgents.stream().filter(e -> 
//e.Resource.getName().equalsIgnoreCase(agent.prodOrderFromAgent.getRouting().getResource())).findFirst().orElseGet(null);									

//traceln("HOLD Order Block " +agent.prodOrderFromAgent.getOrderId() + " Machine " + mm.Resource.getDescription() + " is blocked " + mm.hold.isBlocked());
]]></Code>
							</Value>
						</Parameter>
					</Parameters>
					<ReplicationFlag>false</ReplicationFlag>
					<Replication Class="CodeValue">
						<Code><![CDATA[100]]></Code>
					</Replication>
					<CollectionType>ARRAY_LIST_BASED</CollectionType>
					<InitialLocationType>XYZ</InitialLocationType>
					<XCode Class="CodeValue">
						<Code><![CDATA[0]]></Code>
					</XCode>
					<YCode Class="CodeValue">
						<Code><![CDATA[0]]></Code>
					</YCode>
					<ZCode Class="CodeValue">
						<Code><![CDATA[0]]></Code>
					</ZCode>
					<ColumnCode Class="CodeValue">
						<Code><![CDATA[0]]></Code>
					</ColumnCode>
					<RowCode Class="CodeValue">
						<Code><![CDATA[0]]></Code>
					</RowCode>
					<LocationNameCode Class="CodeValue">
						<Code><![CDATA[""]]></Code>
					</LocationNameCode>
					<InitializationType>SPECIFIED_NUMBER</InitializationType>
					<InitializationDatabaseTableQuery>
						<TableReference>
						</TableReference>
					</InitializationDatabaseTableQuery>
					<InitializationDatabaseType>ONE_AGENT_PER_DATABASE_RECORD</InitializationDatabaseType>
					<QuantityColumn>
					</QuantityColumn>
				</EmbeddedObject>
			</EmbeddedObjects>

			<Presentation>
				<Level>
					<Id>1643198210442</Id>
					<Name><![CDATA[level]]></Name>
					<X>0</X><Y>0</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>true</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>false</ShowLabel>
					<DrawMode>SHAPE_DRAW_2D3D</DrawMode>
					<Z>0</Z>
					<LevelVisibility>DIM_NON_CURRENT</LevelVisibility>

			<Presentation>
				<Text>
					<Id>1693557574623</Id>
					<Name><![CDATA[text8]]></Name>
					<X>400</X><Y>420</Y>
					<Label><X>0</X><Y>-10</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>false</ShowLabel>
					<DrawMode>SHAPE_DRAW_2D</DrawMode>
					<EmbeddedIcon>false</EmbeddedIcon>
					<Z>0</Z>
					<Rotation>0.0</Rotation>
					<Color>-16744320</Color>
					<Text><![CDATA[Failure behavior]]></Text>
					<Font>
						<Name>Arial</Name>
						<Size>16</Size>
						<Style>1</Style>
					</Font>
					<Alignment>LEFT</Alignment>
				</Text>
			</Presentation>

				</Level>
			</Presentation>

		</ActiveObjectClass>
		<!--   =========   Active Object Class   ========  -->
		<ActiveObjectClass>
			<Id>1644220982692</Id>
			<Name><![CDATA[MaterialRelease]]></Name>
			<Import><![CDATA[import java.util.stream.*;]]></Import>
			<Generic>false</Generic>
			<GenericParameter>
				<Id>1644220982690</Id>
				<Name><![CDATA[1644220982690]]></Name>
				<GenericParameterValue Class="CodeValue">
					<Code><![CDATA[T extends Agent]]></Code>
				</GenericParameterValue>
				<GenericParameterLabel><![CDATA[Generic parameter:]]></GenericParameterLabel>
			</GenericParameter>
			<FlowChartsUsage>ENTITY</FlowChartsUsage>
			<SamplesToKeep>100</SamplesToKeep>
			<LimitNumberOfArrayElements>false</LimitNumberOfArrayElements>
			<ElementsLimitValue>100</ElementsLimitValue>
			<MakeDefaultViewArea>true</MakeDefaultViewArea>
			<SceneGridColor/>
			<SceneBackgroundColor/>
			<SceneSkybox>null</SceneSkybox>
			<AgentProperties>
				<EnvironmentDefinesInitialLocation>true</EnvironmentDefinesInitialLocation>
				<RotateAnimationTowardsMovement>true</RotateAnimationTowardsMovement>
				<RotateAnimationVertically>false</RotateAnimationVertically>
				<VelocityCode Class="CodeUnitValue">
					<Code><![CDATA[10]]></Code>
					<Unit Class="SpeedUnits"><![CDATA[MPS]]></Unit>
				</VelocityCode>
				<PhysicalLength Class="CodeUnitValue">
					<Code><![CDATA[1]]></Code>
					<Unit Class="LengthUnits"><![CDATA[METER]]></Unit>
				</PhysicalLength>
				<PhysicalWidth Class="CodeUnitValue">
					<Code><![CDATA[1]]></Code>
					<Unit Class="LengthUnits"><![CDATA[METER]]></Unit>
				</PhysicalWidth>
				<PhysicalHeight Class="CodeUnitValue">
					<Code><![CDATA[1]]></Code>
					<Unit Class="LengthUnits"><![CDATA[METER]]></Unit>
				</PhysicalHeight>
			</AgentProperties>
			<EnvironmentProperties>
					<EnableSteps>false</EnableSteps>
					<StepDurationCode Class="CodeUnitValue">
						<Code><![CDATA[1.0]]></Code>
						<Unit Class="TimeUnits"><![CDATA[SECOND]]></Unit>
					</StepDurationCode>
					<SpaceType>CONTINUOUS</SpaceType>
					<WidthCode><![CDATA[500]]></WidthCode>
					<HeightCode><![CDATA[500]]></HeightCode>
					<ZHeightCode><![CDATA[0]]></ZHeightCode>
					<ColumnsCountCode><![CDATA[100]]></ColumnsCountCode>
					<RowsCountCode><![CDATA[100]]></RowsCountCode>
					<NeigborhoodType>MOORE</NeigborhoodType>
					<LayoutType>USER_DEF</LayoutType>
					<NetworkType>USER_DEF</NetworkType>
					<ConnectionsPerAgentCode><![CDATA[2]]></ConnectionsPerAgentCode>
					<ConnectionsRangeCode><![CDATA[50]]></ConnectionsRangeCode>
					<NeighborLinkFractionCode><![CDATA[0.95]]></NeighborLinkFractionCode>
					<MCode><![CDATA[10]]></MCode>
			</EnvironmentProperties>
			<DatasetsCreationProperties>
				<AutoCreate>true</AutoCreate>
					<OccurrenceAtTime>true</OccurrenceAtTime>
					<OccurrenceDate>1644307200000</OccurrenceDate>
					<OccurrenceTime Class="CodeUnitValue">
						<Code><![CDATA[0]]></Code>
						<Unit Class="TimeUnits"><![CDATA[DAY]]></Unit>
					</OccurrenceTime>
					<RecurrenceCode Class="CodeUnitValue">
						<Code><![CDATA[1]]></Code>
						<Unit Class="TimeUnits"><![CDATA[DAY]]></Unit>
					</RecurrenceCode>
			</DatasetsCreationProperties>
			<ScaleRuler>
				<Id>1644220982688</Id>
				<Name><![CDATA[scale]]></Name>
				<X>0</X><Y>-150</Y>
				<PublicFlag>false</PublicFlag>
				<PresentationFlag>false</PresentationFlag>
				<ShowLabel>false</ShowLabel>
				<DrawMode>SHAPE_DRAW_2D3D</DrawMode>
				<Length>100</Length>
				<Rotation>0</Rotation>
				<ScaleType>BASED_ON_LENGTH</ScaleType>
				<ModelLength>10</ModelLength>
				<LengthUnits>METER</LengthUnits>
				<Scale>10</Scale>
				<InheritedFromParentAgentType>true</InheritedFromParentAgentType>
			</ScaleRuler>
			<CurrentLevel>1644220982691</CurrentLevel>
			<ConnectionsId>1644220982687</ConnectionsId>
			<Variables>
				<Variable Class="Parameter">
					<Id>1644251277354</Id>
					<Name><![CDATA[prodOrderFromAgent]]></Name>
					<X>70</X><Y>80</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Properties SaveInSnapshot="true" ModificatorType="STATIC">
						<Type><![CDATA[ProductionOrder]]></Type>
						<UnitType><![CDATA[NONE]]></UnitType>
						<SdArray>false</SdArray>
						<ParameterEditor>
							<Id>1644251277352</Id>
							<EditorContolType>TEXT_BOX</EditorContolType>
							<MinSliderValue><![CDATA[0]]></MinSliderValue>
							<MaxSliderValue><![CDATA[100]]></MaxSliderValue>
							<DelimeterType>NO_DELIMETER</DelimeterType>
						</ParameterEditor>
					</Properties>                 
				</Variable>
			</Variables>
			<Connectors>
				<Connector>
					<Id>1644322909065</Id>
					<Name><![CDATA[connector2]]></Name>
					<X>230</X><Y>140</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>false</ShowLabel>
					<SourceEmbeddedObjectReference>
						<PackageName><![CDATA[simopt]]></PackageName>
						<ClassName><![CDATA[MaterialRelease]]></ClassName>
						<ItemName><![CDATA[selectOutput]]></ItemName>
					</SourceEmbeddedObjectReference>
					<SourceConnectableItemReference>
						<PackageName><![CDATA[com.anylogic.libraries.processmodeling]]></PackageName>
						<ClassName><![CDATA[SelectOutput]]></ClassName>
						<ItemName><![CDATA[in]]></ItemName>
					</SourceConnectableItemReference>
					<TargetEmbeddedObjectReference>
						<PackageName><![CDATA[simopt]]></PackageName>
						<ClassName><![CDATA[MaterialRelease]]></ClassName>
						<ItemName><![CDATA[enter_from_MRP]]></ItemName>
					</TargetEmbeddedObjectReference>
					<TargetConnectableItemReference>
						<PackageName><![CDATA[com.anylogic.libraries.processmodeling]]></PackageName>
						<ClassName><![CDATA[Enter]]></ClassName>
						<ItemName><![CDATA[out]]></ItemName>
					</TargetConnectableItemReference>
					<Points>
						<Point><X>0</X><Y>0</Y></Point>
						<Point><X>-140</X><Y>0</Y></Point>
					</Points>
				</Connector>
				<Connector>
					<Id>1644322928298</Id>
					<Name><![CDATA[connector5]]></Name>
					<X>350</X><Y>140</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>false</ShowLabel>
					<SourceEmbeddedObjectReference>
						<PackageName><![CDATA[simopt]]></PackageName>
						<ClassName><![CDATA[MaterialRelease]]></ClassName>
						<ItemName><![CDATA[exit_to_machine]]></ItemName>
					</SourceEmbeddedObjectReference>
					<SourceConnectableItemReference>
						<PackageName><![CDATA[com.anylogic.libraries.processmodeling]]></PackageName>
						<ClassName><![CDATA[Exit]]></ClassName>
						<ItemName><![CDATA[in]]></ItemName>
					</SourceConnectableItemReference>
					<TargetEmbeddedObjectReference>
						<PackageName><![CDATA[simopt]]></PackageName>
						<ClassName><![CDATA[MaterialRelease]]></ClassName>
						<ItemName><![CDATA[selectOutput]]></ItemName>
					</TargetEmbeddedObjectReference>
					<TargetConnectableItemReference>
						<PackageName><![CDATA[com.anylogic.libraries.processmodeling]]></PackageName>
						<ClassName><![CDATA[SelectOutput]]></ClassName>
						<ItemName><![CDATA[outT]]></ItemName>
					</TargetConnectableItemReference>
					<Points>
						<Point><X>0</X><Y>0</Y></Point>
						<Point><X>-100</X><Y>0</Y></Point>
					</Points>
				</Connector>
				<Connector>
					<Id>1667658668888</Id>
					<Name><![CDATA[connector]]></Name>
					<X>0</X><Y>0</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>false</ShowLabel>
					<SourceEmbeddedObjectReference>
						<PackageName><![CDATA[simopt]]></PackageName>
						<ClassName><![CDATA[MaterialRelease]]></ClassName>
						<ItemName><![CDATA[exit]]></ItemName>
					</SourceEmbeddedObjectReference>
					<SourceConnectableItemReference>
						<PackageName><![CDATA[com.anylogic.libraries.processmodeling]]></PackageName>
						<ClassName><![CDATA[Exit]]></ClassName>
						<ItemName><![CDATA[in]]></ItemName>
					</SourceConnectableItemReference>
					<TargetEmbeddedObjectReference>
						<PackageName><![CDATA[simopt]]></PackageName>
						<ClassName><![CDATA[MaterialRelease]]></ClassName>
						<ItemName><![CDATA[selectOutput]]></ItemName>
					</TargetEmbeddedObjectReference>
					<TargetConnectableItemReference>
						<PackageName><![CDATA[com.anylogic.libraries.processmodeling]]></PackageName>
						<ClassName><![CDATA[SelectOutput]]></ClassName>
						<ItemName><![CDATA[outF]]></ItemName>
					</TargetConnectableItemReference>
					<Points>
						<Point><X>240</X><Y>210</Y></Point>
						<Point><X>240</X><Y>150</Y></Point>
					</Points>
				</Connector>
			</Connectors>
			<Functions>
				<Function AccessType="public" StaticFunction="false">
					<ReturnModificator>RETURNS_VALUE</ReturnModificator>
					<ReturnType><![CDATA[String]]></ReturnType>
					<Id>1644923608227</Id>
					<Name><![CDATA[toString]]></Name>
					<X>260</X><Y>50</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Body><![CDATA[return
	"prodOrderFromAgent = " + prodOrderFromAgent;]]></Body>
				</Function>
			</Functions>
			<AgentLinks>
				<AgentLink>
					<Id>1644220982687</Id>
					<Name><![CDATA[connections]]></Name>
					<X>50</X><Y>-50</Y>
					<Label><X>15</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<HandleReceiveInConnections>false</HandleReceiveInConnections>
					<AgentLinkType>COLLECTION_OF_LINKS</AgentLinkType>
					<AgentLinkBidirectional>true</AgentLinkBidirectional>
					<MessageType><![CDATA[Object]]></MessageType>
					<LineStyle>SOLID</LineStyle>
					<LineWidth>1</LineWidth>
					<LineColor>-16777216</LineColor>
					<LineZOrder>UNDER_AGENTS</LineZOrder>
					<LineArrow>NONE</LineArrow>
					<LineArrowPosition>END</LineArrowPosition>
				</AgentLink>
			</AgentLinks>

			<ContainerLinks>
				<ContainerLink>
					<Id>1644308405961</Id>
					<Name><![CDATA[main]]></Name>
					<X>50</X><Y>-100</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<ActiveObjectClass>
						<PackageName><![CDATA[simopt]]></PackageName>
						<ClassName><![CDATA[Main]]></ClassName>
					</ActiveObjectClass>
				</ContainerLink>
				<ContainerLink>
					<Id>1644310952190</Id>
					<Name><![CDATA[machineAgent]]></Name>
					<X>150</X><Y>-100</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<ActiveObjectClass>
						<PackageName><![CDATA[simopt]]></PackageName>
						<ClassName><![CDATA[MachineAgent]]></ClassName>
					</ActiveObjectClass>
				</ContainerLink>
			</ContainerLinks>
			<EmbeddedObjects>
				<EmbeddedObject>
					<Id>1644322838165</Id>
					<Name><![CDATA[enter_from_MRP]]></Name>
					<X>70</X><Y>130</Y>
					<Label><X>-10</X><Y>-20</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<ActiveObjectClass>
						<PackageName><![CDATA[com.anylogic.libraries.processmodeling]]></PackageName>
						<ClassName><![CDATA[Enter]]></ClassName>
					</ActiveObjectClass>
					<GenericParameterSubstitute>
						<GenericParameterSubstituteReference>
							<PackageName><![CDATA[com.anylogic.libraries.processmodeling]]></PackageName>
							<ClassName><![CDATA[Enter]]></ClassName>
							<ItemName><![CDATA[1412336242933]]></ItemName>
						</GenericParameterSubstituteReference>
					</GenericParameterSubstitute>
					<Parameters>
						<Parameter>
							<Name><![CDATA[locationType]]></Name>
						</Parameter>
						<Parameter>
							<Name><![CDATA[locationX]]></Name>
						</Parameter>
						<Parameter>
							<Name><![CDATA[locationY]]></Name>
						</Parameter>
						<Parameter>
							<Name><![CDATA[locationZ]]></Name>
						</Parameter>
						<Parameter>
							<Name><![CDATA[locationLatitude]]></Name>
						</Parameter>
						<Parameter>
							<Name><![CDATA[locationLongitude]]></Name>
						</Parameter>
						<Parameter>
							<Name><![CDATA[locationGeoPlaceName]]></Name>
						</Parameter>
						<Parameter>
							<Name><![CDATA[locationXYZInNetwork]]></Name>
						</Parameter>
						<Parameter>
							<Name><![CDATA[locationNetwork]]></Name>
						</Parameter>
						<Parameter>
							<Name><![CDATA[locationLevel]]></Name>
						</Parameter>
						<Parameter>
							<Name><![CDATA[locationNode]]></Name>
						</Parameter>
						<Parameter>
							<Name><![CDATA[locationAttractor]]></Name>
						</Parameter>
						<Parameter>
							<Name><![CDATA[speed]]></Name>
						</Parameter>
						<Parameter>
							<Name><![CDATA[changeDimensions]]></Name>
						</Parameter>
						<Parameter>
							<Name><![CDATA[length]]></Name>
						</Parameter>
						<Parameter>
							<Name><![CDATA[width]]></Name>
						</Parameter>
						<Parameter>
							<Name><![CDATA[height]]></Name>
						</Parameter>
						<Parameter>
							<Name><![CDATA[addToCustomPopulation]]></Name>
						</Parameter>
						<Parameter>
							<Name><![CDATA[population]]></Name>
						</Parameter>
						<Parameter>
							<Name><![CDATA[pushProtocol]]></Name>
						</Parameter>
						<Parameter>
							<Name><![CDATA[onEnter]]></Name>
						</Parameter>
						<Parameter>
							<Name><![CDATA[onRemove]]></Name>
						</Parameter>
						<Parameter>
							<Name><![CDATA[onAtEnter]]></Name>
						</Parameter>
					</Parameters>
					<ReplicationFlag>false</ReplicationFlag>
					<Replication Class="CodeValue">
						<Code><![CDATA[100]]></Code>
					</Replication>
					<CollectionType>ARRAY_LIST_BASED</CollectionType>
					<InitialLocationType>XYZ</InitialLocationType>
					<XCode Class="CodeValue">
						<Code><![CDATA[0]]></Code>
					</XCode>
					<YCode Class="CodeValue">
						<Code><![CDATA[0]]></Code>
					</YCode>
					<ZCode Class="CodeValue">
						<Code><![CDATA[0]]></Code>
					</ZCode>
					<ColumnCode Class="CodeValue">
						<Code><![CDATA[0]]></Code>
					</ColumnCode>
					<RowCode Class="CodeValue">
						<Code><![CDATA[0]]></Code>
					</RowCode>
					<LocationNameCode Class="CodeValue">
						<Code><![CDATA[""]]></Code>
					</LocationNameCode>
					<InitializationType>SPECIFIED_NUMBER</InitializationType>
					<InitializationDatabaseTableQuery>
						<TableReference>
						</TableReference>
					</InitializationDatabaseTableQuery>
					<InitializationDatabaseType>ONE_AGENT_PER_DATABASE_RECORD</InitializationDatabaseType>
					<QuantityColumn>
					</QuantityColumn>
				</EmbeddedObject>
				<EmbeddedObject>
					<Id>1644322906677</Id>
					<Name><![CDATA[selectOutput]]></Name>
					<X>220</X><Y>130</Y>
					<Label><X>-20</X><Y>-25</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<ActiveObjectClass>
						<PackageName><![CDATA[com.anylogic.libraries.processmodeling]]></PackageName>
						<ClassName><![CDATA[SelectOutput]]></ClassName>
					</ActiveObjectClass>
					<GenericParameterSubstitute>
						<GenericParameterSubstituteReference>
							<PackageName><![CDATA[com.anylogic.libraries.processmodeling]]></PackageName>
							<ClassName><![CDATA[SelectOutput]]></ClassName>
							<ItemName><![CDATA[1412336242931]]></ItemName>
						</GenericParameterSubstituteReference>
						<GenericParameterSubstituteValue Class="CodeValue">
							<Code><![CDATA[ProductionOrderAgent]]></Code>
						</GenericParameterSubstituteValue>
					</GenericParameterSubstitute>
					<Parameters>
						<Parameter>
							<Name><![CDATA[conditionIsProbabilistic]]></Name>
							<Value Class="CodeValue">
								<Code><![CDATA[false]]></Code>
							</Value>
						</Parameter>
						<Parameter>
							<Name><![CDATA[condition]]></Name>
							<Value Class="CodeValue">
								<Code><![CDATA[agent.prodOrderFromAgent.getStatus() == ProductionOrder.PRODUCTION_ORDER_STATUS_RELEASED]]></Code>
							</Value>
						</Parameter>
						<Parameter>
							<Name><![CDATA[probability]]></Name>
						</Parameter>
						<Parameter>
							<Name><![CDATA[onAtEnter]]></Name>
						</Parameter>
						<Parameter>
							<Name><![CDATA[onEnter]]></Name>
							<Value Class="CodeValue">
								<Code><![CDATA[//traceln("Material Release so at enter prodorder id " + agent.prodOrderFromAgent.getOrderId() + " status " + agent.prodOrderFromAgent.getStatus() + " planned start " + agent.prodOrderFromAgent.getPlannedStart());]]></Code>
							</Value>
						</Parameter>
						<Parameter>
							<Name><![CDATA[onExitTrue]]></Name>
							<Value Class="CodeValue">
								<Code><![CDATA[//exit_to_machine.
agent.prodOrderFromAgent.setActualReleaseDate(time());]]></Code>
							</Value>
						</Parameter>
						<Parameter>
							<Name><![CDATA[onExitFalse]]></Name>
							<Value Class="CodeValue">
								<Code><![CDATA[//traceln("false");]]></Code>
							</Value>
						</Parameter>
					</Parameters>
					<ReplicationFlag>false</ReplicationFlag>
					<Replication Class="CodeValue">
						<Code><![CDATA[100]]></Code>
					</Replication>
					<CollectionType>ARRAY_LIST_BASED</CollectionType>
					<InitialLocationType>XYZ</InitialLocationType>
					<XCode Class="CodeValue">
						<Code><![CDATA[0]]></Code>
					</XCode>
					<YCode Class="CodeValue">
						<Code><![CDATA[0]]></Code>
					</YCode>
					<ZCode Class="CodeValue">
						<Code><![CDATA[0]]></Code>
					</ZCode>
					<ColumnCode Class="CodeValue">
						<Code><![CDATA[0]]></Code>
					</ColumnCode>
					<RowCode Class="CodeValue">
						<Code><![CDATA[0]]></Code>
					</RowCode>
					<LocationNameCode Class="CodeValue">
						<Code><![CDATA[""]]></Code>
					</LocationNameCode>
					<InitializationType>SPECIFIED_NUMBER</InitializationType>
					<InitializationDatabaseTableQuery>
						<TableReference>
						</TableReference>
					</InitializationDatabaseTableQuery>
					<InitializationDatabaseType>ONE_AGENT_PER_DATABASE_RECORD</InitializationDatabaseType>
					<QuantityColumn>
					</QuantityColumn>
				</EmbeddedObject>
				<EmbeddedObject>
					<Id>1644322924195</Id>
					<Name><![CDATA[exit_to_machine]]></Name>
					<X>350</X><Y>130</Y>
					<Label><X>-10</X><Y>-20</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<ActiveObjectClass>
						<PackageName><![CDATA[com.anylogic.libraries.processmodeling]]></PackageName>
						<ClassName><![CDATA[Exit]]></ClassName>
					</ActiveObjectClass>
					<GenericParameterSubstitute>
						<GenericParameterSubstituteReference>
							<PackageName><![CDATA[com.anylogic.libraries.processmodeling]]></PackageName>
							<ClassName><![CDATA[Exit]]></ClassName>
							<ItemName><![CDATA[1412336242934]]></ItemName>
						</GenericParameterSubstituteReference>
					</GenericParameterSubstitute>
					<Parameters>
						<Parameter>
							<Name><![CDATA[onExit]]></Name>
							<Value Class="CodeValue">
								<Code><![CDATA[//traceln("**************************** exit to machine " + agent.prodOrderFromAgent.getOrderId());																

ProductionOrderAgent newOrder = new ProductionOrderAgent();
newOrder.prodOrderFromAgent = agent.prodOrderFromAgent;
newOrder.markParametersAreSet();	
							
MachineAgent  mm = 	get_Main().machineAgents.stream().filter(e -> 
e.Resource.getName().equalsIgnoreCase(agent.prodOrderFromAgent.getRouting().getResource())).findFirst().orElseGet(null);									
mm.prodOrderFromAgent = agent.prodOrderFromAgent;
mm.enterFromMaterialRelease.take(newOrder);
]]></Code>
							</Value>
						</Parameter>
					</Parameters>
					<ReplicationFlag>false</ReplicationFlag>
					<Replication Class="CodeValue">
						<Code><![CDATA[100]]></Code>
					</Replication>
					<CollectionType>ARRAY_LIST_BASED</CollectionType>
					<InitialLocationType>XYZ</InitialLocationType>
					<XCode Class="CodeValue">
						<Code><![CDATA[0]]></Code>
					</XCode>
					<YCode Class="CodeValue">
						<Code><![CDATA[0]]></Code>
					</YCode>
					<ZCode Class="CodeValue">
						<Code><![CDATA[0]]></Code>
					</ZCode>
					<ColumnCode Class="CodeValue">
						<Code><![CDATA[0]]></Code>
					</ColumnCode>
					<RowCode Class="CodeValue">
						<Code><![CDATA[0]]></Code>
					</RowCode>
					<LocationNameCode Class="CodeValue">
						<Code><![CDATA[""]]></Code>
					</LocationNameCode>
					<InitializationType>SPECIFIED_NUMBER</InitializationType>
					<InitializationDatabaseTableQuery>
						<TableReference>
						</TableReference>
					</InitializationDatabaseTableQuery>
					<InitializationDatabaseType>ONE_AGENT_PER_DATABASE_RECORD</InitializationDatabaseType>
					<QuantityColumn>
					</QuantityColumn>
				</EmbeddedObject>
				<EmbeddedObject>
					<Id>1667658667658</Id>
					<Name><![CDATA[exit]]></Name>
					<X>240</X><Y>200</Y>
					<Label><X>-10</X><Y>-15</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<ActiveObjectClass>
						<PackageName><![CDATA[com.anylogic.libraries.processmodeling]]></PackageName>
						<ClassName><![CDATA[Exit]]></ClassName>
					</ActiveObjectClass>
					<GenericParameterSubstitute>
						<GenericParameterSubstituteReference>
							<PackageName><![CDATA[com.anylogic.libraries.processmodeling]]></PackageName>
							<ClassName><![CDATA[Exit]]></ClassName>
							<ItemName><![CDATA[1412336242934]]></ItemName>
						</GenericParameterSubstituteReference>
					</GenericParameterSubstitute>
					<Parameters>
						<Parameter>
							<Name><![CDATA[onExit]]></Name>
						</Parameter>
					</Parameters>
					<ReplicationFlag>false</ReplicationFlag>
					<Replication Class="CodeValue">
						<Code><![CDATA[100]]></Code>
					</Replication>
					<CollectionType>ARRAY_LIST_BASED</CollectionType>
					<InitialLocationType>XYZ</InitialLocationType>
					<XCode Class="CodeValue">
						<Code><![CDATA[0]]></Code>
					</XCode>
					<YCode Class="CodeValue">
						<Code><![CDATA[0]]></Code>
					</YCode>
					<ZCode Class="CodeValue">
						<Code><![CDATA[0]]></Code>
					</ZCode>
					<ColumnCode Class="CodeValue">
						<Code><![CDATA[0]]></Code>
					</ColumnCode>
					<RowCode Class="CodeValue">
						<Code><![CDATA[0]]></Code>
					</RowCode>
					<LocationNameCode Class="CodeValue">
						<Code><![CDATA[""]]></Code>
					</LocationNameCode>
					<InitializationType>SPECIFIED_NUMBER</InitializationType>
					<InitializationDatabaseTableQuery>
						<TableReference>
						</TableReference>
					</InitializationDatabaseTableQuery>
					<InitializationDatabaseType>ONE_AGENT_PER_DATABASE_RECORD</InitializationDatabaseType>
					<QuantityColumn>
					</QuantityColumn>
				</EmbeddedObject>
			</EmbeddedObjects>

			<Presentation>
				<Level>
					<Id>1644220982691</Id>
					<Name><![CDATA[level]]></Name>
					<X>0</X><Y>0</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>true</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>false</ShowLabel>
					<DrawMode>SHAPE_DRAW_2D3D</DrawMode>
					<Z>0</Z>
					<LevelVisibility>DIM_NON_CURRENT</LevelVisibility>

			<Presentation>
				<Text>
					<Id>1644324482931</Id>
					<Name><![CDATA[text]]></Name>
					<X>20</X><Y>260</Y>
					<Label><X>0</X><Y>-10</Y></Label>
					<PublicFlag>true</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>false</ShowLabel>
					<DrawMode>SHAPE_DRAW_2D</DrawMode>
					<EmbeddedIcon>false</EmbeddedIcon>
					<Z>0</Z>
					<Rotation>0.0</Rotation>
					<Color>-65536</Color>
					<Text><![CDATA[Planed Start Date is reached!!!!!!]]></Text>
					<Font>
						<Name>SansSerif</Name>
						<Size>14</Size>
						<Style>0</Style>
					</Font>
					<Alignment>LEFT</Alignment>
				</Text>
				<Line>
					<Id>1644324536131</Id>
					<Name><![CDATA[line]]></Name>
					<X>100</X><Y>250</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>true</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>false</ShowLabel>
					<DrawMode>SHAPE_DRAW_2D3D</DrawMode>
					<EmbeddedIcon>false</EmbeddedIcon>
					<Z>0</Z>
					<ZHeight>10</ZHeight>
					<LineWidth>2</LineWidth>
					<LineColor>-65536</LineColor>
					<LineMaterial>null</LineMaterial>
					<LineStyle>DASHED</LineStyle>
					<BeginArrowSize>1</BeginArrowSize>
					<BeginArrowStyle>0</BeginArrowStyle>
					<EndArrowSize>1</EndArrowSize>
					<EndArrowStyle>0</EndArrowStyle>
					<Dx>-20</Dx>
					<Dy>-90</Dy>
					<Dz>0</Dz>
				</Line>
				<Line>
					<Id>1644324582269</Id>
					<Name><![CDATA[line1]]></Name>
					<X>100</X><Y>250</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>true</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>false</ShowLabel>
					<DrawMode>SHAPE_DRAW_2D3D</DrawMode>
					<EmbeddedIcon>false</EmbeddedIcon>
					<Z>0</Z>
					<ZHeight>10</ZHeight>
					<LineWidth>2</LineWidth>
					<LineColor>-65536</LineColor>
					<LineMaterial>null</LineMaterial>
					<LineStyle>DASHED</LineStyle>
					<BeginArrowSize>1</BeginArrowSize>
					<BeginArrowStyle>0</BeginArrowStyle>
					<EndArrowSize>1</EndArrowSize>
					<EndArrowStyle>0</EndArrowStyle>
					<Dx>10</Dx>
					<Dy>-30</Dy>
					<Dz>0</Dz>
				</Line>
				<Line>
					<Id>1644324594275</Id>
					<Name><![CDATA[line2]]></Name>
					<X>100</X><Y>250</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>true</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>false</ShowLabel>
					<DrawMode>SHAPE_DRAW_2D3D</DrawMode>
					<EmbeddedIcon>false</EmbeddedIcon>
					<Z>0</Z>
					<ZHeight>10</ZHeight>
					<LineWidth>2</LineWidth>
					<LineColor>-65536</LineColor>
					<LineMaterial>null</LineMaterial>
					<LineStyle>DASHED</LineStyle>
					<BeginArrowSize>1</BeginArrowSize>
					<BeginArrowStyle>0</BeginArrowStyle>
					<EndArrowSize>1</EndArrowSize>
					<EndArrowStyle>0</EndArrowStyle>
					<Dx>-20</Dx>
					<Dy>-20</Dy>
					<Dz>0</Dz>
				</Line>
			</Presentation>

				</Level>
			</Presentation>

		</ActiveObjectClass>
		<!--   =========   Active Object Class   ========  -->
		<ActiveObjectClass>
			<Id>1648060485064</Id>
			<Name><![CDATA[OrderFutureAgent]]></Name>
			<Generic>false</Generic>
			<GenericParameter>
				<Id>1648060485062</Id>
				<Name><![CDATA[1648060485062]]></Name>
				<GenericParameterValue Class="CodeValue">
					<Code><![CDATA[T extends Agent]]></Code>
				</GenericParameterValue>
				<GenericParameterLabel><![CDATA[Generic parameter:]]></GenericParameterLabel>
			</GenericParameter>
			<FlowChartsUsage>ENTITY</FlowChartsUsage>
			<SamplesToKeep>100</SamplesToKeep>
			<LimitNumberOfArrayElements>false</LimitNumberOfArrayElements>
			<ElementsLimitValue>100</ElementsLimitValue>
			<MakeDefaultViewArea>true</MakeDefaultViewArea>
			<SceneGridColor/>
			<SceneBackgroundColor/>
			<SceneSkybox>null</SceneSkybox>
			<AgentProperties>
				<EnvironmentDefinesInitialLocation>true</EnvironmentDefinesInitialLocation>
				<RotateAnimationTowardsMovement>true</RotateAnimationTowardsMovement>
				<RotateAnimationVertically>false</RotateAnimationVertically>
				<VelocityCode Class="CodeUnitValue">
					<Code><![CDATA[10]]></Code>
					<Unit Class="SpeedUnits"><![CDATA[MPS]]></Unit>
				</VelocityCode>
				<PhysicalLength Class="CodeUnitValue">
					<Code><![CDATA[1]]></Code>
					<Unit Class="LengthUnits"><![CDATA[METER]]></Unit>
				</PhysicalLength>
				<PhysicalWidth Class="CodeUnitValue">
					<Code><![CDATA[1]]></Code>
					<Unit Class="LengthUnits"><![CDATA[METER]]></Unit>
				</PhysicalWidth>
				<PhysicalHeight Class="CodeUnitValue">
					<Code><![CDATA[1]]></Code>
					<Unit Class="LengthUnits"><![CDATA[METER]]></Unit>
				</PhysicalHeight>
			</AgentProperties>
			<EnvironmentProperties>
					<EnableSteps>false</EnableSteps>
					<StepDurationCode Class="CodeUnitValue">
						<Code><![CDATA[1.0]]></Code>
						<Unit Class="TimeUnits"><![CDATA[SECOND]]></Unit>
					</StepDurationCode>
					<SpaceType>CONTINUOUS</SpaceType>
					<WidthCode><![CDATA[500]]></WidthCode>
					<HeightCode><![CDATA[500]]></HeightCode>
					<ZHeightCode><![CDATA[0]]></ZHeightCode>
					<ColumnsCountCode><![CDATA[100]]></ColumnsCountCode>
					<RowsCountCode><![CDATA[100]]></RowsCountCode>
					<NeigborhoodType>MOORE</NeigborhoodType>
					<LayoutType>USER_DEF</LayoutType>
					<NetworkType>USER_DEF</NetworkType>
					<ConnectionsPerAgentCode><![CDATA[2]]></ConnectionsPerAgentCode>
					<ConnectionsRangeCode><![CDATA[50]]></ConnectionsRangeCode>
					<NeighborLinkFractionCode><![CDATA[0.95]]></NeighborLinkFractionCode>
					<MCode><![CDATA[10]]></MCode>
			</EnvironmentProperties>
			<DatasetsCreationProperties>
				<AutoCreate>true</AutoCreate>
					<OccurrenceAtTime>true</OccurrenceAtTime>
					<OccurrenceDate>1648108800000</OccurrenceDate>
					<OccurrenceTime Class="CodeUnitValue">
						<Code><![CDATA[0]]></Code>
						<Unit Class="TimeUnits"><![CDATA[DAY]]></Unit>
					</OccurrenceTime>
					<RecurrenceCode Class="CodeUnitValue">
						<Code><![CDATA[1]]></Code>
						<Unit Class="TimeUnits"><![CDATA[DAY]]></Unit>
					</RecurrenceCode>
			</DatasetsCreationProperties>
			<ScaleRuler>
				<Id>1648060485060</Id>
				<Name><![CDATA[scale]]></Name>
				<X>0</X><Y>-150</Y>
				<PublicFlag>false</PublicFlag>
				<PresentationFlag>false</PresentationFlag>
				<ShowLabel>false</ShowLabel>
				<DrawMode>SHAPE_DRAW_2D3D</DrawMode>
				<Length>100</Length>
				<Rotation>0</Rotation>
				<ScaleType>BASED_ON_LENGTH</ScaleType>
				<ModelLength>10</ModelLength>
				<LengthUnits>METER</LengthUnits>
				<Scale>10</Scale>
				<InheritedFromParentAgentType>true</InheritedFromParentAgentType>
			</ScaleRuler>
			<CurrentLevel>1648060485063</CurrentLevel>
			<ConnectionsId>1648060485059</ConnectionsId>
			<Variables>
				<Variable Class="Parameter">
					<Id>1648060512012</Id>
					<Name><![CDATA[orderFutureFromAgent]]></Name>
					<X>60</X><Y>100</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Properties SaveInSnapshot="true" ModificatorType="STATIC">
						<Type><![CDATA[OrderFuture]]></Type>
						<UnitType><![CDATA[NONE]]></UnitType>
						<SdArray>false</SdArray>
						<ParameterEditor>
							<Id>1648060512010</Id>
							<EditorContolType>TEXT_BOX</EditorContolType>
							<MinSliderValue><![CDATA[0]]></MinSliderValue>
							<MaxSliderValue><![CDATA[100]]></MaxSliderValue>
							<DelimeterType>NO_DELIMETER</DelimeterType>
						</ParameterEditor>
					</Properties>                 
				</Variable>
			</Variables>
			<Connectors>
				<Connector>
					<Id>1648197156088</Id>
					<Name><![CDATA[connector1]]></Name>
					<X>150</X><Y>220</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>false</ShowLabel>
					<SourceEmbeddedObjectReference>
						<PackageName><![CDATA[simopt]]></PackageName>
						<ClassName><![CDATA[OrderFutureAgent]]></ClassName>
						<ItemName><![CDATA[queue]]></ItemName>
					</SourceEmbeddedObjectReference>
					<SourceConnectableItemReference>
						<PackageName><![CDATA[com.anylogic.libraries.processmodeling]]></PackageName>
						<ClassName><![CDATA[Queue]]></ClassName>
						<ItemName><![CDATA[out]]></ItemName>
					</SourceConnectableItemReference>
					<TargetEmbeddedObjectReference>
						<PackageName><![CDATA[simopt]]></PackageName>
						<ClassName><![CDATA[OrderFutureAgent]]></ClassName>
						<ItemName><![CDATA[exit]]></ItemName>
					</TargetEmbeddedObjectReference>
					<TargetConnectableItemReference>
						<PackageName><![CDATA[com.anylogic.libraries.processmodeling]]></PackageName>
						<ClassName><![CDATA[Exit]]></ClassName>
						<ItemName><![CDATA[in]]></ItemName>
					</TargetConnectableItemReference>
					<Points>
						<Point><X>0</X><Y>0</Y></Point>
						<Point><X>10</X><Y>-40</Y></Point>
					</Points>
				</Connector>
				<Connector>
					<Id>1648197162873</Id>
					<Name><![CDATA[connector]]></Name>
					<X>110</X><Y>220</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>false</ShowLabel>
					<SourceEmbeddedObjectReference>
						<PackageName><![CDATA[simopt]]></PackageName>
						<ClassName><![CDATA[OrderFutureAgent]]></ClassName>
						<ItemName><![CDATA[queue]]></ItemName>
					</SourceEmbeddedObjectReference>
					<SourceConnectableItemReference>
						<PackageName><![CDATA[com.anylogic.libraries.processmodeling]]></PackageName>
						<ClassName><![CDATA[Queue]]></ClassName>
						<ItemName><![CDATA[in]]></ItemName>
					</SourceConnectableItemReference>
					<TargetEmbeddedObjectReference>
						<PackageName><![CDATA[simopt]]></PackageName>
						<ClassName><![CDATA[OrderFutureAgent]]></ClassName>
						<ItemName><![CDATA[enter]]></ItemName>
					</TargetEmbeddedObjectReference>
					<TargetConnectableItemReference>
						<PackageName><![CDATA[com.anylogic.libraries.processmodeling]]></PackageName>
						<ClassName><![CDATA[Enter]]></ClassName>
						<ItemName><![CDATA[out]]></ItemName>
					</TargetConnectableItemReference>
					<Points>
						<Point><X>0</X><Y>0</Y></Point>
						<Point><X>-30</X><Y>-40</Y></Point>
					</Points>
				</Connector>
			</Connectors>
			<Events>
				<Event>
					<Id>1648146843752</Id>
					<Name><![CDATA[arrivalRate]]></Name>
					<X>280</X><Y>200</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Properties TriggerType="timeout" Mode="userControls">
						<Timeout Class="CodeUnitValue">
							<Code><![CDATA[0]]></Code>
							<Unit Class="TimeUnits"><![CDATA[DAY]]></Unit>
						</Timeout>
						<Rate Class="CodeUnitValue">
							<Code><![CDATA[1]]></Code>
							<Unit Class="RateUnits"><![CDATA[PER_DAY]]></Unit>
						</Rate>
						<OccurrenceAtTime>true</OccurrenceAtTime>
						<OccurrenceDate>1640937600000</OccurrenceDate>
						<OccurrenceTime Class="CodeUnitValue">
							<Code><![CDATA[0]]></Code>
							<Unit Class="TimeUnits"><![CDATA[DAY]]></Unit>
						</OccurrenceTime>
						<RecurrenceCode Class="CodeUnitValue">
							<Code><![CDATA[1]]></Code>
							<Unit Class="TimeUnits"><![CDATA[HOUR]]></Unit>
						</RecurrenceCode>
						<Condition><![CDATA[false]]></Condition>
					</Properties>
					<Action><![CDATA[
if(get_Main().simParams.getDemandGeneration().equals(SimulationParameter.DEMAND_GENERATION_CUSTOMER_REQUIRED_LEADTIME)){
	
	traceln("new in " + time());
		//if(orderFutureFromAgent != null){		
	
	//for(OrderFuture of : get_Main().orderFuture){
	
		double irt = OrderFuture.GetInterArrivalTime(this.orderFutureFromAgent, time(), get_Main().var_random_arrivalRate, main.mrpFileNameSuffix);
		traceln("irt " + irt + " item " + this.orderFutureFromAgent.getItem().getItem());
	
		OrderFutureAgent ofa = new OrderFutureAgent();
		orderFutureFromAgent.irt = time() + irt;
		ofa.orderFutureFromAgent = orderFutureFromAgent;
		ofa.markParametersAreSet();		
		enter.take(ofa);
		
		//ofa.enter.take(ofa);
		traceln("time 0 " + ofa.orderFutureFromAgent.getItem().getItem());
		//orderFutureAgent.arrivalRate.restart(time());	
		
		//arrivalRate.restartTo(time() + irt);	
		traceln(this.orderFutureFromAgent.getItem().getItem());
		traceln(this.getId());
	//}
}]]></Action>
				</Event>
			</Events>
			<DynamicEvents>
				<DynamicEventClass>
					<Id>1648197567207</Id>
					<Name><![CDATA[MyDynamicEvent]]></Name>
					<X>280</X><Y>240</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
				</DynamicEventClass>
			</DynamicEvents>
			<AgentLinks>
				<AgentLink>
					<Id>1648060485059</Id>
					<Name><![CDATA[connections]]></Name>
					<X>50</X><Y>-50</Y>
					<Label><X>15</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<HandleReceiveInConnections>false</HandleReceiveInConnections>
					<AgentLinkType>COLLECTION_OF_LINKS</AgentLinkType>
					<AgentLinkBidirectional>true</AgentLinkBidirectional>
					<MessageType><![CDATA[Object]]></MessageType>
					<LineStyle>SOLID</LineStyle>
					<LineWidth>1</LineWidth>
					<LineColor>-16777216</LineColor>
					<LineZOrder>UNDER_AGENTS</LineZOrder>
					<LineArrow>NONE</LineArrow>
					<LineArrowPosition>END</LineArrowPosition>
				</AgentLink>
			</AgentLinks>

			<ContainerLinks>
				<ContainerLink>
					<Id>1648060678151</Id>
					<Name><![CDATA[main]]></Name>
					<X>50</X><Y>-100</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<ActiveObjectClass>
						<PackageName><![CDATA[simopt]]></PackageName>
						<ClassName><![CDATA[Main]]></ClassName>
					</ActiveObjectClass>
				</ContainerLink>
			</ContainerLinks>
			<EmbeddedObjects>
				<EmbeddedObject>
					<Id>1648146730747</Id>
					<Name><![CDATA[enter]]></Name>
					<X>60</X><Y>170</Y>
					<Label><X>-10</X><Y>-20</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<ActiveObjectClass>
						<PackageName><![CDATA[com.anylogic.libraries.processmodeling]]></PackageName>
						<ClassName><![CDATA[Enter]]></ClassName>
					</ActiveObjectClass>
					<GenericParameterSubstitute>
						<GenericParameterSubstituteReference>
							<PackageName><![CDATA[com.anylogic.libraries.processmodeling]]></PackageName>
							<ClassName><![CDATA[Enter]]></ClassName>
							<ItemName><![CDATA[1412336242933]]></ItemName>
						</GenericParameterSubstituteReference>
						<GenericParameterSubstituteValue Class="CodeValue">
							<Code><![CDATA[OrderFutureAgent]]></Code>
						</GenericParameterSubstituteValue>
					</GenericParameterSubstitute>
					<Parameters>
						<Parameter>
							<Name><![CDATA[locationType]]></Name>
						</Parameter>
						<Parameter>
							<Name><![CDATA[locationX]]></Name>
						</Parameter>
						<Parameter>
							<Name><![CDATA[locationY]]></Name>
						</Parameter>
						<Parameter>
							<Name><![CDATA[locationZ]]></Name>
						</Parameter>
						<Parameter>
							<Name><![CDATA[locationLatitude]]></Name>
						</Parameter>
						<Parameter>
							<Name><![CDATA[locationLongitude]]></Name>
						</Parameter>
						<Parameter>
							<Name><![CDATA[locationGeoPlaceName]]></Name>
						</Parameter>
						<Parameter>
							<Name><![CDATA[locationXYZInNetwork]]></Name>
						</Parameter>
						<Parameter>
							<Name><![CDATA[locationNetwork]]></Name>
						</Parameter>
						<Parameter>
							<Name><![CDATA[locationLevel]]></Name>
						</Parameter>
						<Parameter>
							<Name><![CDATA[locationNode]]></Name>
						</Parameter>
						<Parameter>
							<Name><![CDATA[locationAttractor]]></Name>
						</Parameter>
						<Parameter>
							<Name><![CDATA[speed]]></Name>
						</Parameter>
						<Parameter>
							<Name><![CDATA[changeDimensions]]></Name>
						</Parameter>
						<Parameter>
							<Name><![CDATA[length]]></Name>
						</Parameter>
						<Parameter>
							<Name><![CDATA[width]]></Name>
						</Parameter>
						<Parameter>
							<Name><![CDATA[height]]></Name>
						</Parameter>
						<Parameter>
							<Name><![CDATA[addToCustomPopulation]]></Name>
						</Parameter>
						<Parameter>
							<Name><![CDATA[population]]></Name>
						</Parameter>
						<Parameter>
							<Name><![CDATA[pushProtocol]]></Name>
						</Parameter>
						<Parameter>
							<Name><![CDATA[onEnter]]></Name>
							<Value Class="CodeValue">
								<Code><![CDATA[traceln("at enter of " + agent.orderFutureFromAgent.getItem().getItem() + " time " + time());
orderFutureFromAgent = agent.orderFutureFromAgent;
arrivalRate.restartTo(agent.orderFutureFromAgent.irt);
traceln("Restart at enter " + agent.orderFutureFromAgent.irt);
]]></Code>
							</Value>
						</Parameter>
						<Parameter>
							<Name><![CDATA[onRemove]]></Name>
						</Parameter>
						<Parameter>
							<Name><![CDATA[onAtEnter]]></Name>
						</Parameter>
					</Parameters>
					<ReplicationFlag>false</ReplicationFlag>
					<Replication Class="CodeValue">
						<Code><![CDATA[100]]></Code>
					</Replication>
					<CollectionType>ARRAY_LIST_BASED</CollectionType>
					<InitialLocationType>XYZ</InitialLocationType>
					<XCode Class="CodeValue">
						<Code><![CDATA[0]]></Code>
					</XCode>
					<YCode Class="CodeValue">
						<Code><![CDATA[0]]></Code>
					</YCode>
					<ZCode Class="CodeValue">
						<Code><![CDATA[0]]></Code>
					</ZCode>
					<ColumnCode Class="CodeValue">
						<Code><![CDATA[0]]></Code>
					</ColumnCode>
					<RowCode Class="CodeValue">
						<Code><![CDATA[0]]></Code>
					</RowCode>
					<LocationNameCode Class="CodeValue">
						<Code><![CDATA[""]]></Code>
					</LocationNameCode>
					<InitializationType>SPECIFIED_NUMBER</InitializationType>
					<InitializationDatabaseTableQuery>
						<TableReference>
						</TableReference>
					</InitializationDatabaseTableQuery>
					<InitializationDatabaseType>ONE_AGENT_PER_DATABASE_RECORD</InitializationDatabaseType>
					<QuantityColumn>
					</QuantityColumn>
				</EmbeddedObject>
				<EmbeddedObject>
					<Id>1648196970900</Id>
					<Name><![CDATA[exit]]></Name>
					<X>160</X><Y>170</Y>
					<Label><X>-10</X><Y>-20</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<ActiveObjectClass>
						<PackageName><![CDATA[com.anylogic.libraries.processmodeling]]></PackageName>
						<ClassName><![CDATA[Exit]]></ClassName>
					</ActiveObjectClass>
					<GenericParameterSubstitute>
						<GenericParameterSubstituteReference>
							<PackageName><![CDATA[com.anylogic.libraries.processmodeling]]></PackageName>
							<ClassName><![CDATA[Exit]]></ClassName>
							<ItemName><![CDATA[1412336242934]]></ItemName>
						</GenericParameterSubstituteReference>
					</GenericParameterSubstitute>
					<Parameters>
						<Parameter>
							<Name><![CDATA[onExit]]></Name>
							<Value Class="CodeValue">
								<Code><![CDATA[traceln("at exit of " + agent.orderFutureFromAgent.getItem().getItem());
]]></Code>
							</Value>
						</Parameter>
					</Parameters>
					<ReplicationFlag>false</ReplicationFlag>
					<Replication Class="CodeValue">
						<Code><![CDATA[100]]></Code>
					</Replication>
					<CollectionType>ARRAY_LIST_BASED</CollectionType>
					<InitialLocationType>XYZ</InitialLocationType>
					<XCode Class="CodeValue">
						<Code><![CDATA[0]]></Code>
					</XCode>
					<YCode Class="CodeValue">
						<Code><![CDATA[0]]></Code>
					</YCode>
					<ZCode Class="CodeValue">
						<Code><![CDATA[0]]></Code>
					</ZCode>
					<ColumnCode Class="CodeValue">
						<Code><![CDATA[0]]></Code>
					</ColumnCode>
					<RowCode Class="CodeValue">
						<Code><![CDATA[0]]></Code>
					</RowCode>
					<LocationNameCode Class="CodeValue">
						<Code><![CDATA[""]]></Code>
					</LocationNameCode>
					<InitializationType>SPECIFIED_NUMBER</InitializationType>
					<InitializationDatabaseTableQuery>
						<TableReference>
						</TableReference>
					</InitializationDatabaseTableQuery>
					<InitializationDatabaseType>ONE_AGENT_PER_DATABASE_RECORD</InitializationDatabaseType>
					<QuantityColumn>
					</QuantityColumn>
				</EmbeddedObject>
				<EmbeddedObject>
					<Id>1648197154200</Id>
					<Name><![CDATA[queue]]></Name>
					<X>110</X><Y>200</Y>
					<Label><X>-5</X><Y>-15</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<ActiveObjectClass>
						<PackageName><![CDATA[com.anylogic.libraries.processmodeling]]></PackageName>
						<ClassName><![CDATA[Queue]]></ClassName>
					</ActiveObjectClass>
					<GenericParameterSubstitute>
						<GenericParameterSubstituteReference>
							<PackageName><![CDATA[com.anylogic.libraries.processmodeling]]></PackageName>
							<ClassName><![CDATA[Queue]]></ClassName>
							<ItemName><![CDATA[1412336242932]]></ItemName>
						</GenericParameterSubstituteReference>
					</GenericParameterSubstitute>
					<Parameters>
						<Parameter>
							<Name><![CDATA[capacity]]></Name>
						</Parameter>
						<Parameter>
							<Name><![CDATA[maximumCapacity]]></Name>
						</Parameter>
						<Parameter>
							<Name><![CDATA[entityLocation]]></Name>
						</Parameter>
						<Parameter>
							<Name><![CDATA[queuing]]></Name>
						</Parameter>
						<Parameter>
							<Name><![CDATA[priority]]></Name>
						</Parameter>
						<Parameter>
							<Name><![CDATA[comparison]]></Name>
						</Parameter>
						<Parameter>
							<Name><![CDATA[enableTimeout]]></Name>
						</Parameter>
						<Parameter>
							<Name><![CDATA[timeout]]></Name>
						</Parameter>
						<Parameter>
							<Name><![CDATA[enablePreemption]]></Name>
						</Parameter>
						<Parameter>
							<Name><![CDATA[restoreEntityLocationOnExit]]></Name>
						</Parameter>
						<Parameter>
							<Name><![CDATA[forceStatisticsCollection]]></Name>
						</Parameter>
						<Parameter>
							<Name><![CDATA[onEnter]]></Name>
						</Parameter>
						<Parameter>
							<Name><![CDATA[onAtExit]]></Name>
						</Parameter>
						<Parameter>
							<Name><![CDATA[onExit]]></Name>
						</Parameter>
						<Parameter>
							<Name><![CDATA[onExitTimeout]]></Name>
						</Parameter>
						<Parameter>
							<Name><![CDATA[onExitPreempted]]></Name>
						</Parameter>
						<Parameter>
							<Name><![CDATA[onRemove]]></Name>
						</Parameter>
					</Parameters>
					<ReplicationFlag>false</ReplicationFlag>
					<Replication Class="CodeValue">
						<Code><![CDATA[100]]></Code>
					</Replication>
					<CollectionType>ARRAY_LIST_BASED</CollectionType>
					<InitialLocationType>XYZ</InitialLocationType>
					<XCode Class="CodeValue">
						<Code><![CDATA[0]]></Code>
					</XCode>
					<YCode Class="CodeValue">
						<Code><![CDATA[0]]></Code>
					</YCode>
					<ZCode Class="CodeValue">
						<Code><![CDATA[0]]></Code>
					</ZCode>
					<ColumnCode Class="CodeValue">
						<Code><![CDATA[0]]></Code>
					</ColumnCode>
					<RowCode Class="CodeValue">
						<Code><![CDATA[0]]></Code>
					</RowCode>
					<LocationNameCode Class="CodeValue">
						<Code><![CDATA[""]]></Code>
					</LocationNameCode>
					<InitializationType>SPECIFIED_NUMBER</InitializationType>
					<InitializationDatabaseTableQuery>
						<TableReference>
						</TableReference>
					</InitializationDatabaseTableQuery>
					<InitializationDatabaseType>ONE_AGENT_PER_DATABASE_RECORD</InitializationDatabaseType>
					<QuantityColumn>
					</QuantityColumn>
				</EmbeddedObject>
			</EmbeddedObjects>

			<Presentation>
				<Level>
					<Id>1648060485063</Id>
					<Name><![CDATA[level]]></Name>
					<X>0</X><Y>0</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>true</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>false</ShowLabel>
					<DrawMode>SHAPE_DRAW_2D3D</DrawMode>
					<Z>0</Z>
					<LevelVisibility>DIM_NON_CURRENT</LevelVisibility>


				</Level>
			</Presentation>

		</ActiveObjectClass>
		<!--   =========   Active Object Class   ========  -->
		<ActiveObjectClass>
			<Id>1648534705804</Id>
			<Name><![CDATA[Documentation]]></Name>
			<Generic>false</Generic>
			<GenericParameter>
				<Id>1648534705802</Id>
				<Name><![CDATA[1648534705802]]></Name>
				<GenericParameterValue Class="CodeValue">
					<Code><![CDATA[T extends Agent]]></Code>
				</GenericParameterValue>
				<GenericParameterLabel><![CDATA[Generic parameter:]]></GenericParameterLabel>
			</GenericParameter>
			<FlowChartsUsage>ENTITY</FlowChartsUsage>
			<SamplesToKeep>100</SamplesToKeep>
			<LimitNumberOfArrayElements>false</LimitNumberOfArrayElements>
			<ElementsLimitValue>100</ElementsLimitValue>
			<MakeDefaultViewArea>true</MakeDefaultViewArea>
			<SceneGridColor/>
			<SceneBackgroundColor/>
			<SceneSkybox>null</SceneSkybox>
			<AgentProperties>
				<EnvironmentDefinesInitialLocation>true</EnvironmentDefinesInitialLocation>
				<RotateAnimationTowardsMovement>true</RotateAnimationTowardsMovement>
				<RotateAnimationVertically>false</RotateAnimationVertically>
				<VelocityCode Class="CodeUnitValue">
					<Code><![CDATA[10]]></Code>
					<Unit Class="SpeedUnits"><![CDATA[MPS]]></Unit>
				</VelocityCode>
				<PhysicalLength Class="CodeUnitValue">
					<Code><![CDATA[1]]></Code>
					<Unit Class="LengthUnits"><![CDATA[METER]]></Unit>
				</PhysicalLength>
				<PhysicalWidth Class="CodeUnitValue">
					<Code><![CDATA[1]]></Code>
					<Unit Class="LengthUnits"><![CDATA[METER]]></Unit>
				</PhysicalWidth>
				<PhysicalHeight Class="CodeUnitValue">
					<Code><![CDATA[1]]></Code>
					<Unit Class="LengthUnits"><![CDATA[METER]]></Unit>
				</PhysicalHeight>
			</AgentProperties>
			<EnvironmentProperties>
					<EnableSteps>false</EnableSteps>
					<StepDurationCode Class="CodeUnitValue">
						<Code><![CDATA[1.0]]></Code>
						<Unit Class="TimeUnits"><![CDATA[SECOND]]></Unit>
					</StepDurationCode>
					<SpaceType>CONTINUOUS</SpaceType>
					<WidthCode><![CDATA[500]]></WidthCode>
					<HeightCode><![CDATA[500]]></HeightCode>
					<ZHeightCode><![CDATA[0]]></ZHeightCode>
					<ColumnsCountCode><![CDATA[100]]></ColumnsCountCode>
					<RowsCountCode><![CDATA[100]]></RowsCountCode>
					<NeigborhoodType>MOORE</NeigborhoodType>
					<LayoutType>USER_DEF</LayoutType>
					<NetworkType>USER_DEF</NetworkType>
					<ConnectionsPerAgentCode><![CDATA[2]]></ConnectionsPerAgentCode>
					<ConnectionsRangeCode><![CDATA[50]]></ConnectionsRangeCode>
					<NeighborLinkFractionCode><![CDATA[0.95]]></NeighborLinkFractionCode>
					<MCode><![CDATA[10]]></MCode>
			</EnvironmentProperties>
			<DatasetsCreationProperties>
				<AutoCreate>true</AutoCreate>
					<OccurrenceAtTime>true</OccurrenceAtTime>
					<OccurrenceDate>1648540800000</OccurrenceDate>
					<OccurrenceTime Class="CodeUnitValue">
						<Code><![CDATA[0]]></Code>
						<Unit Class="TimeUnits"><![CDATA[DAY]]></Unit>
					</OccurrenceTime>
					<RecurrenceCode Class="CodeUnitValue">
						<Code><![CDATA[1]]></Code>
						<Unit Class="TimeUnits"><![CDATA[DAY]]></Unit>
					</RecurrenceCode>
			</DatasetsCreationProperties>
			<ScaleRuler>
				<Id>1648534705800</Id>
				<Name><![CDATA[scale]]></Name>
				<X>0</X><Y>-150</Y>
				<PublicFlag>false</PublicFlag>
				<PresentationFlag>false</PresentationFlag>
				<ShowLabel>false</ShowLabel>
				<DrawMode>SHAPE_DRAW_2D3D</DrawMode>
				<Length>100</Length>
				<Rotation>0</Rotation>
				<ScaleType>BASED_ON_LENGTH</ScaleType>
				<ModelLength>10</ModelLength>
				<LengthUnits>METER</LengthUnits>
				<Scale>10</Scale>
				<InheritedFromParentAgentType>true</InheritedFromParentAgentType>
			</ScaleRuler>
			<CurrentLevel>1648534705803</CurrentLevel>
			<ConnectionsId>1648534705799</ConnectionsId>
			<AgentLinks>
				<AgentLink>
					<Id>1648534705799</Id>
					<Name><![CDATA[connections]]></Name>
					<X>50</X><Y>-50</Y>
					<Label><X>15</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<HandleReceiveInConnections>false</HandleReceiveInConnections>
					<AgentLinkType>COLLECTION_OF_LINKS</AgentLinkType>
					<AgentLinkBidirectional>true</AgentLinkBidirectional>
					<MessageType><![CDATA[Object]]></MessageType>
					<LineStyle>SOLID</LineStyle>
					<LineWidth>1</LineWidth>
					<LineColor>-16777216</LineColor>
					<LineZOrder>UNDER_AGENTS</LineZOrder>
					<LineArrow>NONE</LineArrow>
					<LineArrowPosition>END</LineArrowPosition>
				</AgentLink>
			</AgentLinks>


			<Presentation>
				<Level>
					<Id>1648534705803</Id>
					<Name><![CDATA[level]]></Name>
					<X>0</X><Y>0</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>true</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>false</ShowLabel>
					<DrawMode>SHAPE_DRAW_2D3D</DrawMode>
					<Z>0</Z>
					<LevelVisibility>DIM_NON_CURRENT</LevelVisibility>


				</Level>
			</Presentation>

		</ActiveObjectClass>
		<!--   =========   Active Object Class   ========  -->
		<ActiveObjectClass>
			<Id>1652788218460</Id>
			<Name><![CDATA[Cplex]]></Name>
			<Import><![CDATA[import java.io.File;
import ilog.concert.*; // CPLEX
import ilog.cplex.*; // CPLEX
import static java.util.Arrays.stream; // for streaming arrays
import java.util.stream.*;
import org.eclipse.jdt.internal.compiler.codegen.DoubleCache;
import java.text.DecimalFormat; 
//import org.graalvm.compiler.replacements.nodes.arithmetic.IntegerAddExactNode;]]></Import>
			<Generic>false</Generic>
			<GenericParameter>
				<Id>1652788218458</Id>
				<Name><![CDATA[1652788218458]]></Name>
				<GenericParameterValue Class="CodeValue">
					<Code><![CDATA[T extends Agent]]></Code>
				</GenericParameterValue>
				<GenericParameterLabel><![CDATA[Generic parameter:]]></GenericParameterLabel>
			</GenericParameter>
			<FlowChartsUsage>ENTITY</FlowChartsUsage>
			<SamplesToKeep>100</SamplesToKeep>
			<LimitNumberOfArrayElements>false</LimitNumberOfArrayElements>
			<ElementsLimitValue>100</ElementsLimitValue>
			<MakeDefaultViewArea>true</MakeDefaultViewArea>
			<SceneGridColor/>
			<SceneBackgroundColor/>
			<SceneSkybox>null</SceneSkybox>
			<AgentProperties>
				<EnvironmentDefinesInitialLocation>true</EnvironmentDefinesInitialLocation>
				<RotateAnimationTowardsMovement>true</RotateAnimationTowardsMovement>
				<RotateAnimationVertically>false</RotateAnimationVertically>
				<VelocityCode Class="CodeUnitValue">
					<Code><![CDATA[10]]></Code>
					<Unit Class="SpeedUnits"><![CDATA[MPS]]></Unit>
				</VelocityCode>
				<PhysicalLength Class="CodeUnitValue">
					<Code><![CDATA[1]]></Code>
					<Unit Class="LengthUnits"><![CDATA[METER]]></Unit>
				</PhysicalLength>
				<PhysicalWidth Class="CodeUnitValue">
					<Code><![CDATA[1]]></Code>
					<Unit Class="LengthUnits"><![CDATA[METER]]></Unit>
				</PhysicalWidth>
				<PhysicalHeight Class="CodeUnitValue">
					<Code><![CDATA[1]]></Code>
					<Unit Class="LengthUnits"><![CDATA[METER]]></Unit>
				</PhysicalHeight>
			</AgentProperties>
			<EnvironmentProperties>
					<EnableSteps>false</EnableSteps>
					<StepDurationCode Class="CodeUnitValue">
						<Code><![CDATA[1.0]]></Code>
						<Unit Class="TimeUnits"><![CDATA[SECOND]]></Unit>
					</StepDurationCode>
					<SpaceType>CONTINUOUS</SpaceType>
					<WidthCode><![CDATA[500]]></WidthCode>
					<HeightCode><![CDATA[500]]></HeightCode>
					<ZHeightCode><![CDATA[0]]></ZHeightCode>
					<ColumnsCountCode><![CDATA[100]]></ColumnsCountCode>
					<RowsCountCode><![CDATA[100]]></RowsCountCode>
					<NeigborhoodType>MOORE</NeigborhoodType>
					<LayoutType>USER_DEF</LayoutType>
					<NetworkType>USER_DEF</NetworkType>
					<ConnectionsPerAgentCode><![CDATA[2]]></ConnectionsPerAgentCode>
					<ConnectionsRangeCode><![CDATA[50]]></ConnectionsRangeCode>
					<NeighborLinkFractionCode><![CDATA[0.95]]></NeighborLinkFractionCode>
					<MCode><![CDATA[10]]></MCode>
			</EnvironmentProperties>
			<DatasetsCreationProperties>
				<AutoCreate>true</AutoCreate>
					<OccurrenceAtTime>true</OccurrenceAtTime>
					<OccurrenceDate>1652860800000</OccurrenceDate>
					<OccurrenceTime Class="CodeUnitValue">
						<Code><![CDATA[0]]></Code>
						<Unit Class="TimeUnits"><![CDATA[DAY]]></Unit>
					</OccurrenceTime>
					<RecurrenceCode Class="CodeUnitValue">
						<Code><![CDATA[1]]></Code>
						<Unit Class="TimeUnits"><![CDATA[DAY]]></Unit>
					</RecurrenceCode>
			</DatasetsCreationProperties>
			<ScaleRuler>
				<Id>1652788218456</Id>
				<Name><![CDATA[scale]]></Name>
				<X>0</X><Y>-150</Y>
				<PublicFlag>false</PublicFlag>
				<PresentationFlag>false</PresentationFlag>
				<ShowLabel>false</ShowLabel>
				<DrawMode>SHAPE_DRAW_2D3D</DrawMode>
				<Length>100</Length>
				<Rotation>0</Rotation>
				<ScaleType>BASED_ON_LENGTH</ScaleType>
				<ModelLength>10</ModelLength>
				<LengthUnits>METER</LengthUnits>
				<Scale>10</Scale>
				<InheritedFromParentAgentType>true</InheritedFromParentAgentType>
			</ScaleRuler>
			<CurrentLevel>1652788218459</CurrentLevel>
			<ConnectionsId>1652788218455</ConnectionsId>
			<Variables>
				<Variable Class="Parameter">
					<Id>1679470648563</Id>
					<Name><![CDATA[ClearingFunctionSegments]]></Name>
					<X>50</X><Y>260</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Properties SaveInSnapshot="true" ModificatorType="STATIC">
						<Type><![CDATA[List<ClearingFunctionSegments>]]></Type>
						<UnitType><![CDATA[NONE]]></UnitType>
						<SdArray>false</SdArray>
						<DefaultValue Class="CodeValue">
							<Code><![CDATA[new ArrayList()]]></Code>
						</DefaultValue>
						<ParameterEditor>
							<Id>1679470648561</Id>
							<EditorContolType>TEXT_BOX</EditorContolType>
							<MinSliderValue><![CDATA[0]]></MinSliderValue>
							<MaxSliderValue><![CDATA[100]]></MaxSliderValue>
							<DelimeterType>NO_DELIMETER</DelimeterType>
						</ParameterEditor>
					</Properties>                 
				</Variable>
			</Variables>
			<Functions>
				<Function AccessType="default" StaticFunction="false">
					<ReturnModificator>RETURNS_VALUE</ReturnModificator>
					<ReturnType><![CDATA[int]]></ReturnType>
					<Id>1652788265552</Id>
					<Name><![CDATA[Function_ClearingFunction_without_ct]]></Name>
					<X>490</X><Y>160</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Parameter>
						<Name><![CDATA[itemsToPlan]]></Name>
						<Type><![CDATA[List<MRP>]]></Type>
					</Parameter>
					<Parameter>
						<Name><![CDATA[bomLevel]]></Name>
						<Type><![CDATA[int]]></Type>
					</Parameter>
					<Parameter>
						<Name><![CDATA[inResource]]></Name>
						<Type><![CDATA[Resource]]></Type>
					</Parameter>
					<Parameter>
						<Name><![CDATA[fileSuffix]]></Name>
						<Type><![CDATA[String]]></Type>
					</Parameter>
					<Body><![CDATA[try{

Tools to = new Tools();
							
traceln("----------- Start CF OPTIMIZATION Without Ct at " + time () + " ----------------");
							
StringBuilder output = new StringBuilder();

int maxCapacity = 1440;
//double wipCosts = 0;
//double inventoryHoldingCosts = 0;
traceln("Total found Segments: " + ClearingFunctionSegments.size());


/*
Iterator<MRP> iterator = itemsToPlan.iterator();
while (iterator.hasNext()) {
    MRP o = iterator.next();
    if (o.getItem().getItem() == 103 ||     
    o.getItem().getItem() == 111 ||
    o.getItem().getItem() == 115 ||
    o.getItem().getItem() == 119 ||
    o.getItem().getItem() == 123 ||
    o.getItem().getItem() == 127 ||
    o.getItem().getItem() == 131
    ) {
        iterator.remove(); // Safely remove the element from the list
    }
}
*/

	//via the bom level the cf is associated
	List<ClearingFunctionSegments> selectedSegments = new ArrayList();
	Item firstBomItem = itemsToPlan.get(0).getItem();
	//wipCosts = firstBomItem.getHoldingCostsWIP();
	//inventoryHoldingCosts = firstBomItem.getHoldingCosts();	
	
	//Routing firstRoutingItem = main.routings.stream().filter(e -> e.getItem().getItem() == firstBomItem.getItem()).findFirst().get();	
	//Resource firstResource= main.resources.stream().filter(e -> e.getName().equalsIgnoreCase(firstRoutingItem.getResource())).findFirst().get();
	
	//maxCapacity = inResource.getCapacity();
	//don't map it to the prodction stage 1-4, select the values based on the resource
	traceln("Total found segments: " + selectedSegments);
	
	if(firstBomItem.getLotsizePolicy().equalsIgnoreCase(Item.LOT_POLICY_FOP)) {
		int fop = firstBomItem.getFOPPeriod();	
		traceln("FOP Period:" + fop);	
					
		selectedSegments = ClearingFunctionSegments.stream().filter(e -> e.getLotParameter() == fop &&
							 e.getLotPolicy().equalsIgnoreCase(Item.LOT_POLICY_FOP) && e.getResource().equalsIgnoreCase(inResource.getName()) 
				 && e.getExperiment().equalsIgnoreCase(main.simParams.getExperiment())).collect(Collectors.toList());															 																								
	}
	else if(firstBomItem.getLotsizePolicy().equalsIgnoreCase(Item.LOT_POLICY_FOQ)) {
		int foq = (int)firstBomItem.getFOQQuantity();	
		traceln("FOQ Qty:" + foq);	
					
		selectedSegments = ClearingFunctionSegments.stream().filter(e -> e.getLotParameter() == foq &&
							 e.getLotPolicy().equalsIgnoreCase(Item.LOT_POLICY_FOQ) && e.getResource().equalsIgnoreCase(inResource.getName()) 
				 && e.getExperiment().equalsIgnoreCase(main.simParams.getExperiment())).collect(Collectors.toList());															 																								
	}
				
	traceln("Resource: " + inResource.getName());
	traceln("Resource Stage Number: " + inResource.getStageNumber());
	traceln("Production Stage: " + (bomLevel + 1));
	traceln("Max Capacity: " + maxCapacity);
	
	traceln("Items to Plan: ");
	itemsToPlan.forEach(e -> traceln(e.getItem().getItem() + " eProcessingTime " + e.getItem().getRouting().getEProcessingTime() + ";"));

	traceln("Selected Slopes: ");		
	selectedSegments.forEach(e -> traceln(e.getSlope() + ";"));
	traceln("Selected Intercepts: ");
	
	selectedSegments.forEach(e -> traceln(e.getyIntercept() + ";"));
	
	if(selectedSegments.size() == 0){
		traceln("STOP Simulation: No Segments found!");
		System.exit(0);
	}
	
	to.log("Segment Cnt: " + selectedSegments.size(), Tools.LogCFOptimization);
	
	double intercepts[] = new double[selectedSegments.size()];
	double slopes[] = new double[selectedSegments.size()];
	
	for(int i = 0; i < selectedSegments.size(); i++) {
		slopes[i] = selectedSegments.get(i).getSlope();
		intercepts[i] = selectedSegments.get(i).getyIntercept();
	}		
			
int numberSegments = selectedSegments.size();

//double oCosts = 0;
//double oFactor = 0;//1000
double setupTime = 18; //standard = 18
int leadtimeHorizon = main.simParams.getLeadTimeHorizon();


traceln("Leadtime Horizon: " + leadtimeHorizon);

IloCplex cplex = new IloCplex();

     String[][] Inames = new String[itemsToPlan.size()][get_Main().simParams.getMRPPlanningHorizon()];
     String[][] Pnames = new String[itemsToPlan.size()][get_Main().simParams.getMRPPlanningHorizon()];
     String[] PLnames = new String[get_Main().simParams.getMRPPlanningHorizon()];
     String[] Lnames = new String[get_Main().simParams.getMRPPlanningHorizon()];
     String[][] Wnames = new String[itemsToPlan.size()][get_Main().simParams.getMRPPlanningHorizon()];
     String[][] Rnames = new String[itemsToPlan.size()][get_Main().simParams.getMRPPlanningHorizon()];     
     String[][] Bnames = new String[itemsToPlan.size()][get_Main().simParams.getMRPPlanningHorizon()];     
     String[][] Znames = new String[itemsToPlan.size()][get_Main().simParams.getMRPPlanningHorizon()];     
     
     
     for(int i = 0; i< get_Main().simParams.getMRPPlanningHorizon(); i++){
          for (int p = 0; p < itemsToPlan.size(); p++) {
        	 	Inames[p][i] = "I" + itemsToPlan.get(p).getItem().getItem() + "_" + i; 
        	 	Pnames[p][i] = "P" + itemsToPlan.get(p).getItem().getItem() + "_" + i; 
        	 	Wnames[p][i] = "W" + itemsToPlan.get(p).getItem().getItem() + "_" + i; 
        	 	Rnames[p][i] = "R" + itemsToPlan.get(p).getItem().getItem() + "_" + i; 
        	 	Bnames[p][i] = "B" + itemsToPlan.get(p).getItem().getItem() + "_" + i; 
        	 	PLnames[i] = "PL" + itemsToPlan.get(p).getItem().getItem() + "_" + i; 
        	 	Lnames[i] = "L" + itemsToPlan.get(p).getItem().getItem() + "_" + i;
	    	 	Znames[p][i] = "Z" + itemsToPlan.get(p).getItem().getItem() + "_" + i;  
        	 	 
	     }
     }


  //   IloNumVar[] C = new IloNumVar[main.simParams.getMRPPlanningHorizon()]; cweg
     for (int t = 0; t < get_Main().simParams.getMRPPlanningHorizon(); t++) {
//        C[t] = cplex.numVar(0, Double.MAX_VALUE, "C" + "_" + t); cweg
     }
     
     IloNumVar[][] I = new IloNumVar[itemsToPlan.size()][];
     for (int p = 0; p < itemsToPlan.size(); p++) {
        I[p] = cplex.numVarArray(get_Main().simParams.getMRPPlanningHorizon(), 0, Double.MAX_VALUE, Inames[p]);
        //oCosts += itemsToPlan.get(p).getItem().getHoldingCosts();
     }
     
     //oCosts = oFactor*oCosts;
     
     IloNumVar[][] P = new IloNumVar[itemsToPlan.size()][];
     for (int p = 0; p < itemsToPlan.size(); p++) {     
        P[p] = cplex.numVarArray(get_Main().simParams.getMRPPlanningHorizon(), 0,  Double.MAX_VALUE, Pnames[p]);        
     }
     
     IloNumVar[] PL = new IloNumVar[leadtimeHorizon];     
     IloNumVar[] L = new IloNumVar[leadtimeHorizon];     
     
     for (int t = 0; t < leadtimeHorizon; t++) {               
     	PL[t] = cplex.numVar(0,  Double.MAX_VALUE, PLnames[t]);
     	L[t] = cplex.numVar(0,  Double.MAX_VALUE, Lnames[t]);
     }
     
                    
     IloNumVar[][] W = new IloNumVar[itemsToPlan.size()][];
     for (int p = 0; p < itemsToPlan.size(); p++) {
        W[p] = cplex.numVarArray(get_Main().simParams.getMRPPlanningHorizon(), 0, Double.MAX_VALUE, Wnames[p]);
     }
		
	 IloNumVar[][] R = new IloNumVar[itemsToPlan.size()][];
     for (int p = 0; p < itemsToPlan.size(); p++) {
        R[p] = cplex.numVarArray(get_Main().simParams.getMRPPlanningHorizon(), 0.0, Double.MAX_VALUE, Rnames[p]);
     }          
     
     IloNumVar[][] B = new IloNumVar[itemsToPlan.size()][];
     for (int p = 0; p < itemsToPlan.size(); p++) {
        B[p] = cplex.numVarArray(get_Main().simParams.getMRPPlanningHorizon(), 0.0, Double.MAX_VALUE, Bnames[p]);
     }
     
     IloNumVar[][] Z = new IloNumVar[itemsToPlan.size()][];
     for (int p = 0; p < itemsToPlan.size(); p++) {
        Z[p] = cplex.numVarArray(get_Main().simParams.getMRPPlanningHorizon(), 0, Double.MAX_VALUE, Znames[p]);
     }    
               	
	double[] inventory = new double[itemsToPlan.size()];
	double[] wip = new double[itemsToPlan.size()];
	double[] produce = new double[itemsToPlan.size()];
	double[] tl = new double[itemsToPlan.size()];
		
	int[][] X = new int[itemsToPlan.size()][get_Main().simParams.getMRPPlanningHorizon()];

	List<SpecialObject> iQd = new ArrayList<SpecialObject>();
	List<SpecialObject> runningOrders = new ArrayList<SpecialObject>();
	
     for (int p = 0; p < itemsToPlan.size(); p++) {      	     

     		   inventory[p] = 0;
     		   
     		   //wip[p] = (int)ProductionOrder.GetCurrentWip(get_Main().productionOrders, itemsToPlan.get(p).getItem(), get_Main().simParams);
     		   	wip[p]=0;
     		   
	        	int tmp_item = itemsToPlan.get(p).getItem().getItem();
				     		
     		   produce[p] = 0;
     		   
     		   //tl[p] = itemsToPlan.get(p).getItem().getTransportLotSize();
     	       for (int t = 0; t < get_Main().simParams.getMRPPlanningHorizon(); t++) {               	                          	               	
	               			               		               		               		               	
	               	//int tmp_item = itemsToPlan.get(p).getItem().getItem();
	               	int temp_t = t;
	               	int quantityRunningProductionOrders = 0;
	               	int lateOrders = 0;
	               	
	               	MRP mrpItem = null;
	               	
	               	if(t > 0){
		               	mrpItem = get_Main().mrpTable.stream().filter(e -> e.getItem().getItem() == tmp_item
		               	 && e.getTime() == time() && e.getPeriod() == temp_t-1).findFirst().orElseGet(() -> new MRP());
		               	 
		               	 //traceln("T for running Orders: " + t);
		               	 quantityRunningProductionOrders = remainingProductionOrderQty(tmp_item,t + time());
		               	 
		               	 //late Orders must only be computed in period 1 and not the remaining.
		               	 if(t == 1){
		               	 	lateOrders = lateProductionOrdersQty(tmp_item,t + time());						
		               	 }
		               	 
		               	 //traceln("t " + t + " PlannedOrderReceipts " + (int) mrpItem.getPlannedOrderReceipts()); 
		               	 
		               	 X[p][t] += (int) mrpItem.getPlannedOrderReceipts();
		               	 		               	 
		               	//mrpItem.setPlannedOrderReceipts(mrpItem.getPeriod() + 50);
		               	//traceln("MRP Item for Optimization");
		               	//traceln(MRP.GetCSVHeader());
		               	//traceln(MRP.GetCSVString(mrpItem));
	               	}
															
					if(quantityRunningProductionOrders > 0 || lateOrders > 0){
						traceln("RunningProduction Order Qty: " + quantityRunningProductionOrders + " time: " + time() + " t " + t + " item " + tmp_item);
						traceln("old Xpt: " + X[p][t]);
						
						if(t == 1){
							X[p][1] += (quantityRunningProductionOrders + lateOrders);							
						}else{
							X[p][t] += quantityRunningProductionOrders;
						}															
						
						traceln("new Xpt: " + X[p][t]);
						traceln("Now we have to consider the Remaining Qty for Capacity Consumption of: " + X[p][t]);
						
						SpecialObject runningOrder = new SpecialObject(
	        				mrpItem.getItem().getItem(),
	        				X[p][t], 
	        				t,
	        				quantityRunningProductionOrders + lateOrders);
	        				
	        			runningOrders.add(runningOrder);						
					}
															
					//if(t == 1){						
	        			//X[p][t] += (int) mrpItem.getPlannedOrderReceipts();	        				        			
	        		//}else if(t > 1){	        		
	        		
	        		
	        		//}

	        		if(X[p][t] > 0 && t > 0) {
	        			SpecialObject so = new SpecialObject(
	        				mrpItem.getItem().getItem(),
	        				X[p][t], 
	        				t,
	        				quantityRunningProductionOrders + lateOrders);
	        			iQd.add(so);
	        			traceln("X[" + p + "," + t + "] " + X[p][t] + " " + mrpItem.getItem().getItem());	        				        			        		
	        			
	        			//traceln("~~~~~~~~~~~~~" + so.getItem() + " qty: " + so.getQuantity() + " dd " + so.getDueDate());
	        			
	        		}        		  	        		        		
            }     	      	
     }                                        
     
     //if(iQd.size() == 0){     	
     	//throw new ProblemFoundException("No Planned order Receipts found.");
     //}
     	
               
     String[][] RiNames = new String[iQd.size()][leadtimeHorizon];
     int[][] releaseTmp = new int[iQd.size()][main.simParams.getMRPPlanningHorizon()];
     String[] releaseForX = new String[iQd.size()];

	 // this combinations are constructed .. every time the due date in this case 13, a 0 value is added RI_103_13_106.0_0R103_0
	 
	 //RI_103_13_106.0_0R103_0 + RI_103_13_106.0_0R103_0
       //+ RI_103_13_106.0_0R103_0 + RI_103_13_106.0_1R103_1
       //+ RI_103_13_106.0_2R103_2 + RI_103_13_106.0_3R103_3
       //+ RI_103_13_106.0_4R103_4 + RI_103_13_106.0_5R103_5
       //+ RI_103_13_106.0_6R103_6 + RI_103_13_106.0_7R103_7
       //+ RI_103_13_106.0_8R103_8 + RI_103_13_106.0_9R103_9
       //+ RI_103_13_106.0_10R103_10 + RI_103_13_106.0_11R103_11
       //+ RI_103_13_106.0_12R103_12 + RI_103_13_106.0_13R103_13 
	 
	 //for each Xt > 0 an entry to iQd is added and this represnts all Xts of all planned products!
     for (int p = 0; p < iQd.size(); p++) {
          for(int i = 1; i < leadtimeHorizon; i++){
          		int targetT = (int)(iQd.get(p).getDueDate() - leadtimeHorizon + i + 1);          		
          		
          		if(targetT < 0)
          			targetT = 0; // is 0 as this are values later thaen the due date e.g. 13
          		          		
          		releaseTmp[p][targetT] = i+1;
          		
          		if(targetT > 0){          		          		
        	 		RiNames[p][i] = "RI_" +  iQd.get(p).getItem() + "_" + (int)iQd.get(p).getDueDate() +         	 	
        	 		"_" + iQd.get(p).getQuantity() + "_" + targetT + "R" + iQd.get(p).getItem() + "_" + targetT; 
        	 	}else{
        	 		RiNames[p][i] = "noRelease";// + p + "" + i;
        	 	}        	 	        	 	
        	 	
        	 	//traceln(RiNames[p][i]);
	     }    
     }


	 //for each product we need the individual releases RI.....They are constructed with the above equation.            
	 //traceln("iQd.size " + iQd.size());
     IloNumVar[][] RI = new IloNumVar[iQd.size()][];
     for (int p = 0; p < iQd.size(); p++) {
          	     	
     	//e.g. if we have 8 releases while iqd.size = 8 and this all all the xts, we also need 8 RIs to get an individual decision for each Xt, which must be associated with an Release
     	// in each RiNames the item and due date (item and xt) is coded, consequently this works. 
        RI[p] = cplex.boolVarArray(leadtimeHorizon, RiNames[p]);                
        
     }                                      
            
     	//Objective Function     
		IloLinearNumExpr objFunction  = cplex.linearNumExpr();
	         
        for (int p = 0; p < itemsToPlan.size(); p++) {
           for (int t = 0; t < get_Main().simParams.getMRPPlanningHorizon(); t++) {
              objFunction.addTerm (itemsToPlan.get(p).getItem().getHoldingCosts(), I[p][t]);
            }
         }

        for (int p = 0; p < itemsToPlan.size(); p++) {
           for (int t = 0; t < get_Main().simParams.getMRPPlanningHorizon(); t++) {
             objFunction.addTerm (itemsToPlan.get(p).getItem().getHoldingCostsWIP(), W[p][t]);
            }                     	            
         } 
         
         for (int p = 0; p < itemsToPlan.size(); p++) {
           for (int t = 0; t < get_Main().simParams.getMRPPlanningHorizon(); t++) {
             objFunction.addTerm (itemsToPlan.get(p).getItem().getBacklogCosts(), B[p][t]);
            }                     	            
         } 
         
                  
         for (int t = 0; t < get_Main().simParams.getMRPPlanningHorizon(); t++) {
             //objFunction.addTerm (oCosts, C[t]); cweg
         }                     	                              
                                      
         cplex.addMinimize(objFunction); //objective function
       
         for (int p = 0; p < itemsToPlan.size(); p++) {
           		
         	cplex.addEq(I[p][0],0); //Eq7
         	cplex.addEq(P[p][0],0); //Eq8  Pg,0 must be zero to avoid production in this period. this is not possible.                           
         	//cplex.addEq(W[p][0],0); //Eq7
         	cplex.addEq(R[p][0],0); //Eq9
         	cplex.addEq(W[p][0],0); //Eq10
         
            for (int t = 1; t < get_Main().simParams.getMRPPlanningHorizon(); t++) {
	           	cplex.addEq(cplex.sum(cplex.sum(I[p][t], X[p][t]),B[p][t-1]), 
                       cplex.sum(cplex.sum(I[p][t-1], P[p][t-1]),B[p][t]));
        	}
            
              
            cplex.addEq(W[p][0], R[p][0]);
            
            for (int t = 1; t < get_Main().simParams.getMRPPlanningHorizon(); t++) {
               cplex.addEq(cplex.sum(W[p][t], P[p][t-1]), 
                           cplex.sum(W[p][t-1], R[p][t]));   
                                                                                                                                    
            }			             											
         }
         
         //********************* Sum of RI_t == 1 *************************
         // RI_103_13_106.0_0R103_0 + RI_103_13_106.0_0R103_0 + RI_103_13_106.0_0R103_0 + RI_103_13_106.0_1R103_1  + RI_103_13_106.0_2R103_2 + RI_103_13_106.0_3R103_3  + RI_103_13_106.0_4R103_4 + RI_103_13_106.0_5R103_5 .... = 1       
         // CF Article EQ3 
          List<String> unique = new ArrayList();
          
          for (int p = 0; p < iQd.size(); p++) {
            IloLinearNumExpr num_expr_Sum_Binaries = cplex.linearNumExpr();  
            boolean weHaveRI = false;	           
	            for (int t = 1; t < leadtimeHorizon; t++) {	            	
	            	
	            	//int tmp_p = p;
	            	//int tmp_t = t;
	            	//traceln("test auf " + RI[tmp_p][tmp_t].getName());
	            	
	            	//boolean exists = unique.stream().filter(element -> element != null).anyMatch(element -> element.equals(RI[tmp_p][tmp_t].getName()));
	            	            	
	            	//if(!exists) {
	            		//unique.add(RI[tmp_p][tmp_t].getName());
	            		//traceln("p" + p + " t " + t );
	            		
	            		if(RI[p][t] != null){
	            		//traceln("ri not null");
	            		String variableName = RI[p][t].getName();
	            		//char isItRI = "RI";
	            		//traceln("Found variable " + variableName);
	            		
							           		
		            		if(variableName.contains("RI")){
		            			weHaveRI = true;
		            			num_expr_Sum_Binaries.addTerm(1,RI[p][t]);															
		            		}
		            		
	            		}
	            		
	            		
	            		//traceln("add" + RI[tmp_p][tmp_t].getName());
	            	//}else{
	            		//num_expr_Sum_Binaries.addTerm(0,RI[p][t]);															
	            	//}					
	            }
	            	            
	            if(weHaveRI)
	            	cplex.addEq(num_expr_Sum_Binaries,1);
            }
         
         
         //RI structure
         //Eq2 where Rg,t = RIg,t*Xg,t
         //RI_item_Xt_qty_start_lth_...end_lth_Ritem_start_lth...end_lth
         for (int pp = 0; pp < itemsToPlan.size(); pp++) {
         	IloLinearNumExpr cf = cplex.linearNumExpr();				         
	       for (int t = 1; t < main.simParams.getMRPPlanningHorizon()-1; t++) {	            	            
			       	String o = "";
			       	int sizeExpr = 0;
			        IloLinearNumExpr num_expr = cplex.linearNumExpr();
			                    
	                for (int p = 0; p < iQd.size(); p++) {
	                	if(iQd.get(p).getItem()== itemsToPlan.get(pp).getItem().getItem()){
	                	
		            		if(releaseTmp[p][t] > 0){
		            			
		            			o = o + iQd.get(p).getQuantity() + "*" + RI[p][releaseTmp[p][t]-1].getName() +  "+";	            			
		            			num_expr.addTerm(iQd.get(p).getQuantity(),RI[p][releaseTmp[p][t]-1]);
		            					            					            					            			
		            			sizeExpr++;		            					            					            			
		            		}			        
	            		}
					}
					
				if(o.length() > 1){
		            if(sizeExpr > 0){
		            	//Constraint Release Size 
			            cplex.addEq(R[pp][t],num_expr);    
			                  
			        }

				}else{
				         cplex.addEq(R[pp][t],0);          								
				}
																
				num_expr.clear();             														
			}         
         }
                         
		IloLinearNumExpr[] sumRIs = new IloLinearNumExpr[main.simParams.getMRPPlanningHorizon()];
		
		for (int t = 0; t < main.simParams.getMRPPlanningHorizon(); t++) {
		    IloLinearNumExpr sumRIsI = cplex.linearNumExpr();
		
		    for (int pp = 0; pp < itemsToPlan.size(); pp++) {
		        for (int p = 0; p < iQd.size(); p++) {
		            if (iQd.get(p).getItem() == itemsToPlan.get(pp).getItem().getItem()) {
		                if (releaseTmp[p][t] > 0) {
		                	//traceln("###### " + 1.0 + " :::: " +  RI[p][releaseTmp[p][t] - 1]);		                
		                    sumRIsI.addTerm(1.0, RI[p][releaseTmp[p][t] - 1]);		                    
		                }
		            }
		        }
		    }
		    
		    sumRIs[t] = sumRIsI;		    		    		    
		    //sumRIsI.clear();
		}				
		             


            
//Constraint avoiding that RI with later due date, releases order earlier that RI with earlier due date (orders should not overteak each other)
//The release of order 2 should not before order 1                                         
// ********************************* Guarantee Release ORDER  ****************************************
// ***************************************************************************************************            
//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
// Constraint avoiding that RI with later due date, releases order earlier that
// RI with earlier due date (orders should not overteak each other) The release
// of order 2 should not before order 1

//daher
traceln("iQd size " + iQd.size());

List<SpecialObject> iQdSorted = iQd;

Collections.sort(iQdSorted, Comparator.comparing(SpecialObject::getDueDate).thenComparing(SpecialObject::getItem));
//Collections.sort(iQdSorted, Comparator.comparing(SpecialObject::getItem).thenComparing(SpecialObject::getDueDate));

traceln("IQd sorted:");
for(SpecialObject o : iQdSorted){
	traceln(o.getDueDate()  + " " + o.getItem() + " " + o.getQuantity());						
}

for(int i = 0; i < iQdSorted.size() -1; i++){
//now take the first succesor:
		SpecialObject currentiQd = iQdSorted.get(i);		
		SpecialObject succesoriQd = iQdSorted.get(i+1);
		
		if(currentiQd.getDueDate() <= succesoriQd.getDueDate() && currentiQd.getDueDate() > 1){
						
			int overlappingStart = max((int)succesoriQd.getDueDate() - leadtimeHorizon,0);
			//traceln("overlapping start" + (int)succesoriQd.getDueDate()  + " -" + leadtimeHorizon + "=" + overlappingStart);
			// for the overlapping time we have to generate the RI comparisions:			
			IloLinearNumExpr lhs = cplex.linearNumExpr();
	        IloLinearNumExpr rhs = cplex.linearNumExpr();

             // traceln("Start Index " + RIstartIndex);
            int overlappingPeriods = (int)currentiQd.getDueDate() - overlappingStart;
			
			int RIstartIndex =  max(0, (leadtimeHorizon - overlappingPeriods));                                            

            StringBuilder lhsOut = new StringBuilder();
            StringBuilder rhsOut = new StringBuilder();
                          
            int multiplier = 0;                   
            //traceln("Overlapping Periods " + overlappingPeriods);
            //traceln("Overlapping Start "  + overlappingStart);            
            
            for (int o = 0; o < overlappingPeriods; o++) {
				
				IloNumVar found = Function_FindeRIVarialbe(iQdSorted.size(), RI, currentiQd.getItem(), (int)currentiQd.getDueDate(), o+1, (int)currentiQd.getQuantity());
				
				IloNumVar foundSuccessor = Function_FindeRIVarialbe(iQdSorted.size(), RI, succesoriQd.getItem(), (int)succesoriQd.getDueDate(), o+1, (int)succesoriQd.getQuantity());
				
                //if (RI[p][RIstartIndex + o].getName().contains("RI")) {
                //traceln("found" + found.getName());
                if (found.getName().contains("RI")) {
                
                	lhs.addTerm(multiplier + 1, found);
                	lhsOut.append(multiplier + 1 + " " + found.getName()  + " + ");
                	
                	rhs.addTerm(multiplier + 1, foundSuccessor);
                	rhsOut.append(multiplier + 1 + " " + foundSuccessor.getName() + " + ");
                	                
                	multiplier++;
                }
            }
            
            //for the remaining periods we have to extend the rhs:
            
            
            for (int o = 0; o < succesoriQd.getDueDate() - overlappingPeriods; o++) {
												
				IloNumVar foundSuccessor = Function_FindeRIVarialbe(iQdSorted.size(), RI, succesoriQd.getItem(), (int)succesoriQd.getDueDate(), overlappingPeriods + o + 1, (int)succesoriQd.getQuantity());								
				
                //if (RI[p][RIstartIndex + o].getName().contains("RI")) {
                //traceln("found" + found.getName());
                if (foundSuccessor.getName().contains("RI")) {                                
                	
                	rhs.addTerm(multiplier + 1, foundSuccessor);
                	rhsOut.append(multiplier + 1 + " " + foundSuccessor.getName() + " + ");
                	                
                	multiplier++;
                }
            }
            
            
            cplex.addLe(lhs, rhs);

         traceln("Overlapping:");
         traceln(lhsOut.toString() + "<=");
         traceln(rhsOut.toString());             						
		
		}													
}
         
//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~            
                                                                                                
            
         //****************** CF SECTION ***************************************
         //*********************************************************************
         
         for (int t = 0; t < main.simParams.getMRPPlanningHorizon(); t++) {	    
         
	     	IloLinearNumExpr cf = cplex.linearNumExpr();				             	    
	     	IloLinearNumExpr cf1 = cplex.linearNumExpr();				             	    
	       	IloLinearNumExpr cf2 = cplex.linearNumExpr();				             	    
		   	IloLinearNumExpr cf3 = cplex.linearNumExpr();				             	    
	       	IloLinearNumExpr cf4 = cplex.linearNumExpr();				             	    

    	    
    	    //Pgt smaller Wgt - Constraint for single item qty
        	 for (int pp = 0; pp < itemsToPlan.size(); pp++) {        	  			
					//merk dir, dass die weiter unten verwendet werden
					//double setupProption = 18.0/106.0;
					double setupProption = 0;
					
	         		cf.addTerm(itemsToPlan.get(pp).getItem().getRouting().getEProcessingTime()+setupProption,P[pp][t]);	         		
	         		
	         		cf1.addTerm(itemsToPlan.get(pp).getItem().getRouting().getEProcessingTime()+setupProption,P[pp][t]); 	         		        		
         			cf2.addTerm(itemsToPlan.get(pp).getItem().getRouting().getEProcessingTime()+setupProption,W[pp][t]);         			         		        			         			
         			
         			cf3.addTerm(itemsToPlan.get(pp).getItem().getRouting().getEProcessingTime()+setupProption,P[pp][t]);         		
         			cf4.addTerm(itemsToPlan.get(pp).getItem().getRouting().getEProcessingTime()+setupProption,W[pp][t]);
         			
         			
         			//***************** Ppt, <= Wp,t ***********************        			         		         			
         			cplex.addLe(
         				//cplex.sum(P[pp][t],cplex.prod(0,sumRIs[t])),//LHS         			
         				cplex.sum(P[pp][t],0),//LHS         			
        				cplex.sum(W[pp][t],0));//RHS         			
        			//****************************************        			         		         				
        				        				        				        			        			        				
        	  }
        	          	  
			  //CF Constraints			           	  
			  //PL <= MC + Ct (Eq12)			  
			  //traceln("setup time " + setupTime + " sum ri " + sumRIs);
         	  //cplex.addLe(cplex.sum(cf,cplex.prod(setupTime,sumRIs)), //LHS         	  
         	  
         	  
         	  // **************** PL und L ausgeben *********************
         	  //keine constraints werden spter so auch nicht wiedervendet
         	  cplex.addEq(PL[t],cf);
         	  cplex.addEq(L[t],cf2);
         	  //********************************************************* 
         	  
         	  
         	  //cplex.addEq(PL[t],cplex.sum(cf,cplex.prod(setupTime,sumRIs)));
         	  //cplex.addEq(L[t],cplex.sum(cf2,cplex.prod(setupTime,sumRIs)));         	           	           	           	  
         	  
         	  /******** PLt <=MC+Ct (Eq14) ************/
         	  if(t==0){         	           	           	           	  
         	  		cplex.addLe(cf,0);	//RHS
         	  	}else{
         	  		//cplex.addLe(cf,         	  		
         	  		//traceln("da" + sumRIs[t].toString());
         	  		cplex.addLe(cplex.sum(cf,cplex.prod(setupTime,sumRIs[t])),         	  
         	  		maxCapacity);	//RHS
         	  	}
         	           	           	           	  		         	           	           	  
         	           	           	  
         	  // ---- we have three segments         	           	           	  
			  //CF partition 2 from numerical example
			  //traceln("# segments " + numberSegments);
			  //represent CF as k*x + d -> 
			  for(int i = 0; i < numberSegments; i++){
	         	  cplex.addLe(
    	     	  	cplex.sum(cf1,cplex.prod(setupTime,sumRIs[t])), //LHS				
				
         	  		cplex.sum(cplex.sum(cplex.prod(max(slopes[i],0),         	  	         	  	
         	  		
         	  		cplex.sum(cf2,cplex.prod(setupTime,sumRIs[t]))),intercepts[i]),0));//RHS         	  		         	  						
         	  	
         	  		traceln("Slope (x): " + slopes[i] + " Y-intercept (d) " + intercepts[i]);
         	  		         	  		
         	  	//traceln("sumRIs " + sumRIs + " st " + setupTime);	
         	  }//for
         	           	           	           	  
         	           	           	           	  			           	  
         	  /******************************* PLt <= Lt + Ct (Eq18) *********************/
         	  //Constraint Pl musst be smaller as SL for all t         	           	  
         	  cplex.addLe(
         	  	cplex.sum(cf3,cplex.prod(setupTime,sumRIs[t])), //LHS         	  
	         	cplex.sum(cplex.sum(cf4,cplex.prod(setupTime,sumRIs[t])),0));         	  	         	
	          //***************************************************************************
         	  
			  cf.clear();
			  cf1.clear();
 			  cf2.clear();
 			  cf3.clear();
 			  cf4.clear();
         }



			// Create a two-dimensional array of IloNumVars
            int numRows = iQd.size(); // Assuming iQd is a list or array
                        
            // ... Initialize and populate the RI array with IloNumVars ...

            // Find the variable by name in the RI array
            traceln("iQd size: " + iQd.size());
            String targetVariableName = "noRelease";
            boolean isVariableFound = false;
            IloNumVar foundVariable = null;

            for (int i = 0; i < numRows; i++) {
                for (int j = 1; j < RI[i].length-1; j++) {
                    IloNumVar var = RI[i][j];
                    if (var.getName().equals(targetVariableName)) {
                        isVariableFound = true;
                        foundVariable = var;
                        break;
                    }
                }
                if (isVariableFound) {
                    break;
                }
            }
            
            if (isVariableFound) {
                // Add a constraint to enforce the found variable to be zero
                traceln("Yes found set no release to 0");                
                foundVariable.setName("noRelease");                                
                cplex.addEq(foundVariable, 0);
            }
            
            //All Entries represent Running Orders. So the associated
            //RI_...1 must be set to one
            
                                    
            int numberOpenOrders = runningOrders.size();
            for(SpecialObject o : runningOrders){
            	traceln(o.getItem() + " " + o.getQuantity() + " " + o.getQuantityRunning());
            }
            
            
            traceln("Count Running Orders: " + numberOpenOrders);
            traceln("RI length: " + RI.length);
            if(iQd.size() > 0){
            for (int i = 0; i < iQd.size(); i++) {
            	isVariableFound = false;            	
            	if(iQd.get(i).getQuantityRunning() > 0){
            		traceln("search " + iQd.get(i).getItem() + " " + iQd.get(i).getDueDate() + " " + iQd.get(i).getQuantity() + " " + iQd.get(i).getQuantityRunning());
	            	for(int a=0; a < iQd.size(); a++){
	            	for (int j = 1; j < RI[a].length; j++) {
	            	
	            		//"RI_103_13_106.0_0R103_0"
	            					                                		
	            	    String[] RiSplitted = RI[a][j].getName().split("_");
				        //traceln(RI[a][j].getName().split("_"));
	                    
	                    IloNumVar var = RI[a][j];
	                    
	                    if(!var.getName().equals("noRelease")){
	                    	
	                    	targetVariableName = "RI_" + iQd.get(i).getItem() + "_" + (int) iQd.get(i).getDueDate() + "_" + 
	                    	iQd.get(i).getQuantity() + "_1" + "R" +  iQd.get(i).getItem() + "_1";
	                    
	                    	//traceln("Running Order Target Name ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~: " + targetVariableName);
	                    
		                    if (var.getName().equals(targetVariableName)) {
		                        isVariableFound = true;
		                        foundVariable = var;
		                        break;
		                    }//if
		                 }//if
	                }//for
	                
	                if(isVariableFound){
	                	break;
	                }
	                
	               }//for                         
				}//if
				                
                if (isVariableFound) {	                	                	                
	                cplex.addEq(foundVariable, 1);
	                traceln("Release Variable found " + foundVariable.getName() + " set to 1");
	                isVariableFound = false;
            	}
            }//for
            }//if
                                                               
    
    //cplex.deleteNames();
    
    //if(time() == 0)
    if(Tools.Log_CF_Optimization_Values){                 
		cplex.exportModel("model/NewModel_" + time() + "_" + bomLevel + "_" + firstBomItem.getItem() +".lp");
	}	
	//cplex.writeSolution("model/NewModel_" + time() + "_" + bomLevel + ".sol");

	//cplex.setParam(IloCplex.BooleanParam.PreInd, true);
	//0.05 were to hard ... 0.1 before
	//cplex.setParam(IloCplex.Param.MIP.Tolerances.MIPGap, 0.05);
	//cplex.setParam(IloCplex.IntParam.DataCheck, 2);	
	cplex.setParam(IloCplex.Param.Threads, 4);
	cplex.setParam(IloCplex.IntParam.WorkMem, 2000);
						
	if(cplex.solve() && Tools.Log_CF_Optimization_Values){
		    
		    System.out.println("Solution status: " + cplex.getStatus());
            System.out.println();
            System.out.println("Objective Value = " + cplex.getObjValue());
          
            System.out.println("Pieces: Wip, X, Release, P");
            System.out.println("Minutes: PL L, MC, CF1, CF2, CF3");
            System.out.println("\tp\tTime\tt\tWip\tX\tRelease\tP\tPL\tL\tMC\tCF1\tCF2\tCF3\tInv\tIBl\tWB\tObjPP\tCt\tBt\tPTime\tSTime\tPL\tLt\tICo\tWCo\tBco\tCo");
          	
            int[] t_sum_wip = new int[get_Main().simParams.getMRPPlanningHorizon()];
            int[] t_sum_pl = new int[get_Main().simParams.getMRPPlanningHorizon()];
            int[] t_sum_l = new int[get_Main().simParams.getMRPPlanningHorizon()];
            int[] t_sum_load = new int[get_Main().simParams.getMRPPlanningHorizon()];
            int[] t_sum_x = new int[get_Main().simParams.getMRPPlanningHorizon()];
            int[] t_sum_r = new int[get_Main().simParams.getMRPPlanningHorizon()];
            int[] t_sum_p = new int[get_Main().simParams.getMRPPlanningHorizon()];
          	
            for (int p = 0; p < itemsToPlan.size(); p++) {
                        	
               for (int t = 0; t < get_Main().simParams.getMRPPlanningHorizon(); t++) {
               
               double inventoryBalance = 0;
               double wipBalance = 0;

               if(t>0){
                  inventoryBalance = cplex.getValue(I[p][t-1])-X[p][t]+cplex.getValue(P[p][t-1]) - cplex.getValue(B[p][t-1]) + cplex.getValue(B[p][t]);
                  wipBalance = cplex.getValue(W[p][t-1])+cplex.getValue(R[p][t])-cplex.getValue(P[p][t-1]);               
               }
               		
               	  double lt = cplex.getValue(W[p][t])*itemsToPlan.get(p).getItem().getRouting().getEProcessingTime();
               	  double pl = cplex.getValue(P[p][t])*itemsToPlan.get(p).getItem().getRouting().getEProcessingTime();
               	  
               	  double objectivePerPeriod = cplex.getValue(W[p][t]) * itemsToPlan.get(p).getItem().getHoldingCostsWIP() + 
               	  							  cplex.getValue(I[p][t]) * itemsToPlan.get(p).getItem().getHoldingCosts() + 
               	  							  cplex.getValue(B[p][t]) * itemsToPlan.get(p).getItem().getBacklogCosts() 
               	  							  ;  
               	  							  
               	  							  
               	 // traceln(cplex.getValue(W[p][t]) + "*" + itemsToPlan.get(p).getItem().getHoldingCostsWIP() + " = " + cplex.getValue(W[p][t]) * itemsToPlan.get(p).getItem().getHoldingCostsWIP());							               	  
               	 // traceln(cplex.getValue(I[p][t]) + "*" + itemsToPlan.get(p).getItem().getHoldingCosts() + " = "  + cplex.getValue(I[p][t]) * itemsToPlan.get(p).getItem().getHoldingCosts());							               	  
               	 // traceln(cplex.getValue(B[p][t]) + "*" + itemsToPlan.get(p).getItem().getBacklogCosts() + " = " + cplex.getValue(B[p][t]) * itemsToPlan.get(p).getItem().getBacklogCosts());							               	  
               	 // traceln(cplex.getValue(C[t]) + "*" + oCosts + " = " + cplex.getValue(C[t]) * oCosts);							               	  
               	  
               	  int slope2 = -99;
               	  int slope3 = -99;
               	  
               	  if(selectedSegments.size() == 2){
               	  	slope2 = (int)(slopes[1]*lt+intercepts[1]);
               	  }
               	  
              	  if(selectedSegments.size() == 3){
               	  	slope3 = (int)(slopes[2]*lt+intercepts[2]);
               	  }
               	                 	  
               	  int wipForPrintLn = (int)cplex.getValue(W[p][t]);               	                 	                 	  
               	  
                  System.out.println("\t" + itemsToPlan.get(p).getItem().getItem() +
                                     "\t" + (time() + t -1) +
                                     "\t" + t +                                     
                                     "\t" + (int)Math.round(wipForPrintLn) +
                                     "\t" + X[p][t] +
                                     "\t" + (int)Math.round(cplex.getValue(R[p][t])) +                                            
                                     "\t" + cplex.getValue(P[p][t]) +
                                     //"\t" + (int)Math.round(pl) +
                                     //"\t" + (int)Math.round(lt) +                                     
                                     "\t" + cplex.getValue(PL[t]) +      
                                     "\t" + cplex.getValue(L[t])  +
                                     "\t" + maxCapacity + 
                                     "\t" + (int)(slopes[0]*lt+intercepts[0]) + 
                                     "\t" + slope2 + 
                                     "\t" + slope3 +                                      
                                     "\t" + Math.round(cplex.getValue(I[p][t])) +
                                     "\t" + Math.round(inventoryBalance) +
                                     "\t" + (int)Math.round(wipBalance) +
                                     "\t" + (int)Math.round(objectivePerPeriod) +
                                     "\t -555" +  
                                     "\t" + (int)cplex.getValue(B[p][t]) + 
                                     "\t" + itemsToPlan.get(p).getItem().getRouting().getEProcessingTime() +
                                     "\t" + itemsToPlan.get(p).getItem().getRouting().getESetupTime()  +
                                     "\t" + cplex.getValue(PL[t]) +      
                                     "\t" + cplex.getValue(L[t])  +
                                     "\t" + (int)itemsToPlan.get(p).getItem().getHoldingCosts() +
                                     "\t" + (int)itemsToPlan.get(p).getItem().getHoldingCostsWIP() +
                                     "\t" + (int)itemsToPlan.get(p).getItem().getBacklogCosts() +
                                     "\t" + (int)-55                                                                              
                                     );                                                                                                 
            
            		//t_sum_wip[t] += wipForPrintLn;
            		
            		t_sum_x[t] += X[p][t];            		
            		t_sum_wip[t] += (int)cplex.getValue(W[p][t]) ;
            		t_sum_r[t] += (int)Math.round(cplex.getValue(R[p][t]));            		
            		t_sum_p[t] += (int)cplex.getValue(P[p][t]);
            		
            		//if(t==0){
            			t_sum_pl[t] = (int)cplex.getValue(PL[t]);
            			t_sum_l[t] = (int)cplex.getValue(L[t]);
            		//}
            			
            		t_sum_load[t] += lt;
	                                    
			if(OptimizationResult.WRITE_OPTIMIZATION_RESULTS_TO_XLXS){                    
                    OptimizationResult optResult = new OptimizationResult(                                        
                                        
	                   					itemsToPlan.get(p).getItem().getItem(),
	                                     (time() + t -1),
	                                     t,                                     
	                                     (int)Math.round(wipForPrintLn),
	                                     X[p][t],
	                                     Math.round(cplex.getValue(R[p][t])),                                            
	                                     cplex.getValue(P[p][t]),
	                                     cplex.getValue(PL[t]),      
	                                     cplex.getValue(L[t]),
	                                      maxCapacity,
	                                     (int)(slopes[0]*lt+intercepts[0]),
	                                      slope2,
	                                      slope3,                                      
	                                      (int)Math.round(cplex.getValue(I[p][t])),
	                                      (int)Math.round(inventoryBalance),
	                                      (int)Math.round(wipBalance),
	                                      (int)Math.round(objectivePerPeriod),
	                                      -55,
	                                      (int)cplex.getValue(B[p][t]), 
	                                     (double) itemsToPlan.get(p).getItem().getRouting().getEProcessingTime(),
	                                     (double) itemsToPlan.get(p).getItem().getRouting().getESetupTime(),
	                                     cplex.getValue(PL[t]),      
	                                     cplex.getValue(L[t]),
	                                     (int)itemsToPlan.get(p).getItem().getHoldingCosts(),
	                                     (int)itemsToPlan.get(p).getItem().getHoldingCostsWIP(),
	                                     (int)itemsToPlan.get(p).getItem().getBacklogCosts(),
	                                     (int)-55,
	                                     cplex.getValue(Z[p][t])                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            
	                    );
                                                            
	                    get_Main().optimizationResults.add(optResult);                                                      
	                 }   
               }                              
            }
            
            System.out.println("\n");
            System.out.println("\tTime\tt\tX\tWip\tR\tP\tPL\tL");           
            for(int t = 0; t < get_Main().simParams.getMRPPlanningHorizon(); t++) {
            
            	System.out.println(
            		"\t" + (time() + t) +
       				"\t" + t +           
       				"\t" + t_sum_x[t] + 		
            		"\t" + t_sum_wip[t] +
            		"\t" + t_sum_r[t] +
            		"\t" + t_sum_p[t] +
	           		"\t" + t_sum_pl[t] +
            		"\t" + t_sum_l[t]            	
            	);            
            }
                 	  
            
            //if(OptimizationResult.WRITE_OPTIMIZATION_RESULTS_TO_XLXS)
			//OptimizationResult.WriteXlsxOptimizationResults(get_Main().optimizationResults, get_Main().simParams);            
            	//traceln("size +++++++++++ " + get_Main().optimizationResults.size());
            
		}else{
			traceln("NO Solution " + cplex.getStatus());
		}															
        	
        	for (int p = 0; p < iQd.size(); p++) {        	        
               for (int t = 1; t < leadtimeHorizon; t++) {   
            				            
            				//traceln("da vor qty " + p + " " + t + " " + RI[p][t].getName());            				            				
					        					        				        
					        if(RI[p][t].getName() != "noRelease"){
					        						        
					        double qty = cplex.getValue(RI[p][t]);    			            			            		            
					        //traceln(qty);
					        //traceln("da for if");				               					        
							if(qty > 0.9){
					        //traceln("da");				               					        
								
								//traceln("qty " + qty + " " + RI[p][t].getName());
								
								
								//if we have a running order, we have to reduce the release qty, as it was only required for the decision of release qty
			                    //but the qty itself is already considered for production.
			                    //traceln("X[" + p + "," + t + "] " + X[p][t] + " qty " + iQd.get(p).getQuantity() + " Running Orders Qty: " + iQd.get(p).getQuantityRunning());	        				        			        		
			                    
			                    String[] RiSplitted = RI[p][t].getName().split("_");
			                    traceln(RI[p][t].getName().split("_"));
			                    
			                    double qtyXt = Double.parseDouble(RiSplitted[3]);
			                    int itemIntTmp = Integer.parseInt(RiSplitted[1]);
			                    int plannedEnd = Integer.parseInt(RiSplitted[2]);
			                    			                    			                    			                    
			                    SpecialObject sp = iQd.stream().filter(e -> e.getItem() == itemIntTmp && e.getDueDate() == plannedEnd).findFirst().get();
			                    
			                    //traceln("X qty " + iQd.get(p).getQuantity() + " Running Orders Qty: " + iQd.get(p).getQuantityRunning() + " item " + iQd.get(p).getItem() + "DD " + iQd.get(p).getDueDate());	        				        			        					                    
			                    traceln("Xqtyn " + qtyXt + " Running Orders Qty: " + sp.getQuantityRunning() + " item " + sp.getItem() + " DD " + sp.getDueDate());
			                    
			                    //double qtyFinal = Math.ceil(iQd.get(p).getQuantity()-iQd.get(p).getQuantityRunning());
			                    double qtyFinal = Math.ceil(qtyXt - sp.getQuantityRunning());
			                    
			                    traceln("Final Qty: " + qtyFinal);
			                    //traceln("Final QtyN: " + qtyFinalN);
			                    if(qtyFinal > 0){
			                    
			                    	
			                    				                    
				                    ProductionOrder order = new ProductionOrder();			                    			                    
				                    
				                    order.setQuantity(qtyFinal);			                    			                    
				                    
				                    traceln("Set Production Order Qty: " + order.getQuantity());
				                    order.setCreatedAt(time());
												                    				                    								
									//int itemIntTmp = iQd.get(p).getItem();
										
				                    //Item item = get_Main().items.stream().filter(e -> e.getItem() == itemIntTmp).findFirst().get();																		                     
				                    Item item = get_Main().items.stream().filter(e -> e.getItem() == itemIntTmp).findFirst().get();																		                     
				                    
				                    order.setOrderId(get_Main().prodOrderId++);
				                    order.setItem(item);
				                                                                                                                                  
									order.setPlannedCapacity(Routing.GetPlannedCapacityPerItem(get_Main().routings, order.getItem(), get_Main().simParams, order));
									
									//order.setPlannedCapacity(Routing.GetPlannedCapacityPerItem(routingList, order.getItem(), simParams, order));
									order.setPlannedSetupTime(Routing.GetPlannedSetupTimePerItem(get_Main().routings, order.getItem(), get_Main().simParams, order));								
				                    
				                    int minimumRoutingStep = Routing.GetMinimumStep(get_Main().routings, order.getItem() , get_Main().simParams);
									int maximumRoutingStep = Routing.GetMaximumStep(get_Main().routings, order.getItem() , get_Main().simParams);
							
									order.setMinimumRoutingStep(minimumRoutingStep);
									order.setMaximumRoutingStep(maximumRoutingStep);			
									order.setCurrentRoutingStep(minimumRoutingStep);                                        			                    			                    
				                                                            
				                    //order.setQuantity(Math.round(iQd.get(p).getQuantity()));
				                    
				                    //traceln("################################## " + iQd.get(p).getQuantity());
				                    				                    				                    				                    
				                    //get the start and end dates from the RI decision variables			                    
				                    
				                    
				                    //order.setPlannedStart(max(Integer.parseInt(RiSplitted[5]) + time() - item.getSafetyLeadTime(), time()));
				                    //order.setPlannedStart(Integer.parseInt(RiSplitted[5] + time());
	
				                    //safety leadtime for stochastic scenario
				                    //order.setPlannedStart(max(Integer.parseInt(RiSplitted[5]) + time() - 1, time()));
				                    
				                   // order.setPlannedStart(max(Integer.parseInt(RiSplitted[5]) + time() - 1, time()));
				                    
				                    //Optimization Starts with 0, so we have to subract -1 from the result to meet the correct MRP Periods
				                    order.setPlannedStart(max(Integer.parseInt(RiSplitted[5]) + time() - 1, time()));
				                    order.setPlannedEnd(Integer.parseInt(RiSplitted[2]) + time() - 1);
				                    
				                    traceln("Planned Start: " + order.getPlannedStart() +  " Planne End:" + order.getPlannedEnd() + " Time " + time());			                    			                            
				                    
				                    long exists = 0;				
				                                   			                    
				                    if(order.getPlannedStart() < time())
				                    	exists = 1;			                    											
					                    if(exists == 0){
					                    	//traceln("Production Order Added");														                    
						                    Routing routingObject = get_Main().routings.stream().filter(e -> e.getItem().getItem() == order.getItem().getItem()).findFirst().get();			
											order.setRouting(routingObject);
											order.setStatus(ProductionOrder.PRODUCTION_ORDER_STATUS_UNPROCESSED);
						                    
						                    get_Main().productionOrders.add(order);	                    						
															                    
					                    }//if
					                }    
		                    	}// if qty	
		                    	}	                    
		                 }//for            
		            }//for
                        
        if(false) {
			traceln("Production Orders from Optmization Before Removing");
			traceln(ProductionOrder.GetCSVHeader());
			
	        for (ProductionOrder order: get_Main().productionOrders) {
	           traceln(ProductionOrder.GetCSVString(order));
	        }        
			
	        //get_Main().productionOrders.removeIf(e -> e.getPlannedStart() > time());
	
	        traceln("Production Orders from Optmization FOR SIMULATION");
	        traceln(ProductionOrder.GetCSVHeader());
	
	        for (ProductionOrder order: get_Main().productionOrders) {
	            traceln(ProductionOrder.GetCSVString(order));
	        }        
	        traceln("**************************");                							
        }
		
		//get_Main().Function_OrderRelease();
		
		cplex.deleteNames();        
    	if(Tools.Log_CF_Optimization_Values){                 
			cplex.exportModel("model/NV/NewModel" + time() + "_" + bomLevel + ".lp");
		}			
		cplex.end();
	}				
	catch (IloException exc) {
         System.err.println("Concert exception '" + exc.getMessage() + "' caught");
         System.exit(-1);
    }
    //catch (ProblemFoundException exc) {
      //   System.err.println("Expection'" + exc.getMessage() + "' caught");
         //System.exit(-1);
    //}
    
return 0;


]]></Body>
				</Function>
				<Function AccessType="default" StaticFunction="false">
					<ReturnModificator>RETURNS_VALUE</ReturnModificator>
					<ReturnType><![CDATA[int]]></ReturnType>
					<Id>1659945920799</Id>
					<Name><![CDATA[Function_ClearingFunction1]]></Name>
					<ExcludeFromBuild>true</ExcludeFromBuild>
					<X>50</X><Y>230</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Parameter>
						<Name><![CDATA[itemsToPlan]]></Name>
						<Type><![CDATA[List<MRP>]]></Type>
					</Parameter>
					<Parameter>
						<Name><![CDATA[bomLevel]]></Name>
						<Type><![CDATA[int]]></Type>
					</Parameter>
					<Body><![CDATA[
try {
							

traceln("----------- Start OPTIMIZE at " + time () + " ----------------");
							
IloCplex model = new IloCplex();
IloLinearNumExpr obj = model.linearNumExpr();
List<IloRange> constraints = new ArrayList<IloRange>();

IloConstraint c;
		
//int g = 0;

List<IloNumVar> var = new ArrayList();

StringBuilder output = new StringBuilder();

double points[] = new double[] {200.0, 400.0, 600.0, 800.0};
double slopes[] = new double[] { 30.0, 80.0, 130.0, 50.0, 40.0};


   try (IloCplex cplex = new IloCplex()) {
	
     IloNumVar[][] Inv = new IloNumVar[itemsToPlan.size()][];
     for (int p = 0; p < itemsToPlan.size(); p++) {
        Inv[p] = cplex.numVarArray(get_Main().simParams.getMRPPlanningHorizon(), 0.0, Double.MAX_VALUE);
     }
     
     IloNumVar[][] Wip = new IloNumVar[itemsToPlan.size()][];
     for (int p = 0; p < itemsToPlan.size(); p++) {
        Wip[p] = cplex.numVarArray(get_Main().simParams.getMRPPlanningHorizon(), 0.0, Double.MAX_VALUE);
     }
		
	 IloNumVar[][] Release = new IloNumVar[itemsToPlan.size()][];
     for (int p = 0; p < itemsToPlan.size(); p++) {
        Release[p] = cplex.numVarArray(get_Main().simParams.getMRPPlanningHorizon(), 0.0, Double.MAX_VALUE);
     }
	
	double[] inventory = new double[itemsToPlan.size()];
	double[] wip = new double[itemsToPlan.size()];
	
	//int Release[][] = new int[itemsToPlan.size()][get_Main().simParams.getMRPPlanningHorizon()];
	
	int setupTime = 120;
	int processingTime = 2;
	int capacity = 1440;
		
	int[][] X = new int[itemsToPlan.size()][get_Main().simParams.getMRPPlanningHorizon()];
	double[] WipOrder = new double[get_Main().simParams.getMRPPlanningHorizon()];
	int[] CfHelpValueRounded = new int[get_Main().simParams.getMRPPlanningHorizon()];
	
     for (int p = 0; p < itemsToPlan.size(); p++) {      	     

     		   //inventory[p] = StockBooking.GetStockItemQuantity(get_Main().stockBookings, itemsToPlan.get(p).getItem()).getQuantity();
     		   inventory[p] = 250;
     		   wip[p] = 500;
     			
     	       for (int t = 0; t < get_Main().simParams.getMRPPlanningHorizon(); t++) {
               	
               	int item = 110;
               	
               	if(p == 1){
               		item = 111;
               	}
               	
               	int tmp_item = item;
               	int temp_t = t;
               	
               	MRP mrpItem = get_Main().mrpTable.stream().filter(e -> e.getItem().getItem() == tmp_item
               	 && e.getTime() == time() && e.getPeriod() == temp_t).findFirst().orElseGet(() -> new MRP());
 
        		X[p][t] = (int) mrpItem.getPlannedOrderReceipts();
        		  
        		WipOrder[t] +=  mrpItem.getPlannedOrderReceipts() * processingTime + setupTime;
        		CfHelpValueRounded[t] =  (int) Math.ceil(WipOrder[t] / capacity);
        		        		        		
            }     	      	
     }
     
     
     /*
     for (int p = 0; p < itemsToPlan.size(); p++) {      
     	       for (int t = 0; t < get_Main().simParams.getMRPPlanningHorizon(); t++) {
     	       if(X[p][t] > 0)
	               	Release[p][t-CfHelpValueRounded[t]] = X[p][t];        		        		        		
            }     	      	
     }
     */
     
	
	 IloLinearNumExpr minInventory  = cplex.linearNumExpr();
	         
         for (int p = 0; p < itemsToPlan.size(); p++) {
            for (int t = 0; t < get_Main().simParams.getMRPPlanningHorizon(); t++) {
               minInventory.addTerm (1, Inv[p][t]);
            }
         }
           
         cplex.addMinimize(minInventory);                     
       
         for (int p = 0; p < itemsToPlan.size(); p++) {
            
            //wip constraint            
            cplex.addEq(cplex.sum(Wip[p][0], X[p][0]), 
                           cplex.sum(wip[p], Release[p][0]));
            
            for (int t = 1; t < get_Main().simParams.getMRPPlanningHorizon(); t++) {
               cplex.addEq(cplex.sum(Wip[p][t], X[p][t]), 
                           cplex.sum(Wip[p][t-1], Release[p][t]));
            }
			
			//inventory balance             
         	cplex.addEq(cplex.sum(Inv[p][0], X[p][0]), 
            			cplex.sum(inventory[p], Release[p][0]));
         
            for (int t = 1; t < get_Main().simParams.getMRPPlanningHorizon(); t++) {
	           	cplex.addEq(cplex.sum(Inv[p][t], X[p][t]), 
                       cplex.sum(Inv[p][t-1], Release[p][t]));
        	}

			//capacity (cf)
            cplex.addLe(X[p][0], 
                           cplex.sum(wip[0], Release[p][0]));				                           
                        
            for (int t = 1; t < get_Main().simParams.getMRPPlanningHorizon(); t++) {
               cplex.addLe(X[p][t], 
                           cplex.sum(Wip[p][t-1], Release[p][t]));				                                                             
            }
         }
    
    if(time() == 0)                 
		cplex.exportModel("NewModel.lp");
	
	if(cplex.solve()){
		    System.out.println("Solution status: " + cplex.getStatus());
            System.out.println();
            System.out.println("Inventory = " + cplex.getObjValue());
          
            System.out.println();
            System.out.println("\tp\tt\tWip\tX\tRelease\tInv");
          
            for (int p = 0; p < itemsToPlan.size(); p++) {
               for (int t = 0; t < get_Main().simParams.getMRPPlanningHorizon(); t++) {
                  System.out.println("\t" + p +
                                     "\t" + t +
                                     "\t" + cplex.getValue(Wip[p][t]) +
                                     "\t" + X[p][t] +
                                     "\t" + cplex.getValue(Release[p][t]) +                               
                                     "\t" + cplex.getValue(Inv[p][t]) 
                                     //"\t" + WipOrder[t] +
                                     //"\t" + CfHelpValueRounded[t]
                                     );
               }
            }	
		}
	}
	catch (IloException exc) {
         System.err.println("Concert exception '" + exc.getMessage() + "' caught");
         System.exit(-1);
      }
			
	for(MRP planItem :  itemsToPlan)
	 { 
	 
		output.setLength(0);						
		
		for(int t = 1; t <= get_Main().simParams.getSimOptHorizon(); t++) { // t=1 ... T
		
			int t_tmp = t;																		
									
			//for(MRP item : itemsToPlan){// item is associated to machine
				
				MRP mrpItem = get_Main().mrpTable.stream().filter(e -> e.getItem().getItem() == 
				planItem.getItem().getItem() && e.getTime() == time() && e.getPeriod() == t_tmp).findFirst().orElseGet(() -> new MRP());
			
				Routing routingEntry = get_Main().routings.stream().
				filter(e -> e.getItem().getItem() == mrpItem.getItem().getItem()).findFirst().orElse(new Routing());									
									 				 				 				 
				 //IloNumVar v_Wip = model.numVar(0, Double.MAX_VALUE, "W_" + planItem.getItem().getItem() + "_" + t + "_" + routingEntry.getResource());				 
				 //IloNumVar v_plannedOrderRelease = model.numVar(0, Double.MAX_VALUE, "R_" + planItem.getItem().getItem() + "_" + t + "_" + routingEntry.getResource());
		 		 
		 		 //IloNumVar v_Wip = model.numVar(0.0, Double.MAX_VALUE, "W" + planItem.getItem().getItem() + "" + t);
		 		 
		 		 IloNumVar v_Wip = model.numVar(0.0, Double.MAX_VALUE, "W" + planItem.getItem().getItem() + "" + t);				 
				 		 
				 IloNumVar v_plannedOrderRelease = model.numVar(0.0, 200, "R" + planItem.getItem().getItem() + "" + t);
				 				 		 		 			 		 
		 		 constraints.add(model.addGe(v_Wip,0));
		 		 constraints.add(model.addGe(v_plannedOrderRelease,0));		 		 
				 				 				 		 	 			 
	 			 //var[0][all] = v_Wip;
	 			 //all++;
	 			 var.add(v_Wip);
	 			 output.append(v_Wip.toString() + "; \n");
	 			 //var[0][all] = v_plannedOrderRelease;
	 			 //all++;	 	
	 			 var.add(v_plannedOrderRelease);
	 			 output.append(v_plannedOrderRelease.toString() + ";\n");
	 		 		 	 				 			 
	 			 
				 //IloNumVar prev_V_Wip = model.numVar(0, Double.MAX_VALUE, "W_" + planItem.getItem().getItem() + "_" + (t-1) + "_" + routingEntry.getResource());
	 			 IloNumVar prev_V_Wip = model.numVar(0.0, Double.MAX_VALUE, "W" + planItem.getItem().getItem() + "" + (t-1));
	 			  output.append(prev_V_Wip.toString() + ";");
	 			 //var[0][all] = prev_V_Wip;
	 			 //all++;	
	 			 
 			 	 double receipts = mrpItem.getPlannedOrderReceipts() * -1;
 			 	 //totalReceipts += receipts;
 			 	
 			 	if(t == 1){ 
	 			 //model.addEq(v_Wip,
	 			 	//model.sum(0,model.sum(v_plannedOrderRelease,receipts)),"WIP Balance " + planItem.getItem().getItem() + "_" + (t-1) + "_" + routingEntry.getResource());		
	 			 	//model.addEq(v_Wip,
	 			 	//model.sum(0,model.sum(v_plannedOrderRelease,receipts)),"WIP Balance " + planItem.getItem().getItem() + "_" + (t-1));		 				 			 		 			 			 			 	
			
					model.addEq(v_Wip,
	 			 	model.sum(0,model.sum(v_plannedOrderRelease,receipts)),"WIPBalance" + planItem.getItem().getItem() + "" + (t));		 				 			 		 			 			 			 		 			 		 			 		 			 				
	 			 	
	 			 	//constraints.add(model.addEq(v_Wip,
	 			 	//model.sum(0,model.sum(v_plannedOrderRelease,receipts)),"WIPBalance" + planItem.getItem().getItem() + "" + (t)));
	 			 	 				 			 		 			 			 			 	
				}else{
					//model.addEq(v_Wip,
	 			 	//model.sum(prev_V_Wip,model.sum(v_plannedOrderRelease,receipts)),"WIP Balance " + planItem.getItem().getItem() + "_" + (t-1) + "_" + routingEntry.getResource());	
	 			 	
	 			 	model.addEq(v_Wip,
	 			 	model.sum(prev_V_Wip,model.sum(v_plannedOrderRelease,receipts)),"WIPBalance" + planItem.getItem().getItem() + "" + (t));		 				 			 		 			 			 			 										 					 				 			 		 			 			 			 					
				}
				
				if(t == 1){				
				 //model.addLe(-1*receipts, model.sum(prev_V_Wip,v_plannedOrderRelease),"Capacity " + planItem.getItem().getItem() + "_" + (t-1) + "_" + routingEntry.getResource());	 			 	
	 			 	model.addLe(-1*receipts, model.sum(0,v_plannedOrderRelease),"Capacity" + planItem.getItem().getItem() + "" + (t));	 			 	
	 			 }else{
	 			 	//model.addGe(-1*receipts, model.sum(prev_V_Wip,v_plannedOrderRelease),"Capacity" + planItem.getItem().getItem() + "" + (t));	 			 		 			 
	 			 	model.addLe(-1*receipts, model.sum(prev_V_Wip,v_plannedOrderRelease),"Capacity" + planItem.getItem().getItem() + "" + (t));	 			 		 			 
	 			 }
	 			 
	 			 	
 			 //} 			 	 			 	 			 				 				 	 				 				 							
							
			IloNumVar v_Inventory = model.numVar(0.0, Double.MAX_VALUE,"I" + planItem.getItem().getItem() + "" + (t));						 
	 		constraints.add(model.addGe(v_Inventory,0.0)); //Inventory >= 0	
	 		
	 		IloNumVar prev_V_Inventory = model.numVar(0, Double.MAX_VALUE, "I" + planItem.getItem().getItem() + "" + (t-1));
	 		//IloNumVar v_plannedOrderReleaseNo = model.numVar(0, Double.MAX_VALUE, "R_" + planItem.getItem().getItem() + "_" + t);	 		

	 		//constraints.add(model.addGe(v_plannedOrderRelease,0)); //Inventory >= 0	
	 		
	 		if(t == 1){	 		
	 			StockBooking currentInventory = StockBooking.GetStockItemQuantity(get_Main().stockBookings, planItem.getItem());
		 		model.addEq(v_Inventory,model.sum(currentInventory.getQuantity(),model.sum(receipts,v_plannedOrderRelease)),"InventoryBalance"+ planItem.getItem().getItem() + (t));			 			 	
	 		}else{
				model.addEq(v_Inventory,model.sum(prev_V_Inventory,model.sum(receipts,v_plannedOrderRelease)),"InventoryBalance"+ planItem.getItem().getItem() +  (t));			 			 		 		
	 		}
	 			 		
	 		var.add(v_Inventory);
	 		//all++;
	 		output.append(v_Inventory.toString() + ";\n");
	 		

	 		//var[0][all] = prev_V_Inventory;
	 		//all++;
	 		//var[0][all] = v_plannedOrderReleaseNo;
	 		//all++;
	 			 							
	 		obj.addTerm(planItem.getItem().getHoldingCosts(), v_Inventory);	 			 			 						 									 		 	 		 	 		 	 			 		 														
	 		//obj.addTerm(planItem.getItem().getHoldingCostsWIP(), v_Wip);	 
	 		output.append(obj.toString() + "\n");			 			 						 									 		 	 		 	 		 	 			 		 															 		

		}
				
		//traceln(output.toString());
			
	}
	
	//traceln(obj.toString());
	model.addMinimize(obj);
			
	// Print out the optimal objective value and decision variables
	//traceln("Model output");
	//model.output();

	
	//IloCplex.Param.Preprocessing.Presolve = false;
	//model.setParam(IloCplex.BooleanParam.PreInd, false);	
	
	//model.setParam(IloCplex.Param.MIP.Display, 5); 
	//traceln(model.getObjective().getExpr().toString());	
	//model.setParam(IloCplex.Param.Simplex.Display, 0);									
	
	traceln("Export model");
	
//		Random random = new Random();
			
			//File file = new File(directory, "ForecastHistory"+dateAsString + random.nextInt(10)+ ".csv");
	
//	model.exportModel("output/model "  + time() + "_"+ random.nextInt(10) +".lp");		
	model.exportModel("output/model_"  + time() + "_"+ bomLevel +".lp");		
	model.exportModel("model.lp");		 
	//model.setOut(null);
	//traceln(model.output().toString());
	boolean isSolved = model.solve();

	if(isSolved) {			
		traceln("Solution status: " + model.getStatus());
		traceln("Objective value: " + model.getObjValue());				


			for(int i = 0; i < var.size(); i++) {				
			
				//String[] splitted = var[0][i].getName().split("_");
							
				//int splittedInt = Integer.parseInt(splitted[1]);
				String itemst = var.get(i).getName().substring(1,4);
				int itemInt = Integer.parseInt(itemst);
				Item item = get_Main().items.stream().filter(e -> e.getItem() == itemInt).findFirst().get();
				
				double qty = 0;
								
				if(var.get(i).getName().substring(0,1).equals("R")){
					qty = model.getValue(var.get(i)) / item.getHoldingCosts();
				}

				//traceln("Decision Variable:; " + var.get(i) + "; value=" + model.getValue(var.get(i)) + "; qty=" + qty);												
			}				
			
			for (int i=0;i<constraints.size();i++) {

						//traceln(constraints.get(i).getExpr().toString() + "= " + model.getValue(constraints.get(i).getExpr()));						
																					
						//System.out.println("dual constraint "+(i+1)+"  = "+model.getDual(constraints.get(i)));
						//System.out.println("slack constraint "+(i+1)+" = "+model.getSlack(constraints.get(i)));
			}
							
		
		traceln("**************************");
        traceln("Production Orders In Simulation BEFORE Removing");
        traceln(ProductionOrder.GetCSVHeader());

        for (ProductionOrder order: get_Main().productionOrders) {
            traceln(ProductionOrder.GetCSVString(order));
        }        
		traceln("**************************");

        //get_Main().productionOrders.removeIf(e -> e.getPlannedStart() > (time() - get_Main().simParams.getPlanningFrequency()) + 1);
        
        for(int i = 0; i < var.size(); i++) {
                
            //String[] splitted = var[0][i].getName().split("_");
						
			//int splittedInt = Integer.parseInt(splitted[1]); // Extract Item
			
			//int k = Integer.parseInt(splitted[2]); // planning horizon
			
			//Item item = get_Main().items.stream().filter(e -> e.getItem() == splittedInt).findFirst().get();
			
			String itemst = var.get(i).getName().substring(1,4);
			int itemInt = Integer.parseInt(itemst);
			Item item = get_Main().items.stream().filter(e -> e.getItem() == itemInt).findFirst().get();
			
			double qty = 0;	
											    
            //if(splitted[0].equals("R")){
            
            String kSt = var.get(i).getName().substring(4,var.get(i).getName().length());
            int k = Integer.parseInt(kSt);
            
            if(var.get(i).getName().substring(0,1).equals("R")){
				qty = model.getValue(var.get(i)) / item.getHoldingCosts();			                               
					if(qty > 0){
	                    ProductionOrder order = new ProductionOrder();
	                    
	                    order.setOrderId(get_Main().prodOrderId++);
	                    order.setItem(item);
	                                                                                                                                  
						order.setPlannedCapacity(Routing.GetPlannedCapacityPerItem(get_Main().routings, order.getItem(), get_Main().simParams, order));
	                    
	                    int minimumRoutingStep = Routing.GetMinimumStep(get_Main().routings, order.getItem() , get_Main().simParams);
						int maximumRoutingStep = Routing.GetMaximumStep(get_Main().routings, order.getItem() , get_Main().simParams);
				
						order.setMinimumRoutingStep(minimumRoutingStep);
						order.setMaximumRoutingStep(maximumRoutingStep);			
						order.setCurrentRoutingStep(minimumRoutingStep);                                        
	                                                            
	                    order.setQuantity(qty);
	                    order.setCreatedAt(time());
	                    	                    
	                    order.setPlannedStart(time() + k - item.getLeadTime());
	                    order.setPlannedEnd(time() + k);
	                    
	                    order.setPlannedStart(time() + k );
	                    order.setPlannedEnd(time() + k + item.getLeadTime());
	                    
	                    Routing routingObject = get_Main().routings.stream().filter(e -> e.getItem().getItem() == order.getItem().getItem()).findFirst().get();			
						order.setRouting(routingObject);
						order.setStatus(ProductionOrder.PRODUCTION_ORDER_STATUS_UNPROCESSED);
	                    get_Main().productionOrders.add(order);	                    						
						
	                    ProductionOrderAgent a = new ProductionOrderAgent();
	                    a.prodOrderFromAgent = order;
                    }
                 }            
        }
        
		traceln("time " + time());
		traceln("Production Orders from Optmization Before Removing");
		traceln(ProductionOrder.GetCSVHeader());

        for (ProductionOrder order: get_Main().productionOrders) {
            traceln(ProductionOrder.GetCSVString(order));
        }        
		
        //get_Main().productionOrders.removeIf(e -> e.getPlannedStart() > time());

        traceln("Production Orders from Optmization FOR SIMULATION");
        traceln(ProductionOrder.GetCSVHeader());

        for (ProductionOrder order: get_Main().productionOrders) {
            traceln(ProductionOrder.GetCSVString(order));
        }        
        traceln("**************************");                							
		
		//get_Main().Function_OrderRelease();
				
	}	
		model.exportModel("test.lp");

	model.end();

} catch(IloException ex) {
	ex.printStackTrace();
}
return 0;
]]></Body>
				</Function>
				<Function AccessType="default" StaticFunction="false">
					<ReturnModificator>RETURNS_VALUE</ReturnModificator>
					<ReturnType><![CDATA[int]]></ReturnType>
					<Id>1661758218674</Id>
					<Name><![CDATA[Function_ClearingFunctionp]]></Name>
					<X>50</X><Y>200</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Parameter>
						<Name><![CDATA[itemsToPlan]]></Name>
						<Type><![CDATA[List<MRP>]]></Type>
					</Parameter>
					<Parameter>
						<Name><![CDATA[bomLevel]]></Name>
						<Type><![CDATA[int]]></Type>
					</Parameter>
					<Body><![CDATA[try{
							

traceln("----------- Start OPTIMIZE at " + time () + " ----------------");

StockBooking.GetTraceCSVString(get_Main().stockBookings, "Start %%%%%%%", "End %%%%%%%");
							
StringBuilder output = new StringBuilder();

double points[] = new double[] {200.0, 400.0, 600.0, 800.0};
double slopes[] = new double[] { 30.0, 80.0, 130.0, 50.0, 40.0};

IloCplex cplex = new IloCplex();
//   try{
	
     IloNumVar[][] Inv = new IloNumVar[itemsToPlan.size()][];
     for (int p = 0; p < itemsToPlan.size(); p++) {
        Inv[p] = cplex.numVarArray(get_Main().simParams.getMRPPlanningHorizon(), 0.0, Double.MAX_VALUE);
     }
     
     IloNumVar[][] Wip = new IloNumVar[itemsToPlan.size()][];
     for (int p = 0; p < itemsToPlan.size(); p++) {
        Wip[p] = cplex.numVarArray(get_Main().simParams.getMRPPlanningHorizon(), 0.0, Double.MAX_VALUE);
     }
		
	 IloNumVar[][] Release = new IloNumVar[itemsToPlan.size()][];
     for (int p = 0; p < itemsToPlan.size(); p++) {
        Release[p] = cplex.numVarArray(get_Main().simParams.getMRPPlanningHorizon(), 0.0, Double.MAX_VALUE);
     }

	 IloNumVar[][] X = new IloNumVar[itemsToPlan.size()][];
     for (int p = 0; p < itemsToPlan.size(); p++) {
        X[p] = cplex.numVarArray(get_Main().simParams.getMRPPlanningHorizon(), 0.0, Double.MAX_VALUE);
     }
	
	double[] inventory = new double[itemsToPlan.size()];
	double[] wip = new double[itemsToPlan.size()];
	
	//int Release[][] = new int[itemsToPlan.size()][get_Main().simParams.getMRPPlanningHorizon()];
	
	int setupTime = 120;
	int processingTime = 2;
	int capacity = 1440;
		
	int[][] D = new int[itemsToPlan.size()][get_Main().simParams.getMRPPlanningHorizon()];
	//double[] WipOrder = new double[get_Main().simParams.getMRPPlanningHorizon()];
	//int[] CfHelpValueRounded = new int[get_Main().simParams.getMRPPlanningHorizon()];
	
     for (int p = 0; p < itemsToPlan.size(); p++) {      	     

     		   inventory[p] = (int)StockBooking.GetStockItemQuantity(get_Main().stockBookings, itemsToPlan.get(p).getItem()).getQuantity();
     		   wip[p] = (int)ProductionOrder.GetCurrentWip(get_Main().productionOrders, itemsToPlan.get(p).getItem(), get_Main().simParams);
				//wip[p] = 0;
				//inventory[p]=0;
			   traceln("Inventory[0] for " + itemsToPlan.get(p).getItem().getItem() + "=" + inventory[p]);
			   traceln("wip[0] for " + itemsToPlan.get(p).getItem().getItem() + "=" + wip[p]);
				    			
     	       for (int t = 0; t < get_Main().simParams.getMRPPlanningHorizon(); t++) {               	                          	               	
               	
               	int tmp_item = itemsToPlan.get(p).getItem().getItem();
               	int temp_t = t;
               	
               	MRP mrpItem = get_Main().mrpTable.stream().filter(e -> e.getItem().getItem() == tmp_item
               	 && e.getTime() == time() && e.getPeriod() == temp_t).findFirst().orElseGet(() -> new MRP());

				if(itemsToPlan.get(p).getItem().getType().equalsIgnoreCase(Item.ITEM_TYPE_SALES)){ 
        			D[p][t] = (int) mrpItem.getGrossRequirements();
        		}else{
					//D[p][t] = (int) mrpItem.getPlannedOrderReceipts();
					D[p][t] = (int) mrpItem.getGrossRequirements();					
        		}
        		  
        		//WipOrder[t] +=  mrpItem.getPlannedOrderReceipts() * processingTime + setupTime;
        		//CfHelpValueRounded[t] =  (int) Math.ceil(WipOrder[t] / capacity);
        		        		        		
            }     	      	
     }
     
	 IloLinearNumExpr minInventory  = cplex.linearNumExpr();
	 IloLinearNumExpr minWip  = cplex.linearNumExpr();
	         
         for (int p = 0; p < itemsToPlan.size(); p++) {
            for (int t = 0; t < get_Main().simParams.getMRPPlanningHorizon(); t++) {
               minInventory.addTerm (1, Inv[p][t]);
               minWip.addTerm (1, Wip[p][t]);
            }
         }
           
         cplex.addMinimize(minInventory);                     
       
         for (int p = 0; p < itemsToPlan.size(); p++) {
            
            //wip constraint            
            cplex.addEq(cplex.sum(Wip[p][0], X[p][0]), 
                           cplex.sum(wip[p], Release[p][0]));
            
            for (int t = 1; t < get_Main().simParams.getMRPPlanningHorizon(); t++) {
               cplex.addEq(cplex.sum(Wip[p][t], X[p][t]), 
                           cplex.sum(Wip[p][t-1], Release[p][t]));
            }
			
			//inventory balance   
         	cplex.addEq(cplex.sum(inventory[p], X[p][0]), 
            			cplex.sum(Inv[p][0], D[p][0]));
         
            for (int t = 1; t < get_Main().simParams.getMRPPlanningHorizon(); t++) {
	           	cplex.addEq(cplex.sum(Inv[p][t-1], X[p][t]), 
                       cplex.sum(Inv[p][t], D[p][t]));
        	}

			//capacity (cf)
			
            cplex.addLe(X[p][0], 
                           cplex.sum(wip[0], Release[p][0]));				                           
                        
            for (int t = 1; t < get_Main().simParams.getMRPPlanningHorizon(); t++) {
               cplex.addLe(X[p][t], 
                           cplex.sum(Wip[p][t-1], Release[p][t]));				                                                             

            }
             

            for (int t = 0; t < get_Main().simParams.getMRPPlanningHorizon(); t++) {
            	IloLinearNumExpr num_expr = cplex.linearNumExpr();
				num_expr.addTerm(1.0, X[p][t]);            
	               	
	               	//cplex.addLe(num_expr,400); 
	               	
	               	//if(bomLevel==0)
		               	cplex.addLe(num_expr,400); 
		               	
                           //cplex.sum(Wip[p][t-1], Release[p][t]));				                                                             
            }
            
            
         }
    
    //if(time() == 0)                 
		cplex.exportModel("model/NewModel_" + time() + "_" + bomLevel + ".lp");
	
	if(cplex.solve()){
		    System.out.println("Solution status: " + cplex.getStatus());
            System.out.println();
            System.out.println("Inventory = " + cplex.getObjValue());
          
            System.out.println();
            System.out.println("\tp\tt\tWip\tX\tRelease\tInv\tD");
          
            for (int p = 0; p < itemsToPlan.size(); p++) {
               for (int t = 0; t < get_Main().simParams.getMRPPlanningHorizon(); t++) {
                  System.out.println("\t" + itemsToPlan.get(p).getItem().getItem() +
                                     "\t" + t +
                                     "\t" + cplex.getValue(Wip[p][t]) +
                                     "\t" + cplex.getValue(X[p][t]) +
                                     "\t" + cplex.getValue(Release[p][t]) +                               
                                     "\t" + cplex.getValue(Inv[p][t]) +
                                     "\t" + D[p][t] 
                                     //"\t" + CfHelpValueRounded[t]
                                     );
                  
                    //OptimizationResult optResult = new OptimizationResult(time(),itemsToPlan.get(p).getItem().getItem(), t,
                    //cplex.getValue(Wip[p][t]), cplex.getValue(Release[p][t]), 0,cplex.getValue(X[p][t]),
                    //cplex.getValue(Inv[p][t]) );

	                //get_Main().optimizationResults.add(optResult);                 
               }
            }	
		}
												
		traceln("**************************");
        traceln("Production Orders In Simulation BEFORE Removing");
        traceln(ProductionOrder.GetCSVHeader());

        for (ProductionOrder order: get_Main().productionOrders) {
            traceln(ProductionOrder.GetCSVString(order));
        }        
		traceln("**************************");

        //get_Main().productionOrders.removeIf(e -> e.getPlannedStart() > (time() - get_Main().simParams.getPlanningFrequency()) + 1);
        
			for (int p = 0; p < itemsToPlan.size(); p++) {
               for (int t = 0; t < get_Main().simParams.getMRPPlanningHorizon(); t++) {
               
					        double qty = cplex.getValue(Release[p][t]);    			            			            		            
					        
							if(qty > 0){
			                    ProductionOrder order = new ProductionOrder();
			                    								
								int itemIntTmp = itemsToPlan.get(p).getItem().getItem();
									
			                    Item item = get_Main().items.stream().filter(e -> e.getItem() == itemIntTmp).findFirst().get();																		                     
			                    
			                    order.setOrderId(get_Main().prodOrderId++);
			                    order.setItem(item);
			                                                                                                                                  
								order.setPlannedCapacity(Routing.GetPlannedCapacityPerItem(get_Main().routings, order.getItem(), get_Main().simParams, order));
			                    
			                    int minimumRoutingStep = Routing.GetMinimumStep(get_Main().routings, order.getItem() , get_Main().simParams);
								int maximumRoutingStep = Routing.GetMaximumStep(get_Main().routings, order.getItem() , get_Main().simParams);
						
								order.setMinimumRoutingStep(minimumRoutingStep);
								order.setMaximumRoutingStep(maximumRoutingStep);			
								order.setCurrentRoutingStep(minimumRoutingStep);                                        
			                                                            
			                    order.setQuantity(qty);
			                    order.setCreatedAt(time());
			                    	                    
			                    order.setPlannedStart(time() + t - item.getLeadTime());
			                    order.setPlannedEnd(time() + t);
			                    
			                    //order.setPlannedStart(time() + t );
			                    //order.setPlannedEnd(time() + t + item.getLeadTime());
			                    
			                    //check if order for qty and period already exists
			                    
			                    long exists = get_Main().productionOrders.stream().filter(e -> e.getItem().getItem() == order.getItem().getItem() &&
			                    											e.getQuantity()==order.getQuantity() && e.getPlannedStart() == order.getPlannedStart() &&
			                    											e.getPlannedEnd() == order.getPlannedEnd()).count();
			                    
			                    if(order.getPlannedStart() < time())
			                    	exists = 1;
			                    											
			                    if(exists == 0){														                    
				                    Routing routingObject = get_Main().routings.stream().filter(e -> e.getItem().getItem() == order.getItem().getItem()).findFirst().get();			
									order.setRouting(routingObject);
									order.setStatus(ProductionOrder.PRODUCTION_ORDER_STATUS_UNPROCESSED);
				                    get_Main().productionOrders.add(order);	                    						
									
				                    ProductionOrderAgent a = new ProductionOrderAgent();
				                    a.prodOrderFromAgent = order;
			                    }
		                    }
		                 }            
		            }
        
        
		traceln("time " + time());
		traceln("Production Orders from Optmization Before Removing");
		traceln(ProductionOrder.GetCSVHeader());

        for (ProductionOrder order: get_Main().productionOrders) {
            traceln(ProductionOrder.GetCSVString(order));
        }        
		
        //get_Main().productionOrders.removeIf(e -> e.getPlannedStart() > time());
/*
        traceln("Production Orders from Optmization FOR SIMULATION");
        traceln(ProductionOrder.GetCSVHeader());

        for (ProductionOrder order: get_Main().productionOrders) {
            traceln(ProductionOrder.GetCSVString(order));
        }        
        traceln("**************************");                							
*/		
		//get_Main().Function_OrderRelease();
		}				
	
	catch (IloException exc) {
         System.err.println("Concert exception '" + exc.getMessage() + "' caught");
         System.exit(-1);
    }

//} catch(IloException ex) {
	//ex.printStackTrace();
//}	

return 0;
]]></Body>
				</Function>
				<Function AccessType="default" StaticFunction="false">
					<ReturnModificator>RETURNS_VALUE</ReturnModificator>
					<ReturnType><![CDATA[int]]></ReturnType>
					<Id>1665395310320</Id>
					<Name><![CDATA[Function_ClearingFunction_QtyBasedVersion]]></Name>
					<X>50</X><Y>170</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Parameter>
						<Name><![CDATA[itemsToPlan]]></Name>
						<Type><![CDATA[List<MRP>]]></Type>
					</Parameter>
					<Parameter>
						<Name><![CDATA[bomLevel]]></Name>
						<Type><![CDATA[int]]></Type>
					</Parameter>
					<Body><![CDATA[try{
							

traceln("----------- Start OPTIMIZE at " + time () + " ----------------");

StockBooking.GetTraceCSVString(get_Main().stockBookings, "Start %%%%%%%", "End %%%%%%%");
CustomerOrder.GetTraceCSVString(get_Main().customerOrders, "Start %%%%%%%", "End %%%%%%%");
							
StringBuilder output = new StringBuilder();

double points[] = new double[] {200.0, 400.0, 600.0, 800.0};
double slopes[] = new double[] { 30.0, 80.0, 130.0, 50.0, 40.0};

IloCplex cplex = new IloCplex();

     String[][] Inames = new String[itemsToPlan.size()][get_Main().simParams.getMRPPlanningHorizon()];
     String[][] Pnames = new String[itemsToPlan.size()][get_Main().simParams.getMRPPlanningHorizon()];
     String[][] Wnames = new String[itemsToPlan.size()][get_Main().simParams.getMRPPlanningHorizon()];
     String[][] Rnames = new String[itemsToPlan.size()][get_Main().simParams.getMRPPlanningHorizon()];
     
     for(int i = 0; i< get_Main().simParams.getMRPPlanningHorizon(); i++){
          for (int p = 0; p < itemsToPlan.size(); p++) {
        	 	Inames[p][i] = "I" + itemsToPlan.get(p).getItem().getItem() + "_" + i; 
        	 	Pnames[p][i] = "P" + itemsToPlan.get(p).getItem().getItem() + "_" + i; 
        	 	Wnames[p][i] = "W" + itemsToPlan.get(p).getItem().getItem() + "_" + i; 
        	 	Rnames[p][i] = "R" + itemsToPlan.get(p).getItem().getItem() + "_" + i; 
	     }    
     }
     
     IloNumVar[][] I = new IloNumVar[itemsToPlan.size()][];
     for (int p = 0; p < itemsToPlan.size(); p++) {
        I[p] = cplex.numVarArray(get_Main().simParams.getMRPPlanningHorizon(), 0, Double.MAX_VALUE, Inames[p]);
     }
     
     IloNumVar[][] P = new IloNumVar[itemsToPlan.size()][];
     for (int p = 0; p < itemsToPlan.size(); p++) {
        P[p] = cplex.numVarArray(get_Main().simParams.getMRPPlanningHorizon(), 0, 200, Pnames[p]);
     }
               
     IloNumVar[][] W = new IloNumVar[itemsToPlan.size()][];
     for (int p = 0; p < itemsToPlan.size(); p++) {
        W[p] = cplex.numVarArray(get_Main().simParams.getMRPPlanningHorizon(), 0, Double.MAX_VALUE, Wnames[p]);
     }
		
	 IloNumVar[][] R = new IloNumVar[itemsToPlan.size()][];
     for (int p = 0; p < itemsToPlan.size(); p++) {
        R[p] = cplex.numVarArray(get_Main().simParams.getMRPPlanningHorizon(), 0.0, Double.MAX_VALUE, Rnames[p]);
     }
               	
	double[] inventory = new double[itemsToPlan.size()];
	double[] wip = new double[itemsToPlan.size()];
	double[] produce = new double[itemsToPlan.size()];
	double[] tl = new double[itemsToPlan.size()];
		
	int[][] X = new int[itemsToPlan.size()][get_Main().simParams.getMRPPlanningHorizon()];

	List<SpecialObject> iQd = new ArrayList<SpecialObject>();
	
     for (int p = 0; p < itemsToPlan.size(); p++) {      	     

     		   //inventory[p] = (int)StockBooking.GetStockItemQuantity(get_Main().stockBookings, itemsToPlan.get(p).getItem()).getQuantity();
     		   inventory[p] = 0;
     		   
     		   wip[p] = (int)ProductionOrder.GetCurrentWip(get_Main().productionOrders, itemsToPlan.get(p).getItem(), get_Main().simParams);
     		   produce[p] = 0;
     		   
     		   tl[p] = itemsToPlan.get(p).getItem().getTransportLotSize();

			   traceln("Inventory[0] for " + itemsToPlan.get(p).getItem().getItem() + "=" + inventory[p]);
			   traceln("wip[0] for " + itemsToPlan.get(p).getItem().getItem() + "=" + wip[p]);
			   				    			
     	       for (int t = 0; t < get_Main().simParams.getMRPPlanningHorizon(); t++) {               	                          	               	
               	
               	int tmp_item = itemsToPlan.get(p).getItem().getItem();
               	int temp_t = t;
               	
               	MRP mrpItem = get_Main().mrpTable.stream().filter(e -> e.getItem().getItem() == tmp_item
               	 && e.getTime() == time() && e.getPeriod() == temp_t).findFirst().orElseGet(() -> new MRP());

				if(itemsToPlan.get(p).getItem().getType().equalsIgnoreCase(Item.ITEM_TYPE_SALES)){ 
        			X[p][t] = (int) mrpItem.getPlannedOrderReceipts();					
        			
        		}else{
					X[p][t] = (int) mrpItem.getPlannedOrderReceipts();					
        		}
        		
        		if(X[p][t] > 0) {
        			SpecialObject so = new SpecialObject(
        				mrpItem.getItem().getItem(),
        				X[p][t], 
        				t);
        			iQd.add(so);
        		}        		  	        		        		
            }     	      	
     }
     
     int leadtimeHorizon = 26;
     
     String[][] RiNames = new String[iQd.size()][leadtimeHorizon];
     int[][] releaseTmp = new int[iQd.size()][main.simParams.getMRPPlanningHorizon()];
     String[] releaseForX = new String[iQd.size()];
          
     for (int p = 0; p < iQd.size(); p++) {
          for(int i = 0; i < leadtimeHorizon; i++){
          		int targetT = (int)(iQd.get(p).getDueDate() - leadtimeHorizon + i);          		
          		
          		if(targetT < 0)
          			targetT = 0;
          		
          		releaseTmp[p][targetT] = i+1;          		
        	 	RiNames[p][i] = "RI_" +  iQd.get(p).getItem() + "_" + (int)iQd.get(p).getDueDate() + 
        	 	
        	 	"_" + iQd.get(p).getQuantity() + "_" + targetT + "R" + iQd.get(p).getItem() + "_" + targetT; 
	     }    
     }

            
     IloNumVar[][] RI = new IloNumVar[iQd.size()][];
     for (int p = 0; p < iQd.size(); p++) {
        RI[p] = cplex.boolVarArray(leadtimeHorizon, RiNames[p]);
     }
          
     	//Objective Function     
		IloLinearNumExpr minInventory  = cplex.linearNumExpr();
	         
        for (int p = 0; p < itemsToPlan.size(); p++) {
           for (int t = 0; t < get_Main().simParams.getMRPPlanningHorizon(); t++) {
              minInventory.addTerm (itemsToPlan.get(p).getItem().getHoldingCosts(), I[p][t]);
            }
         }

        for (int p = 0; p < itemsToPlan.size(); p++) {
           for (int t = 0; t < get_Main().simParams.getMRPPlanningHorizon(); t++) {
             minInventory.addTerm (itemsToPlan.get(p).getItem().getHoldingCostsWIP(), W[p][t]);
            }                     	            
         }
         

           
         cplex.addMinimize(minInventory);
       
         for (int p = 0; p < itemsToPlan.size(); p++) {

			//inventory balance   
         	//cplex.addEq(cplex.sum(I[p][0], X[p][0]), 
            		//	cplex.sum(inventory[p], P[p][0]));
            		
            		
            //cplex.addEq(cplex.sum(I[p][0], X[p][0]), 
            			//cplex.sum(I[p][0], P[p][0]));
            		
         	cplex.addEq(I[p][0],0);
         
            for (int t = 1; t < get_Main().simParams.getMRPPlanningHorizon(); t++) {
	           	cplex.addEq(cplex.sum(I[p][t], X[p][t]), 
                       cplex.sum(I[p][t-1], P[p][t-1]));
        	}
            
            //wip constraint            
            //cplex.addEq(cplex.sum(W[p][0], produce[p]), 
              //             cplex.sum(wip[p], R[p][0]));
            cplex.addEq(W[p][0], R[p][0]);
            
            for (int t = 1; t < get_Main().simParams.getMRPPlanningHorizon(); t++) {
               cplex.addEq(cplex.sum(W[p][t], P[p][t-1]), 
                           cplex.sum(W[p][t-1], R[p][t]));
            }
			             									
			//Clearing Functions
            for (int t = 0; t < get_Main().simParams.getMRPPlanningHorizon(); t++) {
            	IloLinearNumExpr num_expr = cplex.linearNumExpr();
				 
				 //CF3 is part of variable definition				
		        
		        //CF2		        		        
		        cplex.addLe(P[p][t], 
                           (cplex.sum(25,cplex.prod(0.5,W[p][t]))));
		        
				//CF1
		        cplex.addLe(P[p][t], W[p][t]); 
		               	 		               	
            }


            //for (int t = 0; t < get_Main().simParams.getMRPPlanningHorizon(); t++) {
            	//IloLinearNumExpr num_expr = cplex.linearNumExpr();
			//	cplex.addEq(cplex.prod(1,R[p][t]), 
              //             cplex.prod(RI[p][t], X[p][t])); 		               	
              	
              	
               	//cplex.addEq(cplex.prod(1,R[p][t]), 
                  //         cplex.prod(tl[p],RI[p][t])); 		               	
              	
            //}


            //cplex.addEq(num_expr_Sum_Binaries,cntX);
         }
         
                  
          for (int p = 0; p < iQd.size(); p++) {
            IloLinearNumExpr num_expr_Sum_Binaries = cplex.linearNumExpr();            
	            for (int t = 0; t < leadtimeHorizon; t++) {
					//cplex.addEq(cplex.sum(RI[p][t],0),1); 		               	
					num_expr_Sum_Binaries.addTerm(1.,RI[p][t]);								
							
	            }
	            cplex.addEq(num_expr_Sum_Binaries,1);
            }
         
         for (int pp = 0; pp < itemsToPlan.size(); pp++) {         
	       for (int t = 0; t < main.simParams.getMRPPlanningHorizon(); t++) {	            	            
			       	String o = "";
			       	int sizeExpr = 0;
			        IloLinearNumExpr num_expr = cplex.linearNumExpr();
			                    
	                for (int p = 0; p < iQd.size(); p++) {
	                	if(iQd.get(p).getItem()== itemsToPlan.get(pp).getItem().getItem()){
		            		if(releaseTmp[p][t] > 0){
		            			//traceln(RI[p][t].getName());	            		
		            			//traceln(p + " " + (releaseTmp[p][t]-1));
		            			o = o + iQd.get(p).getQuantity() + "*" + RI[p][releaseTmp[p][t]-1].getName() +  "+";	            			
		            			num_expr.addTerm(iQd.get(p).getQuantity(),RI[p][releaseTmp[p][t]-1]);		            			
		            			sizeExpr++;
		            		}			        
	            		}
					}
					
				if(o.length() > 1){
		            //traceln(o);		            		            
		                //num_expr.addTerm(-1., R[0][t]);		            
		            if(sizeExpr > 0){
			            cplex.addEq(R[pp][t],num_expr);          
			        }

				}else{
				         cplex.addEq(R[pp][t],0);          								
				}
				
				num_expr.clear();             
			}         
         }
    
    //if(time() == 0)                 
		cplex.exportModel("model/NewModel_" + time() + "_" + bomLevel + ".lp");
	
	//cplex.setParam(IloCplex.BooleanParam.PreInd, false);
	//cplex.setParam(IloCplex.IntParam.DataCheck, 2);	
						
	if(cplex.solve()){
		    
		    System.out.println("Solution status: " + cplex.getStatus());
            System.out.println();
            System.out.println("Objective Value = " + cplex.getObjValue());
          
            System.out.println();
            System.out.println("\tp\tTime\tt\tWip\tX\tRelease\tP\tInv\tInvBelance\tWipBalance\tObjPerPeriod");
          
            for (int p = 0; p < itemsToPlan.size(); p++) {
               for (int t = 0; t < get_Main().simParams.getMRPPlanningHorizon(); t++) {
               
               double inventoryBalance = 0;
               double wipBalance = 0;

               if(t>0){
                  inventoryBalance = cplex.getValue(I[p][t-1])-X[p][t]+cplex.getValue(P[p][t-1]);
                  wipBalance = cplex.getValue(W[p][t-1])+cplex.getValue(R[p][t])-cplex.getValue(P[p][t-1]);
               
               }
               	  double objectivePerPeriod = cplex.getValue(W[p][t]) * 0.5 + cplex.getValue(I[p][t]);
                  System.out.println("\t" + itemsToPlan.get(p).getItem().getItem() +
                                     "\t" + (time() + t) +
                                     "\t" + t +
                                     "\t" + (int)cplex.getValue(W[p][t]) +
                                     "\t" + X[p][t] +
                                     "\t" + (int)cplex.getValue(R[p][t]) +       
                                     //"\t" + (int)cplex.getValue(RI[p][t]) +                                                       
                                     "\t" + Math.round(cplex.getValue(P[p][t])) +                               
                                     "\t" + Math.round(cplex.getValue(I[p][t])) +
                                     "\t" + Math.round(inventoryBalance) +
                                     "\t" + (int)wipBalance +
                                     "\t" + (int)objectivePerPeriod 
                                     );                                                                                                 
                                    
                    //OptimizationResult optResult = new OptimizationResult(time(),itemsToPlan.get(p).getItem().getItem(), t,
                    //cplex.getValue(W[p][t]), cplex.getValue(R[p][t]), 0,cplex.getValue(P[p][t]),
                    //cplex.getValue(I[p][t]) );
                    
                    //get_Main().optimizationResults.add(optResult);                 
                                     
               }
            }
            
          for (int p = 0; p < iQd.size(); p++) {
          	for(int i = 0; i < leadtimeHorizon; i++){
          		if(cplex.getValue(RI[p][i]) > 0){
        	 		traceln(RI[p][i].getName() + " Value " + cplex.getValue(RI[p][i]));
        	 		releaseForX[p] = RI[p][i].getName();
        	 	}
	     	}    
     	  }
     	  
            
            //if(OptimizationResult.WRITE_OPTIMIZATION_RESULTS_TO_XLXS)
			//OptimizationResult.WriteXlsxOptimizationResults(get_Main().optimizationResults, get_Main().simParams);            
            	//traceln("size +++++++++++ " + get_Main().optimizationResults.size());
            
		}else{
			traceln("NO Solution " + cplex.getStatus());
		}
												
		traceln("**************************");
        traceln("Production Orders In Simulation BEFORE Removing");
        traceln(ProductionOrder.GetCSVHeader());

        for (ProductionOrder order: get_Main().productionOrders) {
            traceln(ProductionOrder.GetCSVString(order));
        }        
		traceln("**************************");

        //get_Main().productionOrders.removeIf(e -> e.getPlannedStart() > (time() - get_Main().simParams.getPlanningFrequency()) + 1);
        
			for (int p = 0; p < itemsToPlan.size(); p++) {
			   int prevReleases = 0;
               for (int t = 0; t < get_Main().simParams.getMRPPlanningHorizon(); t++) {
               
					        double qty = cplex.getValue(R[p][t]);    			            			            		            
					        
							if(qty > 0){
			                    ProductionOrder order = new ProductionOrder();
			                    								
								int itemIntTmp = itemsToPlan.get(p).getItem().getItem();
									
			                    Item item = get_Main().items.stream().filter(e -> e.getItem() == itemIntTmp).findFirst().get();																		                     
			                    
			                    order.setOrderId(get_Main().prodOrderId++);
			                    order.setItem(item);
			                                                                                                                                  
								order.setPlannedCapacity(Routing.GetPlannedCapacityPerItem(get_Main().routings, order.getItem(), get_Main().simParams, order));
			                    
			                    int minimumRoutingStep = Routing.GetMinimumStep(get_Main().routings, order.getItem() , get_Main().simParams);
								int maximumRoutingStep = Routing.GetMaximumStep(get_Main().routings, order.getItem() , get_Main().simParams);
						
								order.setMinimumRoutingStep(minimumRoutingStep);
								order.setMaximumRoutingStep(maximumRoutingStep);			
								order.setCurrentRoutingStep(minimumRoutingStep);                                        
			                                                            
			                    order.setQuantity(Math.round(qty));
			                    order.setCreatedAt(time());
								//traceln(X[p][t]);
								//traceln(t);
								//traceln(time());			                    	                    
			                    order.setPlannedStart(time() + t);

			                    //traceln("get relase " + R[p][t].getName());
			                    

			                    
			                    //check if order for qty and period already exists
			                    
			                    long exists = get_Main().productionOrders.stream().filter(e -> e.getItem().getItem() == order.getItem().getItem() &&
			                    											e.getQuantity()==order.getQuantity() && e.getPlannedStart() == order.getPlannedStart() &&
			                    											e.getPlannedEnd() == order.getPlannedEnd()).count();
			                    
			                    //traceln("searach " + R[p][t].getName());			                    
               					int xPeriod = 0;
               					for (int k = 0; k < releaseForX.length; k++) {
               						//traceln(releaseForX[k]);
               						if(releaseForX[k].contains(R[p][t].getName())){
               							//traceln("found " + releaseForX[k]);
               							
               							xPeriod = Integer.parseInt(releaseForX[k].split("_")[2]);
               							//traceln("..." + value);
               							
               						}               					
               					}
			                    
			                    order.setPlannedEnd(xPeriod + time());
			                    
			                    if(order.getPlannedStart() < time())
			                    	exists = 1;
			                    											
			                    if(exists == 0){														                    
				                    Routing routingObject = get_Main().routings.stream().filter(e -> e.getItem().getItem() == order.getItem().getItem()).findFirst().get();			
									order.setRouting(routingObject);
									order.setStatus(ProductionOrder.PRODUCTION_ORDER_STATUS_UNPROCESSED);
				                    get_Main().productionOrders.add(order);	                    						
									
				                    ProductionOrderAgent a = new ProductionOrderAgent();
				                    a.prodOrderFromAgent = order;
			                    }
		                    }
		                 }            
		            }
        
        
		traceln("time " + time());
		traceln("Production Orders from Optmization Before Removing");
		traceln(ProductionOrder.GetCSVHeader());

        for (ProductionOrder order: get_Main().productionOrders) {
            traceln(ProductionOrder.GetCSVString(order));
        }        
		
        //get_Main().productionOrders.removeIf(e -> e.getPlannedStart() > time());
/*
        traceln("Production Orders from Optmization FOR SIMULATION");
        traceln(ProductionOrder.GetCSVHeader());

        for (ProductionOrder order: get_Main().productionOrders) {
            traceln(ProductionOrder.GetCSVString(order));
        }        
        traceln("**************************");                							
*/		
		//get_Main().Function_OrderRelease();
				
	}
	catch (IloException exc) {
         System.err.println("Concert exception '" + exc.getMessage() + "' caught");
         System.exit(-1);
    }

//} catch(IloException ex) {
	//ex.printStackTrace();
//}	
return 0;
]]></Body>
				</Function>
				<Function AccessType="default" StaticFunction="false">
					<ReturnModificator>RETURNS_VALUE</ReturnModificator>
					<ReturnType><![CDATA[int]]></ReturnType>
					<Id>1666840985068</Id>
					<Name><![CDATA[Function_ClearingFunctionWithoutMachineCapacity]]></Name>
					<X>50</X><Y>140</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Parameter>
						<Name><![CDATA[itemsToPlan]]></Name>
						<Type><![CDATA[List<MRP>]]></Type>
					</Parameter>
					<Parameter>
						<Name><![CDATA[bomLevel]]></Name>
						<Type><![CDATA[int]]></Type>
					</Parameter>
					<Body><![CDATA[try{
							

traceln("----------- Start OPTIMIZE at " + time () + " ----------------");

//StockBooking.GetTraceCSVString(get_Main().stockBookings, "Start %%%%%%%", "End %%%%%%%");
//CustomerOrder.GetTraceCSVString(get_Main().customerOrders, "Start %%%%%%%", "End %%%%%%%");
							
StringBuilder output = new StringBuilder();

double points[] = new double[] {200.0, 400.0, 600.0, 800.0};
double slopes[] = new double[] { 30.0, 80.0, 130.0, 50.0, 40.0};

double oCosts = 0;
double oFactor = 1000;
int leadtimeHorizon = main.simParams.getLeadTimeHorizon();
traceln("Leadtime Horizon: " + leadtimeHorizon);
IloCplex cplex = new IloCplex();

     String[][] Inames = new String[itemsToPlan.size()][get_Main().simParams.getMRPPlanningHorizon()];
     String[][] Pnames = new String[itemsToPlan.size()][get_Main().simParams.getMRPPlanningHorizon()];
     String[][] Wnames = new String[itemsToPlan.size()][get_Main().simParams.getMRPPlanningHorizon()];
     String[][] Rnames = new String[itemsToPlan.size()][get_Main().simParams.getMRPPlanningHorizon()];     
     
     for(int i = 0; i< get_Main().simParams.getMRPPlanningHorizon(); i++){
          for (int p = 0; p < itemsToPlan.size(); p++) {
        	 	Inames[p][i] = "I" + itemsToPlan.get(p).getItem().getItem() + "_" + i; 
        	 	Pnames[p][i] = "P" + itemsToPlan.get(p).getItem().getItem() + "_" + i; 
        	 	Wnames[p][i] = "W" + itemsToPlan.get(p).getItem().getItem() + "_" + i; 
        	 	Rnames[p][i] = "R" + itemsToPlan.get(p).getItem().getItem() + "_" + i; 
	     }
     }

     IloNumVar[] C = new IloNumVar[main.simParams.getMRPPlanningHorizon()];
     for (int t = 0; t < get_Main().simParams.getMRPPlanningHorizon(); t++) {
        C[t] = cplex.numVar(0, Double.MAX_VALUE, "C" + "_" + t);
     }
     
     IloNumVar[][] I = new IloNumVar[itemsToPlan.size()][];
     for (int p = 0; p < itemsToPlan.size(); p++) {
        I[p] = cplex.numVarArray(get_Main().simParams.getMRPPlanningHorizon(), 0, Double.MAX_VALUE, Inames[p]);
        oCosts += itemsToPlan.get(p).getItem().getHoldingCosts();
     }
     
     oCosts = oFactor*oCosts;
     
     IloNumVar[][] P = new IloNumVar[itemsToPlan.size()][];
     for (int p = 0; p < itemsToPlan.size(); p++) {
        P[p] = cplex.numVarArray(get_Main().simParams.getMRPPlanningHorizon(), 0,  Double.MAX_VALUE, Pnames[p]);
     }
               
     IloNumVar[][] W = new IloNumVar[itemsToPlan.size()][];
     for (int p = 0; p < itemsToPlan.size(); p++) {
        W[p] = cplex.numVarArray(get_Main().simParams.getMRPPlanningHorizon(), 0, Double.MAX_VALUE, Wnames[p]);
     }
		
	 IloNumVar[][] R = new IloNumVar[itemsToPlan.size()][];
     for (int p = 0; p < itemsToPlan.size(); p++) {
        R[p] = cplex.numVarArray(get_Main().simParams.getMRPPlanningHorizon(), 0.0, Double.MAX_VALUE, Rnames[p]);
     }
               	
	double[] inventory = new double[itemsToPlan.size()];
	double[] wip = new double[itemsToPlan.size()];
	double[] produce = new double[itemsToPlan.size()];
	double[] tl = new double[itemsToPlan.size()];
		
	int[][] X = new int[itemsToPlan.size()][get_Main().simParams.getMRPPlanningHorizon()];

	List<SpecialObject> iQd = new ArrayList<SpecialObject>();
	
     for (int p = 0; p < itemsToPlan.size(); p++) {      	     

     		   inventory[p] = 0;
     		   
     		   wip[p] = (int)ProductionOrder.GetCurrentWip(get_Main().productionOrders, itemsToPlan.get(p).getItem(), get_Main().simParams);
     		   produce[p] = 0;
     		   
     		   tl[p] = itemsToPlan.get(p).getItem().getTransportLotSize();
			   				    			
     	       for (int t = 0; t < get_Main().simParams.getMRPPlanningHorizon(); t++) {               	                          	               	
               	
               	int tmp_item = itemsToPlan.get(p).getItem().getItem();
               	int temp_t = t;
               	
               	MRP mrpItem = get_Main().mrpTable.stream().filter(e -> e.getItem().getItem() == tmp_item
               	 && e.getTime() == time() && e.getPeriod() == temp_t).findFirst().orElseGet(() -> new MRP());

				if(itemsToPlan.get(p).getItem().getType().equalsIgnoreCase(Item.ITEM_TYPE_SALES)){ 
        			X[p][t] = (int) mrpItem.getPlannedOrderReceipts();					
        			
        		}else{
					X[p][t] = (int) mrpItem.getPlannedOrderReceipts();					
        		}
        		
        		if(X[p][t] > 0) {
        			SpecialObject so = new SpecialObject(
        				mrpItem.getItem().getItem(),
        				X[p][t], 
        				t);
        			iQd.add(so);
        		}        		  	        		        		
            }     	      	
     }
          
     String[][] RiNames = new String[iQd.size()][leadtimeHorizon];
     int[][] releaseTmp = new int[iQd.size()][main.simParams.getMRPPlanningHorizon()];
     String[] releaseForX = new String[iQd.size()];
          
     for (int p = 0; p < iQd.size(); p++) {
          for(int i = 0; i < leadtimeHorizon; i++){
          		int targetT = (int)(iQd.get(p).getDueDate() - leadtimeHorizon + i);          		
          		
          		if(targetT < 0)
          			targetT = 0;
          		          		
          		releaseTmp[p][targetT] = i+1;          		
        	 	RiNames[p][i] = "RI_" +  iQd.get(p).getItem() + "_" + (int)iQd.get(p).getDueDate() + 
        	 	
        	 	"_" + iQd.get(p).getQuantity() + "_" + targetT + "R" + iQd.get(p).getItem() + "_" + targetT; 
	     }    
     }
            
     IloNumVar[][] RI = new IloNumVar[iQd.size()][];
     for (int p = 0; p < iQd.size(); p++) {
        RI[p] = cplex.boolVarArray(leadtimeHorizon, RiNames[p]);
     }
          
     	//Objective Function     
		IloLinearNumExpr objFunction  = cplex.linearNumExpr();
	         
        for (int p = 0; p < itemsToPlan.size(); p++) {
           for (int t = 0; t < get_Main().simParams.getMRPPlanningHorizon(); t++) {
              objFunction.addTerm (itemsToPlan.get(p).getItem().getHoldingCosts(), I[p][t]);
            }
         }

        for (int p = 0; p < itemsToPlan.size(); p++) {
           for (int t = 0; t < get_Main().simParams.getMRPPlanningHorizon(); t++) {
             objFunction.addTerm (itemsToPlan.get(p).getItem().getHoldingCostsWIP(), W[p][t]);
            }                     	            
         } 
         
         for (int t = 0; t < get_Main().simParams.getMRPPlanningHorizon(); t++) {
             objFunction.addTerm (oCosts, C[t]);
         }                     	                              
                                      
         cplex.addMinimize(objFunction);
       
         for (int p = 0; p < itemsToPlan.size(); p++) {

			//inventory balance   
         	//cplex.addEq(cplex.sum(I[p][0], X[p][0]), 
            		//	cplex.sum(inventory[p], P[p][0]));
            		
            		
            //cplex.addEq(cplex.sum(I[p][0], X[p][0]), 
            			//cplex.sum(I[p][0], P[p][0]));
            		
         	cplex.addEq(I[p][0],0);
         
            for (int t = 1; t < get_Main().simParams.getMRPPlanningHorizon(); t++) {
	           	cplex.addEq(cplex.sum(I[p][t], X[p][t]), 
                       cplex.sum(I[p][t-1], P[p][t-1]));
        	}
                                                
            //wip constraint            
            //cplex.addEq(cplex.sum(W[p][0], produce[p]), 
              //             cplex.sum(wip[p], R[p][0]));
            cplex.addEq(W[p][0], R[p][0]);
                        
            for (int t = 1; t < get_Main().simParams.getMRPPlanningHorizon(); t++) {
               cplex.addEq(cplex.sum(W[p][t], P[p][t-1]), 
                           cplex.sum(W[p][t-1], R[p][t]));   
                                                                                                                                    
            }			             											
         }
         
                  
          for (int p = 0; p < iQd.size(); p++) {
            IloLinearNumExpr num_expr_Sum_Binaries = cplex.linearNumExpr();            
	            for (int t = 0; t < leadtimeHorizon; t++) {
					num_expr_Sum_Binaries.addTerm(1,RI[p][t]);															
	            }
	            cplex.addEq(num_expr_Sum_Binaries,1);
            }
         
         
         for (int pp = 0; pp < itemsToPlan.size(); pp++) {
         	IloLinearNumExpr cf = cplex.linearNumExpr();				         
	       for (int t = 0; t < main.simParams.getMRPPlanningHorizon(); t++) {	            	            
			       	String o = "";
			       	int sizeExpr = 0;
			        IloLinearNumExpr num_expr = cplex.linearNumExpr();
			                    
	                for (int p = 0; p < iQd.size(); p++) {
	                	if(iQd.get(p).getItem()== itemsToPlan.get(pp).getItem().getItem()){
		            		if(releaseTmp[p][t] > 0){
		            			//traceln(RI[p][t].getName());	            		
		            			//traceln(p + " " + (releaseTmp[p][t]-1));
		            			o = o + iQd.get(p).getQuantity() + "*" + RI[p][releaseTmp[p][t]-1].getName() +  "+";	            			
		            			num_expr.addTerm(iQd.get(p).getQuantity(),RI[p][releaseTmp[p][t]-1]);		            			
		            					            			
		            			sizeExpr++;		            					            					            			
		            		}			        
	            		}
					}
					
				if(o.length() > 1){
		            if(sizeExpr > 0){
		            	//Constraint Release Size 
			            cplex.addEq(R[pp][t],num_expr);    
			                  
			        }

				}else{
				         cplex.addEq(R[pp][t],0);          								
				}
																
				num_expr.clear();             														
			}         
         }                                    
         
         for (int t = 0; t < main.simParams.getMRPPlanningHorizon(); t++) {	    
	     	IloLinearNumExpr cf = cplex.linearNumExpr();				             	    
	     	IloLinearNumExpr cf1 = cplex.linearNumExpr();				             	    
	       	IloLinearNumExpr cf2 = cplex.linearNumExpr();				             	    
		   	IloLinearNumExpr cf3 = cplex.linearNumExpr();				             	    
	       	IloLinearNumExpr cf4 = cplex.linearNumExpr();				             	    
    	    
        	 for (int pp = 0; pp < itemsToPlan.size(); pp++) {        	 
 			
	         		cf.addTerm(itemsToPlan.get(pp).getItem().getRouting().getEProcessingTime(),P[pp][t]);         			         			         			         		
	         		cf1.addTerm(itemsToPlan.get(pp).getItem().getRouting().getEProcessingTime(),P[pp][t]); 	         		        		
         			cf2.addTerm(itemsToPlan.get(pp).getItem().getRouting().getEProcessingTime(),W[pp][t]);         			         		
         			         			
         			cf3.addTerm(itemsToPlan.get(pp).getItem().getRouting().getEProcessingTime(),P[pp][t]);         		
         			cf4.addTerm(itemsToPlan.get(pp).getItem().getRouting().getEProcessingTime(),W[pp][t]);
         			         			         		         			
         			cplex.addLe(P[pp][t],W[pp][t]);         			         			         			
        	  }
        	          	  
        	  //todo: richtige kapazttat pro periode d.h. statt 1440
        	  
         	  //CF partition 3
         	  cplex.addLe(cplex.sum(cf,2),cplex.sum(1440,C[t]));			
         	  
			  //CF partition 2
         	  cplex.addLe(cf1,cplex.sum(cplex.sum(cplex.prod(0.5,cf2),360),C[t]));
         	  
         	  //CF partition 1
         	  cplex.addLe(cf3,cplex.sum(cf4,C[t]));         	  
         	  
			  cf.clear();
			  cf1.clear();
 			  cf2.clear();
 			  cf3.clear();
 			  cf4.clear(); 			   			   			  
         }
                  
    //if(time() == 0)                 
		cplex.exportModel("model/NewModel_" + time() + "_" + bomLevel + ".lp");
	
	//cplex.setParam(IloCplex.BooleanParam.PreInd, false);
	//cplex.setParam(IloCplex.IntParam.DataCheck, 2);	
						
	if(cplex.solve()){
		    
		    System.out.println("Solution status: " + cplex.getStatus());
            System.out.println();
            System.out.println("Objective Value = " + cplex.getObjValue());
          
            System.out.println();
            System.out.println("\tp\tTime\tt\tWip\tX\tRelease\tP\tInv\tIBl\tWB\tObjPP\tCt");
          
            for (int p = 0; p < itemsToPlan.size(); p++) {
               for (int t = 0; t < get_Main().simParams.getMRPPlanningHorizon(); t++) {
               
               double inventoryBalance = 0;
               double wipBalance = 0;

               if(t>0){
                  inventoryBalance = cplex.getValue(I[p][t-1])-X[p][t]+cplex.getValue(P[p][t-1]);
                  wipBalance = cplex.getValue(W[p][t-1])+cplex.getValue(R[p][t])-cplex.getValue(P[p][t-1]);
               
               }
               	  double objectivePerPeriod = cplex.getValue(W[p][t]) * 0.5 + cplex.getValue(I[p][t]);
                  System.out.println("\t" + itemsToPlan.get(p).getItem().getItem() +
                                     "\t" + (time() + t) +
                                     "\t" + t +
                                     "\t" + (int)cplex.getValue(W[p][t]) +
                                     "\t" + X[p][t] +
                                     "\t" + (int)cplex.getValue(R[p][t]) +       
                                     //"\t" + (int)cplex.getValue(RI[p][t]) +                                                       
                                     "\t" + Math.round(cplex.getValue(P[p][t])) +                               
                                     "\t" + Math.round(cplex.getValue(I[p][t])) +
                                     "\t" + Math.round(inventoryBalance) +
                                     "\t" + (int)wipBalance +
                                     "\t" + (int)objectivePerPeriod +
                                     "\t" + Math.round(cplex.getValue(C[t]))                                
                                     );                                                                                                 
                                    
                    //OptimizationResult optResult = new OptimizationResult(time(),itemsToPlan.get(p).getItem().getItem(), t,
                    //cplex.getValue(W[p][t]), cplex.getValue(R[p][t]), 0,cplex.getValue(P[p][t]),
                    //cplex.getValue(I[p][t]) );
                    
                    //get_Main().optimizationResults.add(optResult);                 
                                     
               }
            }
            
          for (int p = 0; p < iQd.size(); p++) {
          	for(int i = 0; i < leadtimeHorizon; i++){
          		if(cplex.getValue(RI[p][i]) > 0){
        	 		traceln(RI[p][i].getName() + " Value " + cplex.getValue(RI[p][i]));
        	 		releaseForX[p] = RI[p][i].getName();
        	 	}
	     	}    
     	  }
     	  
            
            //if(OptimizationResult.WRITE_OPTIMIZATION_RESULTS_TO_XLXS)
			//OptimizationResult.WriteXlsxOptimizationResults(get_Main().optimizationResults, get_Main().simParams);            
            	//traceln("size +++++++++++ " + get_Main().optimizationResults.size());
            
		}else{
			traceln("NO Solution " + cplex.getStatus());
		}												
        	
        	for (int p = 0; p < iQd.size(); p++) {        	        
               for (int t = 0; t < leadtimeHorizon; t++) {               
					        double qty = cplex.getValue(RI[p][t]);    			            			            		            
					        
							if(qty > 0.5){
			                    ProductionOrder order = new ProductionOrder();
			                    								
								int itemIntTmp = iQd.get(p).getItem();
									
			                    Item item = get_Main().items.stream().filter(e -> e.getItem() == itemIntTmp).findFirst().get();																		                     
			                    
			                    order.setOrderId(get_Main().prodOrderId++);
			                    order.setItem(item);
			                                                                                                                                  
								order.setPlannedCapacity(Routing.GetPlannedCapacityPerItem(get_Main().routings, order.getItem(), get_Main().simParams, order));
			                    
			                    int minimumRoutingStep = Routing.GetMinimumStep(get_Main().routings, order.getItem() , get_Main().simParams);
								int maximumRoutingStep = Routing.GetMaximumStep(get_Main().routings, order.getItem() , get_Main().simParams);
						
								order.setMinimumRoutingStep(minimumRoutingStep);
								order.setMaximumRoutingStep(maximumRoutingStep);			
								order.setCurrentRoutingStep(minimumRoutingStep);                                        			                    
			                                                            
			                    order.setQuantity(Math.round(iQd.get(p).getQuantity()));
			                    order.setCreatedAt(time());			                    
			                    
			                    
			                    String[] RiSplitted = RI[p][t].getName().split("_");
			                    
			                    order.setPlannedStart(Integer.parseInt(RiSplitted[5]) + time());
			                    order.setPlannedEnd(Integer.parseInt(RiSplitted[2]) + time());
			                    long exists = 0;	
			                    		                    
			                    if(order.getPlannedStart() < time())
			                    	exists = 1;
			                    											
			                    if(exists == 0){														                    
				                    Routing routingObject = get_Main().routings.stream().filter(e -> e.getItem().getItem() == order.getItem().getItem()).findFirst().get();			
									order.setRouting(routingObject);
									order.setStatus(ProductionOrder.PRODUCTION_ORDER_STATUS_UNPROCESSED);
				                    
				                    get_Main().productionOrders.add(order);	                    						
													                    
			                    }
		                    }
		                 }            
		            }
        
        
		traceln("time " + time());
		traceln("Production Orders from Optmization Before Removing");
		traceln(ProductionOrder.GetCSVHeader());

        for (ProductionOrder order: get_Main().productionOrders) {
            traceln(ProductionOrder.GetCSVString(order));
        }        
		
        //get_Main().productionOrders.removeIf(e -> e.getPlannedStart() > time());
/*
        traceln("Production Orders from Optmization FOR SIMULATION");
        traceln(ProductionOrder.GetCSVHeader());

        for (ProductionOrder order: get_Main().productionOrders) {
            traceln(ProductionOrder.GetCSVString(order));
        }        
        traceln("**************************");                							
*/		
		//get_Main().Function_OrderRelease();
				
	}
	catch (IloException exc) {
         System.err.println("Concert exception '" + exc.getMessage() + "' caught");
         System.exit(-1);
    }

//} catch(IloException ex) {
	//ex.printStackTrace();
//}	
return 0;
]]></Body>
				</Function>
				<Function AccessType="default" StaticFunction="false">
					<ReturnModificator>RETURNS_VALUE</ReturnModificator>
					<ReturnType><![CDATA[int]]></ReturnType>
					<Id>1679118947591</Id>
					<Name><![CDATA[Function_ClearingFunction_wo_cf_const]]></Name>
					<X>50</X><Y>110</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Parameter>
						<Name><![CDATA[itemsToPlan]]></Name>
						<Type><![CDATA[List<MRP>]]></Type>
					</Parameter>
					<Parameter>
						<Name><![CDATA[bomLevel]]></Name>
						<Type><![CDATA[int]]></Type>
					</Parameter>
					<Body><![CDATA[try{
							

traceln("----------- Start OPTIMIZE at " + time () + " ----------------");
							
StringBuilder output = new StringBuilder();

double points[] = new double[] {200.0, 400.0, 600.0, 800.0};
double slopes[] = new double[] { 30.0, 80.0, 130.0, 50.0, 40.0};

double oCosts = 0;
double oFactor = 1000;
double setupTime = 0;
int leadtimeHorizon = main.simParams.getLeadTimeHorizon();
traceln("Leadtime Horizon: " + leadtimeHorizon);

IloCplex cplex = new IloCplex();

     String[][] Inames = new String[itemsToPlan.size()][get_Main().simParams.getMRPPlanningHorizon()];
     String[][] Pnames = new String[itemsToPlan.size()][get_Main().simParams.getMRPPlanningHorizon()];
     String[][] Wnames = new String[itemsToPlan.size()][get_Main().simParams.getMRPPlanningHorizon()];
     String[][] Rnames = new String[itemsToPlan.size()][get_Main().simParams.getMRPPlanningHorizon()];     
     
     for(int i = 0; i< get_Main().simParams.getMRPPlanningHorizon(); i++){
          for (int p = 0; p < itemsToPlan.size(); p++) {
        	 	Inames[p][i] = "I" + itemsToPlan.get(p).getItem().getItem() + "_" + i; 
        	 	Pnames[p][i] = "P" + itemsToPlan.get(p).getItem().getItem() + "_" + i; 
        	 	Wnames[p][i] = "W" + itemsToPlan.get(p).getItem().getItem() + "_" + i; 
        	 	Rnames[p][i] = "R" + itemsToPlan.get(p).getItem().getItem() + "_" + i; 
	     }
     }

     IloNumVar[] C = new IloNumVar[main.simParams.getMRPPlanningHorizon()];
     for (int t = 0; t < get_Main().simParams.getMRPPlanningHorizon(); t++) {
        C[t] = cplex.numVar(0, Double.MAX_VALUE, "C" + "_" + t);
     }
     
     IloNumVar[][] I = new IloNumVar[itemsToPlan.size()][];
     for (int p = 0; p < itemsToPlan.size(); p++) {
        I[p] = cplex.numVarArray(get_Main().simParams.getMRPPlanningHorizon(), 0, Double.MAX_VALUE, Inames[p]);
        oCosts += itemsToPlan.get(p).getItem().getHoldingCosts();
     }
     
     oCosts = oFactor*oCosts;
     
     IloNumVar[][] P = new IloNumVar[itemsToPlan.size()][];
     for (int p = 0; p < itemsToPlan.size(); p++) {
        P[p] = cplex.numVarArray(get_Main().simParams.getMRPPlanningHorizon(), 0,  Double.MAX_VALUE, Pnames[p]);
     }
               
     IloNumVar[][] W = new IloNumVar[itemsToPlan.size()][];
     for (int p = 0; p < itemsToPlan.size(); p++) {
        W[p] = cplex.numVarArray(get_Main().simParams.getMRPPlanningHorizon(), 0, Double.MAX_VALUE, Wnames[p]);
     }
		
	 IloNumVar[][] R = new IloNumVar[itemsToPlan.size()][];
     for (int p = 0; p < itemsToPlan.size(); p++) {
        R[p] = cplex.numVarArray(get_Main().simParams.getMRPPlanningHorizon(), 0.0, Double.MAX_VALUE, Rnames[p]);
     }
               	
	double[] inventory = new double[itemsToPlan.size()];
	double[] wip = new double[itemsToPlan.size()];
	double[] produce = new double[itemsToPlan.size()];
	double[] tl = new double[itemsToPlan.size()];
		
	int[][] X = new int[itemsToPlan.size()][get_Main().simParams.getMRPPlanningHorizon()];

	List<SpecialObject> iQd = new ArrayList<SpecialObject>();
	
     for (int p = 0; p < itemsToPlan.size(); p++) {      	     

     		   inventory[p] = 0;
     		   
     		   wip[p] = (int)ProductionOrder.GetCurrentWip(get_Main().productionOrders, itemsToPlan.get(p).getItem(), get_Main().simParams);
     		   produce[p] = 0;
     		   
     		   tl[p] = itemsToPlan.get(p).getItem().getTransportLotSize();
			   				    			
     	       for (int t = 0; t < get_Main().simParams.getMRPPlanningHorizon(); t++) {               	                          	               	
	               	
	               	int tmp_item = itemsToPlan.get(p).getItem().getItem();
	               	int temp_t = t;
	               	
	               	MRP mrpItem = get_Main().mrpTable.stream().filter(e -> e.getItem().getItem() == tmp_item
	               	 && e.getTime() == time() && e.getPeriod() == temp_t).findFirst().orElseGet(() -> new MRP());
	
					if(itemsToPlan.get(p).getItem().getType().equalsIgnoreCase(Item.ITEM_TYPE_SALES)){ 
	        			X[p][t] = (int) mrpItem.getPlannedOrderReceipts();
	        			
	        		}else{
						X[p][t] = (int) mrpItem.getPlannedOrderReceipts();					
	        		}
	        		
	        		if(X[p][t] > 0) {
	        			SpecialObject so = new SpecialObject(
	        				mrpItem.getItem().getItem(),
	        				X[p][t], 
	        				t);
	        			iQd.add(so);
	        		}        		  	        		        		
            }     	      	
     }
          
     String[][] RiNames = new String[iQd.size()][leadtimeHorizon];
     int[][] releaseTmp = new int[iQd.size()][main.simParams.getMRPPlanningHorizon()];
     String[] releaseForX = new String[iQd.size()];
          
     for (int p = 0; p < iQd.size(); p++) {
          for(int i = 0; i < leadtimeHorizon; i++){
          		int targetT = (int)(iQd.get(p).getDueDate() - leadtimeHorizon + i);          		
          		
          		if(targetT < 0)
          			targetT = 0;
          		          		
          		releaseTmp[p][targetT] = i+1;          		
        	 	RiNames[p][i] = "RI_" +  iQd.get(p).getItem() + "_" + (int)iQd.get(p).getDueDate() + 
        	 	
        	 	"_" + iQd.get(p).getQuantity() + "_" + targetT + "R" + iQd.get(p).getItem() + "_" + targetT; 
	     }    
     }
            
     IloNumVar[][] RI = new IloNumVar[iQd.size()][];
     for (int p = 0; p < iQd.size(); p++) {
        RI[p] = cplex.boolVarArray(leadtimeHorizon, RiNames[p]);
     }
          
     	//Objective Function     
		IloLinearNumExpr objFunction  = cplex.linearNumExpr();
	         
        for (int p = 0; p < itemsToPlan.size(); p++) {
           for (int t = 0; t < get_Main().simParams.getMRPPlanningHorizon(); t++) {
              objFunction.addTerm (itemsToPlan.get(p).getItem().getHoldingCosts(), I[p][t]);
            }
         }

        for (int p = 0; p < itemsToPlan.size(); p++) {
           for (int t = 0; t < get_Main().simParams.getMRPPlanningHorizon(); t++) {
             objFunction.addTerm (itemsToPlan.get(p).getItem().getHoldingCostsWIP(), W[p][t]);
            }                     	            
         } 
         
         for (int t = 0; t < get_Main().simParams.getMRPPlanningHorizon(); t++) {
             objFunction.addTerm (oCosts, C[t]);
         }                     	                              
                                      
         cplex.addMinimize(objFunction);
       
         for (int p = 0; p < itemsToPlan.size(); p++) {

			//inventory balance   
         	//cplex.addEq(cplex.sum(I[p][0], X[p][0]), 
            		//	cplex.sum(inventory[p], P[p][0]));
            		
            		
            //cplex.addEq(cplex.sum(I[p][0], X[p][0]), 
            			//cplex.sum(I[p][0], P[p][0]));
            		
         	cplex.addEq(I[p][0],0);
         
            for (int t = 1; t < get_Main().simParams.getMRPPlanningHorizon(); t++) {
	           	cplex.addEq(cplex.sum(I[p][t], X[p][t]), 
                       cplex.sum(I[p][t-1], P[p][t-1]));
        	}
            
            //wip constraint            
            //cplex.addEq(cplex.sum(W[p][0], produce[p]), 
              //             cplex.sum(wip[p], R[p][0]));
              
              
            cplex.addEq(W[p][0], R[p][0]);
            
            for (int t = 1; t < get_Main().simParams.getMRPPlanningHorizon(); t++) {
               cplex.addEq(cplex.sum(W[p][t], P[p][t-1]), 
                           cplex.sum(W[p][t-1], R[p][t]));   
                                                                                                                                    
            }			             											
         }
         
                  
          for (int p = 0; p < iQd.size(); p++) {
            IloLinearNumExpr num_expr_Sum_Binaries = cplex.linearNumExpr();            
	            for (int t = 0; t < leadtimeHorizon; t++) {
					num_expr_Sum_Binaries.addTerm(1,RI[p][t]);															
	            }
	            cplex.addEq(num_expr_Sum_Binaries,1);
            }
         
         
         //RI structure
         //RI_item_Xt_qty_start_lth_...end_lth_Ritem_start_lth...end_lth
         for (int pp = 0; pp < itemsToPlan.size(); pp++) {
         	IloLinearNumExpr cf = cplex.linearNumExpr();				         
	       for (int t = 0; t < main.simParams.getMRPPlanningHorizon(); t++) {	            	            
			       	String o = "";
			       	int sizeExpr = 0;
			        IloLinearNumExpr num_expr = cplex.linearNumExpr();
			                    
	                for (int p = 0; p < iQd.size(); p++) {
	                	if(iQd.get(p).getItem()== itemsToPlan.get(pp).getItem().getItem()){
		            		if(releaseTmp[p][t] > 0){
		            			//traceln(RI[p][t-1].getName());	            		
		            			//traceln(p + " " + (releaseTmp[p][t]-1));
		            			o = o + iQd.get(p).getQuantity() + "*" + RI[p][releaseTmp[p][t]-1].getName() +  "+";	            			
		            			num_expr.addTerm(iQd.get(p).getQuantity(),RI[p][releaseTmp[p][t]-1]);		            			
		            					            			
		            			sizeExpr++;		            					            					            			
		            			//traceln(o);
		            		}			        
	            		}
					}
					
				if(o.length() > 1){
		            if(sizeExpr > 0){
		            	//Constraint Release Size 
			            cplex.addEq(R[pp][t],num_expr);    
			                  
			        }

				}else{
				         cplex.addEq(R[pp][t],0);          								
				}
																
				num_expr.clear();             														
			}         
         }
         
         //sumRIs: represent the RI for the leadtime horizon
         IloLinearNumExpr sumRIs = cplex.linearNumExpr();			
           for (int t = 0; t < main.simParams.getMRPPlanningHorizon(); t++) {	    
                   	 for (int pp = 0; pp < itemsToPlan.size(); pp++) {        	 
           

           for (int p = 0; p < iQd.size(); p++) {
 				    if(iQd.get(p).getItem()== itemsToPlan.get(pp).getItem().getItem()){ 	
 				    	if(releaseTmp[p][t] > 0){ 				    			
			        	//RI[p] = cplex.boolVarArray(leadtimeHorizon, RiNames[p]);
				        sumRIs.addTerm(1.0,RI[p][releaseTmp[p][t]-1]);		        
				        }
		        }
	     	}
           }
           }                  
         
         //Constraint avoiding that RI with later due date, releases order earlier that RI with earlier due date (orders should not overteak each other)
         //The release of order 2 should not before order 1         
         //traceln("iQd size " + iQd.size());
         for (int p = 0; p < iQd.size(); p++) {
  	 		//traceln("~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~");
          	//for(int i = 0; i < leadtimeHorizon; i++){
          	//for(int i = 0; i < 1; i++){
          		//if(cplex.getValue(RI[p][i]) > 0){
          		
          			int i = 0;
        	 		//traceln(RI[p][i].getName());
        	 		
        	 		String[] RiSplitted = RI[p][i].getName().split("_");			                    
			        
			        int endDate = Integer.parseInt(RiSplitted[2]); //enddate (Xt)
			        int item = Integer.parseInt(RiSplitted[1]); //enddate (Xt)
					//traceln("item " +item + " endDate " + endDate);							
					//check if another RIs with a later endDate (Xt) exists
					
        	         for (int p2 = 0; p2 < iQd.size(); p2++) {
	                   	int i2 = 0;
	                   	
							String[] RiSplittedSuccessor = RI[p2][i2].getName().split("_");			                    	                   			                   	
							
							int endDateSuccessor = Integer.parseInt(RiSplittedSuccessor[2]); //enddate (Xt)
					        int itemSuccessor = Integer.parseInt(RiSplittedSuccessor[1]); //enddate (Xt)

					        //traceln("item Succ " +itemSuccessor + " endDate " + endDateSuccessor);							
		                   		if(endDate < endDateSuccessor){ //don't iterate over the same RI
				                   	int RiendDateSuccessor = Integer.parseInt(RiSplittedSuccessor[2]); //enddate (Xt) RI successor
				                   	//traceln(" ----> Overlapping Successor " + itemSuccessor + " end date " + endDateSuccessor + 
				                   	//" " + RI[p2][i2].getName());	                   		                   		
				                   	int overlappingStart = (endDateSuccessor - leadtimeHorizon);
				                   	//traceln("overlapping start " + overlappingStart);
				                   	//traceln("overlapping end " + endDate);

									IloLinearNumExpr lhs = cplex.linearNumExpr();				             	    
				                   	IloLinearNumExpr rhs = cplex.linearNumExpr();				                   					        

				                   	//traceln("Start Index " + RIstartIndex);
				                   	int overlappingPeriods = endDate - overlappingStart;
				                   	
				                   	int RIstartIndex = max(0,(leadtimeHorizon-overlappingPeriods));				                   		
				                   	
				                   	StringBuilder lhsOut = new StringBuilder();
				                   	StringBuilder rhsOut = new StringBuilder();
				                   	
				                   	for(int o = 0; o < overlappingPeriods; o++){
				                   		//traceln(" p " + p);
				                   		//traceln(" p2 " + p2);
				                   		//traceln(RI[p][0]);				                   		
				                   		//traceln(RI[p2][0]);
				                   		//traceln(RIstartIndex + o);
					                   	lhs.addTerm(1,RI[p][RIstartIndex + o]);
					                   	lhsOut.append(RI[p][RIstartIndex + o].getName() + "+");
					                   	
					                   	rhs.addTerm(1,RI[p2][o]);
					                   	rhsOut.append(RI[p2][o].getName() + "+");
					                 }
				                   	cplex.addGe(lhs,rhs);
				                   	//traceln(lhsOut.toString() + ">=" + rhsOut.toString());
				                 }   	         
        	         }
     	  }     
                            
         
         for (int t = 0; t < main.simParams.getMRPPlanningHorizon(); t++) {	    
	     	IloLinearNumExpr cf = cplex.linearNumExpr();				             	    
	     	IloLinearNumExpr cf1 = cplex.linearNumExpr();				             	    
	       	IloLinearNumExpr cf2 = cplex.linearNumExpr();				             	    
		   	IloLinearNumExpr cf3 = cplex.linearNumExpr();				             	    
	       	IloLinearNumExpr cf4 = cplex.linearNumExpr();				             	    

    	    
        	 for (int pp = 0; pp < itemsToPlan.size(); pp++) {        	  			

	         		cf.addTerm(itemsToPlan.get(pp).getItem().getRouting().getEProcessingTime(),P[pp][t]);	         		
	         		
	         		cf1.addTerm(itemsToPlan.get(pp).getItem().getRouting().getEProcessingTime(),P[pp][t]); 	         		        		
         			cf2.addTerm(itemsToPlan.get(pp).getItem().getRouting().getEProcessingTime(),W[pp][t]);         			         		
         			         			
         			cf3.addTerm(itemsToPlan.get(pp).getItem().getRouting().getEProcessingTime(),P[pp][t]);         		
         			cf4.addTerm(itemsToPlan.get(pp).getItem().getRouting().getEProcessingTime(),W[pp][t]);
         			         			         		         			
         			cplex.addLe(
         				cplex.sum(P[pp][t],cplex.prod(0,sumRIs)),//LHS         			
        				cplex.sum(W[pp][t],0));//RHS         			
        	  }
        	          	  
        	  //todo: richtige kapazttat pro periode d.h. statt 1440
        	  
         	  //CF partition 3
         	  //todo: check cf,2, why is there a 2
         	  //cplex.addLe(cplex.sum(cplex.prod(cf,2),cplex.prod(setupTime,sumRIs)), //LHS
         	  //lineare Teil
         	  //cfString.append()
         	  cplex.addLe(cplex.sum(cf,cplex.prod(setupTime,sumRIs)), //LHS
         	  cplex.sum(1440,C[t]));			
         	           	           	           	  
			  //CF partition 2
         	  cplex.addLe(
         	  	cplex.sum(cf1,cplex.prod(setupTime,sumRIs)), //LHS
         	    
         	    //changed from 360 to 720 ... why is this wrong??? with 360
         	  	cplex.sum(cplex.sum(cplex.prod(0.5,
         	  		cplex.sum(cf2,cplex.prod(setupTime,sumRIs))),360),C[t]));//RHS
         	  
         	  //CF partition 1
         	  
         	  cplex.addLe(
         	  	cplex.sum(cf3,cplex.prod(setupTime,sumRIs)), //LHS         	  
	         	cplex.sum(cplex.sum(cf4,cplex.prod(setupTime,sumRIs)),C[t]));         	  
         	  
			  cf.clear();
			  cf1.clear();
 			  cf2.clear();
 			  cf3.clear();
 			  cf4.clear();
         }
         
            
    
    //if(time() == 0)                 
		//cplex.exportModel("model/NewModel_" + time() + "_" + bomLevel + ".lp");
		//cplex.writeSolution("model/NewModel_" + time() + "_" + bomLevel + ".sol");
	
	cplex.setParam(IloCplex.BooleanParam.PreInd, false);
	//cplex.setParam(IloCplex.IntParam.DataCheck, 2);	
	cplex.setParam(IloCplex.IntParam.WorkMem, 2000);
	boolean writeOutput = false;					
	if(cplex.solve() && writeOutput){
		    
		    System.out.println("Solution status: " + cplex.getStatus());
            System.out.println();
            System.out.println("Objective Value = " + cplex.getObjValue());
          
            System.out.println();
            System.out.println("\tp\tTime\tt\tWip\tX\tRelease\tP\tPL\tL\tCF3\tCF2\tCF1\tInv\tIBl\tWB\tObjPP\tCt");
          
            for (int p = 0; p < itemsToPlan.size(); p++) {
               for (int t = 0; t < get_Main().simParams.getMRPPlanningHorizon(); t++) {
               
               double inventoryBalance = 0;
               double wipBalance = 0;

               if(t>0){
                  inventoryBalance = cplex.getValue(I[p][t-1])-X[p][t]+cplex.getValue(P[p][t-1]);
                  wipBalance = cplex.getValue(W[p][t-1])+cplex.getValue(R[p][t])-cplex.getValue(P[p][t-1]);
               
               }
               		
               	  double lt = cplex.getValue(W[p][t])*itemsToPlan.get(p).getItem().getRouting().getEProcessingTime();
               	  double pl = cplex.getValue(P[p][t])*itemsToPlan.get(p).getItem().getRouting().getEProcessingTime();
               	  double objectivePerPeriod = cplex.getValue(W[p][t]) * 0.5 + cplex.getValue(I[p][t]);
               	  
                  System.out.println("\t" + itemsToPlan.get(p).getItem().getItem() +
                                     "\t" + (time() + t) +
                                     "\t" + t +
                                     "\t" + (int)cplex.getValue(W[p][t]) +
                                     "\t" + X[p][t] +
                                     "\t" + (int)cplex.getValue(R[p][t]) +       
                                     //"\t" + (int)cplex.getValue(RI[p][t]) +                                                       
                                     "\t" + (int)cplex.getValue(P[p][t]) +
                                     "\t" + (int)pl +
                                     "\t" + (int)lt +
                                     "\t" + 1440 + 
                                     "\t" + (int)(0.5*lt+360) + 
                                     "\t" + (int)lt +
                                     "\t" + Math.round(cplex.getValue(I[p][t])) +
                                     "\t" + Math.round(inventoryBalance) +
                                     "\t" + (int)wipBalance +
                                     "\t" + (int)objectivePerPeriod +
                                     "\t" + Math.round(cplex.getValue(C[t]))                                
                                     );                                                                                                 
                                    
                    //OptimizationResult optResult = new OptimizationResult(time(),itemsToPlan.get(p).getItem().getItem(), t,
                    //cplex.getValue(W[p][t]), cplex.getValue(R[p][t]), 0,cplex.getValue(P[p][t]),
                    //cplex.getValue(I[p][t]) );
                    
                    //get_Main().optimizationResults.add(optResult);                 
                                     
               }
            }
                 	  
            
            //if(OptimizationResult.WRITE_OPTIMIZATION_RESULTS_TO_XLXS)
			//OptimizationResult.WriteXlsxOptimizationResults(get_Main().optimizationResults, get_Main().simParams);            
            	//traceln("size +++++++++++ " + get_Main().optimizationResults.size());
            
		}else{
			traceln("NO Solution " + cplex.getStatus());
		}												
        	
        	for (int p = 0; p < iQd.size(); p++) {        	        
               for (int t = 0; t < leadtimeHorizon; t++) {   
                           
					        double qty = cplex.getValue(RI[p][t]);    			            			            		            
					        
							if(qty > 0.9){
			                    ProductionOrder order = new ProductionOrder();
			                    								
								int itemIntTmp = iQd.get(p).getItem();
									
			                    Item item = get_Main().items.stream().filter(e -> e.getItem() == itemIntTmp).findFirst().get();																		                     
			                    
			                    order.setOrderId(get_Main().prodOrderId++);
			                    order.setItem(item);
			                                                                                                                                  
								order.setPlannedCapacity(Routing.GetPlannedCapacityPerItem(get_Main().routings, order.getItem(), get_Main().simParams, order));
			                    
			                    int minimumRoutingStep = Routing.GetMinimumStep(get_Main().routings, order.getItem() , get_Main().simParams);
								int maximumRoutingStep = Routing.GetMaximumStep(get_Main().routings, order.getItem() , get_Main().simParams);
						
								order.setMinimumRoutingStep(minimumRoutingStep);
								order.setMaximumRoutingStep(maximumRoutingStep);			
								order.setCurrentRoutingStep(minimumRoutingStep);                                        			                    
			                                                            
			                    order.setQuantity(Math.round(iQd.get(p).getQuantity()));
			                    order.setCreatedAt(time());			                    
			                    
			                    //get the start and end dates from the RI decision variables			                    
			                    String[] RiSplitted = RI[p][t].getName().split("_");
			                    
			                    order.setPlannedStart(Integer.parseInt(RiSplitted[5]) + time());
			                    
			                    order.setPlannedEnd(Integer.parseInt(RiSplitted[2]) + time());
			                    
			                    long exists = 0;	
			                    		                    
			                    if(order.getPlannedStart() < time())
			                    	exists = 1;
			                    											
			                    if(exists == 0){														                    
				                    Routing routingObject = get_Main().routings.stream().filter(e -> e.getItem().getItem() == order.getItem().getItem()).findFirst().get();			
									order.setRouting(routingObject);
									order.setStatus(ProductionOrder.PRODUCTION_ORDER_STATUS_UNPROCESSED);
				                    
				                    get_Main().productionOrders.add(order);	                    						
													                    
			                    }
		                    }
		                 }            
		            }
        
        
		//traceln("time " + time());
		traceln("Production Orders from Optmization Before Removing");
		traceln(ProductionOrder.GetCSVHeader());

        for (ProductionOrder order: get_Main().productionOrders) {
            traceln(ProductionOrder.GetCSVString(order));
        }        
		
        //get_Main().productionOrders.removeIf(e -> e.getPlannedStart() > time());
/*
        traceln("Production Orders from Optmization FOR SIMULATION");
        traceln(ProductionOrder.GetCSVHeader());

        for (ProductionOrder order: get_Main().productionOrders) {
            traceln(ProductionOrder.GetCSVString(order));
        }        
        traceln("**************************");                							
*/		
		//get_Main().Function_OrderRelease();
		cplex.end();		
	}
	catch (IloException exc) {
         System.err.println("Concert exception '" + exc.getMessage() + "' caught");
         System.exit(-1);
    }

//} catch(IloException ex) {
	//ex.printStackTrace();
//}	
return 0;
]]></Body>
				</Function>
				<Function AccessType="default" StaticFunction="false">
					<ReturnModificator>RETURNS_VALUE</ReturnModificator>
					<ReturnType><![CDATA[int]]></ReturnType>
					<Id>1679909126017</Id>
					<Name><![CDATA[Function_ClearingFunctionStageWise]]></Name>
					<X>50</X><Y>290</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Parameter>
						<Name><![CDATA[itemsToPlan]]></Name>
						<Type><![CDATA[List<MRP>]]></Type>
					</Parameter>
					<Parameter>
						<Name><![CDATA[bomLevel]]></Name>
						<Type><![CDATA[int]]></Type>
					</Parameter>
					<Body><![CDATA[try{
							
traceln("----------- Start CF OPTIMIZATION at " + time () + " ----------------");
							
StringBuilder output = new StringBuilder();


double intercepts[] = new double[5];
double slopes[] = new double[5];
int maxCapacity = 0;

traceln("Total found Segments: " + ClearingFunctionSegments.size());

//via the bom level the cf is associated
List<ClearingFunctionSegments> selectedSegments = new ArrayList();
//if(bomLevel== 0){
	Item firstBomItem = itemsToPlan.get(0).getItem();
	
	Routing firstRoutingItem = main.routings.stream().filter(e -> e.getItem().getItem() == firstBomItem.getItem()).findFirst().get();	
	Resource firstResource= main.resources.stream().filter(e -> e.getName().equalsIgnoreCase(firstRoutingItem.getResource())).findFirst().get();
	
	maxCapacity = main.resources.stream().filter(e -> e.getResourceGroup().
	equalsIgnoreCase(firstResource.getResourceGroup())).mapToInt(Resource::getCapacity).sum();																													
	
	if(firstBomItem.getLotsizePolicy().equalsIgnoreCase(Item.LOT_POLICY_FOP)) {
		int fop = firstBomItem.getFOPPeriod();	
		traceln("FOP Period:" + fop);	
	
	selectedSegments = ClearingFunctionSegments.stream().filter(e -> e.getLotParameter() == fop &&
			 e.getLotPolicy().equalsIgnoreCase(Item.LOT_POLICY_FOP) && e.getProductionStage() 
			 == bomLevel + 1 && e.getExperiment().equalsIgnoreCase(main.simParams.getExperiment())).collect(Collectors.toList());															 																

	}
		
	traceln("Selected Slopes: ");		
	selectedSegments.forEach(e -> traceln(e.getSlope() + ";"));
	traceln("Selected Intercepts: ");
	selectedSegments.forEach(e -> traceln(e.getyIntercept() + ";"));
	
	if(selectedSegments.size() == 0){
		traceln("STOP Simulation: No Segments found!");
		System.exit(0);
	}
	
	for(int i = 0; i < selectedSegments.size(); i++) {
		slopes[i] = selectedSegments.get(i).getSlope();
		intercepts[i] = selectedSegments.get(i).getyIntercept();
	}		
			
//}

int numberSegments = selectedSegments.size();

double oCosts = 0;
double oFactor = 1000;
double setupTime = 0;
int leadtimeHorizon = main.simParams.getLeadTimeHorizon();

traceln("Production Stage: " + (bomLevel + 1));
traceln("Max Capacity: " + maxCapacity);
traceln("Leadtime Horizon: " + leadtimeHorizon);

IloCplex cplex = new IloCplex();

     String[][] Inames = new String[itemsToPlan.size()][get_Main().simParams.getMRPPlanningHorizon()];
     String[][] Pnames = new String[itemsToPlan.size()][get_Main().simParams.getMRPPlanningHorizon()];
     String[][] Wnames = new String[itemsToPlan.size()][get_Main().simParams.getMRPPlanningHorizon()];
     String[][] Rnames = new String[itemsToPlan.size()][get_Main().simParams.getMRPPlanningHorizon()];     
     
     for(int i = 0; i< get_Main().simParams.getMRPPlanningHorizon(); i++){
          for (int p = 0; p < itemsToPlan.size(); p++) {
        	 	Inames[p][i] = "I" + itemsToPlan.get(p).getItem().getItem() + "_" + i; 
        	 	Pnames[p][i] = "P" + itemsToPlan.get(p).getItem().getItem() + "_" + i; 
        	 	Wnames[p][i] = "W" + itemsToPlan.get(p).getItem().getItem() + "_" + i; 
        	 	Rnames[p][i] = "R" + itemsToPlan.get(p).getItem().getItem() + "_" + i; 
	     }
     }

     IloNumVar[] C = new IloNumVar[main.simParams.getMRPPlanningHorizon()];
     for (int t = 0; t < get_Main().simParams.getMRPPlanningHorizon(); t++) {
        C[t] = cplex.numVar(0, Double.MAX_VALUE, "C" + "_" + t);
     }
     
     IloNumVar[][] I = new IloNumVar[itemsToPlan.size()][];
     for (int p = 0; p < itemsToPlan.size(); p++) {
        I[p] = cplex.numVarArray(get_Main().simParams.getMRPPlanningHorizon(), 0, Double.MAX_VALUE, Inames[p]);
        oCosts += itemsToPlan.get(p).getItem().getHoldingCosts();
     }
     
     oCosts = oFactor*oCosts;
     
     IloNumVar[][] P = new IloNumVar[itemsToPlan.size()][];
     for (int p = 0; p < itemsToPlan.size(); p++) {
        P[p] = cplex.numVarArray(get_Main().simParams.getMRPPlanningHorizon(), 0,  Double.MAX_VALUE, Pnames[p]);
     }
               
     IloNumVar[][] W = new IloNumVar[itemsToPlan.size()][];
     for (int p = 0; p < itemsToPlan.size(); p++) {
        W[p] = cplex.numVarArray(get_Main().simParams.getMRPPlanningHorizon(), 0, Double.MAX_VALUE, Wnames[p]);
     }
		
	 IloNumVar[][] R = new IloNumVar[itemsToPlan.size()][];
     for (int p = 0; p < itemsToPlan.size(); p++) {
        R[p] = cplex.numVarArray(get_Main().simParams.getMRPPlanningHorizon(), 0.0, Double.MAX_VALUE, Rnames[p]);
     }
               	
	double[] inventory = new double[itemsToPlan.size()];
	double[] wip = new double[itemsToPlan.size()];
	double[] produce = new double[itemsToPlan.size()];
	double[] tl = new double[itemsToPlan.size()];
		
	int[][] X = new int[itemsToPlan.size()][get_Main().simParams.getMRPPlanningHorizon()];

	List<SpecialObject> iQd = new ArrayList<SpecialObject>();
	
     for (int p = 0; p < itemsToPlan.size(); p++) {      	     

     		   inventory[p] = 0;
     		   
     		   wip[p] = (int)ProductionOrder.GetCurrentWip(get_Main().productionOrders, itemsToPlan.get(p).getItem(), get_Main().simParams);
     		   produce[p] = 0;
     		   
     		   tl[p] = itemsToPlan.get(p).getItem().getTransportLotSize();
			   				    			
     	       for (int t = 0; t < get_Main().simParams.getMRPPlanningHorizon(); t++) {               	                          	               	
	               	
	               	int tmp_item = itemsToPlan.get(p).getItem().getItem();
	               	int temp_t = t;
	               	
	               	MRP mrpItem = get_Main().mrpTable.stream().filter(e -> e.getItem().getItem() == tmp_item
	               	 && e.getTime() == time() && e.getPeriod() == temp_t).findFirst().orElseGet(() -> new MRP());
	
					if(itemsToPlan.get(p).getItem().getType().equalsIgnoreCase(Item.ITEM_TYPE_SALES)){ 
	        			X[p][t] = (int) mrpItem.getPlannedOrderReceipts();
	        			
	        		}else{
						X[p][t] = (int) mrpItem.getPlannedOrderReceipts();					
	        		}
	        		
	        		if(X[p][t] > 0) {
	        			SpecialObject so = new SpecialObject(
	        				mrpItem.getItem().getItem(),
	        				X[p][t], 
	        				t);
	        			iQd.add(so);
	        		}        		  	        		        		
            }     	      	
     }
          
     String[][] RiNames = new String[iQd.size()][leadtimeHorizon];
     int[][] releaseTmp = new int[iQd.size()][main.simParams.getMRPPlanningHorizon()];
     String[] releaseForX = new String[iQd.size()];
          
     for (int p = 0; p < iQd.size(); p++) {
          for(int i = 0; i < leadtimeHorizon; i++){
          		int targetT = (int)(iQd.get(p).getDueDate() - leadtimeHorizon + i);          		
          		
          		if(targetT < 0)
          			targetT = 0;
          		          		
          		releaseTmp[p][targetT] = i+1;          		
        	 	RiNames[p][i] = "RI_" +  iQd.get(p).getItem() + "_" + (int)iQd.get(p).getDueDate() + 
        	 	
        	 	"_" + iQd.get(p).getQuantity() + "_" + targetT + "R" + iQd.get(p).getItem() + "_" + targetT; 
	     }    
     }
            
     IloNumVar[][] RI = new IloNumVar[iQd.size()][];
     for (int p = 0; p < iQd.size(); p++) {
        RI[p] = cplex.boolVarArray(leadtimeHorizon, RiNames[p]);
     }
          
     	//Objective Function     
		IloLinearNumExpr objFunction  = cplex.linearNumExpr();
	         
        for (int p = 0; p < itemsToPlan.size(); p++) {
           for (int t = 0; t < get_Main().simParams.getMRPPlanningHorizon(); t++) {
              objFunction.addTerm (itemsToPlan.get(p).getItem().getHoldingCosts(), I[p][t]);
            }
         }

        for (int p = 0; p < itemsToPlan.size(); p++) {
           for (int t = 0; t < get_Main().simParams.getMRPPlanningHorizon(); t++) {
             objFunction.addTerm (itemsToPlan.get(p).getItem().getHoldingCostsWIP(), W[p][t]);
            }                     	            
         } 
         
         for (int t = 0; t < get_Main().simParams.getMRPPlanningHorizon(); t++) {
             objFunction.addTerm (oCosts, C[t]);
         }                     	                              
                                      
         cplex.addMinimize(objFunction);
       
         for (int p = 0; p < itemsToPlan.size(); p++) {
           		
         	cplex.addEq(I[p][0],0);
         
            for (int t = 1; t < get_Main().simParams.getMRPPlanningHorizon(); t++) {
	           	cplex.addEq(cplex.sum(I[p][t], X[p][t]), 
                       cplex.sum(I[p][t-1], P[p][t-1]));
        	}
            
              
            cplex.addEq(W[p][0], R[p][0]);
            
            for (int t = 1; t < get_Main().simParams.getMRPPlanningHorizon(); t++) {
               cplex.addEq(cplex.sum(W[p][t], P[p][t-1]), 
                           cplex.sum(W[p][t-1], R[p][t]));   
                                                                                                                                    
            }			             											
         }
         
                  
          for (int p = 0; p < iQd.size(); p++) {
            IloLinearNumExpr num_expr_Sum_Binaries = cplex.linearNumExpr();            
	            for (int t = 0; t < leadtimeHorizon; t++) {
					num_expr_Sum_Binaries.addTerm(1,RI[p][t]);															
	            }
	            cplex.addEq(num_expr_Sum_Binaries,1);
            }
         
         
         //RI structure
         //RI_item_Xt_qty_start_lth_...end_lth_Ritem_start_lth...end_lth
         for (int pp = 0; pp < itemsToPlan.size(); pp++) {
         	IloLinearNumExpr cf = cplex.linearNumExpr();				         
	       for (int t = 0; t < main.simParams.getMRPPlanningHorizon(); t++) {	            	            
			       	String o = "";
			       	int sizeExpr = 0;
			        IloLinearNumExpr num_expr = cplex.linearNumExpr();
			                    
	                for (int p = 0; p < iQd.size(); p++) {
	                	if(iQd.get(p).getItem()== itemsToPlan.get(pp).getItem().getItem()){
		            		if(releaseTmp[p][t] > 0){
		            			o = o + iQd.get(p).getQuantity() + "*" + RI[p][releaseTmp[p][t]-1].getName() +  "+";	            			
		            			num_expr.addTerm(iQd.get(p).getQuantity(),RI[p][releaseTmp[p][t]-1]);		            			
		            					            			
		            			sizeExpr++;		            					            					            			
		            		}			        
	            		}
					}
					
				if(o.length() > 1){
		            if(sizeExpr > 0){
		            	//Constraint Release Size 
			            cplex.addEq(R[pp][t],num_expr);    
			                  
			        }

				}else{
				         cplex.addEq(R[pp][t],0);          								
				}
																
				num_expr.clear();             														
			}         
         }
         
         //sumRIs: represent the RI for the leadtime horizon
         IloLinearNumExpr sumRIs = cplex.linearNumExpr();			
           for (int t = 0; t < main.simParams.getMRPPlanningHorizon(); t++) {	    
                   	 for (int pp = 0; pp < itemsToPlan.size(); pp++) {        	 
           

           for (int p = 0; p < iQd.size(); p++) {
 				    if(iQd.get(p).getItem()== itemsToPlan.get(pp).getItem().getItem()){ 	
 				    	if(releaseTmp[p][t] > 0){ 				    			
			        	//RI[p] = cplex.boolVarArray(leadtimeHorizon, RiNames[p]);
				        sumRIs.addTerm(1.0,RI[p][releaseTmp[p][t]-1]);		        
				        }
		        }
	     	}
           }
           }                  
         
         //Constraint avoiding that RI with later due date, releases order earlier that RI with earlier due date (orders should not overteak each other)
         //The release of order 2 should not before order 1         
         //traceln("iQd size " + iQd.size());
         for (int p = 0; p < iQd.size(); p++) {          		
          			int i = 0;
        	 		
        	 		String[] RiSplitted = RI[p][i].getName().split("_");			                    
			        
			        int endDate = Integer.parseInt(RiSplitted[2]); //enddate (Xt)
			        int item = Integer.parseInt(RiSplitted[1]); //enddate (Xt)
					//check if another RIs with a later endDate (Xt) exists
					
        	         for (int p2 = 0; p2 < iQd.size(); p2++) {
	                   	int i2 = 0;
	                   	
							String[] RiSplittedSuccessor = RI[p2][i2].getName().split("_");			                    	                   			                   	
							
							int endDateSuccessor = Integer.parseInt(RiSplittedSuccessor[2]); //enddate (Xt)
					        int itemSuccessor = Integer.parseInt(RiSplittedSuccessor[1]); //enddate (Xt)
		                   		if(endDate < endDateSuccessor){ //don't iterate over the same RI
				                   	int RiendDateSuccessor = Integer.parseInt(RiSplittedSuccessor[2]); //enddate (Xt) RI successor
                   		                   		
				                   	int overlappingStart = (endDateSuccessor - leadtimeHorizon);

									IloLinearNumExpr lhs = cplex.linearNumExpr();				             	    
				                   	IloLinearNumExpr rhs = cplex.linearNumExpr();				                   					        

				                   	int overlappingPeriods = endDate - overlappingStart;
				                   	
				                   	int RIstartIndex = max(0,(leadtimeHorizon-overlappingPeriods));				                   		
				                   	
				                   	StringBuilder lhsOut = new StringBuilder();
				                   	StringBuilder rhsOut = new StringBuilder();
				                   	
				                   	for(int o = 0; o < overlappingPeriods; o++){

					                   	lhs.addTerm(1,RI[p][RIstartIndex + o]);
					                   	lhsOut.append(RI[p][RIstartIndex + o].getName() + "+");
					                   	
					                   	rhs.addTerm(1,RI[p2][o]);
					                   	rhsOut.append(RI[p2][o].getName() + "+");
					                 }
				                   	cplex.addGe(lhs,rhs);
				                 }   	         
        	         }
     	  }     
                            
         
         for (int t = 0; t < main.simParams.getMRPPlanningHorizon(); t++) {	    
	     	IloLinearNumExpr cf = cplex.linearNumExpr();				             	    
	     	IloLinearNumExpr cf1 = cplex.linearNumExpr();				             	    
	       	IloLinearNumExpr cf2 = cplex.linearNumExpr();				             	    
		   	IloLinearNumExpr cf3 = cplex.linearNumExpr();				             	    
	       	IloLinearNumExpr cf4 = cplex.linearNumExpr();				             	    

    	    
    	    //Pgt smaler Wgt - Constraint for single item qty
        	 for (int pp = 0; pp < itemsToPlan.size(); pp++) {        	  			

	         		cf.addTerm(itemsToPlan.get(pp).getItem().getRouting().getEProcessingTime(),P[pp][t]);	         		
	         		
	         		cf1.addTerm(itemsToPlan.get(pp).getItem().getRouting().getEProcessingTime(),P[pp][t]); 	         		        		
         			cf2.addTerm(itemsToPlan.get(pp).getItem().getRouting().getEProcessingTime(),W[pp][t]);         			         		
         			         			
         			cf3.addTerm(itemsToPlan.get(pp).getItem().getRouting().getEProcessingTime(),P[pp][t]);         		
         			cf4.addTerm(itemsToPlan.get(pp).getItem().getRouting().getEProcessingTime(),W[pp][t]);
         			         			         		         			
         			cplex.addLe(
         				cplex.sum(P[pp][t],cplex.prod(0,sumRIs)),//LHS         			
        				cplex.sum(W[pp][t],0));//RHS         			
        	  }
        	          	  

			  //CF Constraints
			           	  
			  //PL <= MC + Ct (Eq10)
			  //Partitation 3 numerical example
         	  cplex.addLe(cplex.sum(cf,cplex.prod(setupTime,sumRIs)), //LHS
         	  
         	  //cplex.sum(1440,C[t]));			
         	  cplex.sum(maxCapacity,C[t]));			
         	           	           	  
         	  // ---- we have three segments         	           	           	  
			  //CF partition 2 from numerical example
			  for(int i = 0; i < numberSegments; i++){
	         	  cplex.addLe(
    	     	  	cplex.sum(cf1,cplex.prod(setupTime,sumRIs)), //LHS
         	    
         	    //changed from 360 to 720 ... why is this wrong??? with 360
         	    //from the numerical example
         	  	//cplex.sum(cplex.sum(cplex.prod(0.5,
         	  		//cplex.sum(cf2,cplex.prod(setupTime,sumRIs))),360),C[t]));//RHS
         	  		
         	  	cplex.sum(cplex.sum(cplex.prod(slopes[i],
         	  	cplex.sum(cf2,cplex.prod(setupTime,sumRIs))),intercepts[i]),C[t]));//RHS         	  		         	  		
         	  		
         	  }//for
         	           	           	           	  
			  //PLt <= Lt + Ct (Eq14)
         	  //Constraint Pl musst be smaller as SL for all t
         	  //CF partition 1 (numerical example)        	  
         	  cplex.addLe(
         	  	cplex.sum(cf3,cplex.prod(setupTime,sumRIs)), //LHS         	  
	         	cplex.sum(cplex.sum(cf4,cplex.prod(setupTime,sumRIs)),C[t]));         	  
         	  
			  cf.clear();
			  cf1.clear();
 			  cf2.clear();
 			  cf3.clear();
 			  cf4.clear();
         }
                         
    if(time() == 0)                 
		cplex.exportModel("model/NewModel_" + time() + "_" + bomLevel + ".lp");
		//cplex.writeSolution("model/NewModel_" + time() + "_" + bomLevel + ".sol");
	
	cplex.setParam(IloCplex.BooleanParam.PreInd, true);
	cplex.setParam(IloCplex.Param.MIP.Tolerances.MIPGap, 0.05);
	//cplex.setParam(IloCplex.IntParam.DataCheck, 2);	
	cplex.setParam(IloCplex.IntParam.WorkMem, 2000);
	boolean writeOutput = true;					
	if(cplex.solve() && writeOutput){
		    
		    System.out.println("Solution status: " + cplex.getStatus());
            System.out.println();
            System.out.println("Objective Value = " + cplex.getObjValue());
          
            System.out.println();
            System.out.println("\tp\tTime\tt\tWip\tX\tRelease\tP\tPL\tL\tCF3\tCF2\tCF1\tInv\tIBl\tWB\tObjPP\tCt");
          
            for (int p = 0; p < itemsToPlan.size(); p++) {
               for (int t = 0; t < get_Main().simParams.getMRPPlanningHorizon(); t++) {
               
               double inventoryBalance = 0;
               double wipBalance = 0;

               if(t>0){
                  inventoryBalance = cplex.getValue(I[p][t-1])-X[p][t]+cplex.getValue(P[p][t-1]);
                  wipBalance = cplex.getValue(W[p][t-1])+cplex.getValue(R[p][t])-cplex.getValue(P[p][t-1]);
               
               }
               		
               	  double lt = cplex.getValue(W[p][t])*itemsToPlan.get(p).getItem().getRouting().getEProcessingTime();
               	  double pl = cplex.getValue(P[p][t])*itemsToPlan.get(p).getItem().getRouting().getEProcessingTime();
               	  double objectivePerPeriod = cplex.getValue(W[p][t]) * 0.5 + cplex.getValue(I[p][t]);
               	  
                  System.out.println("\t" + itemsToPlan.get(p).getItem().getItem() +
                                     "\t" + (time() + t) +
                                     "\t" + t +
                                     "\t" + (int)cplex.getValue(W[p][t]) +
                                     "\t" + X[p][t] +
                                     "\t" + (int)cplex.getValue(R[p][t]) +       
                                     //"\t" + (int)cplex.getValue(RI[p][t]) +                                                       
                                     "\t" + (int)cplex.getValue(P[p][t]) +
                                     "\t" + (int)pl +
                                     "\t" + (int)lt +
                                     "\t" + maxCapacity + 
                                     "\t" + (int)(0.5*lt+360) + 
                                     "\t" + (int)lt +
                                     "\t" + Math.round(cplex.getValue(I[p][t])) +
                                     "\t" + Math.round(inventoryBalance) +
                                     "\t" + (int)wipBalance +
                                     "\t" + (int)objectivePerPeriod +
                                     "\t" + Math.round(cplex.getValue(C[t]))                                
                                     );                                                                                                 
                                    
                    //OptimizationResult optResult = new OptimizationResult(time(),itemsToPlan.get(p).getItem().getItem(), t,
                    //cplex.getValue(W[p][t]), cplex.getValue(R[p][t]), 0,cplex.getValue(P[p][t]),
                    //cplex.getValue(I[p][t]) );
                    
                    //get_Main().optimizationResults.add(optResult);                 
                                     
               }
            }
                 	  
            
            //if(OptimizationResult.WRITE_OPTIMIZATION_RESULTS_TO_XLXS)
			//OptimizationResult.WriteXlsxOptimizationResults(get_Main().optimizationResults, get_Main().simParams);            
            	//traceln("size +++++++++++ " + get_Main().optimizationResults.size());
            
		}else{
			traceln("NO Solution " + cplex.getStatus());
		}												
        	
        	for (int p = 0; p < iQd.size(); p++) {        	        
               for (int t = 0; t < leadtimeHorizon; t++) {   
                           
					        double qty = cplex.getValue(RI[p][t]);    			            			            		            
					        
							if(qty > 0.9){
			                    ProductionOrder order = new ProductionOrder();
			                    								
								int itemIntTmp = iQd.get(p).getItem();
									
			                    Item item = get_Main().items.stream().filter(e -> e.getItem() == itemIntTmp).findFirst().get();																		                     
			                    
			                    order.setOrderId(get_Main().prodOrderId++);
			                    order.setItem(item);
			                                                                                                                                  
								order.setPlannedCapacity(Routing.GetPlannedCapacityPerItem(get_Main().routings, order.getItem(), get_Main().simParams, order));
			                    
			                    int minimumRoutingStep = Routing.GetMinimumStep(get_Main().routings, order.getItem() , get_Main().simParams);
								int maximumRoutingStep = Routing.GetMaximumStep(get_Main().routings, order.getItem() , get_Main().simParams);
						
								order.setMinimumRoutingStep(minimumRoutingStep);
								order.setMaximumRoutingStep(maximumRoutingStep);			
								order.setCurrentRoutingStep(minimumRoutingStep);                                        			                    
			                                                            
			                    order.setQuantity(Math.round(iQd.get(p).getQuantity()));
			                    order.setCreatedAt(time());			                    
			                    
			                    //get the start and end dates from the RI decision variables			                    
			                    String[] RiSplitted = RI[p][t].getName().split("_");
			                    
			                    order.setPlannedStart(Integer.parseInt(RiSplitted[5]) + time());
			                    
			                    order.setPlannedEnd(Integer.parseInt(RiSplitted[2]) + time());
			                    
			                    long exists = 0;	
			                    		                    
			                    if(order.getPlannedStart() < time())
			                    	exists = 1;
			                    											
			                    if(exists == 0){														                    
				                    Routing routingObject = get_Main().routings.stream().filter(e -> e.getItem().getItem() == order.getItem().getItem()).findFirst().get();			
									order.setRouting(routingObject);
									order.setStatus(ProductionOrder.PRODUCTION_ORDER_STATUS_UNPROCESSED);
				                    
				                    get_Main().productionOrders.add(order);	                    						
													                    
			                    }
		                    }
		                 }            
		            }
        
        
		traceln("Production Orders from Optmization Before Removing");
		traceln(ProductionOrder.GetCSVHeader());

        for (ProductionOrder order: get_Main().productionOrders) {
           // traceln(ProductionOrder.GetCSVString(order));
        }        
		
        //get_Main().productionOrders.removeIf(e -> e.getPlannedStart() > time());
/*
        traceln("Production Orders from Optmization FOR SIMULATION");
        traceln(ProductionOrder.GetCSVHeader());

        for (ProductionOrder order: get_Main().productionOrders) {
            traceln(ProductionOrder.GetCSVString(order));
        }        
        traceln("**************************");                							
*/		
		//get_Main().Function_OrderRelease();
		cplex.end();		
	}
	catch (IloException exc) {
         System.err.println("Concert exception '" + exc.getMessage() + "' caught");
         System.exit(-1);
    }

return 0;
]]></Body>
				</Function>
				<Function AccessType="default" StaticFunction="false">
					<ReturnModificator>RETURNS_VALUE</ReturnModificator>
					<ReturnType><![CDATA[int]]></ReturnType>
					<Id>1686894652411</Id>
					<Name><![CDATA[Function_ClearingFunction_No_Backlog]]></Name>
					<X>50</X><Y>50</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Parameter>
						<Name><![CDATA[itemsToPlan]]></Name>
						<Type><![CDATA[List<MRP>]]></Type>
					</Parameter>
					<Parameter>
						<Name><![CDATA[bomLevel]]></Name>
						<Type><![CDATA[int]]></Type>
					</Parameter>
					<Parameter>
						<Name><![CDATA[inResource]]></Name>
						<Type><![CDATA[Resource]]></Type>
					</Parameter>
					<Body><![CDATA[try{

Tools to = new Tools();
							
traceln("----------- Start CF OPTIMIZATION at " + time () + " ----------------");
							
StringBuilder output = new StringBuilder();

int maxCapacity = 0;
double wipCosts = 0;
double inventoryHoldingCosts = 0;
traceln("Total found Segments: " + ClearingFunctionSegments.size());

//via the bom level the cf is associated
List<ClearingFunctionSegments> selectedSegments = new ArrayList();
	
	Item firstBomItem = itemsToPlan.get(0).getItem();
	wipCosts = firstBomItem.getHoldingCostsWIP();
	inventoryHoldingCosts = firstBomItem.getHoldingCosts();	
	
	//Routing firstRoutingItem = main.routings.stream().filter(e -> e.getItem().getItem() == firstBomItem.getItem()).findFirst().get();	
	//Resource firstResource= main.resources.stream().filter(e -> e.getName().equalsIgnoreCase(firstRoutingItem.getResource())).findFirst().get();
	
	maxCapacity = inResource.getCapacity();
	//don't map it to the prodction stage 1-4, select the values based on the resource
	if(firstBomItem.getLotsizePolicy().equalsIgnoreCase(Item.LOT_POLICY_FOP)) {
		int fop = firstBomItem.getFOPPeriod();	
		traceln("FOP Period:" + fop);	
					
		selectedSegments = ClearingFunctionSegments.stream().filter(e -> e.getLotParameter() == fop &&
							 e.getLotPolicy().equalsIgnoreCase(Item.LOT_POLICY_FOP) && e.getResource().equalsIgnoreCase(inResource.getName()) 
				 && e.getExperiment().equalsIgnoreCase(main.simParams.getExperiment())).collect(Collectors.toList());															 																								
	}
	else if(firstBomItem.getLotsizePolicy().equalsIgnoreCase(Item.LOT_POLICY_FOQ)) {
		int foq = (int)firstBomItem.getFOQQuantity();	
		traceln("FOQ Qty:" + foq);	
					
		selectedSegments = ClearingFunctionSegments.stream().filter(e -> e.getLotParameter() == foq &&
							 e.getLotPolicy().equalsIgnoreCase(Item.LOT_POLICY_FOQ) && e.getResource().equalsIgnoreCase(inResource.getName()) 
				 && e.getExperiment().equalsIgnoreCase(main.simParams.getExperiment())).collect(Collectors.toList());															 																								
	}
	
			
	traceln("Resource: " + inResource.getName());
	traceln("Resource Stage Number: " + inResource.getStageNumber());
	traceln("Production Stage: " + (bomLevel + 1));
	traceln("Max Capacity: " + maxCapacity);
	traceln("Items to Plan: ");
	itemsToPlan.forEach(e -> traceln(e.getItem().getItem() + ";"));
	traceln("Selected Slopes: ");		
	selectedSegments.forEach(e -> traceln(e.getSlope() + ";"));
	traceln("Selected Intercepts: ");
	selectedSegments.forEach(e -> traceln(e.getyIntercept() + ";"));
	
	if(selectedSegments.size() == 0){
		traceln("STOP Simulation: No Segments found!");
		System.exit(0);
	}
	
	to.log("Segment Cnt: " + selectedSegments.size(), Tools.LogCFOptimization);
	
	double intercepts[] = new double[selectedSegments.size()];
	double slopes[] = new double[selectedSegments.size()];
	
	for(int i = 0; i < selectedSegments.size(); i++) {
		slopes[i] = selectedSegments.get(i).getSlope();
		intercepts[i] = selectedSegments.get(i).getyIntercept();
	}		
			
int numberSegments = selectedSegments.size();

double oCosts = 0;
double oFactor = 1000;
double setupTime = 0;
int leadtimeHorizon = main.simParams.getLeadTimeHorizon();


traceln("Leadtime Horizon: " + leadtimeHorizon);

IloCplex cplex = new IloCplex();

     String[][] Inames = new String[itemsToPlan.size()][get_Main().simParams.getMRPPlanningHorizon()];
     String[][] Pnames = new String[itemsToPlan.size()][get_Main().simParams.getMRPPlanningHorizon()];
     String[][] Wnames = new String[itemsToPlan.size()][get_Main().simParams.getMRPPlanningHorizon()];
     String[][] Rnames = new String[itemsToPlan.size()][get_Main().simParams.getMRPPlanningHorizon()];     
     
     for(int i = 0; i< get_Main().simParams.getMRPPlanningHorizon(); i++){
          for (int p = 0; p < itemsToPlan.size(); p++) {
        	 	Inames[p][i] = "I" + itemsToPlan.get(p).getItem().getItem() + "_" + i; 
        	 	Pnames[p][i] = "P" + itemsToPlan.get(p).getItem().getItem() + "_" + i; 
        	 	Wnames[p][i] = "W" + itemsToPlan.get(p).getItem().getItem() + "_" + i; 
        	 	Rnames[p][i] = "R" + itemsToPlan.get(p).getItem().getItem() + "_" + i; 
	     }
     }

     IloNumVar[] C = new IloNumVar[main.simParams.getMRPPlanningHorizon()];
     for (int t = 0; t < get_Main().simParams.getMRPPlanningHorizon(); t++) {
        C[t] = cplex.numVar(0, Double.MAX_VALUE, "C" + "_" + t);
     }
     
     IloNumVar[][] I = new IloNumVar[itemsToPlan.size()][];
     for (int p = 0; p < itemsToPlan.size(); p++) {
        I[p] = cplex.numVarArray(get_Main().simParams.getMRPPlanningHorizon(), 0, Double.MAX_VALUE, Inames[p]);
        oCosts += itemsToPlan.get(p).getItem().getHoldingCosts();
     }
     
     oCosts = oFactor*oCosts;
     
     IloNumVar[][] P = new IloNumVar[itemsToPlan.size()][];
     for (int p = 0; p < itemsToPlan.size(); p++) {
        P[p] = cplex.numVarArray(get_Main().simParams.getMRPPlanningHorizon(), 0,  Double.MAX_VALUE, Pnames[p]);
     }
               
     IloNumVar[][] W = new IloNumVar[itemsToPlan.size()][];
     for (int p = 0; p < itemsToPlan.size(); p++) {
        W[p] = cplex.numVarArray(get_Main().simParams.getMRPPlanningHorizon(), 0, Double.MAX_VALUE, Wnames[p]);
     }
		
	 IloNumVar[][] R = new IloNumVar[itemsToPlan.size()][];
     for (int p = 0; p < itemsToPlan.size(); p++) {
        R[p] = cplex.numVarArray(get_Main().simParams.getMRPPlanningHorizon(), 0.0, Double.MAX_VALUE, Rnames[p]);
     }
               	
	double[] inventory = new double[itemsToPlan.size()];
	double[] wip = new double[itemsToPlan.size()];
	double[] produce = new double[itemsToPlan.size()];
	double[] tl = new double[itemsToPlan.size()];
		
	int[][] X = new int[itemsToPlan.size()][get_Main().simParams.getMRPPlanningHorizon()];

	List<SpecialObject> iQd = new ArrayList<SpecialObject>();
	
     for (int p = 0; p < itemsToPlan.size(); p++) {      	     

     		   inventory[p] = 0;
     		   
     		   wip[p] = (int)ProductionOrder.GetCurrentWip(get_Main().productionOrders, itemsToPlan.get(p).getItem(), get_Main().simParams);
     		   produce[p] = 0;
     		   
     		   tl[p] = itemsToPlan.get(p).getItem().getTransportLotSize();
			   				    			
     	       for (int t = 0; t < get_Main().simParams.getMRPPlanningHorizon(); t++) {               	                          	               	
	               	
	               	int tmp_item = itemsToPlan.get(p).getItem().getItem();
	               	int temp_t = t;
	               	
	               	MRP mrpItem = get_Main().mrpTable.stream().filter(e -> e.getItem().getItem() == tmp_item
	               	 && e.getTime() == time() && e.getPeriod() == temp_t).findFirst().orElseGet(() -> new MRP());
	
					if(itemsToPlan.get(p).getItem().getType().equalsIgnoreCase(Item.ITEM_TYPE_SALES)){ 
	        			X[p][t] = (int) mrpItem.getPlannedOrderReceipts();
	        			
	        		}else{
						X[p][t] = (int) mrpItem.getPlannedOrderReceipts();					
	        		}
	        		
	        		if(X[p][t] > 0) {
	        			SpecialObject so = new SpecialObject(
	        				mrpItem.getItem().getItem(),
	        				X[p][t], 
	        				t);
	        			iQd.add(so);
	        		}        		  	        		        		
            }     	      	
     }
          
     String[][] RiNames = new String[iQd.size()][leadtimeHorizon];
     int[][] releaseTmp = new int[iQd.size()][main.simParams.getMRPPlanningHorizon()];
     String[] releaseForX = new String[iQd.size()];
          
     for (int p = 0; p < iQd.size(); p++) {
          for(int i = 0; i < leadtimeHorizon; i++){
          		int targetT = (int)(iQd.get(p).getDueDate() - leadtimeHorizon + i);          		
          		
          		if(targetT < 0)
          			targetT = 0;
          		          		
          		releaseTmp[p][targetT] = i+1;          		
        	 	RiNames[p][i] = "RI_" +  iQd.get(p).getItem() + "_" + (int)iQd.get(p).getDueDate() + 
        	 	
        	 	"_" + iQd.get(p).getQuantity() + "_" + targetT + "R" + iQd.get(p).getItem() + "_" + targetT; 
	     }    
     }
            
     IloNumVar[][] RI = new IloNumVar[iQd.size()][];
     for (int p = 0; p < iQd.size(); p++) {
        RI[p] = cplex.boolVarArray(leadtimeHorizon, RiNames[p]);
     }
          
     	//Objective Function     
		IloLinearNumExpr objFunction  = cplex.linearNumExpr();
	         
        for (int p = 0; p < itemsToPlan.size(); p++) {
           for (int t = 0; t < get_Main().simParams.getMRPPlanningHorizon(); t++) {
              objFunction.addTerm (itemsToPlan.get(p).getItem().getHoldingCosts(), I[p][t]);
            }
         }

        for (int p = 0; p < itemsToPlan.size(); p++) {
           for (int t = 0; t < get_Main().simParams.getMRPPlanningHorizon(); t++) {
             objFunction.addTerm (itemsToPlan.get(p).getItem().getHoldingCostsWIP(), W[p][t]);
            }                     	            
         } 
         
         for (int t = 0; t < get_Main().simParams.getMRPPlanningHorizon(); t++) {
             objFunction.addTerm (oCosts, C[t]);
         }                     	                              
                                      
         cplex.addMinimize(objFunction);
       
         for (int p = 0; p < itemsToPlan.size(); p++) {
           		
         	cplex.addEq(I[p][0],0);
         
            for (int t = 1; t < get_Main().simParams.getMRPPlanningHorizon(); t++) {
	           	cplex.addEq(cplex.sum(I[p][t], X[p][t]), 
                       cplex.sum(I[p][t-1], P[p][t-1]));
        	}
            
              
            cplex.addEq(W[p][0], R[p][0]);
            
            for (int t = 1; t < get_Main().simParams.getMRPPlanningHorizon(); t++) {
               cplex.addEq(cplex.sum(W[p][t], P[p][t-1]), 
                           cplex.sum(W[p][t-1], R[p][t]));   
                                                                                                                                    
            }			             											
         }
         
                  
          for (int p = 0; p < iQd.size(); p++) {
            IloLinearNumExpr num_expr_Sum_Binaries = cplex.linearNumExpr();            
	            for (int t = 0; t < leadtimeHorizon; t++) {
					num_expr_Sum_Binaries.addTerm(1,RI[p][t]);															
	            }
	            cplex.addEq(num_expr_Sum_Binaries,1);
            }
         
         
         //RI structure
         //RI_item_Xt_qty_start_lth_...end_lth_Ritem_start_lth...end_lth
         for (int pp = 0; pp < itemsToPlan.size(); pp++) {
         	IloLinearNumExpr cf = cplex.linearNumExpr();				         
	       for (int t = 0; t < main.simParams.getMRPPlanningHorizon(); t++) {	            	            
			       	String o = "";
			       	int sizeExpr = 0;
			        IloLinearNumExpr num_expr = cplex.linearNumExpr();
			                    
	                for (int p = 0; p < iQd.size(); p++) {
	                	if(iQd.get(p).getItem()== itemsToPlan.get(pp).getItem().getItem()){
		            		if(releaseTmp[p][t] > 0){
		            			o = o + iQd.get(p).getQuantity() + "*" + RI[p][releaseTmp[p][t]-1].getName() +  "+";	            			
		            			num_expr.addTerm(iQd.get(p).getQuantity(),RI[p][releaseTmp[p][t]-1]);		            			
		            					            			
		            			sizeExpr++;		            					            					            			
		            		}			        
	            		}
					}
					
				if(o.length() > 1){
		            if(sizeExpr > 0){
		            	//Constraint Release Size 
			            cplex.addEq(R[pp][t],num_expr);    
			                  
			        }

				}else{
				         cplex.addEq(R[pp][t],0);          								
				}
																
				num_expr.clear();             														
			}         
         }
         
         //sumRIs: represent the RI for the leadtime horizon
         IloLinearNumExpr sumRIs = cplex.linearNumExpr();			
           for (int t = 0; t < main.simParams.getMRPPlanningHorizon(); t++) {	    
                   	 for (int pp = 0; pp < itemsToPlan.size(); pp++) {        	 
           

           for (int p = 0; p < iQd.size(); p++) {
 				    if(iQd.get(p).getItem()== itemsToPlan.get(pp).getItem().getItem()){ 	
 				    	if(releaseTmp[p][t] > 0){ 				    			
			        	//RI[p] = cplex.boolVarArray(leadtimeHorizon, RiNames[p]);
				        sumRIs.addTerm(1.0,RI[p][releaseTmp[p][t]-1]);		        
				        }
		        }
	     	}
           }
           }                  
         
         //Constraint avoiding that RI with later due date, releases order earlier that RI with earlier due date (orders should not overteak each other)
         //The release of order 2 should not before order 1         
         //traceln("iQd size " + iQd.size());
         for (int p = 0; p < iQd.size(); p++) {          		
          			int i = 0;
        	 		
        	 		String[] RiSplitted = RI[p][i].getName().split("_");			                    
			        
			        int endDate = Integer.parseInt(RiSplitted[2]); //enddate (Xt)
			        int item = Integer.parseInt(RiSplitted[1]); //enddate (Xt)
					//check if another RIs with a later endDate (Xt) exists
					
        	         for (int p2 = 0; p2 < iQd.size(); p2++) {
	                   	int i2 = 0;
	                   	
							String[] RiSplittedSuccessor = RI[p2][i2].getName().split("_");			                    	                   			                   	
							
							int endDateSuccessor = Integer.parseInt(RiSplittedSuccessor[2]); //enddate (Xt)
					        int itemSuccessor = Integer.parseInt(RiSplittedSuccessor[1]); //enddate (Xt)
		                   		if(endDate < endDateSuccessor){ //don't iterate over the same RI
				                   	int RiendDateSuccessor = Integer.parseInt(RiSplittedSuccessor[2]); //enddate (Xt) RI successor
                   		                   		
				                   	int overlappingStart = (endDateSuccessor - leadtimeHorizon);

									IloLinearNumExpr lhs = cplex.linearNumExpr();				             	    
				                   	IloLinearNumExpr rhs = cplex.linearNumExpr();				                   					        

				                   	int overlappingPeriods = endDate - overlappingStart;
				                   	
				                   	int RIstartIndex = max(0,(leadtimeHorizon-overlappingPeriods));				                   		
				                   	
				                   	StringBuilder lhsOut = new StringBuilder();
				                   	StringBuilder rhsOut = new StringBuilder();
				                   	
				                   	for(int o = 0; o < overlappingPeriods; o++){

					                   	lhs.addTerm(1,RI[p][RIstartIndex + o]);
					                   	lhsOut.append(RI[p][RIstartIndex + o].getName() + "+");
					                   	
					                   	rhs.addTerm(1,RI[p2][o]);
					                   	rhsOut.append(RI[p2][o].getName() + "+");
					                 }
				                   	cplex.addGe(lhs,rhs);
				                 }   	         
        	         }
     	  }     
                            
         
         for (int t = 0; t < main.simParams.getMRPPlanningHorizon(); t++) {	    
	     	IloLinearNumExpr cf = cplex.linearNumExpr();				             	    
	     	IloLinearNumExpr cf1 = cplex.linearNumExpr();				             	    
	       	IloLinearNumExpr cf2 = cplex.linearNumExpr();				             	    
		   	IloLinearNumExpr cf3 = cplex.linearNumExpr();				             	    
	       	IloLinearNumExpr cf4 = cplex.linearNumExpr();				             	    

    	    
    	    //Pgt smaller Wgt - Constraint for single item qty
        	 for (int pp = 0; pp < itemsToPlan.size(); pp++) {        	  			

	         		cf.addTerm(itemsToPlan.get(pp).getItem().getRouting().getEProcessingTime(),P[pp][t]);	         		
	         		
	         		cf1.addTerm(itemsToPlan.get(pp).getItem().getRouting().getEProcessingTime(),P[pp][t]); 	         		        		
         			cf2.addTerm(itemsToPlan.get(pp).getItem().getRouting().getEProcessingTime(),W[pp][t]);         			         		
         			         			
         			cf3.addTerm(itemsToPlan.get(pp).getItem().getRouting().getEProcessingTime(),P[pp][t]);         		
         			cf4.addTerm(itemsToPlan.get(pp).getItem().getRouting().getEProcessingTime(),W[pp][t]);
         			         			         		         			
         			cplex.addLe(
         				cplex.sum(P[pp][t],cplex.prod(0,sumRIs)),//LHS         			
        				cplex.sum(W[pp][t],0));//RHS         			
        	  }
        	          	  

			  //CF Constraints
			           	  
			  //PL <= MC + Ct (Eq10)
			  //Partitation 3 numerical example
         	  cplex.addLe(cplex.sum(cf,cplex.prod(setupTime,sumRIs)), //LHS
         	  
         	  //cplex.sum(1440,C[t]));			
         	  cplex.sum(maxCapacity,C[t]));			
         	           	           	  
         	  // ---- we have three segments         	           	           	  
			  //CF partition 2 from numerical example
			  for(int i = 0; i < numberSegments; i++){
	         	  cplex.addLe(
    	     	  	cplex.sum(cf1,cplex.prod(setupTime,sumRIs)), //LHS
         	    
         	    //changed from 360 to 720 ... why is this wrong??? with 360
         	    //from the numerical example
         	  	//cplex.sum(cplex.sum(cplex.prod(0.5,
         	  	//cplex.sum(cf2,cplex.prod(setupTime,sumRIs))),360),C[t]));//RHS
         	  		
         	  	cplex.sum(cplex.sum(cplex.prod(max(slopes[i],0),
         	  	cplex.sum(cf2,cplex.prod(setupTime,sumRIs))),intercepts[i]),C[t]));//RHS         	  		         	  		
         	  		
         	  }//for
         	           	           	           	  
			  //PLt <= Lt + Ct (Eq14)
         	  //Constraint Pl musst be smaller as SL for all t
         	  //CF partition 1 (numerical example)        	  
         	  cplex.addLe(
         	  	cplex.sum(cf3,cplex.prod(setupTime,sumRIs)), //LHS         	  
	         	cplex.sum(cplex.sum(cf4,cplex.prod(setupTime,sumRIs)),C[t]));         	  
         	  
			  cf.clear();
			  cf1.clear();
 			  cf2.clear();
 			  cf3.clear();
 			  cf4.clear();
         }
                         
    //if(time() == 0)
    if(Tools.Log_CF_Optimization_Values){                 
		cplex.exportModel("model/NewModel_" + time() + "_" + bomLevel + ".lp");
	}	
	//cplex.writeSolution("model/NewModel_" + time() + "_" + bomLevel + ".sol");

	cplex.setParam(IloCplex.BooleanParam.PreInd, true);
	//0.05 were to hard 
	cplex.setParam(IloCplex.Param.MIP.Tolerances.MIPGap, 0.1);
	//cplex.setParam(IloCplex.IntParam.DataCheck, 2);	
	cplex.setParam(IloCplex.IntParam.WorkMem, 2000);
						
	if(cplex.solve() && Tools.Log_CF_Optimization_Values){
		    
		    System.out.println("Solution status: " + cplex.getStatus());
            System.out.println();
            System.out.println("Objective Value = " + cplex.getObjValue());
          
            System.out.println("Pieces: Wip, X, Release, P");
            System.out.println("Minutes: PL L, MC, CF1, CF2, CF3");
            System.out.println("\tp\tTime\tt\tWip\tX\tRelease\tP\tPL\tL\tMC\tCF1\tCF2\tCF3\tInv\tIBl\tWB\tObjPP\tCt");
          	
            int[] t_sum_wip = new int[get_Main().simParams.getMRPPlanningHorizon()];
            int[] t_sum_pl = new int[get_Main().simParams.getMRPPlanningHorizon()];
            int[] t_sum_load = new int[get_Main().simParams.getMRPPlanningHorizon()];
          	
            for (int p = 0; p < itemsToPlan.size(); p++) {
                        	
               for (int t = 0; t < get_Main().simParams.getMRPPlanningHorizon(); t++) {
               
               double inventoryBalance = 0;
               double wipBalance = 0;

               if(t>0){
                  inventoryBalance = cplex.getValue(I[p][t-1])-X[p][t]+cplex.getValue(P[p][t-1]);
                  wipBalance = cplex.getValue(W[p][t-1])+cplex.getValue(R[p][t])-cplex.getValue(P[p][t-1]);               
               }
               		
               	  double lt = cplex.getValue(W[p][t])*itemsToPlan.get(p).getItem().getRouting().getEProcessingTime();
               	  double pl = cplex.getValue(P[p][t])*itemsToPlan.get(p).getItem().getRouting().getEProcessingTime();
               	  double objectivePerPeriod = cplex.getValue(W[p][t]) * wipCosts + cplex.getValue(I[p][t]) * inventoryHoldingCosts;
               	  
               	  int wipForPrintLn = (int)cplex.getValue(W[p][t]);
               	  
                  System.out.println("\t" + itemsToPlan.get(p).getItem().getItem() +
                                     "\t" + (time() + t) +
                                     "\t" + t +
                                     //"\t" + (int)cplex.getValue(W[p][t]) +
                                     "\t" + wipForPrintLn +
                                     "\t" + X[p][t] +
                                     "\t" + (int)cplex.getValue(R[p][t]) +       
                                     //"\t" + (int)cplex.getValue(RI[p][t]) +                                                       
                                     "\t" + (int)cplex.getValue(P[p][t]) +
                                     "\t" + (int)pl +
                                     "\t" + (int)lt +
                                     "\t" + maxCapacity + 
                                     "\t" + (int)(slopes[0]*lt+intercepts[0]) + 
                                     "\t" + (int)(slopes[1]*lt+intercepts[1]) + 
                                     "\t" + (int)(slopes[2]*lt+intercepts[2]) +                                      
                                     "\t" + Math.round(cplex.getValue(I[p][t])) +
                                     "\t" + Math.round(inventoryBalance) +
                                     "\t" + (int)wipBalance +
                                     "\t" + (int)objectivePerPeriod +
                                     "\t" + Math.round(cplex.getValue(C[t]))                                
                                     );                                                                                                 
            
            		t_sum_wip[t] += wipForPrintLn;
            		t_sum_pl[t] += pl;
            		t_sum_load[t] += lt;
                                    
                    //OptimizationResult optResult = new OptimizationResult(time(),itemsToPlan.get(p).getItem().getItem(), t,
                    //cplex.getValue(W[p][t]), cplex.getValue(R[p][t]), 0,cplex.getValue(P[p][t]),
                    //cplex.getValue(I[p][t]) );
                    
                    //get_Main().optimizationResults.add(optResult);                                                      
               }                              
            }
            
            System.out.println("\n");
            System.out.println("\tTime\tt\tWip\tPL\tL");           
            for(int t = 0; t < get_Main().simParams.getMRPPlanningHorizon(); t++) {
            
            	System.out.println(
            		"\t" + (time() + t) +
       				"\t" + t +            		
            		"\t" + t_sum_wip[t] +
	           		"\t" + t_sum_pl[t] +
            		"\t" + t_sum_load[t]            	
            	);            
            }
                 	  
            
            //if(OptimizationResult.WRITE_OPTIMIZATION_RESULTS_TO_XLXS)
			//OptimizationResult.WriteXlsxOptimizationResults(get_Main().optimizationResults, get_Main().simParams);            
            	//traceln("size +++++++++++ " + get_Main().optimizationResults.size());
            
		}else{
			traceln("NO Solution " + cplex.getStatus());
		}												
        	
        	for (int p = 0; p < iQd.size(); p++) {        	        
               for (int t = 0; t < leadtimeHorizon; t++) {   
                           
					        double qty = cplex.getValue(RI[p][t]);    			            			            		            
					        
							if(qty > 0.9){
			                    ProductionOrder order = new ProductionOrder();
			                    								
								int itemIntTmp = iQd.get(p).getItem();
									
			                    Item item = get_Main().items.stream().filter(e -> e.getItem() == itemIntTmp).findFirst().get();																		                     
			                    
			                    order.setOrderId(get_Main().prodOrderId++);
			                    order.setItem(item);
			                                                                                                                                  
								order.setPlannedCapacity(Routing.GetPlannedCapacityPerItem(get_Main().routings, order.getItem(), get_Main().simParams, order));
			                    
			                    int minimumRoutingStep = Routing.GetMinimumStep(get_Main().routings, order.getItem() , get_Main().simParams);
								int maximumRoutingStep = Routing.GetMaximumStep(get_Main().routings, order.getItem() , get_Main().simParams);
						
								order.setMinimumRoutingStep(minimumRoutingStep);
								order.setMaximumRoutingStep(maximumRoutingStep);			
								order.setCurrentRoutingStep(minimumRoutingStep);                                        			                    
			                                                            
			                    order.setQuantity(Math.round(iQd.get(p).getQuantity()));
			                    order.setCreatedAt(time());			                    
			                    
			                    //get the start and end dates from the RI decision variables			                    
			                    String[] RiSplitted = RI[p][t].getName().split("_");
			                    
			                    order.setPlannedStart(max(Integer.parseInt(RiSplitted[5]) + time() - item.getSafetyLeadTime(), time()));
			                    order.setPlannedEnd(Integer.parseInt(RiSplitted[2]) + time());
			                    
			                    long exists = 0;	
			                    		                    
			                    if(order.getPlannedStart() < time())
			                    	exists = 1;
			                    											
			                    if(exists == 0){														                    
				                    Routing routingObject = get_Main().routings.stream().filter(e -> e.getItem().getItem() == order.getItem().getItem()).findFirst().get();			
									order.setRouting(routingObject);
									order.setStatus(ProductionOrder.PRODUCTION_ORDER_STATUS_UNPROCESSED);
				                    
				                    get_Main().productionOrders.add(order);	                    						
													                    
			                    }
		                    }
		                 }            
		            }
                        
        if(false) {
			traceln("Production Orders from Optmization Before Removing");
			traceln(ProductionOrder.GetCSVHeader());
			
	        for (ProductionOrder order: get_Main().productionOrders) {
	           traceln(ProductionOrder.GetCSVString(order));
	        }        
			
	        //get_Main().productionOrders.removeIf(e -> e.getPlannedStart() > time());
	
	        traceln("Production Orders from Optmization FOR SIMULATION");
	        traceln(ProductionOrder.GetCSVHeader());
	
	        for (ProductionOrder order: get_Main().productionOrders) {
	            traceln(ProductionOrder.GetCSVString(order));
	        }        
	        traceln("**************************");                							
        }
		
		//get_Main().Function_OrderRelease();
		cplex.end();		
	}
	catch (IloException exc) {
         System.err.println("Concert exception '" + exc.getMessage() + "' caught");
         System.exit(-1);
    }

return 0;
]]></Body>
				</Function>
				<Function AccessType="default" StaticFunction="false">
					<ReturnModificator>RETURNS_VALUE</ReturnModificator>
					<ReturnType><![CDATA[int]]></ReturnType>
					<Id>1689568582064</Id>
					<Name><![CDATA[remainingProductionOrderQty]]></Name>
					<X>50</X><Y>410</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Parameter>
						<Name><![CDATA[item]]></Name>
						<Type><![CDATA[int]]></Type>
					</Parameter>
					<Parameter>
						<Name><![CDATA[plannedEnd]]></Name>
						<Type><![CDATA[double]]></Type>
					</Parameter>
					<Body><![CDATA[int runningOrdersQty = 0;

RoutingTimes empty = new RoutingTimes();
empty.setEnd(-99);
empty.setId(0);

for(ProductionOrder o : main.productionOrders.stream().filter(e -> e.getStatus() == ProductionOrder.PRODUCTION_ORDER_STATUS_PROCESSING 
&& e.getItem().getItem() == item && e.getPlannedEnd() == plannedEnd).collect(Collectors.toList())) {             
	
	double realizedSetupTime = (o.getTotalProcessingTime() - o.getNetProcessingTime()) / 1440;        	
    double eSetupTime = o.getItem().getRouting().getESetupTime() / 1440;   
		
    //*************************************************************
	//we have to check, if a gap between two routing times exists			
	RoutingTimes rtRunning = main.RoutingTimesList.stream().filter(e -> e.getProductionOrder().getOrderId() == o.getOrderId() && e.getStatus() == RoutingTimes.ROUTING_TIME_PROCESSING).findFirst().orElse(empty);
		
	//traceln("Found Running Routing Time: " + rtRunning.getId() + " Start " + rtRunning.getStart() + " Ende " + rtRunning.getEnd() + " STatus " + rtRunning.getStatus());				
	traceln("Running Production Order Id: " + o.getOrderId() + " planned Start " + o.getPlannedStart() + " planned end " + o.getPlannedEnd() + " qty " + o.getQuantity());
	double capaStartEndDiff = 0;
	if(rtRunning.getId() > 0) {
		traceln("Found Running Routing Time: " + rtRunning.getId() + " Start " + rtRunning.getStart() + " Ende " + rtRunning.getEnd() + " Status " + rtRunning.getStatus());				
		
		//now we select the finihsed with the highest id
		RoutingTimes rtMaxFinished = main.RoutingTimesList.stream().filter(e -> e.getProductionOrder().getOrderId() == o.getOrderId() && e.getStatus() == RoutingTimes.ROUTING_TIME_FINISHED).max(Comparator.comparing(RoutingTimes::getId)).orElse(empty);

		if(rtMaxFinished.getId() > 0) {
			//traceln("Found Running Routing Time: " + rtMaxFinished.getId() + " Start " + rtMaxFinished.getStart() + " Ende " + rtMaxFinished.getEnd() + " STatus " + rtMaxFinished.getStatus());																	
			capaStartEndDiff = rtRunning.getStart() - rtMaxFinished.getEnd();
		}								
	}
    //*************************************************************     	
	
	double remainingCapacity = ((o.getPlannedCapacity()/1440) - eSetupTime + realizedSetupTime) - (time() - o.getActualStart() - capaStartEndDiff); 			        	
	traceln("(("+o.getPlannedCapacity()+ "+/1440) - "+eSetupTime+" + "+realizedSetupTime+") - ("+time()+" -"+ o.getActualStart() + " - " + capaStartEndDiff + ")"); 			        	
	traceln("(("+o.getTotalProcessingTime()+ "+/1440) - "+eSetupTime+" + "+realizedSetupTime+") - ("+time()+" -"+ o.getActualStart() + " - " + capaStartEndDiff + ")"); 			        	
	traceln(remainingCapacity + "/(" + o.getItem().getRouting().getEProcessingTime() + "/1440)");
	traceln("original qty: " + o.getQuantity());
	
	double remainingQty = (remainingCapacity / (o.getItem().getRouting().getEProcessingTime()/1440));
	traceln("remaining qty: " + remainingQty);
	
	runningOrdersQty += (remainingQty);			
}

//traceln("#################### in remaining " + runningOrdersQty);

return runningOrdersQty;]]></Body>
				</Function>
				<Function AccessType="default" StaticFunction="false">
					<ReturnModificator>RETURNS_VALUE</ReturnModificator>
					<ReturnType><![CDATA[int]]></ReturnType>
					<Id>1692788548148</Id>
					<Name><![CDATA[Function_ClearingFunction_Without_LateOrders]]></Name>
					<X>50</X><Y>80</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Parameter>
						<Name><![CDATA[itemsToPlan]]></Name>
						<Type><![CDATA[List<MRP>]]></Type>
					</Parameter>
					<Parameter>
						<Name><![CDATA[bomLevel]]></Name>
						<Type><![CDATA[int]]></Type>
					</Parameter>
					<Parameter>
						<Name><![CDATA[inResource]]></Name>
						<Type><![CDATA[Resource]]></Type>
					</Parameter>
					<Parameter>
						<Name><![CDATA[fileSuffix]]></Name>
						<Type><![CDATA[String]]></Type>
					</Parameter>
					<Body><![CDATA[try{

Tools to = new Tools();
							
traceln("----------- Start CF OPTIMIZATION at " + time () + " ----------------");
							
StringBuilder output = new StringBuilder();

int maxCapacity = 1440;
double wipCosts = 0;
double inventoryHoldingCosts = 0;
traceln("Total found Segments: " + ClearingFunctionSegments.size());


/*
Iterator<MRP> iterator = itemsToPlan.iterator();
while (iterator.hasNext()) {
    MRP o = iterator.next();
    if (o.getItem().getItem() == 103 ||     
    o.getItem().getItem() == 111 ||
    o.getItem().getItem() == 115 ||
    o.getItem().getItem() == 119 ||
    o.getItem().getItem() == 123 ||
    o.getItem().getItem() == 127 ||
    o.getItem().getItem() == 131
    ) {
        iterator.remove(); // Safely remove the element from the list
    }
}
*/

//via the bom level the cf is associated
List<ClearingFunctionSegments> selectedSegments = new ArrayList();
	
	Item firstBomItem = itemsToPlan.get(0).getItem();
	wipCosts = firstBomItem.getHoldingCostsWIP();
	inventoryHoldingCosts = firstBomItem.getHoldingCosts();	
	
	//Routing firstRoutingItem = main.routings.stream().filter(e -> e.getItem().getItem() == firstBomItem.getItem()).findFirst().get();	
	//Resource firstResource= main.resources.stream().filter(e -> e.getName().equalsIgnoreCase(firstRoutingItem.getResource())).findFirst().get();
	
	//maxCapacity = inResource.getCapacity();
	//don't map it to the prodction stage 1-4, select the values based on the resource
	traceln("Total found segments: " + selectedSegments);
	
	if(firstBomItem.getLotsizePolicy().equalsIgnoreCase(Item.LOT_POLICY_FOP)) {
		int fop = firstBomItem.getFOPPeriod();	
		traceln("FOP Period:" + fop);	
					
		selectedSegments = ClearingFunctionSegments.stream().filter(e -> e.getLotParameter() == fop &&
							 e.getLotPolicy().equalsIgnoreCase(Item.LOT_POLICY_FOP) && e.getResource().equalsIgnoreCase(inResource.getName()) 
				 && e.getExperiment().equalsIgnoreCase(main.simParams.getExperiment())).collect(Collectors.toList());															 																								
	}
	else if(firstBomItem.getLotsizePolicy().equalsIgnoreCase(Item.LOT_POLICY_FOQ)) {
		int foq = (int)firstBomItem.getFOQQuantity();	
		traceln("FOQ Qty:" + foq);	
					
		selectedSegments = ClearingFunctionSegments.stream().filter(e -> e.getLotParameter() == foq &&
							 e.getLotPolicy().equalsIgnoreCase(Item.LOT_POLICY_FOQ) && e.getResource().equalsIgnoreCase(inResource.getName()) 
				 && e.getExperiment().equalsIgnoreCase(main.simParams.getExperiment())).collect(Collectors.toList());															 																								
	}
	
			
	traceln("Resource: " + inResource.getName());
	traceln("Resource Stage Number: " + inResource.getStageNumber());
	traceln("Production Stage: " + (bomLevel + 1));
	traceln("Max Capacity: " + maxCapacity);
	
	traceln("Items to Plan: ");
	itemsToPlan.forEach(e -> traceln(e.getItem().getItem() + " eProcessingTime " + e.getItem().getRouting().getEProcessingTime() + ";"));

	traceln("Selected Slopes: ");		
	selectedSegments.forEach(e -> traceln(e.getSlope() + ";"));
	traceln("Selected Intercepts: ");
	
	selectedSegments.forEach(e -> traceln(e.getyIntercept() + ";"));
	
	if(selectedSegments.size() == 0){
		traceln("STOP Simulation: No Segments found!");
		System.exit(0);
	}
	
	to.log("Segment Cnt: " + selectedSegments.size(), Tools.LogCFOptimization);
	
	double intercepts[] = new double[selectedSegments.size()];
	double slopes[] = new double[selectedSegments.size()];
	
	for(int i = 0; i < selectedSegments.size(); i++) {
		slopes[i] = selectedSegments.get(i).getSlope();
		intercepts[i] = selectedSegments.get(i).getyIntercept();
	}		
			
int numberSegments = selectedSegments.size();

double oCosts = 0;
double oFactor = 1000;
double setupTime = 18;
int leadtimeHorizon = main.simParams.getLeadTimeHorizon();


traceln("Leadtime Horizon: " + leadtimeHorizon);

IloCplex cplex = new IloCplex();

     String[][] Inames = new String[itemsToPlan.size()][get_Main().simParams.getMRPPlanningHorizon()];
     String[][] Pnames = new String[itemsToPlan.size()][get_Main().simParams.getMRPPlanningHorizon()];
     String[] PLnames = new String[get_Main().simParams.getMRPPlanningHorizon()];
     String[] Lnames = new String[get_Main().simParams.getMRPPlanningHorizon()];
     String[][] Wnames = new String[itemsToPlan.size()][get_Main().simParams.getMRPPlanningHorizon()];
     String[][] Rnames = new String[itemsToPlan.size()][get_Main().simParams.getMRPPlanningHorizon()];     
     String[][] Bnames = new String[itemsToPlan.size()][get_Main().simParams.getMRPPlanningHorizon()];     
     
     for(int i = 0; i< get_Main().simParams.getMRPPlanningHorizon(); i++){
          for (int p = 0; p < itemsToPlan.size(); p++) {
        	 	Inames[p][i] = "I" + itemsToPlan.get(p).getItem().getItem() + "_" + i; 
        	 	Pnames[p][i] = "P" + itemsToPlan.get(p).getItem().getItem() + "_" + i; 
        	 	Wnames[p][i] = "W" + itemsToPlan.get(p).getItem().getItem() + "_" + i; 
        	 	Rnames[p][i] = "R" + itemsToPlan.get(p).getItem().getItem() + "_" + i; 
        	 	Bnames[p][i] = "B" + itemsToPlan.get(p).getItem().getItem() + "_" + i; 
        	 	PLnames[i] = "PL" + itemsToPlan.get(p).getItem().getItem() + "_" + i; 
        	 	Lnames[i] = "L" + itemsToPlan.get(p).getItem().getItem() + "_" + i; 
	     }
     }

     IloNumVar[] C = new IloNumVar[main.simParams.getMRPPlanningHorizon()];
     for (int t = 0; t < get_Main().simParams.getMRPPlanningHorizon(); t++) {
        C[t] = cplex.numVar(0, Double.MAX_VALUE, "C" + "_" + t);
     }
     
     IloNumVar[][] I = new IloNumVar[itemsToPlan.size()][];
     for (int p = 0; p < itemsToPlan.size(); p++) {
        I[p] = cplex.numVarArray(get_Main().simParams.getMRPPlanningHorizon(), 0, Double.MAX_VALUE, Inames[p]);
        oCosts += itemsToPlan.get(p).getItem().getHoldingCosts();
     }
     
     oCosts = oFactor*oCosts;
     
     IloNumVar[][] P = new IloNumVar[itemsToPlan.size()][];
     for (int p = 0; p < itemsToPlan.size(); p++) {     
        P[p] = cplex.numVarArray(get_Main().simParams.getMRPPlanningHorizon(), 0,  Double.MAX_VALUE, Pnames[p]);        
     }
     
     IloNumVar[] PL = new IloNumVar[leadtimeHorizon];     
     IloNumVar[] L = new IloNumVar[leadtimeHorizon];     
     
     for (int t = 0; t < leadtimeHorizon; t++) {               
     	PL[t] = cplex.numVar(0,  Double.MAX_VALUE, PLnames[t]);
     	L[t] = cplex.numVar(0,  Double.MAX_VALUE, Lnames[t]);
     }
     
                    
     IloNumVar[][] W = new IloNumVar[itemsToPlan.size()][];
     for (int p = 0; p < itemsToPlan.size(); p++) {
        W[p] = cplex.numVarArray(get_Main().simParams.getMRPPlanningHorizon(), 0, Double.MAX_VALUE, Wnames[p]);
     }
		
	 IloNumVar[][] R = new IloNumVar[itemsToPlan.size()][];
     for (int p = 0; p < itemsToPlan.size(); p++) {
        R[p] = cplex.numVarArray(get_Main().simParams.getMRPPlanningHorizon(), 0.0, Double.MAX_VALUE, Rnames[p]);
     }
     
     //IloNumVar[][] R = new IloNumVar[itemsToPlan.size()][];
     //for (int p = 0; p < itemsToPlan.size(); p++) {
      //  R[p] = cplex.numVarArray(get_Main().simParams.getMRPPlanningHorizon(), 0.0, Double.MAX_VALUE, Rnames[p]);
     //}
     
     IloNumVar[][] B = new IloNumVar[itemsToPlan.size()][];
     for (int p = 0; p < itemsToPlan.size(); p++) {
        B[p] = cplex.numVarArray(get_Main().simParams.getMRPPlanningHorizon(), 0.0, Double.MAX_VALUE, Bnames[p]);
     }
               	
	double[] inventory = new double[itemsToPlan.size()];
	double[] wip = new double[itemsToPlan.size()];
	double[] produce = new double[itemsToPlan.size()];
	double[] tl = new double[itemsToPlan.size()];
		
	int[][] X = new int[itemsToPlan.size()][get_Main().simParams.getMRPPlanningHorizon()];

	List<SpecialObject> iQd = new ArrayList<SpecialObject>();
	
     for (int p = 0; p < itemsToPlan.size(); p++) { 
          	     

     		   inventory[p] = 0;
     		   
     		   //wip[p] = (int)ProductionOrder.GetCurrentWip(get_Main().productionOrders, itemsToPlan.get(p).getItem(), get_Main().simParams);
     		   	wip[p]=0;
     		   
	        	int tmp_item = itemsToPlan.get(p).getItem().getItem();
	               	     		   
				     		
     		   produce[p] = 0;
     		   
     		   //tl[p] = itemsToPlan.get(p).getItem().getTransportLotSize();
     		   int lateOrders = 0;     		   				    			
     	       for (int t = 0; t < get_Main().simParams.getMRPPlanningHorizon(); t++) {               	                          	               	
	               		               		               		               		               	
	               	//int tmp_item = itemsToPlan.get(p).getItem().getItem();
	               	int temp_t = t;
	               					 	           int quantityRunningProductionOrders = remainingProductionOrderQty(tmp_item,t);
	               	
	               	MRP mrpItem = get_Main().mrpTable.stream().filter(e -> e.getItem().getItem() == tmp_item
	               	 && e.getTime() == time() && e.getPeriod() == temp_t).findFirst().orElseGet(() -> new MRP());
					
					if(t == 0){
	               		//lateOrders= (int) mrpItem.getPlannedOrderReceipts();	        			
	               	}
					
					if(quantityRunningProductionOrders > 0 && t == 1){
						traceln("RunningProduction Order Qty: " + quantityRunningProductionOrders + " time: " + time() + " t " + t + " item " + tmp_item);
						X[p][t] = quantityRunningProductionOrders;
					}
					
					
					if(t == 1){
	        			X[p][t] += (int) mrpItem.getPlannedOrderReceipts() + lateOrders;	        				        			
	        		}else if(t > 1){
	        			X[p][t] += (int) mrpItem.getPlannedOrderReceipts();
	        		}
	        				        			        		
	        		if(X[p][t] > 0 && t > 0) {
	        			SpecialObject so = new SpecialObject(
	        				mrpItem.getItem().getItem(),
	        				X[p][t], 
	        				t);
	        			iQd.add(so);
	        			
	        			//traceln("~~~~~~~~~~~~~" + so.getItem() + " qty: " + so.getQuantity() + " dd " + so.getDueDate());
	        			
	        		}        		  	        		        		
            }     	      	
     }
          
     String[][] RiNames = new String[iQd.size()][leadtimeHorizon];
     int[][] releaseTmp = new int[iQd.size()][main.simParams.getMRPPlanningHorizon()];
     String[] releaseForX = new String[iQd.size()];

	 // this combinations are constructed .. every time the due date in this case 13, a 0 value is added RI_103_13_106.0_0R103_0
	 
	 //RI_103_13_106.0_0R103_0 + RI_103_13_106.0_0R103_0
       //+ RI_103_13_106.0_0R103_0 + RI_103_13_106.0_1R103_1
       //+ RI_103_13_106.0_2R103_2 + RI_103_13_106.0_3R103_3
       //+ RI_103_13_106.0_4R103_4 + RI_103_13_106.0_5R103_5
       //+ RI_103_13_106.0_6R103_6 + RI_103_13_106.0_7R103_7
       //+ RI_103_13_106.0_8R103_8 + RI_103_13_106.0_9R103_9
       //+ RI_103_13_106.0_10R103_10 + RI_103_13_106.0_11R103_11
       //+ RI_103_13_106.0_12R103_12 + RI_103_13_106.0_13R103_13 
	 
	 //for each Xt > 0 an entry to iQd is added and this represnts all Xts of all planned products!
     for (int p = 0; p < iQd.size(); p++) {
          for(int i = 1; i < leadtimeHorizon; i++){
          		int targetT = (int)(iQd.get(p).getDueDate() - leadtimeHorizon + i + 1);          		
          		
          		if(targetT < 0)
          			targetT = 0; // is 0 as this are values later thaen the due date e.g. 13
          		          		
          		releaseTmp[p][targetT] = i+1;
          		
          		if(targetT > 0){          		          		
        	 		RiNames[p][i] = "RI_" +  iQd.get(p).getItem() + "_" + (int)iQd.get(p).getDueDate() +         	 	
        	 		"_" + iQd.get(p).getQuantity() + "_" + targetT + "R" + iQd.get(p).getItem() + "_" + targetT; 
        	 	}else{
        	 		RiNames[p][i] = "noRelease";// + p + "" + i;
        	 	}
        	 	
        	 	traceln(RiNames[p][i]);
	     }    
     }


	 //for each product we need the individual releases RI.....They are constructed with the above equation.            
	 traceln("iQd.size " + iQd.size());
     IloNumVar[][] RI = new IloNumVar[iQd.size()][];
     for (int p = 0; p < iQd.size(); p++) {
     	//e.g. if we have 8 releases while iqd.size = 8 and this all all the xts, we also need 8 RIs to get an individual decision for each Xt, which must be associated with an Release
     	// in each RiNames the item and due date (item and xt) is coded, consequently this works. 
        RI[p] = cplex.boolVarArray(leadtimeHorizon, RiNames[p]);
     }                                      
            
     	//Objective Function     
		IloLinearNumExpr objFunction  = cplex.linearNumExpr();
	         
        for (int p = 0; p < itemsToPlan.size(); p++) {
           for (int t = 0; t < get_Main().simParams.getMRPPlanningHorizon(); t++) {
              objFunction.addTerm (itemsToPlan.get(p).getItem().getHoldingCosts(), I[p][t]);
            }
         }

        for (int p = 0; p < itemsToPlan.size(); p++) {
           for (int t = 0; t < get_Main().simParams.getMRPPlanningHorizon(); t++) {
             objFunction.addTerm (itemsToPlan.get(p).getItem().getHoldingCostsWIP(), W[p][t]);
            }                     	            
         } 
         
         for (int p = 0; p < itemsToPlan.size(); p++) {
           for (int t = 0; t < get_Main().simParams.getMRPPlanningHorizon(); t++) {
             objFunction.addTerm (itemsToPlan.get(p).getItem().getBacklogCosts(), B[p][t]);
            }                     	            
         } 
         
                  
         for (int t = 0; t < get_Main().simParams.getMRPPlanningHorizon(); t++) {
             objFunction.addTerm (oCosts, C[t]);
         }                     	                              
                                      
         cplex.addMinimize(objFunction); //objective function
       
         for (int p = 0; p < itemsToPlan.size(); p++) {
           		
         	cplex.addEq(I[p][0],0); //Eq7
         	cplex.addEq(P[p][0],0); //Eq8  Pg,0 must be zero to avoid production in this period. this is not possible.                           
         	//cplex.addEq(W[p][0],0); //Eq7
         	cplex.addEq(R[p][0],0); //Eq9
         	cplex.addEq(W[p][0],0); //Eq10
         
            for (int t = 1; t < get_Main().simParams.getMRPPlanningHorizon(); t++) {
	           	cplex.addEq(cplex.sum(cplex.sum(I[p][t], X[p][t]),B[p][t-1]), 
                       cplex.sum(cplex.sum(I[p][t-1], P[p][t-1]),B[p][t]));
        	}
            
              
            cplex.addEq(W[p][0], R[p][0]);
            
            for (int t = 1; t < get_Main().simParams.getMRPPlanningHorizon(); t++) {
               cplex.addEq(cplex.sum(W[p][t], P[p][t-1]), 
                           cplex.sum(W[p][t-1], R[p][t]));   
                                                                                                                                    
            }			             											
         }
         
         //********************* Sum of RI_t == 1 *************************
         // RI_103_13_106.0_0R103_0 + RI_103_13_106.0_0R103_0 + RI_103_13_106.0_0R103_0 + RI_103_13_106.0_1R103_1  + RI_103_13_106.0_2R103_2 + RI_103_13_106.0_3R103_3  + RI_103_13_106.0_4R103_4 + RI_103_13_106.0_5R103_5 .... = 1       
         // CF Article EQ3 
          List<String> unique = new ArrayList();
          
          for (int p = 0; p < iQd.size(); p++) {
            IloLinearNumExpr num_expr_Sum_Binaries = cplex.linearNumExpr();  
            boolean weHaveRI = false;	           
	            for (int t = 1; t < leadtimeHorizon; t++) {	            	
	            	
	            	//int tmp_p = p;
	            	//int tmp_t = t;
	            	//traceln("test auf " + RI[tmp_p][tmp_t].getName());
	            	
	            	//boolean exists = unique.stream().filter(element -> element != null).anyMatch(element -> element.equals(RI[tmp_p][tmp_t].getName()));
	            	            	
	            	//if(!exists) {
	            		//unique.add(RI[tmp_p][tmp_t].getName());
	            		//traceln("p" + p + " t " + t );
	            		
	            		if(RI[p][t] != null){
	            		//traceln("ri not null");
	            		String variableName = RI[p][t].getName();
	            		//char isItRI = "RI";
	            		//traceln("Found variable " + variableName);
	            		
							           		
		            		if(variableName.contains("RI")){
		            			weHaveRI = true;
		            			num_expr_Sum_Binaries.addTerm(1,RI[p][t]);															
		            		}
		            		
	            		}
	            		
	            		
	            		//traceln("add" + RI[tmp_p][tmp_t].getName());
	            	//}else{
	            		//num_expr_Sum_Binaries.addTerm(0,RI[p][t]);															
	            	//}					
	            }
	            
	            //cplex.addEq(RI[p][0],0);
	            if(weHaveRI)
	            	cplex.addEq(num_expr_Sum_Binaries,1);
            }
         
         
         //RI structure
         //Eq2 where Rg,t = RIg,t*Xg,t
         //RI_item_Xt_qty_start_lth_...end_lth_Ritem_start_lth...end_lth
         for (int pp = 0; pp < itemsToPlan.size(); pp++) {
         	IloLinearNumExpr cf = cplex.linearNumExpr();				         
	       for (int t = 1; t < main.simParams.getMRPPlanningHorizon()-1; t++) {	            	            
			       	String o = "";
			       	int sizeExpr = 0;
			        IloLinearNumExpr num_expr = cplex.linearNumExpr();
			                    
	                for (int p = 0; p < iQd.size(); p++) {
	                	if(iQd.get(p).getItem()== itemsToPlan.get(pp).getItem().getItem()){
	                	
		            		if(releaseTmp[p][t] > 0){
		            			
		            			o = o + iQd.get(p).getQuantity() + "*" + RI[p][releaseTmp[p][t]-1].getName() +  "+";	            			
		            			num_expr.addTerm(iQd.get(p).getQuantity(),RI[p][releaseTmp[p][t]-1]);
		            					            					            					            			
		            			sizeExpr++;		            					            					            			
		            		}			        
	            		}
					}
					
				if(o.length() > 1){
		            if(sizeExpr > 0){
		            	//Constraint Release Size 
			            cplex.addEq(R[pp][t],num_expr);    
			                  
			        }

				}else{
				         cplex.addEq(R[pp][t],0);          								
				}
																
				num_expr.clear();             														
			}         
         }
         
         //sumRIs: represent the RI for the leadtime horizon
         //required for EQ10 and EQ11 to get the setuptime as part of the clearing functions
         IloLinearNumExpr sumRIs = cplex.linearNumExpr();			
           for (int t = 0; t < main.simParams.getMRPPlanningHorizon()-1; t++) {	    
               for (int pp = 0; pp < itemsToPlan.size(); pp++) {        	            
		           for (int p = 0; p < iQd.size(); p++) {
		 				    if(iQd.get(p).getItem()== itemsToPlan.get(pp).getItem().getItem()){ 	
		 				    	if(releaseTmp[p][t] > 0){ 				    			
					        	//RI[p] = cplex.boolVarArray(leadtimeHorizon, RiNames[p]);
					        	  sumRIs.addTerm(1.0,RI[p][releaseTmp[p][t]-1]); // the -1 allows releases RIt in the same period as Xt
						       	}//if
				       		}//if
				   		}//for           
	         		}//for
	         }//for                  
         
         //Constraint avoiding that RI with later due date, releases order earlier that RI with earlier due date (orders should not overteak each other)
         //The release of order 2 should not before order 1         
         //traceln("iQd size " + iQd.size());
         //****************** Order of Releases ***************************************
         //****************************************************************************
         
         
         //for each product we need the individual releases RI.....They are constructed with the above equation.            
	 	
     	/*
     	for (int p = 0; p < iQd.size(); p++) {     	
     		StringBuilder s = new StringBuilder();
     		s.append("");
     		for (int t = 0; t < main.simParams.getMRPPlanningHorizon()-1; t++) {	    	
        		s.append("," + RI[p][t].getName());
        	}
        	
			        	ForecastHistory.AppendToFile(ClearingFunction.FILENAME_RELEASE_ORDER + ".csv",
						s.toString(),
						ClearingFunction.class,
						ClearingFunction.LOG_CF_RELEASE_ORDER_DELETE_OUTPUTFILE);
     	}                                      
         */
        
        
        
         // ********************************* Guarantee Release ORDER  ****************************************
         // ***************************************************************************************************
         for (int pp = 0; pp < itemsToPlan.size(); pp++) {        	            
            for (int i = 0; i < leadtimeHorizon; i++) {
                for (int j = 0; j < iQd.size(); j++) {
                    for (int k = j + 1; k < iQd.size(); k++) {
                        IloLinearNumExpr constraint = cplex.linearNumExpr();
                                                                        
                        if(RI[j][i].getName() != "noRelease" && RI[k][i].getName() != "noRelease" && RI[j][i].getName() != null){
	                    
		                    String[] RiSplitted = RI[j][i].getName().split("_");                        
	                        int item =  Integer.parseInt(RiSplitted[1]);
	                        
	                        String[] RiSplitted2 = RI[k][i].getName().split("_");                        
	                        int item2 =  Integer.parseInt(RiSplitted2[1]);
	                        	                    
			                    if(itemsToPlan.get(pp).getItem().getItem() == item && itemsToPlan.get(pp).getItem().getItem() == item2){    
			                        constraint.addTerm(RI[j][i], 1.0); // 1 of set j		                        
			                        constraint.addTerm(RI[k][i], -1.0); // -1 of set k
			                        cplex.addLe(constraint, 0); // set j[i] - set k[i] <= 0
			                     }                                                   
	                        }
	                    }
	                }
	            }
	        }
        
         
                  
         
         if(false){
         for (int p = 0; p < iQd.size(); p++) {          		
          			int i = 1;
        	 		
        	 		
        	 		String[] RiSplitted = RI[p][i].getName().split("_");			                    			        			        			        			       										        	 		
			        
			        if(RI[p][i].getName() != "noRelease"){
							
			        			        			        
			        int endDate = Integer.parseInt(RiSplitted[2]); //enddate (Xt)
			        int item = Integer.parseInt(RiSplitted[1]); //enddate (Xt)
					//check if another RIs with a later endDate (Xt) exists
					
					 ForecastHistory.AppendToFile(ClearingFunction.FILENAME_RELEASE_ORDER + ".csv",
								"enddatum" + endDate + " item " + item + " p" + p + "s " +iQd.size(),
								ClearingFunction.class,
								ClearingFunction.LOG_CF_RELEASE_ORDER_DELETE_OUTPUTFILE);
					
					
        	         for (int p2 = 0; p2 < iQd.size(); p2++) {
	                   	int i2 = 1;
	                   	
							String[] RiSplittedSuccessor = RI[p2][i2].getName().split("_");			                    	                   			                   	
							
							if(RI[p2][i2].getName() != "noRelease"){
							
							
							int endDateSuccessor = Integer.parseInt(RiSplittedSuccessor[2]); //enddate (Xt)
					        int itemSuccessor = Integer.parseInt(RiSplittedSuccessor[1]); //enddate (Xt)
					        					        					        						        					        					        									
					        					        					        					        
		                   		if(endDate < endDateSuccessor && itemSuccessor == item){ //don't iterate over the same RI
		                   		
				                   		ForecastHistory.AppendToFile(ClearingFunction.FILENAME_RELEASE_ORDER + ".csv",
										"enddatum s" + endDateSuccessor + " item s " + itemSuccessor + "p" ,
										ClearingFunction.class,
										ClearingFunction.LOG_CF_RELEASE_ORDER_DELETE_OUTPUTFILE);					        					        					        	
			                   		
			                   		
					                   	int RiendDateSuccessor = Integer.parseInt(RiSplittedSuccessor[2]); //enddate (Xt) RI successor
	                   		                   		
					                   	int overlappingStart = (endDateSuccessor - leadtimeHorizon);
	
										IloLinearNumExpr lhs = cplex.linearNumExpr();				             	    
					                   	IloLinearNumExpr rhs = cplex.linearNumExpr();				                   					        
	
					                   	int overlappingPeriods = endDate - overlappingStart;
					                   	
					                   	int RIstartIndex = max(0,(leadtimeHorizon-overlappingPeriods));				                   		
					                   	
					                   	StringBuilder lhsOut = new StringBuilder();
					                   	StringBuilder rhsOut = new StringBuilder();
					                   	
						                   	for(int o = 0; o < overlappingPeriods; o++){
		
							                   	lhs.addTerm(1,RI[p][RIstartIndex + o]);
							                   	lhsOut.append(RI[p][RIstartIndex + o].getName() + "+");
							                   	
							                   	rhs.addTerm(1,RI[p2][o]);
							                   	rhsOut.append(RI[p2][o].getName() + "+");
							                 }//for
					                   	cplex.addGe(lhs,rhs);
				                	 }//if   	         
        	         			}//for
        	         		}//if	
        	         	}//if	
     	  			}//for     
           		}//if true                 
         
         //****************** CF SECTION ***************************************
         //*********************************************************************
         
         for (int t = 0; t < main.simParams.getMRPPlanningHorizon(); t++) {	    
         
	     	IloLinearNumExpr cf = cplex.linearNumExpr();				             	    
	     	IloLinearNumExpr cf1 = cplex.linearNumExpr();				             	    
	       	IloLinearNumExpr cf2 = cplex.linearNumExpr();				             	    
		   	IloLinearNumExpr cf3 = cplex.linearNumExpr();				             	    
	       	IloLinearNumExpr cf4 = cplex.linearNumExpr();				             	    

    	    
    	    //Pgt smaller Wgt - Constraint for single item qty
        	 for (int pp = 0; pp < itemsToPlan.size(); pp++) {        	  			

	         		cf.addTerm(itemsToPlan.get(pp).getItem().getRouting().getEProcessingTime(),P[pp][t]);	         		
	         		
	         		cf1.addTerm(itemsToPlan.get(pp).getItem().getRouting().getEProcessingTime(),P[pp][t]); 	         		        		
         			cf2.addTerm(itemsToPlan.get(pp).getItem().getRouting().getEProcessingTime(),W[pp][t]);         			         		        			         			
         			
         			cf3.addTerm(itemsToPlan.get(pp).getItem().getRouting().getEProcessingTime(),P[pp][t]);         		
         			cf4.addTerm(itemsToPlan.get(pp).getItem().getRouting().getEProcessingTime(),W[pp][t]);
         			
         			//Ppt, <= Wp,t         			         		         			
         			cplex.addLe(
         				cplex.sum(P[pp][t],cplex.prod(0,sumRIs)),//LHS         			
        				cplex.sum(W[pp][t],0));//RHS         			
        				        				        				        			        			        				
        	  }
        	          	  

			  //CF Constraints			           	  
			  //PL <= MC + Ct (Eq12)			  
			  traceln("setup time " + setupTime + " sum ri " + sumRIs);
         	  //cplex.addLe(cplex.sum(cf,cplex.prod(setupTime,sumRIs)), //LHS         	  
         	  
         	  cplex.addEq(PL[t],cf);
         	  cplex.addEq(L[t],cf2);
         	  
         	  if(t==0){         	           	           	           	  
         	  		cplex.addLe(cf,         	  
         	  		cplex.sum(0,C[t]));	//RHS
         	  	}else{
         	  		cplex.addLe(cf,         	  
         	  		cplex.sum(maxCapacity,C[t]));	//RHS
         	  	}
         	           	           	           	  		         	           	           	  
         	           	           	  
         	  // ---- we have three segments         	           	           	  
			  //CF partition 2 from numerical example
			  for(int i = 0; i < numberSegments; i++){
	         	  cplex.addLe(
    	     	  	cplex.sum(cf1,cplex.prod(setupTime,sumRIs)), //LHS				

         	  	cplex.sum(cplex.sum(cplex.prod(max(slopes[i],0),
         	  	cplex.sum(cf2,cplex.prod(setupTime,sumRIs))),intercepts[i]),C[t]));//RHS         	  		         	  		
         	  		         	  		
         	  	traceln("sumRIs " + sumRIs + " st " + setupTime);	
         	  }//for
         	           	           	           	  
			  //PLt <= Lt + Ct (Eq14)
         	  //Constraint Pl musst be smaller as SL for all t
         	  
         	  cplex.addLe(
         	  	cplex.sum(cf3,cplex.prod(setupTime,sumRIs)), //LHS         	  
	         	cplex.sum(cplex.sum(cf4,cplex.prod(setupTime,sumRIs)),C[t]));         	  
         	  
			  cf.clear();
			  cf1.clear();
 			  cf2.clear();
 			  cf3.clear();
 			  cf4.clear();
         }



// Create a two-dimensional array of IloNumVars
            int numRows = iQd.size(); // Assuming iQd is a list or array
            
            
            // ... Initialize and populate the RI array with IloNumVars ...

            // Find the variable by name in the RI array
            String targetVariableName = "noRelease";
            boolean isVariableFound = false;
            IloNumVar foundVariable = null;

            for (int i = 0; i < numRows; i++) {
                for (int j = 1; j < RI[i].length-1; j++) {
                    IloNumVar var = RI[i][j];
                    if (var.getName().equals(targetVariableName)) {
                        isVariableFound = true;
                        foundVariable = var;
                        break;
                    }
                }
                if (isVariableFound) {
                    break;
                }
            }
            
            if (isVariableFound) {
                // Add a constraint to enforce the found variable to be zero
                traceln("Yes found");                
                foundVariable.setName("noRelease");                                
                cplex.addEq(foundVariable, 0);
            }
                                                               
    
    //cplex.deleteNames();
    
    //if(time() == 0)
    if(Tools.Log_CF_Optimization_Values){                 
		cplex.exportModel("model/NewModel_" + time() + "_" + bomLevel + ".lp");
	}	
	//cplex.writeSolution("model/NewModel_" + time() + "_" + bomLevel + ".sol");

	//cplex.setParam(IloCplex.BooleanParam.PreInd, true);
	//0.05 were to hard ... 0.1 before
	//cplex.setParam(IloCplex.Param.MIP.Tolerances.MIPGap, 0.05);
	//cplex.setParam(IloCplex.IntParam.DataCheck, 2);	
	cplex.setParam(IloCplex.IntParam.WorkMem, 2000);
						
	if(cplex.solve() && Tools.Log_CF_Optimization_Values){
		    
		    System.out.println("Solution status: " + cplex.getStatus());
            System.out.println();
            System.out.println("Objective Value = " + cplex.getObjValue());
          
            System.out.println("Pieces: Wip, X, Release, P");
            System.out.println("Minutes: PL L, MC, CF1, CF2, CF3");
            System.out.println("\tp\tTime\tt\tWip\tX\tRelease\tP\tPL\tL\tMC\tCF1\tCF2\tCF3\tInv\tIBl\tWB\tObjPP\tCt\tBt\tPTime\tSTime\tPL");
          	
            int[] t_sum_wip = new int[get_Main().simParams.getMRPPlanningHorizon()];
            int[] t_sum_pl = new int[get_Main().simParams.getMRPPlanningHorizon()];
            int[] t_sum_l = new int[get_Main().simParams.getMRPPlanningHorizon()];
            int[] t_sum_load = new int[get_Main().simParams.getMRPPlanningHorizon()];
            int[] t_sum_x = new int[get_Main().simParams.getMRPPlanningHorizon()];
            int[] t_sum_r = new int[get_Main().simParams.getMRPPlanningHorizon()];
            int[] t_sum_p = new int[get_Main().simParams.getMRPPlanningHorizon()];
          	
            for (int p = 0; p < itemsToPlan.size(); p++) {
                        	
               for (int t = 0; t < get_Main().simParams.getMRPPlanningHorizon(); t++) {
               
               double inventoryBalance = 0;
               double wipBalance = 0;

               if(t>0){
                  inventoryBalance = cplex.getValue(I[p][t-1])-X[p][t]+cplex.getValue(P[p][t-1]) - cplex.getValue(B[p][t-1]) + cplex.getValue(B[p][t]);
                  wipBalance = cplex.getValue(W[p][t-1])+cplex.getValue(R[p][t])-cplex.getValue(P[p][t-1]);               
               }
               		
               	  double lt = cplex.getValue(W[p][t])*itemsToPlan.get(p).getItem().getRouting().getEProcessingTime();
               	  double pl = cplex.getValue(P[p][t])*itemsToPlan.get(p).getItem().getRouting().getEProcessingTime();
               	  double objectivePerPeriod = cplex.getValue(W[p][t]) * wipCosts + cplex.getValue(I[p][t]) * inventoryHoldingCosts;
               	  
               	  
               	  int slope2 = -99;
               	  int slope3 = -99;
               	  
               	  if(selectedSegments.size() == 2){
               	  	slope2 = (int)(slopes[1]*lt+intercepts[1]);
               	  }
               	  
              	  if(selectedSegments.size() == 3){
               	  	slope3 = (int)(slopes[2]*lt+intercepts[2]);
               	  }
               	                 	  
               	  int wipForPrintLn = (int)cplex.getValue(W[p][t]);               	                 	                 	  
               	  
                  System.out.println("\t" + itemsToPlan.get(p).getItem().getItem() +
                                     "\t" + (time() + t) +
                                     "\t" + t +
                                     //"\t" + (int)cplex.getValue(W[p][t]) +
                                     "\t" + (int)Math.round(wipForPrintLn) +
                                     "\t" + X[p][t] +
                                     "\t" + (int)Math.round(cplex.getValue(R[p][t])) +       
                                     //"\t" +  +                                                       
                                     "\t" + (int)cplex.getValue(P[p][t]) +
                                     "\t" + (int)Math.round(pl) +
                                     "\t" + (int)Math.round(lt) +
                                     "\t" + maxCapacity + 
                                     "\t" + (int)(slopes[0]*lt+intercepts[0]) + 
                                     "\t" + slope2 + 
                                     "\t" + slope3 +                                      
                                     "\t" + Math.round(cplex.getValue(I[p][t])) +
                                     "\t" + Math.round(inventoryBalance) +
                                     "\t" + (int)Math.round(wipBalance) +
                                     "\t" + (int)Math.round(objectivePerPeriod) +
                                     "\t" + Math.round(cplex.getValue(C[t])) +
                                     "\t" + (int)cplex.getValue(B[p][t]) + 
                                     "\t" + itemsToPlan.get(p).getItem().getRouting().getEProcessingTime() +
                                     "\t" + itemsToPlan.get(p).getItem().getRouting().getESetupTime()  +
                                     "\t" + (int)cplex.getValue(PL[t]) +      
                                     "\t" + (int)cplex.getValue(L[t])       
                                     );                                                                                                 
            
            		//t_sum_wip[t] += wipForPrintLn;
            		
            		t_sum_x[t] += X[p][t];            		
            		t_sum_wip[t] += (int)cplex.getValue(W[p][t]) ;
            		t_sum_r[t] += (int)Math.round(cplex.getValue(R[p][t]));            		
            		t_sum_p[t] += (int)cplex.getValue(P[p][t]);
            		
            		//if(t==0){
            			t_sum_pl[t] = (int)cplex.getValue(PL[t]);
            			t_sum_l[t] = (int)cplex.getValue(L[t]);
            		//}
            			
            		t_sum_load[t] += lt;
                                    
                    //OptimizationResult optResult = new OptimizationResult(time(),itemsToPlan.get(p).getItem().getItem(), t,
                    //cplex.getValue(W[p][t]), cplex.getValue(R[p][t]), 0,cplex.getValue(P[p][t]),
                    //cplex.getValue(I[p][t]) );                    
                    //get_Main().optimizationResults.add(optResult);                                                      
               }                              
            }
            
            System.out.println("\n");
            System.out.println("\tTime\tt\tX\tWip\tR\tP\tPL\tL");           
            for(int t = 0; t < get_Main().simParams.getMRPPlanningHorizon(); t++) {
            
            	System.out.println(
            		"\t" + (time() + t) +
       				"\t" + t +           
       				"\t" + t_sum_x[t] + 		
            		"\t" + t_sum_wip[t] +
            		"\t" + t_sum_r[t] +
            		"\t" + t_sum_p[t] +
	           		"\t" + t_sum_pl[t] +
            		"\t" + t_sum_l[t]            	
            	);            
            }
                 	  
            
            //if(OptimizationResult.WRITE_OPTIMIZATION_RESULTS_TO_XLXS)
			//OptimizationResult.WriteXlsxOptimizationResults(get_Main().optimizationResults, get_Main().simParams);            
            	//traceln("size +++++++++++ " + get_Main().optimizationResults.size());
            
		}else{
			traceln("NO Solution " + cplex.getStatus());
		}												


			/*
        	for (int p = 0; p < iQd.size(); p++) {        	        
               for (int t = 0; t < leadtimeHorizon; t++) {   
                            
                            traceln("da");
					        
					        //double qty = cplex.getValue(RI[p][t]);    			            			            		            
					        double qty = 99;					        					        
							int itemIntTmp = iQd.get(p).getItem();
					        traceln(RI[p][t].getName().split("_"));
					        traceln("item " + itemIntTmp + " p " + p + "t " + t + "qty " + qty);
			}
			}
        	*/
        	
        	for (int p = 0; p < iQd.size(); p++) {        	        
               for (int t = 1; t < leadtimeHorizon; t++) {   
            				            
            				//traceln("da vor qty " + p + " " + t + " " + RI[p][t].getName());            				            				
					        					        				        
					        if(RI[p][t].getName() != "noRelease"){
					        	
					        
					        double qty = cplex.getValue(RI[p][t]);    			            			            		            
					        //traceln(qty);
					        //traceln("da for if");				               					        
							if(qty > 0.9){
					        //traceln("da");				               					        
								
								//traceln("qty " + qty + " " + RI[p][t].getName());
							
			                    ProductionOrder order = new ProductionOrder();
			                    								
								int itemIntTmp = iQd.get(p).getItem();
									
			                    Item item = get_Main().items.stream().filter(e -> e.getItem() == itemIntTmp).findFirst().get();																		                     
			                    
			                    order.setOrderId(get_Main().prodOrderId++);
			                    order.setItem(item);
			                                                                                                                                  
								order.setPlannedCapacity(Routing.GetPlannedCapacityPerItem(get_Main().routings, order.getItem(), get_Main().simParams, order));
			                    
			                    int minimumRoutingStep = Routing.GetMinimumStep(get_Main().routings, order.getItem() , get_Main().simParams);
								int maximumRoutingStep = Routing.GetMaximumStep(get_Main().routings, order.getItem() , get_Main().simParams);
						
								order.setMinimumRoutingStep(minimumRoutingStep);
								order.setMaximumRoutingStep(maximumRoutingStep);			
								order.setCurrentRoutingStep(minimumRoutingStep);                                        			                    
			                    
			                                                            
			                    //order.setQuantity(Math.round(iQd.get(p).getQuantity()));
			                    
			                    //traceln("################################## " + iQd.get(p).getQuantity());
			                    
			                    order.setQuantity(Math.ceil(iQd.get(p).getQuantity()));
			                    
			                    order.setCreatedAt(time());			                    
			                    
			                    //get the start and end dates from the RI decision variables			                    
			                    String[] RiSplitted = RI[p][t].getName().split("_");
			                    
			                    traceln(RI[p][t].getName().split("_"));
			                    
			                    //order.setPlannedStart(max(Integer.parseInt(RiSplitted[5]) + time() - item.getSafetyLeadTime(), time()));
			                    //order.setPlannedStart(Integer.parseInt(RiSplitted[5] + time());

			                    //safety leadtime for stochastic scenario
			                    //order.setPlannedStart(max(Integer.parseInt(RiSplitted[5]) + time() - 1, time()));
			                    
			                   // order.setPlannedStart(max(Integer.parseInt(RiSplitted[5]) + time() - 1, time()));
			                    
			                    order.setPlannedStart(max(Integer.parseInt(RiSplitted[5]) + time(), time()));

			                    order.setPlannedEnd(Integer.parseInt(RiSplitted[2]) + time());
			                    
			                    traceln("Start " + order.getPlannedStart() +  " Time " + time());
			                    
			                    long exists = 0;	
			                    		                    
			                    if(order.getPlannedStart() < time())
			                    	exists = 1;
			                    											
				                    if(exists == 0){
				                    	//traceln("Production Order Added");														                    
					                    Routing routingObject = get_Main().routings.stream().filter(e -> e.getItem().getItem() == order.getItem().getItem()).findFirst().get();			
										order.setRouting(routingObject);
										order.setStatus(ProductionOrder.PRODUCTION_ORDER_STATUS_UNPROCESSED);
					                    
					                    get_Main().productionOrders.add(order);	                    						
														                    
				                    }//if
		                    	}// if qty	
		                    	}	                    
		                 }//for            
		            }//for
                        
        if(false) {
			traceln("Production Orders from Optmization Before Removing");
			traceln(ProductionOrder.GetCSVHeader());
			
	        for (ProductionOrder order: get_Main().productionOrders) {
	           traceln(ProductionOrder.GetCSVString(order));
	        }        
			
	        //get_Main().productionOrders.removeIf(e -> e.getPlannedStart() > time());
	
	        traceln("Production Orders from Optmization FOR SIMULATION");
	        traceln(ProductionOrder.GetCSVHeader());
	
	        for (ProductionOrder order: get_Main().productionOrders) {
	            traceln(ProductionOrder.GetCSVString(order));
	        }        
	        traceln("**************************");                							
        }
		
		//get_Main().Function_OrderRelease();
		
		cplex.deleteNames();        
    	if(Tools.Log_CF_Optimization_Values){                 
			cplex.exportModel("model/NV/NewModel" + time() + "_" + bomLevel + ".lp");
		}	
		
		cplex.end();		
	}
	catch (IloException exc) {
         System.err.println("Concert exception '" + exc.getMessage() + "' caught");
         System.exit(-1);
    }

return 0;
]]></Body>
				</Function>
				<Function AccessType="default" StaticFunction="false">
					<ReturnModificator>RETURNS_VALUE</ReturnModificator>
					<ReturnType><![CDATA[int]]></ReturnType>
					<Id>1693312844474</Id>
					<Name><![CDATA[Function_ClearingFunction_wrong_SumRIs]]></Name>
					<X>490</X><Y>90</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Parameter>
						<Name><![CDATA[itemsToPlan]]></Name>
						<Type><![CDATA[List<MRP>]]></Type>
					</Parameter>
					<Parameter>
						<Name><![CDATA[bomLevel]]></Name>
						<Type><![CDATA[int]]></Type>
					</Parameter>
					<Parameter>
						<Name><![CDATA[inResource]]></Name>
						<Type><![CDATA[Resource]]></Type>
					</Parameter>
					<Parameter>
						<Name><![CDATA[fileSuffix]]></Name>
						<Type><![CDATA[String]]></Type>
					</Parameter>
					<Body><![CDATA[try{

Tools to = new Tools();
							
traceln("----------- Start CF OPTIMIZATION at " + time () + " ----------------");
							
StringBuilder output = new StringBuilder();

int maxCapacity = 1440;
double wipCosts = 0;
double inventoryHoldingCosts = 0;
traceln("Total found Segments: " + ClearingFunctionSegments.size());


/*
Iterator<MRP> iterator = itemsToPlan.iterator();
while (iterator.hasNext()) {
    MRP o = iterator.next();
    if (o.getItem().getItem() == 103 ||     
    o.getItem().getItem() == 111 ||
    o.getItem().getItem() == 115 ||
    o.getItem().getItem() == 119 ||
    o.getItem().getItem() == 123 ||
    o.getItem().getItem() == 127 ||
    o.getItem().getItem() == 131
    ) {
        iterator.remove(); // Safely remove the element from the list
    }
}
*/

//via the bom level the cf is associated
List<ClearingFunctionSegments> selectedSegments = new ArrayList();
	
	Item firstBomItem = itemsToPlan.get(0).getItem();
	wipCosts = firstBomItem.getHoldingCostsWIP();
	inventoryHoldingCosts = firstBomItem.getHoldingCosts();	
	
	//Routing firstRoutingItem = main.routings.stream().filter(e -> e.getItem().getItem() == firstBomItem.getItem()).findFirst().get();	
	//Resource firstResource= main.resources.stream().filter(e -> e.getName().equalsIgnoreCase(firstRoutingItem.getResource())).findFirst().get();
	
	//maxCapacity = inResource.getCapacity();
	//don't map it to the prodction stage 1-4, select the values based on the resource
	traceln("Total found segments: " + selectedSegments);
	
	if(firstBomItem.getLotsizePolicy().equalsIgnoreCase(Item.LOT_POLICY_FOP)) {
		int fop = firstBomItem.getFOPPeriod();	
		traceln("FOP Period:" + fop);	
					
		selectedSegments = ClearingFunctionSegments.stream().filter(e -> e.getLotParameter() == fop &&
							 e.getLotPolicy().equalsIgnoreCase(Item.LOT_POLICY_FOP) && e.getResource().equalsIgnoreCase(inResource.getName()) 
				 && e.getExperiment().equalsIgnoreCase(main.simParams.getExperiment())).collect(Collectors.toList());															 																								
	}
	else if(firstBomItem.getLotsizePolicy().equalsIgnoreCase(Item.LOT_POLICY_FOQ)) {
		int foq = (int)firstBomItem.getFOQQuantity();	
		traceln("FOQ Qty:" + foq);	
					
		selectedSegments = ClearingFunctionSegments.stream().filter(e -> e.getLotParameter() == foq &&
							 e.getLotPolicy().equalsIgnoreCase(Item.LOT_POLICY_FOQ) && e.getResource().equalsIgnoreCase(inResource.getName()) 
				 && e.getExperiment().equalsIgnoreCase(main.simParams.getExperiment())).collect(Collectors.toList());															 																								
	}
	
			
	traceln("Resource: " + inResource.getName());
	traceln("Resource Stage Number: " + inResource.getStageNumber());
	traceln("Production Stage: " + (bomLevel + 1));
	traceln("Max Capacity: " + maxCapacity);
	
	traceln("Items to Plan: ");
	itemsToPlan.forEach(e -> traceln(e.getItem().getItem() + " eProcessingTime " + e.getItem().getRouting().getEProcessingTime() + ";"));

	traceln("Selected Slopes: ");		
	selectedSegments.forEach(e -> traceln(e.getSlope() + ";"));
	traceln("Selected Intercepts: ");
	
	selectedSegments.forEach(e -> traceln(e.getyIntercept() + ";"));
	
	if(selectedSegments.size() == 0){
		traceln("STOP Simulation: No Segments found!");
		System.exit(0);
	}
	
	to.log("Segment Cnt: " + selectedSegments.size(), Tools.LogCFOptimization);
	
	double intercepts[] = new double[selectedSegments.size()];
	double slopes[] = new double[selectedSegments.size()];
	
	for(int i = 0; i < selectedSegments.size(); i++) {
		slopes[i] = selectedSegments.get(i).getSlope();
		intercepts[i] = selectedSegments.get(i).getyIntercept();
	}		
			
int numberSegments = selectedSegments.size();

double oCosts = 0;
double oFactor = 1000;
double setupTime = 18; //standard = 18
int leadtimeHorizon = main.simParams.getLeadTimeHorizon();


traceln("Leadtime Horizon: " + leadtimeHorizon);

IloCplex cplex = new IloCplex();

     String[][] Inames = new String[itemsToPlan.size()][get_Main().simParams.getMRPPlanningHorizon()];
     String[][] Pnames = new String[itemsToPlan.size()][get_Main().simParams.getMRPPlanningHorizon()];
     String[] PLnames = new String[get_Main().simParams.getMRPPlanningHorizon()];
     String[] Lnames = new String[get_Main().simParams.getMRPPlanningHorizon()];
     String[][] Wnames = new String[itemsToPlan.size()][get_Main().simParams.getMRPPlanningHorizon()];
     String[][] Rnames = new String[itemsToPlan.size()][get_Main().simParams.getMRPPlanningHorizon()];     
     String[][] Bnames = new String[itemsToPlan.size()][get_Main().simParams.getMRPPlanningHorizon()];     
     
     for(int i = 0; i< get_Main().simParams.getMRPPlanningHorizon(); i++){
          for (int p = 0; p < itemsToPlan.size(); p++) {
        	 	Inames[p][i] = "I" + itemsToPlan.get(p).getItem().getItem() + "_" + i; 
        	 	Pnames[p][i] = "P" + itemsToPlan.get(p).getItem().getItem() + "_" + i; 
        	 	Wnames[p][i] = "W" + itemsToPlan.get(p).getItem().getItem() + "_" + i; 
        	 	Rnames[p][i] = "R" + itemsToPlan.get(p).getItem().getItem() + "_" + i; 
        	 	Bnames[p][i] = "B" + itemsToPlan.get(p).getItem().getItem() + "_" + i; 
        	 	PLnames[i] = "PL" + itemsToPlan.get(p).getItem().getItem() + "_" + i; 
        	 	Lnames[i] = "L" + itemsToPlan.get(p).getItem().getItem() + "_" + i; 
	     }
     }

     IloNumVar[] C = new IloNumVar[main.simParams.getMRPPlanningHorizon()];
     for (int t = 0; t < get_Main().simParams.getMRPPlanningHorizon(); t++) {
        C[t] = cplex.numVar(0, Double.MAX_VALUE, "C" + "_" + t);
     }
     
     IloNumVar[][] I = new IloNumVar[itemsToPlan.size()][];
     for (int p = 0; p < itemsToPlan.size(); p++) {
        I[p] = cplex.numVarArray(get_Main().simParams.getMRPPlanningHorizon(), 0, Double.MAX_VALUE, Inames[p]);
        oCosts += itemsToPlan.get(p).getItem().getHoldingCosts();
     }
     
     oCosts = oFactor*oCosts;
     
     IloNumVar[][] P = new IloNumVar[itemsToPlan.size()][];
     for (int p = 0; p < itemsToPlan.size(); p++) {     
        P[p] = cplex.numVarArray(get_Main().simParams.getMRPPlanningHorizon(), 0,  Double.MAX_VALUE, Pnames[p]);        
     }
     
     IloNumVar[] PL = new IloNumVar[leadtimeHorizon];     
     IloNumVar[] L = new IloNumVar[leadtimeHorizon];     
     
     for (int t = 0; t < leadtimeHorizon; t++) {               
     	PL[t] = cplex.numVar(0,  Double.MAX_VALUE, PLnames[t]);
     	L[t] = cplex.numVar(0,  Double.MAX_VALUE, Lnames[t]);
     }
     
                    
     IloNumVar[][] W = new IloNumVar[itemsToPlan.size()][];
     for (int p = 0; p < itemsToPlan.size(); p++) {
        W[p] = cplex.numVarArray(get_Main().simParams.getMRPPlanningHorizon(), 0, Double.MAX_VALUE, Wnames[p]);
     }
		
	 IloNumVar[][] R = new IloNumVar[itemsToPlan.size()][];
     for (int p = 0; p < itemsToPlan.size(); p++) {
        R[p] = cplex.numVarArray(get_Main().simParams.getMRPPlanningHorizon(), 0.0, Double.MAX_VALUE, Rnames[p]);
     }
     
     //IloNumVar[][] R = new IloNumVar[itemsToPlan.size()][];
     //for (int p = 0; p < itemsToPlan.size(); p++) {
      //  R[p] = cplex.numVarArray(get_Main().simParams.getMRPPlanningHorizon(), 0.0, Double.MAX_VALUE, Rnames[p]);
     //}
     
     IloNumVar[][] B = new IloNumVar[itemsToPlan.size()][];
     for (int p = 0; p < itemsToPlan.size(); p++) {
        B[p] = cplex.numVarArray(get_Main().simParams.getMRPPlanningHorizon(), 0.0, Double.MAX_VALUE, Bnames[p]);
     }
               	
	double[] inventory = new double[itemsToPlan.size()];
	double[] wip = new double[itemsToPlan.size()];
	double[] produce = new double[itemsToPlan.size()];
	double[] tl = new double[itemsToPlan.size()];
		
	int[][] X = new int[itemsToPlan.size()][get_Main().simParams.getMRPPlanningHorizon()];

	List<SpecialObject> iQd = new ArrayList<SpecialObject>();
	
     for (int p = 0; p < itemsToPlan.size(); p++) {      	     

     		   inventory[p] = 0;
     		   
     		   //wip[p] = (int)ProductionOrder.GetCurrentWip(get_Main().productionOrders, itemsToPlan.get(p).getItem(), get_Main().simParams);
     		   	wip[p]=0;
     		   
	        	int tmp_item = itemsToPlan.get(p).getItem().getItem();
	               	     		   
				     		
     		   produce[p] = 0;
     		   
     		   //tl[p] = itemsToPlan.get(p).getItem().getTransportLotSize();
     		   int lateOrders = 0;     		   				    			
     	       for (int t = 0; t < get_Main().simParams.getMRPPlanningHorizon(); t++) { 
     	       
     	       		int quantityRunningProductionOrders = remainingProductionOrderQty(tmp_item,t);
     	                     	                          	               		               		               		               		               	
	               	//int tmp_item = itemsToPlan.get(p).getItem().getItem();
	               	int temp_t = t;
	               	
	               	MRP mrpItem = get_Main().mrpTable.stream().filter(e -> e.getItem().getItem() == tmp_item
	               	 && e.getTime() == time() && e.getPeriod() == temp_t).findFirst().orElseGet(() -> new MRP());
					
					if(t == 0){
	               		//lateOrders= (int) mrpItem.getPlannedOrderReceipts();	        			
	               	}
					
					if(quantityRunningProductionOrders > 0 && t == 1){
						traceln("RunningProduction Order Qty: " + quantityRunningProductionOrders + " time: " + time() + " t " + t + " item " + tmp_item);
						X[p][t] = quantityRunningProductionOrders;
					}
					
					
					if(t == 1){
	        			X[p][t] += (int) mrpItem.getPlannedOrderReceipts() + lateOrders;	        				        			
	        		}else if(t > 1){
	        			X[p][t] += (int) mrpItem.getPlannedOrderReceipts();
	        		}
	        				        			        		
	        		if(X[p][t] > 0 && t > 0) {
	        			SpecialObject so = new SpecialObject(
	        				mrpItem.getItem().getItem(),
	        				X[p][t], 
	        				t);
	        			iQd.add(so);
	        			
	        			//traceln("~~~~~~~~~~~~~" + so.getItem() + " qty: " + so.getQuantity() + " dd " + so.getDueDate());
	        			
	        		}        		  	        		        		
            }     	      	
     }
          
     String[][] RiNames = new String[iQd.size()][leadtimeHorizon];
     int[][] releaseTmp = new int[iQd.size()][main.simParams.getMRPPlanningHorizon()];
     String[] releaseForX = new String[iQd.size()];

	 // this combinations are constructed .. every time the due date in this case 13, a 0 value is added RI_103_13_106.0_0R103_0
	 
	 //RI_103_13_106.0_0R103_0 + RI_103_13_106.0_0R103_0
       //+ RI_103_13_106.0_0R103_0 + RI_103_13_106.0_1R103_1
       //+ RI_103_13_106.0_2R103_2 + RI_103_13_106.0_3R103_3
       //+ RI_103_13_106.0_4R103_4 + RI_103_13_106.0_5R103_5
       //+ RI_103_13_106.0_6R103_6 + RI_103_13_106.0_7R103_7
       //+ RI_103_13_106.0_8R103_8 + RI_103_13_106.0_9R103_9
       //+ RI_103_13_106.0_10R103_10 + RI_103_13_106.0_11R103_11
       //+ RI_103_13_106.0_12R103_12 + RI_103_13_106.0_13R103_13 
	 
	 //for each Xt > 0 an entry to iQd is added and this represnts all Xts of all planned products!
     for (int p = 0; p < iQd.size(); p++) {
          for(int i = 1; i < leadtimeHorizon; i++){
          		int targetT = (int)(iQd.get(p).getDueDate() - leadtimeHorizon + i + 1);          		
          		
          		if(targetT < 0)
          			targetT = 0; // is 0 as this are values later thaen the due date e.g. 13
          		          		
          		releaseTmp[p][targetT] = i+1;
          		
          		if(targetT > 0){          		          		
        	 		RiNames[p][i] = "RI_" +  iQd.get(p).getItem() + "_" + (int)iQd.get(p).getDueDate() +         	 	
        	 		"_" + iQd.get(p).getQuantity() + "_" + targetT + "R" + iQd.get(p).getItem() + "_" + targetT; 
        	 	}else{
        	 		RiNames[p][i] = "noRelease";// + p + "" + i;
        	 	}
        	 	
        	 	traceln(RiNames[p][i]);
	     }    
     }


	 //for each product we need the individual releases RI.....They are constructed with the above equation.            
	 traceln("iQd.size " + iQd.size());
     IloNumVar[][] RI = new IloNumVar[iQd.size()][];
     for (int p = 0; p < iQd.size(); p++) {
     	//e.g. if we have 8 releases while iqd.size = 8 and this all all the xts, we also need 8 RIs to get an individual decision for each Xt, which must be associated with an Release
     	// in each RiNames the item and due date (item and xt) is coded, consequently this works. 
        RI[p] = cplex.boolVarArray(leadtimeHorizon, RiNames[p]);
     }                                      
            
     	//Objective Function     
		IloLinearNumExpr objFunction  = cplex.linearNumExpr();
	         
        for (int p = 0; p < itemsToPlan.size(); p++) {
           for (int t = 0; t < get_Main().simParams.getMRPPlanningHorizon(); t++) {
              objFunction.addTerm (itemsToPlan.get(p).getItem().getHoldingCosts(), I[p][t]);
            }
         }

        for (int p = 0; p < itemsToPlan.size(); p++) {
           for (int t = 0; t < get_Main().simParams.getMRPPlanningHorizon(); t++) {
             objFunction.addTerm (itemsToPlan.get(p).getItem().getHoldingCostsWIP(), W[p][t]);
            }                     	            
         } 
         
         for (int p = 0; p < itemsToPlan.size(); p++) {
           for (int t = 0; t < get_Main().simParams.getMRPPlanningHorizon(); t++) {
             objFunction.addTerm (itemsToPlan.get(p).getItem().getBacklogCosts(), B[p][t]);
            }                     	            
         } 
         
                  
         for (int t = 0; t < get_Main().simParams.getMRPPlanningHorizon(); t++) {
             objFunction.addTerm (oCosts, C[t]);
         }                     	                              
                                      
         cplex.addMinimize(objFunction); //objective function
       
         for (int p = 0; p < itemsToPlan.size(); p++) {
           		
         	cplex.addEq(I[p][0],0); //Eq7
         	cplex.addEq(P[p][0],0); //Eq8  Pg,0 must be zero to avoid production in this period. this is not possible.                           
         	//cplex.addEq(W[p][0],0); //Eq7
         	cplex.addEq(R[p][0],0); //Eq9
         	cplex.addEq(W[p][0],0); //Eq10
         
            for (int t = 1; t < get_Main().simParams.getMRPPlanningHorizon(); t++) {
	           	cplex.addEq(cplex.sum(cplex.sum(I[p][t], X[p][t]),B[p][t-1]), 
                       cplex.sum(cplex.sum(I[p][t-1], P[p][t-1]),B[p][t]));
        	}
            
              
            cplex.addEq(W[p][0], R[p][0]);
            
            for (int t = 1; t < get_Main().simParams.getMRPPlanningHorizon(); t++) {
               cplex.addEq(cplex.sum(W[p][t], P[p][t-1]), 
                           cplex.sum(W[p][t-1], R[p][t]));   
                                                                                                                                    
            }			             											
         }
         
         //********************* Sum of RI_t == 1 *************************
         // RI_103_13_106.0_0R103_0 + RI_103_13_106.0_0R103_0 + RI_103_13_106.0_0R103_0 + RI_103_13_106.0_1R103_1  + RI_103_13_106.0_2R103_2 + RI_103_13_106.0_3R103_3  + RI_103_13_106.0_4R103_4 + RI_103_13_106.0_5R103_5 .... = 1       
         // CF Article EQ3 
          List<String> unique = new ArrayList();
          
          for (int p = 0; p < iQd.size(); p++) {
            IloLinearNumExpr num_expr_Sum_Binaries = cplex.linearNumExpr();  
            boolean weHaveRI = false;	           
	            for (int t = 1; t < leadtimeHorizon; t++) {	            	
	            	
	            	//int tmp_p = p;
	            	//int tmp_t = t;
	            	//traceln("test auf " + RI[tmp_p][tmp_t].getName());
	            	
	            	//boolean exists = unique.stream().filter(element -> element != null).anyMatch(element -> element.equals(RI[tmp_p][tmp_t].getName()));
	            	            	
	            	//if(!exists) {
	            		//unique.add(RI[tmp_p][tmp_t].getName());
	            		//traceln("p" + p + " t " + t );
	            		
	            		if(RI[p][t] != null){
	            		//traceln("ri not null");
	            		String variableName = RI[p][t].getName();
	            		//char isItRI = "RI";
	            		//traceln("Found variable " + variableName);
	            		
							           		
		            		if(variableName.contains("RI")){
		            			weHaveRI = true;
		            			num_expr_Sum_Binaries.addTerm(1,RI[p][t]);															
		            		}
		            		
	            		}
	            		
	            		
	            		//traceln("add" + RI[tmp_p][tmp_t].getName());
	            	//}else{
	            		//num_expr_Sum_Binaries.addTerm(0,RI[p][t]);															
	            	//}					
	            }
	            
	            //cplex.addEq(RI[p][0],0);
	            if(weHaveRI)
	            	cplex.addEq(num_expr_Sum_Binaries,1);
            }
         
         
         //RI structure
         //Eq2 where Rg,t = RIg,t*Xg,t
         //RI_item_Xt_qty_start_lth_...end_lth_Ritem_start_lth...end_lth
         for (int pp = 0; pp < itemsToPlan.size(); pp++) {
         	IloLinearNumExpr cf = cplex.linearNumExpr();				         
	       for (int t = 1; t < main.simParams.getMRPPlanningHorizon()-1; t++) {	            	            
			       	String o = "";
			       	int sizeExpr = 0;
			        IloLinearNumExpr num_expr = cplex.linearNumExpr();
			                    
	                for (int p = 0; p < iQd.size(); p++) {
	                	if(iQd.get(p).getItem()== itemsToPlan.get(pp).getItem().getItem()){
	                	
		            		if(releaseTmp[p][t] > 0){
		            			
		            			o = o + iQd.get(p).getQuantity() + "*" + RI[p][releaseTmp[p][t]-1].getName() +  "+";	            			
		            			num_expr.addTerm(iQd.get(p).getQuantity(),RI[p][releaseTmp[p][t]-1]);
		            					            					            					            			
		            			sizeExpr++;		            					            					            			
		            		}			        
	            		}
					}
					
				if(o.length() > 1){
		            if(sizeExpr > 0){
		            	//Constraint Release Size 
			            cplex.addEq(R[pp][t],num_expr);    
			                  
			        }

				}else{
				         cplex.addEq(R[pp][t],0);          								
				}
																
				num_expr.clear();             														
			}         
         }
         
         //sumRIs: represent the RI for the leadtime horizon
         //required for EQ10 and EQ11 to get the setuptime as part of the clearing functions
         IloLinearNumExpr sumRIs = cplex.linearNumExpr();			
           for (int t = 0; t < main.simParams.getMRPPlanningHorizon()-1; t++) {	    
               for (int pp = 0; pp < itemsToPlan.size(); pp++) {        	            
		           for (int p = 0; p < iQd.size(); p++) {
		 				    if(iQd.get(p).getItem()== itemsToPlan.get(pp).getItem().getItem()){ 	
		 				    	if(releaseTmp[p][t] > 0){ 				    			
					        	//RI[p] = cplex.boolVarArray(leadtimeHorizon, RiNames[p]);
					        	  sumRIs.addTerm(1.0,RI[p][releaseTmp[p][t]-1]); // the -1 allows releases RIt in the same period as Xt
						       	}//if
				       		}//if
				   		}//for           
	         		}//for
	         }//for                  
         
         //Constraint avoiding that RI with later due date, releases order earlier that RI with earlier due date (orders should not overteak each other)
         //The release of order 2 should not before order 1                                         
         // ********************************* Guarantee Release ORDER  ****************************************
         // ***************************************************************************************************
         for (int pp = 0; pp < itemsToPlan.size(); pp++) {        	            
            for (int i = 0; i < leadtimeHorizon; i++) {
                for (int j = 0; j < iQd.size(); j++) {
                    for (int k = j + 1; k < iQd.size(); k++) {
                        IloLinearNumExpr constraint = cplex.linearNumExpr();
                                                                        
                        if(RI[j][i].getName() != "noRelease" && RI[k][i].getName() != "noRelease" && RI[j][i].getName() != null){
	                    
		                    String[] RiSplitted = RI[j][i].getName().split("_");                        
	                        int item =  Integer.parseInt(RiSplitted[1]);
	                        
	                        String[] RiSplitted2 = RI[k][i].getName().split("_");                        
	                        int item2 =  Integer.parseInt(RiSplitted2[1]);
	                        	                    
			                    if(itemsToPlan.get(pp).getItem().getItem() == item && itemsToPlan.get(pp).getItem().getItem() == item2){    
			                        constraint.addTerm(RI[j][i], 1.0); // 1 of set j		                        
			                        constraint.addTerm(RI[k][i], -1.0); // -1 of set k
			                        cplex.addLe(constraint, 0); // set j[i] - set k[i] <= 0
			                     }                                                   
	                        }
	                    }
	                }
	            }
	        }
                          
         //****************** CF SECTION ***************************************
         //*********************************************************************
         
         for (int t = 0; t < main.simParams.getMRPPlanningHorizon(); t++) {	    
         
	     	IloLinearNumExpr cf = cplex.linearNumExpr();				             	    
	     	IloLinearNumExpr cf1 = cplex.linearNumExpr();				             	    
	       	IloLinearNumExpr cf2 = cplex.linearNumExpr();				             	    
		   	IloLinearNumExpr cf3 = cplex.linearNumExpr();				             	    
	       	IloLinearNumExpr cf4 = cplex.linearNumExpr();				             	    

    	    
    	    //Pgt smaller Wgt - Constraint for single item qty
        	 for (int pp = 0; pp < itemsToPlan.size(); pp++) {        	  			
					//merk dir, dass die weiter unten verwendet werden
					//double setupProption = 18.0/106.0;
					double setupProption = 0;
					
	         		cf.addTerm(itemsToPlan.get(pp).getItem().getRouting().getEProcessingTime()+setupProption,P[pp][t]);	         		
	         		
	         		cf1.addTerm(itemsToPlan.get(pp).getItem().getRouting().getEProcessingTime()+setupProption,P[pp][t]); 	         		        		
         			cf2.addTerm(itemsToPlan.get(pp).getItem().getRouting().getEProcessingTime()+setupProption,W[pp][t]);         			         		        			         			
         			
         			cf3.addTerm(itemsToPlan.get(pp).getItem().getRouting().getEProcessingTime()+setupProption,P[pp][t]);         		
         			cf4.addTerm(itemsToPlan.get(pp).getItem().getRouting().getEProcessingTime()+setupProption,W[pp][t]);
         			
         			
         			//***************** Ppt, <= Wp,t ***********************        			         		         			
         			cplex.addLe(
         				cplex.sum(P[pp][t],cplex.prod(0,sumRIs)),//LHS         			
        				cplex.sum(W[pp][t],0));//RHS         			
        			//****************************************        			         		         				
        				        				        				        			        			        				
        	  }
        	          	  
			  //CF Constraints			           	  
			  //PL <= MC + Ct (Eq12)			  
			  //traceln("setup time " + setupTime + " sum ri " + sumRIs);
         	  //cplex.addLe(cplex.sum(cf,cplex.prod(setupTime,sumRIs)), //LHS         	  
         	  
         	  
         	  // **************** PL und L ausgeben *********************
         	  //keine constraints werden spter so auch nicht wiedervendet
         	  cplex.addEq(PL[t],cf);
         	  cplex.addEq(L[t],cf2);
         	  //********************************************************* 
         	  
         	  
         	  //cplex.addEq(PL[t],cplex.sum(cf,cplex.prod(setupTime,sumRIs)));
         	  //cplex.addEq(L[t],cplex.sum(cf2,cplex.prod(setupTime,sumRIs)));         	           	           	           	  
         	  
         	  if(t==0){         	           	           	           	  
         	  		cplex.addLe(cf,         	  
         	  		cplex.sum(0,C[t]));	//RHS
         	  	}else{
         	  		//cplex.addLe(cf,
         	  		cplex.addLe(cplex.sum(cf,cplex.prod(setupTime,sumRIs)),         	  
         	  		cplex.sum(maxCapacity,C[t]));	//RHS
         	  	}
         	           	           	           	  		         	           	           	  
         	           	           	  
         	  // ---- we have three segments         	           	           	  
			  //CF partition 2 from numerical example
			  for(int i = 0; i < numberSegments; i++){
	         	  cplex.addLe(
    	     	  	cplex.sum(cf1,cplex.prod(setupTime,sumRIs)), //LHS				
				
         	  	cplex.sum(cplex.sum(cplex.prod(max(slopes[i],0),         	  	         	  	
         	  	cplex.sum(cf2,cplex.prod(setupTime,sumRIs))),intercepts[i]),C[t]));//RHS         	  		         	  						
         	  	traceln("slope " + slopes[i] + " intercept " + intercepts[i]);
         	  		         	  		
         	  	//traceln("sumRIs " + sumRIs + " st " + setupTime);	
         	  }//for
         	           	           	           	  
			  
         	  
         	  //******************************* PLt <= Lt + Ct (Eq14) *********************
         	  //Constraint Pl musst be smaller as SL for all t         	           	  
         	  cplex.addLe(
         	  	cplex.sum(cf3,cplex.prod(setupTime,sumRIs)), //LHS         	  
	         	cplex.sum(cplex.sum(cf4,cplex.prod(setupTime,sumRIs)),C[t]));         	  	         	
	          //***************************************************************************
         	  
			  cf.clear();
			  cf1.clear();
 			  cf2.clear();
 			  cf3.clear();
 			  cf4.clear();
         }



// Create a two-dimensional array of IloNumVars
            int numRows = iQd.size(); // Assuming iQd is a list or array
            
            
            // ... Initialize and populate the RI array with IloNumVars ...

            // Find the variable by name in the RI array
            String targetVariableName = "noRelease";
            boolean isVariableFound = false;
            IloNumVar foundVariable = null;

            for (int i = 0; i < numRows; i++) {
                for (int j = 1; j < RI[i].length-1; j++) {
                    IloNumVar var = RI[i][j];
                    if (var.getName().equals(targetVariableName)) {
                        isVariableFound = true;
                        foundVariable = var;
                        break;
                    }
                }
                if (isVariableFound) {
                    break;
                }
            }
            
            if (isVariableFound) {
                // Add a constraint to enforce the found variable to be zero
                traceln("Yes found");                
                foundVariable.setName("noRelease");                                
                cplex.addEq(foundVariable, 0);
            }
                                                               
    
    //cplex.deleteNames();
    
    //if(time() == 0)
    if(Tools.Log_CF_Optimization_Values){                 
		cplex.exportModel("model/NewModel_" + time() + "_" + bomLevel + ".lp");
	}	
	//cplex.writeSolution("model/NewModel_" + time() + "_" + bomLevel + ".sol");

	//cplex.setParam(IloCplex.BooleanParam.PreInd, true);
	//0.05 were to hard ... 0.1 before
	//cplex.setParam(IloCplex.Param.MIP.Tolerances.MIPGap, 0.05);
	//cplex.setParam(IloCplex.IntParam.DataCheck, 2);	
	cplex.setParam(IloCplex.IntParam.WorkMem, 2000);
						
	if(cplex.solve() && Tools.Log_CF_Optimization_Values){
		    
		    System.out.println("Solution status: " + cplex.getStatus());
            System.out.println();
            System.out.println("Objective Value = " + cplex.getObjValue());
          
            System.out.println("Pieces: Wip, X, Release, P");
            System.out.println("Minutes: PL L, MC, CF1, CF2, CF3");
            System.out.println("\tp\tTime\tt\tWip\tX\tRelease\tP\tPL\tL\tMC\tCF1\tCF2\tCF3\tInv\tIBl\tWB\tObjPP\tCt\tBt\tPTime\tSTime\tPL");
          	
            int[] t_sum_wip = new int[get_Main().simParams.getMRPPlanningHorizon()];
            int[] t_sum_pl = new int[get_Main().simParams.getMRPPlanningHorizon()];
            int[] t_sum_l = new int[get_Main().simParams.getMRPPlanningHorizon()];
            int[] t_sum_load = new int[get_Main().simParams.getMRPPlanningHorizon()];
            int[] t_sum_x = new int[get_Main().simParams.getMRPPlanningHorizon()];
            int[] t_sum_r = new int[get_Main().simParams.getMRPPlanningHorizon()];
            int[] t_sum_p = new int[get_Main().simParams.getMRPPlanningHorizon()];
          	
            for (int p = 0; p < itemsToPlan.size(); p++) {
                        	
               for (int t = 0; t < get_Main().simParams.getMRPPlanningHorizon(); t++) {
               
               double inventoryBalance = 0;
               double wipBalance = 0;

               if(t>0){
                  inventoryBalance = cplex.getValue(I[p][t-1])-X[p][t]+cplex.getValue(P[p][t-1]) - cplex.getValue(B[p][t-1]) + cplex.getValue(B[p][t]);
                  wipBalance = cplex.getValue(W[p][t-1])+cplex.getValue(R[p][t])-cplex.getValue(P[p][t-1]);               
               }
               		
               	  double lt = cplex.getValue(W[p][t])*itemsToPlan.get(p).getItem().getRouting().getEProcessingTime();
               	  double pl = cplex.getValue(P[p][t])*itemsToPlan.get(p).getItem().getRouting().getEProcessingTime();
               	  double objectivePerPeriod = cplex.getValue(W[p][t]) * wipCosts + cplex.getValue(I[p][t]) * inventoryHoldingCosts;
               	  
               	  
               	  int slope2 = -99;
               	  int slope3 = -99;
               	  
               	  if(selectedSegments.size() == 2){
               	  	slope2 = (int)(slopes[1]*lt+intercepts[1]);
               	  }
               	  
              	  if(selectedSegments.size() == 3){
               	  	slope3 = (int)(slopes[2]*lt+intercepts[2]);
               	  }
               	                 	  
               	  int wipForPrintLn = (int)cplex.getValue(W[p][t]);               	                 	                 	  
               	  
                  System.out.println("\t" + itemsToPlan.get(p).getItem().getItem() +
                                     "\t" + (time() + t) +
                                     "\t" + t +
                                     //"\t" + (int)cplex.getValue(W[p][t]) +
                                     "\t" + (int)Math.round(wipForPrintLn) +
                                     "\t" + X[p][t] +
                                     "\t" + (int)Math.round(cplex.getValue(R[p][t])) +       
                                     //"\t" +  +                                                       
                                     "\t" + (int)cplex.getValue(P[p][t]) +
                                     "\t" + (int)Math.round(pl) +
                                     "\t" + (int)Math.round(lt) +
                                     "\t" + maxCapacity + 
                                     "\t" + (int)(slopes[0]*lt+intercepts[0]) + 
                                     "\t" + slope2 + 
                                     "\t" + slope3 +                                      
                                     "\t" + Math.round(cplex.getValue(I[p][t])) +
                                     "\t" + Math.round(inventoryBalance) +
                                     "\t" + (int)Math.round(wipBalance) +
                                     "\t" + (int)Math.round(objectivePerPeriod) +
                                     "\t" + Math.round(cplex.getValue(C[t])) +
                                     "\t" + (int)cplex.getValue(B[p][t]) + 
                                     "\t" + itemsToPlan.get(p).getItem().getRouting().getEProcessingTime() +
                                     "\t" + itemsToPlan.get(p).getItem().getRouting().getESetupTime()  +
                                     "\t" + (int)cplex.getValue(PL[t]) +      
                                     "\t" + (int)cplex.getValue(L[t])       
                                     );                                                                                                 
            
            		//t_sum_wip[t] += wipForPrintLn;
            		
            		t_sum_x[t] += X[p][t];            		
            		t_sum_wip[t] += (int)cplex.getValue(W[p][t]) ;
            		t_sum_r[t] += (int)Math.round(cplex.getValue(R[p][t]));            		
            		t_sum_p[t] += (int)cplex.getValue(P[p][t]);
            		
            		//if(t==0){
            			t_sum_pl[t] = (int)cplex.getValue(PL[t]);
            			t_sum_l[t] = (int)cplex.getValue(L[t]);
            		//}
            			
            		t_sum_load[t] += lt;
                                    
                    //OptimizationResult optResult = new OptimizationResult(time(),itemsToPlan.get(p).getItem().getItem(), t,
                    //cplex.getValue(W[p][t]), cplex.getValue(R[p][t]), 0,cplex.getValue(P[p][t]),
                    //cplex.getValue(I[p][t]) );                    
                    //get_Main().optimizationResults.add(optResult);                                                      
               }                              
            }
            
            System.out.println("\n");
            System.out.println("\tTime\tt\tX\tWip\tR\tP\tPL\tL");           
            for(int t = 0; t < get_Main().simParams.getMRPPlanningHorizon(); t++) {
            
            	System.out.println(
            		"\t" + (time() + t) +
       				"\t" + t +           
       				"\t" + t_sum_x[t] + 		
            		"\t" + t_sum_wip[t] +
            		"\t" + t_sum_r[t] +
            		"\t" + t_sum_p[t] +
	           		"\t" + t_sum_pl[t] +
            		"\t" + t_sum_l[t]            	
            	);            
            }
                 	  
            
            //if(OptimizationResult.WRITE_OPTIMIZATION_RESULTS_TO_XLXS)
			//OptimizationResult.WriteXlsxOptimizationResults(get_Main().optimizationResults, get_Main().simParams);            
            	//traceln("size +++++++++++ " + get_Main().optimizationResults.size());
            
		}else{
			traceln("NO Solution " + cplex.getStatus());
		}												


			/*
        	for (int p = 0; p < iQd.size(); p++) {        	        
               for (int t = 0; t < leadtimeHorizon; t++) {   
                            
                            traceln("da");
					        
					        //double qty = cplex.getValue(RI[p][t]);    			            			            		            
					        double qty = 99;					        					        
							int itemIntTmp = iQd.get(p).getItem();
					        traceln(RI[p][t].getName().split("_"));
					        traceln("item " + itemIntTmp + " p " + p + "t " + t + "qty " + qty);
			}
			}
        	*/
        	
        	for (int p = 0; p < iQd.size(); p++) {        	        
               for (int t = 1; t < leadtimeHorizon; t++) {   
            				            
            				//traceln("da vor qty " + p + " " + t + " " + RI[p][t].getName());            				            				
					        					        				        
					        if(RI[p][t].getName() != "noRelease"){
					        	
					        
					        double qty = cplex.getValue(RI[p][t]);    			            			            		            
					        //traceln(qty);
					        //traceln("da for if");				               					        
							if(qty > 0.9){
					        //traceln("da");				               					        
								
								//traceln("qty " + qty + " " + RI[p][t].getName());
							
			                    ProductionOrder order = new ProductionOrder();
			                    								
								int itemIntTmp = iQd.get(p).getItem();
									
			                    Item item = get_Main().items.stream().filter(e -> e.getItem() == itemIntTmp).findFirst().get();																		                     
			                    
			                    order.setOrderId(get_Main().prodOrderId++);
			                    order.setItem(item);
			                                                                                                                                  
								order.setPlannedCapacity(Routing.GetPlannedCapacityPerItem(get_Main().routings, order.getItem(), get_Main().simParams, order));
			                    
			                    int minimumRoutingStep = Routing.GetMinimumStep(get_Main().routings, order.getItem() , get_Main().simParams);
								int maximumRoutingStep = Routing.GetMaximumStep(get_Main().routings, order.getItem() , get_Main().simParams);
						
								order.setMinimumRoutingStep(minimumRoutingStep);
								order.setMaximumRoutingStep(maximumRoutingStep);			
								order.setCurrentRoutingStep(minimumRoutingStep);                                        			                    
			                    
			                                                            
			                    //order.setQuantity(Math.round(iQd.get(p).getQuantity()));
			                    
			                    //traceln("################################## " + iQd.get(p).getQuantity());
			                    
			                    order.setQuantity(Math.ceil(iQd.get(p).getQuantity()));
			                    
			                    order.setCreatedAt(time());			                    
			                    
			                    //get the start and end dates from the RI decision variables			                    
			                    String[] RiSplitted = RI[p][t].getName().split("_");
			                    
			                    traceln(RI[p][t].getName().split("_"));
			                    
			                    //order.setPlannedStart(max(Integer.parseInt(RiSplitted[5]) + time() - item.getSafetyLeadTime(), time()));
			                    //order.setPlannedStart(Integer.parseInt(RiSplitted[5] + time());

			                    //safety leadtime for stochastic scenario
			                    //order.setPlannedStart(max(Integer.parseInt(RiSplitted[5]) + time() - 1, time()));
			                    
			                   // order.setPlannedStart(max(Integer.parseInt(RiSplitted[5]) + time() - 1, time()));
			                    
			                    order.setPlannedStart(max(Integer.parseInt(RiSplitted[5]) + time(), time()));

			                    order.setPlannedEnd(Integer.parseInt(RiSplitted[2]) + time());
			                    
			                    traceln("Start " + order.getPlannedStart() +  " Time " + time());
			                    
			                    long exists = 0;	
			                    		                    
			                    if(order.getPlannedStart() < time())
			                    	exists = 1;
			                    											
				                    if(exists == 0){
				                    	//traceln("Production Order Added");														                    
					                    Routing routingObject = get_Main().routings.stream().filter(e -> e.getItem().getItem() == order.getItem().getItem()).findFirst().get();			
										order.setRouting(routingObject);
										order.setStatus(ProductionOrder.PRODUCTION_ORDER_STATUS_UNPROCESSED);
					                    
					                    get_Main().productionOrders.add(order);	                    						
														                    
				                    }//if
		                    	}// if qty	
		                    	}	                    
		                 }//for            
		            }//for
                        
        if(false) {
			traceln("Production Orders from Optmization Before Removing");
			traceln(ProductionOrder.GetCSVHeader());
			
	        for (ProductionOrder order: get_Main().productionOrders) {
	           traceln(ProductionOrder.GetCSVString(order));
	        }        
			
	        //get_Main().productionOrders.removeIf(e -> e.getPlannedStart() > time());
	
	        traceln("Production Orders from Optmization FOR SIMULATION");
	        traceln(ProductionOrder.GetCSVHeader());
	
	        for (ProductionOrder order: get_Main().productionOrders) {
	            traceln(ProductionOrder.GetCSVString(order));
	        }        
	        traceln("**************************");                							
        }
		
		//get_Main().Function_OrderRelease();
		
		cplex.deleteNames();        
    	if(Tools.Log_CF_Optimization_Values){                 
			cplex.exportModel("model/NV/NewModel" + time() + "_" + bomLevel + ".lp");
		}	
		
		cplex.end();		
	}
	catch (IloException exc) {
         System.err.println("Concert exception '" + exc.getMessage() + "' caught");
         System.exit(-1);
    }

return 0;
]]></Body>
				</Function>
				<Function AccessType="default" StaticFunction="false">
					<ReturnModificator>RETURNS_VALUE</ReturnModificator>
					<ReturnType><![CDATA[int]]></ReturnType>
					<Id>1694689991596</Id>
					<Name><![CDATA[Function_ClearingFunction_without_late_running_orders]]></Name>
					<X>490</X><Y>60</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Parameter>
						<Name><![CDATA[itemsToPlan]]></Name>
						<Type><![CDATA[List<MRP>]]></Type>
					</Parameter>
					<Parameter>
						<Name><![CDATA[bomLevel]]></Name>
						<Type><![CDATA[int]]></Type>
					</Parameter>
					<Parameter>
						<Name><![CDATA[inResource]]></Name>
						<Type><![CDATA[Resource]]></Type>
					</Parameter>
					<Parameter>
						<Name><![CDATA[fileSuffix]]></Name>
						<Type><![CDATA[String]]></Type>
					</Parameter>
					<Body><![CDATA[try{

Tools to = new Tools();
							
traceln("----------- Start CF OPTIMIZATION at " + time () + " ----------------");
							
StringBuilder output = new StringBuilder();

int maxCapacity = 1440;
double wipCosts = 0;
double inventoryHoldingCosts = 0;
traceln("Total found Segments: " + ClearingFunctionSegments.size());


/*
Iterator<MRP> iterator = itemsToPlan.iterator();
while (iterator.hasNext()) {
    MRP o = iterator.next();
    if (o.getItem().getItem() == 103 ||     
    o.getItem().getItem() == 111 ||
    o.getItem().getItem() == 115 ||
    o.getItem().getItem() == 119 ||
    o.getItem().getItem() == 123 ||
    o.getItem().getItem() == 127 ||
    o.getItem().getItem() == 131
    ) {
        iterator.remove(); // Safely remove the element from the list
    }
}
*/

//via the bom level the cf is associated
List<ClearingFunctionSegments> selectedSegments = new ArrayList();
	
	Item firstBomItem = itemsToPlan.get(0).getItem();
	wipCosts = firstBomItem.getHoldingCostsWIP();
	inventoryHoldingCosts = firstBomItem.getHoldingCosts();	
	
	//Routing firstRoutingItem = main.routings.stream().filter(e -> e.getItem().getItem() == firstBomItem.getItem()).findFirst().get();	
	//Resource firstResource= main.resources.stream().filter(e -> e.getName().equalsIgnoreCase(firstRoutingItem.getResource())).findFirst().get();
	
	//maxCapacity = inResource.getCapacity();
	//don't map it to the prodction stage 1-4, select the values based on the resource
	traceln("Total found segments: " + selectedSegments);
	
	if(firstBomItem.getLotsizePolicy().equalsIgnoreCase(Item.LOT_POLICY_FOP)) {
		int fop = firstBomItem.getFOPPeriod();	
		traceln("FOP Period:" + fop);	
					
		selectedSegments = ClearingFunctionSegments.stream().filter(e -> e.getLotParameter() == fop &&
							 e.getLotPolicy().equalsIgnoreCase(Item.LOT_POLICY_FOP) && e.getResource().equalsIgnoreCase(inResource.getName()) 
				 && e.getExperiment().equalsIgnoreCase(main.simParams.getExperiment())).collect(Collectors.toList());															 																								
	}
	else if(firstBomItem.getLotsizePolicy().equalsIgnoreCase(Item.LOT_POLICY_FOQ)) {
		int foq = (int)firstBomItem.getFOQQuantity();	
		traceln("FOQ Qty:" + foq);	
					
		selectedSegments = ClearingFunctionSegments.stream().filter(e -> e.getLotParameter() == foq &&
							 e.getLotPolicy().equalsIgnoreCase(Item.LOT_POLICY_FOQ) && e.getResource().equalsIgnoreCase(inResource.getName()) 
				 && e.getExperiment().equalsIgnoreCase(main.simParams.getExperiment())).collect(Collectors.toList());															 																								
	}
	
			
	traceln("Resource: " + inResource.getName());
	traceln("Resource Stage Number: " + inResource.getStageNumber());
	traceln("Production Stage: " + (bomLevel + 1));
	traceln("Max Capacity: " + maxCapacity);
	
	traceln("Items to Plan: ");
	itemsToPlan.forEach(e -> traceln(e.getItem().getItem() + " eProcessingTime " + e.getItem().getRouting().getEProcessingTime() + ";"));

	traceln("Selected Slopes: ");		
	selectedSegments.forEach(e -> traceln(e.getSlope() + ";"));
	traceln("Selected Intercepts: ");
	
	selectedSegments.forEach(e -> traceln(e.getyIntercept() + ";"));
	
	if(selectedSegments.size() == 0){
		traceln("STOP Simulation: No Segments found!");
		System.exit(0);
	}
	
	to.log("Segment Cnt: " + selectedSegments.size(), Tools.LogCFOptimization);
	
	double intercepts[] = new double[selectedSegments.size()];
	double slopes[] = new double[selectedSegments.size()];
	
	for(int i = 0; i < selectedSegments.size(); i++) {
		slopes[i] = selectedSegments.get(i).getSlope();
		intercepts[i] = selectedSegments.get(i).getyIntercept();
	}		
			
int numberSegments = selectedSegments.size();

double oCosts = 0;
double oFactor = 1000;
double setupTime = 18; //standard = 18
int leadtimeHorizon = main.simParams.getLeadTimeHorizon();


traceln("Leadtime Horizon: " + leadtimeHorizon);

IloCplex cplex = new IloCplex();

     String[][] Inames = new String[itemsToPlan.size()][get_Main().simParams.getMRPPlanningHorizon()];
     String[][] Pnames = new String[itemsToPlan.size()][get_Main().simParams.getMRPPlanningHorizon()];
     String[] PLnames = new String[get_Main().simParams.getMRPPlanningHorizon()];
     String[] Lnames = new String[get_Main().simParams.getMRPPlanningHorizon()];
     String[][] Wnames = new String[itemsToPlan.size()][get_Main().simParams.getMRPPlanningHorizon()];
     String[][] Rnames = new String[itemsToPlan.size()][get_Main().simParams.getMRPPlanningHorizon()];     
     String[][] Bnames = new String[itemsToPlan.size()][get_Main().simParams.getMRPPlanningHorizon()];     
     
     for(int i = 0; i< get_Main().simParams.getMRPPlanningHorizon(); i++){
          for (int p = 0; p < itemsToPlan.size(); p++) {
        	 	Inames[p][i] = "I" + itemsToPlan.get(p).getItem().getItem() + "_" + i; 
        	 	Pnames[p][i] = "P" + itemsToPlan.get(p).getItem().getItem() + "_" + i; 
        	 	Wnames[p][i] = "W" + itemsToPlan.get(p).getItem().getItem() + "_" + i; 
        	 	Rnames[p][i] = "R" + itemsToPlan.get(p).getItem().getItem() + "_" + i; 
        	 	Bnames[p][i] = "B" + itemsToPlan.get(p).getItem().getItem() + "_" + i; 
        	 	PLnames[i] = "PL" + itemsToPlan.get(p).getItem().getItem() + "_" + i; 
        	 	Lnames[i] = "L" + itemsToPlan.get(p).getItem().getItem() + "_" + i; 
	     }
     }

     IloNumVar[] C = new IloNumVar[main.simParams.getMRPPlanningHorizon()];
     for (int t = 0; t < get_Main().simParams.getMRPPlanningHorizon(); t++) {
        C[t] = cplex.numVar(0, Double.MAX_VALUE, "C" + "_" + t);
     }
     
     IloNumVar[][] I = new IloNumVar[itemsToPlan.size()][];
     for (int p = 0; p < itemsToPlan.size(); p++) {
        I[p] = cplex.numVarArray(get_Main().simParams.getMRPPlanningHorizon(), 0, Double.MAX_VALUE, Inames[p]);
        oCosts += itemsToPlan.get(p).getItem().getHoldingCosts();
     }
     
     oCosts = oFactor*oCosts;
     
     IloNumVar[][] P = new IloNumVar[itemsToPlan.size()][];
     for (int p = 0; p < itemsToPlan.size(); p++) {     
        P[p] = cplex.numVarArray(get_Main().simParams.getMRPPlanningHorizon(), 0,  Double.MAX_VALUE, Pnames[p]);        
     }
     
     IloNumVar[] PL = new IloNumVar[leadtimeHorizon];     
     IloNumVar[] L = new IloNumVar[leadtimeHorizon];     
     
     for (int t = 0; t < leadtimeHorizon; t++) {               
     	PL[t] = cplex.numVar(0,  Double.MAX_VALUE, PLnames[t]);
     	L[t] = cplex.numVar(0,  Double.MAX_VALUE, Lnames[t]);
     }
     
                    
     IloNumVar[][] W = new IloNumVar[itemsToPlan.size()][];
     for (int p = 0; p < itemsToPlan.size(); p++) {
        W[p] = cplex.numVarArray(get_Main().simParams.getMRPPlanningHorizon(), 0, Double.MAX_VALUE, Wnames[p]);
     }
		
	 IloNumVar[][] R = new IloNumVar[itemsToPlan.size()][];
     for (int p = 0; p < itemsToPlan.size(); p++) {
        R[p] = cplex.numVarArray(get_Main().simParams.getMRPPlanningHorizon(), 0.0, Double.MAX_VALUE, Rnames[p]);
     }
     
     //IloNumVar[][] R = new IloNumVar[itemsToPlan.size()][];
     //for (int p = 0; p < itemsToPlan.size(); p++) {
      //  R[p] = cplex.numVarArray(get_Main().simParams.getMRPPlanningHorizon(), 0.0, Double.MAX_VALUE, Rnames[p]);
     //}
     
     IloNumVar[][] B = new IloNumVar[itemsToPlan.size()][];
     for (int p = 0; p < itemsToPlan.size(); p++) {
        B[p] = cplex.numVarArray(get_Main().simParams.getMRPPlanningHorizon(), 0.0, Double.MAX_VALUE, Bnames[p]);
     }
               	
	double[] inventory = new double[itemsToPlan.size()];
	double[] wip = new double[itemsToPlan.size()];
	double[] produce = new double[itemsToPlan.size()];
	double[] tl = new double[itemsToPlan.size()];
		
	int[][] X = new int[itemsToPlan.size()][get_Main().simParams.getMRPPlanningHorizon()];

	List<SpecialObject> iQd = new ArrayList<SpecialObject>();
	
     for (int p = 0; p < itemsToPlan.size(); p++) {      	     

     		   inventory[p] = 0;
     		   
     		   //wip[p] = (int)ProductionOrder.GetCurrentWip(get_Main().productionOrders, itemsToPlan.get(p).getItem(), get_Main().simParams);
     		   	wip[p]=0;
     		   
	        	int tmp_item = itemsToPlan.get(p).getItem().getItem();
	               	     		   			     		
     		   produce[p] = 0;
     		   
     		   //tl[p] = itemsToPlan.get(p).getItem().getTransportLotSize();
     		   int lateOrders = 0;     		   				    			
     	       for (int t = 0; t < get_Main().simParams.getMRPPlanningHorizon(); t++) {               	                          	               	
	               	int quantityRunningProductionOrders = remainingProductionOrderQty(tmp_item,t);
	               		               		               		               		               	
	               	//int tmp_item = itemsToPlan.get(p).getItem().getItem();
	               	int temp_t = t;
	               	
	               	MRP mrpItem = get_Main().mrpTable.stream().filter(e -> e.getItem().getItem() == tmp_item
	               	 && e.getTime() == time() && e.getPeriod() == temp_t).findFirst().orElseGet(() -> new MRP());
					
					if(t == 0){
	               		//lateOrders= (int) mrpItem.getPlannedOrderReceipts();	        			
	               	}
					
					if(quantityRunningProductionOrders > 0 && t == 1){
						traceln("RunningProduction Order Qty: " + quantityRunningProductionOrders + " time: " + time() + " t " + t + " item " + tmp_item);
						X[p][t] = quantityRunningProductionOrders;
					}
					
					if(t == 1){
	        			X[p][t] += (int) mrpItem.getPlannedOrderReceipts() + lateOrders;	        				        			
	        		}else if(t > 1){
	        			X[p][t] += (int) mrpItem.getPlannedOrderReceipts();
	        		}
	        				        			        		
	        		if(X[p][t] > 0 && t > 0) {
	        			SpecialObject so = new SpecialObject(
	        				mrpItem.getItem().getItem(),
	        				X[p][t], 
	        				t);
	        			iQd.add(so);
	        			
	        			//traceln("~~~~~~~~~~~~~" + so.getItem() + " qty: " + so.getQuantity() + " dd " + so.getDueDate());
	        			
	        		}        		  	        		        		
            }     	      	
     }
          
     String[][] RiNames = new String[iQd.size()][leadtimeHorizon];
     int[][] releaseTmp = new int[iQd.size()][main.simParams.getMRPPlanningHorizon()];
     String[] releaseForX = new String[iQd.size()];

	 // this combinations are constructed .. every time the due date in this case 13, a 0 value is added RI_103_13_106.0_0R103_0
	 
	 //RI_103_13_106.0_0R103_0 + RI_103_13_106.0_0R103_0
       //+ RI_103_13_106.0_0R103_0 + RI_103_13_106.0_1R103_1
       //+ RI_103_13_106.0_2R103_2 + RI_103_13_106.0_3R103_3
       //+ RI_103_13_106.0_4R103_4 + RI_103_13_106.0_5R103_5
       //+ RI_103_13_106.0_6R103_6 + RI_103_13_106.0_7R103_7
       //+ RI_103_13_106.0_8R103_8 + RI_103_13_106.0_9R103_9
       //+ RI_103_13_106.0_10R103_10 + RI_103_13_106.0_11R103_11
       //+ RI_103_13_106.0_12R103_12 + RI_103_13_106.0_13R103_13 
	 
	 //for each Xt > 0 an entry to iQd is added and this represnts all Xts of all planned products!
     for (int p = 0; p < iQd.size(); p++) {
          for(int i = 1; i < leadtimeHorizon; i++){
          		int targetT = (int)(iQd.get(p).getDueDate() - leadtimeHorizon + i + 1);          		
          		
          		if(targetT < 0)
          			targetT = 0; // is 0 as this are values later thaen the due date e.g. 13
          		          		
          		releaseTmp[p][targetT] = i+1;
          		
          		if(targetT > 0){          		          		
        	 		RiNames[p][i] = "RI_" +  iQd.get(p).getItem() + "_" + (int)iQd.get(p).getDueDate() +         	 	
        	 		"_" + iQd.get(p).getQuantity() + "_" + targetT + "R" + iQd.get(p).getItem() + "_" + targetT; 
        	 	}else{
        	 		RiNames[p][i] = "noRelease";// + p + "" + i;
        	 	}
        	 	
        	 	//traceln(RiNames[p][i]);
	     }    
     }


	 //for each product we need the individual releases RI.....They are constructed with the above equation.            
	 //traceln("iQd.size " + iQd.size());
     IloNumVar[][] RI = new IloNumVar[iQd.size()][];
     for (int p = 0; p < iQd.size(); p++) {
     	//e.g. if we have 8 releases while iqd.size = 8 and this all all the xts, we also need 8 RIs to get an individual decision for each Xt, which must be associated with an Release
     	// in each RiNames the item and due date (item and xt) is coded, consequently this works. 
        RI[p] = cplex.boolVarArray(leadtimeHorizon, RiNames[p]);
     }                                      
            
     	//Objective Function     
		IloLinearNumExpr objFunction  = cplex.linearNumExpr();
	         
        for (int p = 0; p < itemsToPlan.size(); p++) {
           for (int t = 0; t < get_Main().simParams.getMRPPlanningHorizon(); t++) {
              objFunction.addTerm (itemsToPlan.get(p).getItem().getHoldingCosts(), I[p][t]);
            }
         }

        for (int p = 0; p < itemsToPlan.size(); p++) {
           for (int t = 0; t < get_Main().simParams.getMRPPlanningHorizon(); t++) {
             objFunction.addTerm (itemsToPlan.get(p).getItem().getHoldingCostsWIP(), W[p][t]);
            }                     	            
         } 
         
         for (int p = 0; p < itemsToPlan.size(); p++) {
           for (int t = 0; t < get_Main().simParams.getMRPPlanningHorizon(); t++) {
             objFunction.addTerm (itemsToPlan.get(p).getItem().getBacklogCosts(), B[p][t]);
            }                     	            
         } 
         
                  
         for (int t = 0; t < get_Main().simParams.getMRPPlanningHorizon(); t++) {
             objFunction.addTerm (oCosts, C[t]);
         }                     	                              
                                      
         cplex.addMinimize(objFunction); //objective function
       
         for (int p = 0; p < itemsToPlan.size(); p++) {
           		
         	cplex.addEq(I[p][0],0); //Eq7
         	cplex.addEq(P[p][0],0); //Eq8  Pg,0 must be zero to avoid production in this period. this is not possible.                           
         	//cplex.addEq(W[p][0],0); //Eq7
         	cplex.addEq(R[p][0],0); //Eq9
         	cplex.addEq(W[p][0],0); //Eq10
         
            for (int t = 1; t < get_Main().simParams.getMRPPlanningHorizon(); t++) {
	           	cplex.addEq(cplex.sum(cplex.sum(I[p][t], X[p][t]),B[p][t-1]), 
                       cplex.sum(cplex.sum(I[p][t-1], P[p][t-1]),B[p][t]));
        	}
            
              
            cplex.addEq(W[p][0], R[p][0]);
            
            for (int t = 1; t < get_Main().simParams.getMRPPlanningHorizon(); t++) {
               cplex.addEq(cplex.sum(W[p][t], P[p][t-1]), 
                           cplex.sum(W[p][t-1], R[p][t]));   
                                                                                                                                    
            }			             											
         }
         
         //********************* Sum of RI_t == 1 *************************
         // RI_103_13_106.0_0R103_0 + RI_103_13_106.0_0R103_0 + RI_103_13_106.0_0R103_0 + RI_103_13_106.0_1R103_1  + RI_103_13_106.0_2R103_2 + RI_103_13_106.0_3R103_3  + RI_103_13_106.0_4R103_4 + RI_103_13_106.0_5R103_5 .... = 1       
         // CF Article EQ3 
          List<String> unique = new ArrayList();
          
          for (int p = 0; p < iQd.size(); p++) {
            IloLinearNumExpr num_expr_Sum_Binaries = cplex.linearNumExpr();  
            boolean weHaveRI = false;	           
	            for (int t = 1; t < leadtimeHorizon; t++) {	            	
	            	
	            	//int tmp_p = p;
	            	//int tmp_t = t;
	            	//traceln("test auf " + RI[tmp_p][tmp_t].getName());
	            	
	            	//boolean exists = unique.stream().filter(element -> element != null).anyMatch(element -> element.equals(RI[tmp_p][tmp_t].getName()));
	            	            	
	            	//if(!exists) {
	            		//unique.add(RI[tmp_p][tmp_t].getName());
	            		//traceln("p" + p + " t " + t );
	            		
	            		if(RI[p][t] != null){
	            		//traceln("ri not null");
	            		String variableName = RI[p][t].getName();
	            		//char isItRI = "RI";
	            		//traceln("Found variable " + variableName);
	            		
							           		
		            		if(variableName.contains("RI")){
		            			weHaveRI = true;
		            			num_expr_Sum_Binaries.addTerm(1,RI[p][t]);															
		            		}
		            		
	            		}
	            		
	            		
	            		//traceln("add" + RI[tmp_p][tmp_t].getName());
	            	//}else{
	            		//num_expr_Sum_Binaries.addTerm(0,RI[p][t]);															
	            	//}					
	            }
	            
	            //cplex.addEq(RI[p][0],0);
	            if(weHaveRI)
	            	cplex.addEq(num_expr_Sum_Binaries,1);
            }
         
         
         //RI structure
         //Eq2 where Rg,t = RIg,t*Xg,t
         //RI_item_Xt_qty_start_lth_...end_lth_Ritem_start_lth...end_lth
         for (int pp = 0; pp < itemsToPlan.size(); pp++) {
         	IloLinearNumExpr cf = cplex.linearNumExpr();				         
	       for (int t = 1; t < main.simParams.getMRPPlanningHorizon()-1; t++) {	            	            
			       	String o = "";
			       	int sizeExpr = 0;
			        IloLinearNumExpr num_expr = cplex.linearNumExpr();
			                    
	                for (int p = 0; p < iQd.size(); p++) {
	                	if(iQd.get(p).getItem()== itemsToPlan.get(pp).getItem().getItem()){
	                	
		            		if(releaseTmp[p][t] > 0){
		            			
		            			o = o + iQd.get(p).getQuantity() + "*" + RI[p][releaseTmp[p][t]-1].getName() +  "+";	            			
		            			num_expr.addTerm(iQd.get(p).getQuantity(),RI[p][releaseTmp[p][t]-1]);
		            					            					            					            			
		            			sizeExpr++;		            					            					            			
		            		}			        
	            		}
					}
					
				if(o.length() > 1){
		            if(sizeExpr > 0){
		            	//Constraint Release Size 
			            cplex.addEq(R[pp][t],num_expr);    
			                  
			        }

				}else{
				         cplex.addEq(R[pp][t],0);          								
				}
																
				num_expr.clear();             														
			}         
         }
         
     /*    
         //sumRIs: represent the RI for the leadtime horizon
         //required for EQ10 and EQ11 to get the setuptime as part of the clearing functions
         IloNumVar[] sumRIs = new IloNumVar[leadtimeHorizon];     
         //IloLinearNumExpr sumRIsI = cplex.linearNumExpr();			
         
           for (int t = 0; t < main.simParams.getMRPPlanningHorizon()-1; t++) {
           	IloLinearNumExpr sumRIsI = cplex.linearNumExpr();			
           	    
               for (int pp = 0; pp < itemsToPlan.size(); pp++) {        	            
		           for (int p = 0; p < iQd.size(); p++) {
		 				    if(iQd.get(p).getItem()== itemsToPlan.get(pp).getItem().getItem()){ 	
		 				    	if(releaseTmp[p][t] > 0){ 				    			
					        	//RI[p] = cplex.boolVarArray(leadtimeHorizon, RiNames[p]);					        	  
					        	  sumRIsI.addTerm(1.0,RI[p][releaseTmp[p][t]-1]); // the -1 allows releases RIt in the same period as Xt
						       	}//if
				       		}//if
				   		}//for
				   		           
	         		}//for
	         		sumRIs[t] = sumRIsI;
	         		sumRIsI.clear();
	         }//for                  
         
        */
        
        
		IloLinearNumExpr[] sumRIs = new IloLinearNumExpr[main.simParams.getMRPPlanningHorizon()];
		
		for (int t = 0; t < main.simParams.getMRPPlanningHorizon(); t++) {
		    IloLinearNumExpr sumRIsI = cplex.linearNumExpr();
		
		    for (int pp = 0; pp < itemsToPlan.size(); pp++) {
		        for (int p = 0; p < iQd.size(); p++) {
		            if (iQd.get(p).getItem() == itemsToPlan.get(pp).getItem().getItem()) {
		                if (releaseTmp[p][t] > 0) {
		                	//traceln("###### " + 1.0 + " :::: " +  RI[p][releaseTmp[p][t] - 1]);		                
		                    sumRIsI.addTerm(1.0, RI[p][releaseTmp[p][t] - 1]);
		                }
		            }
		        }
		    }
		    
		    sumRIs[t] = sumRIsI;		    		    		    
		    //sumRIsI.clear();
		}				
		             
         //Constraint avoiding that RI with later due date, releases order earlier that RI with earlier due date (orders should not overteak each other)
         //The release of order 2 should not before order 1                                         
         // ********************************* Guarantee Release ORDER  ****************************************
         // ***************************************************************************************************
         for (int pp = 0; pp < itemsToPlan.size(); pp++) {        	            
            for (int i = 0; i < leadtimeHorizon; i++) {
                for (int j = 0; j < iQd.size(); j++) {
                    for (int k = j + 1; k < iQd.size(); k++) {
                        IloLinearNumExpr constraint = cplex.linearNumExpr();
                                                                        
                        if(RI[j][i].getName() != "noRelease" && RI[k][i].getName() != "noRelease" && RI[j][i].getName() != null){
	                    
		                    String[] RiSplitted = RI[j][i].getName().split("_");                        
	                        int item =  Integer.parseInt(RiSplitted[1]);
	                        
	                        String[] RiSplitted2 = RI[k][i].getName().split("_");                        
	                        int item2 =  Integer.parseInt(RiSplitted2[1]);
	                        	                    
			                    if(itemsToPlan.get(pp).getItem().getItem() == item && itemsToPlan.get(pp).getItem().getItem() == item2){    
			                        constraint.addTerm(RI[j][i], 1.0); // 1 of set j		                        
			                        constraint.addTerm(RI[k][i], -1.0); // -1 of set k
			                        cplex.addLe(constraint, 0); // set j[i] - set k[i] <= 0
			                     }                                                   
	                        }
	                    }
	                }
	            }
	        }
                          
         //****************** CF SECTION ***************************************
         //*********************************************************************
         
         for (int t = 0; t < main.simParams.getMRPPlanningHorizon(); t++) {	    
         
	     	IloLinearNumExpr cf = cplex.linearNumExpr();				             	    
	     	IloLinearNumExpr cf1 = cplex.linearNumExpr();				             	    
	       	IloLinearNumExpr cf2 = cplex.linearNumExpr();				             	    
		   	IloLinearNumExpr cf3 = cplex.linearNumExpr();				             	    
	       	IloLinearNumExpr cf4 = cplex.linearNumExpr();				             	    

    	    
    	    //Pgt smaller Wgt - Constraint for single item qty
        	 for (int pp = 0; pp < itemsToPlan.size(); pp++) {        	  			
					//merk dir, dass die weiter unten verwendet werden
					//double setupProption = 18.0/106.0;
					double setupProption = 0;
					
	         		cf.addTerm(itemsToPlan.get(pp).getItem().getRouting().getEProcessingTime()+setupProption,P[pp][t]);	         		
	         		
	         		cf1.addTerm(itemsToPlan.get(pp).getItem().getRouting().getEProcessingTime()+setupProption,P[pp][t]); 	         		        		
         			cf2.addTerm(itemsToPlan.get(pp).getItem().getRouting().getEProcessingTime()+setupProption,W[pp][t]);         			         		        			         			
         			
         			cf3.addTerm(itemsToPlan.get(pp).getItem().getRouting().getEProcessingTime()+setupProption,P[pp][t]);         		
         			cf4.addTerm(itemsToPlan.get(pp).getItem().getRouting().getEProcessingTime()+setupProption,W[pp][t]);
         			
         			
         			//***************** Ppt, <= Wp,t ***********************        			         		         			
         			cplex.addLe(
         				//cplex.sum(P[pp][t],cplex.prod(0,sumRIs[t])),//LHS         			
         				cplex.sum(P[pp][t],0),//LHS         			
        				cplex.sum(W[pp][t],0));//RHS         			
        			//****************************************        			         		         				
        				        				        				        			        			        				
        	  }
        	          	  
			  //CF Constraints			           	  
			  //PL <= MC + Ct (Eq12)			  
			  //traceln("setup time " + setupTime + " sum ri " + sumRIs);
         	  //cplex.addLe(cplex.sum(cf,cplex.prod(setupTime,sumRIs)), //LHS         	  
         	  
         	  
         	  // **************** PL und L ausgeben *********************
         	  //keine constraints werden spter so auch nicht wiedervendet
         	  cplex.addEq(PL[t],cf);
         	  cplex.addEq(L[t],cf2);
         	  //********************************************************* 
         	  
         	  
         	  //cplex.addEq(PL[t],cplex.sum(cf,cplex.prod(setupTime,sumRIs)));
         	  //cplex.addEq(L[t],cplex.sum(cf2,cplex.prod(setupTime,sumRIs)));         	           	           	           	  
         	  
         	  /******** PLt <=MC+Ct (Eq14) ************/
         	  if(t==0){         	           	           	           	  
         	  		cplex.addLe(cf,         	  
         	  		cplex.sum(0,C[t]));	//RHS
         	  	}else{
         	  		//cplex.addLe(cf,         	  		
         	  		//traceln("da" + sumRIs[t].toString());
         	  		cplex.addLe(cplex.sum(cf,cplex.prod(setupTime,sumRIs[t])),         	  
         	  		cplex.sum(maxCapacity,C[t]));	//RHS
         	  	}
         	           	           	           	  		         	           	           	  
         	           	           	  
         	  // ---- we have three segments         	           	           	  
			  //CF partition 2 from numerical example
			  //traceln("# segments " + numberSegments);
			  //represent CF as k*x + d -> 
			  for(int i = 0; i < numberSegments; i++){
	         	  cplex.addLe(
    	     	  	cplex.sum(cf1,cplex.prod(setupTime,sumRIs[t])), //LHS				
				
         	  		cplex.sum(cplex.sum(cplex.prod(max(slopes[i],0),         	  	         	  	
         	  		
         	  		cplex.sum(cf2,cplex.prod(setupTime,sumRIs[t]))),intercepts[i]),C[t]));//RHS         	  		         	  						
         	  	
         	  		traceln("Slope (x): " + slopes[i] + " Y-intercept (d) " + intercepts[i]);
         	  		         	  		
         	  	//traceln("sumRIs " + sumRIs + " st " + setupTime);	
         	  }//for
         	           	           	           	  
         	           	           	           	  			           	  
         	  /******************************* PLt <= Lt + Ct (Eq18) *********************/
         	  //Constraint Pl musst be smaller as SL for all t         	           	  
         	  cplex.addLe(
         	  	cplex.sum(cf3,cplex.prod(setupTime,sumRIs[t])), //LHS         	  
	         	cplex.sum(cplex.sum(cf4,cplex.prod(setupTime,sumRIs[t])),C[t]));         	  	         	
	          //***************************************************************************
         	  
			  cf.clear();
			  cf1.clear();
 			  cf2.clear();
 			  cf3.clear();
 			  cf4.clear();
         }



// Create a two-dimensional array of IloNumVars
            int numRows = iQd.size(); // Assuming iQd is a list or array
            
            
            // ... Initialize and populate the RI array with IloNumVars ...

            // Find the variable by name in the RI array
            String targetVariableName = "noRelease";
            boolean isVariableFound = false;
            IloNumVar foundVariable = null;

            for (int i = 0; i < numRows; i++) {
                for (int j = 1; j < RI[i].length-1; j++) {
                    IloNumVar var = RI[i][j];
                    if (var.getName().equals(targetVariableName)) {
                        isVariableFound = true;
                        foundVariable = var;
                        break;
                    }
                }
                if (isVariableFound) {
                    break;
                }
            }
            
            if (isVariableFound) {
                // Add a constraint to enforce the found variable to be zero
                traceln("Yes found");                
                foundVariable.setName("noRelease");                                
                cplex.addEq(foundVariable, 0);
            }
                                                               
    
    //cplex.deleteNames();
    
    //if(time() == 0)
    if(Tools.Log_CF_Optimization_Values){                 
		cplex.exportModel("model/NewModel_" + time() + "_" + bomLevel + ".lp");
	}	
	//cplex.writeSolution("model/NewModel_" + time() + "_" + bomLevel + ".sol");

	//cplex.setParam(IloCplex.BooleanParam.PreInd, true);
	//0.05 were to hard ... 0.1 before
	//cplex.setParam(IloCplex.Param.MIP.Tolerances.MIPGap, 0.05);
	//cplex.setParam(IloCplex.IntParam.DataCheck, 2);	
	cplex.setParam(IloCplex.IntParam.WorkMem, 2000);
						
	if(cplex.solve() && Tools.Log_CF_Optimization_Values){
		    
		    System.out.println("Solution status: " + cplex.getStatus());
            System.out.println();
            System.out.println("Objective Value = " + cplex.getObjValue());
          
            System.out.println("Pieces: Wip, X, Release, P");
            System.out.println("Minutes: PL L, MC, CF1, CF2, CF3");
            System.out.println("\tp\tTime\tt\tWip\tX\tRelease\tP\tPL\tL\tMC\tCF1\tCF2\tCF3\tInv\tIBl\tWB\tObjPP\tCt\tBt\tPTime\tSTime\tPL");
          	
            int[] t_sum_wip = new int[get_Main().simParams.getMRPPlanningHorizon()];
            int[] t_sum_pl = new int[get_Main().simParams.getMRPPlanningHorizon()];
            int[] t_sum_l = new int[get_Main().simParams.getMRPPlanningHorizon()];
            int[] t_sum_load = new int[get_Main().simParams.getMRPPlanningHorizon()];
            int[] t_sum_x = new int[get_Main().simParams.getMRPPlanningHorizon()];
            int[] t_sum_r = new int[get_Main().simParams.getMRPPlanningHorizon()];
            int[] t_sum_p = new int[get_Main().simParams.getMRPPlanningHorizon()];
          	
            for (int p = 0; p < itemsToPlan.size(); p++) {
                        	
               for (int t = 0; t < get_Main().simParams.getMRPPlanningHorizon(); t++) {
               
               double inventoryBalance = 0;
               double wipBalance = 0;

               if(t>0){
                  inventoryBalance = cplex.getValue(I[p][t-1])-X[p][t]+cplex.getValue(P[p][t-1]) - cplex.getValue(B[p][t-1]) + cplex.getValue(B[p][t]);
                  wipBalance = cplex.getValue(W[p][t-1])+cplex.getValue(R[p][t])-cplex.getValue(P[p][t-1]);               
               }
               		
               	  double lt = cplex.getValue(W[p][t])*itemsToPlan.get(p).getItem().getRouting().getEProcessingTime();
               	  double pl = cplex.getValue(P[p][t])*itemsToPlan.get(p).getItem().getRouting().getEProcessingTime();
               	  double objectivePerPeriod = cplex.getValue(W[p][t]) * wipCosts + cplex.getValue(I[p][t]) * inventoryHoldingCosts;
               	  
               	  
               	  int slope2 = -99;
               	  int slope3 = -99;
               	  
               	  if(selectedSegments.size() == 2){
               	  	slope2 = (int)(slopes[1]*lt+intercepts[1]);
               	  }
               	  
              	  if(selectedSegments.size() == 3){
               	  	slope3 = (int)(slopes[2]*lt+intercepts[2]);
               	  }
               	                 	  
               	  int wipForPrintLn = (int)cplex.getValue(W[p][t]);               	                 	                 	  
               	  
                  System.out.println("\t" + itemsToPlan.get(p).getItem().getItem() +
                                     "\t" + (time() + t) +
                                     "\t" + t +
                                     //"\t" + (int)cplex.getValue(W[p][t]) +
                                     "\t" + (int)Math.round(wipForPrintLn) +
                                     "\t" + X[p][t] +
                                     "\t" + (int)Math.round(cplex.getValue(R[p][t])) +       
                                     //"\t" +  +                                                       
                                     "\t" + (int)cplex.getValue(P[p][t]) +
                                     "\t" + (int)Math.round(pl) +
                                     "\t" + (int)Math.round(lt) +
                                     "\t" + maxCapacity + 
                                     "\t" + (int)(slopes[0]*lt+intercepts[0]) + 
                                     "\t" + slope2 + 
                                     "\t" + slope3 +                                      
                                     "\t" + Math.round(cplex.getValue(I[p][t])) +
                                     "\t" + Math.round(inventoryBalance) +
                                     "\t" + (int)Math.round(wipBalance) +
                                     "\t" + (int)Math.round(objectivePerPeriod) +
                                     "\t" + Math.round(cplex.getValue(C[t])) +
                                     "\t" + (int)cplex.getValue(B[p][t]) + 
                                     "\t" + itemsToPlan.get(p).getItem().getRouting().getEProcessingTime() +
                                     "\t" + itemsToPlan.get(p).getItem().getRouting().getESetupTime()  +
                                     "\t" + (int)cplex.getValue(PL[t]) +      
                                     "\t" + (int)cplex.getValue(L[t])       
                                     );                                                                                                 
            
            		//t_sum_wip[t] += wipForPrintLn;
            		
            		t_sum_x[t] += X[p][t];            		
            		t_sum_wip[t] += (int)cplex.getValue(W[p][t]) ;
            		t_sum_r[t] += (int)Math.round(cplex.getValue(R[p][t]));            		
            		t_sum_p[t] += (int)cplex.getValue(P[p][t]);
            		
            		//if(t==0){
            			t_sum_pl[t] = (int)cplex.getValue(PL[t]);
            			t_sum_l[t] = (int)cplex.getValue(L[t]);
            		//}
            			
            		t_sum_load[t] += lt;
                                    
                    //OptimizationResult optResult = new OptimizationResult(time(),itemsToPlan.get(p).getItem().getItem(), t,
                    //cplex.getValue(W[p][t]), cplex.getValue(R[p][t]), 0,cplex.getValue(P[p][t]),
                    //cplex.getValue(I[p][t]) );                    
                    //get_Main().optimizationResults.add(optResult);                                                      
               }                              
            }
            
            System.out.println("\n");
            System.out.println("\tTime\tt\tX\tWip\tR\tP\tPL\tL");           
            for(int t = 0; t < get_Main().simParams.getMRPPlanningHorizon(); t++) {
            
            	System.out.println(
            		"\t" + (time() + t) +
       				"\t" + t +           
       				"\t" + t_sum_x[t] + 		
            		"\t" + t_sum_wip[t] +
            		"\t" + t_sum_r[t] +
            		"\t" + t_sum_p[t] +
	           		"\t" + t_sum_pl[t] +
            		"\t" + t_sum_l[t]            	
            	);            
            }
                 	  
            
            //if(OptimizationResult.WRITE_OPTIMIZATION_RESULTS_TO_XLXS)
			//OptimizationResult.WriteXlsxOptimizationResults(get_Main().optimizationResults, get_Main().simParams);            
            	//traceln("size +++++++++++ " + get_Main().optimizationResults.size());
            
		}else{
			traceln("NO Solution " + cplex.getStatus());
		}												


			/*
        	for (int p = 0; p < iQd.size(); p++) {        	        
               for (int t = 0; t < leadtimeHorizon; t++) {   
                            
                            traceln("da");
					        
					        //double qty = cplex.getValue(RI[p][t]);    			            			            		            
					        double qty = 99;					        					        
							int itemIntTmp = iQd.get(p).getItem();
					        traceln(RI[p][t].getName().split("_"));
					        traceln("item " + itemIntTmp + " p " + p + "t " + t + "qty " + qty);
			}
			}
        	*/
        	
        	for (int p = 0; p < iQd.size(); p++) {        	        
               for (int t = 1; t < leadtimeHorizon; t++) {   
            				            
            				//traceln("da vor qty " + p + " " + t + " " + RI[p][t].getName());            				            				
					        					        				        
					        if(RI[p][t].getName() != "noRelease"){
					        	
					        
					        double qty = cplex.getValue(RI[p][t]);    			            			            		            
					        //traceln(qty);
					        //traceln("da for if");				               					        
							if(qty > 0.9){
					        //traceln("da");				               					        
								
								//traceln("qty " + qty + " " + RI[p][t].getName());
							
			                    ProductionOrder order = new ProductionOrder();
			                    								
								int itemIntTmp = iQd.get(p).getItem();
									
			                    Item item = get_Main().items.stream().filter(e -> e.getItem() == itemIntTmp).findFirst().get();																		                     
			                    
			                    order.setOrderId(get_Main().prodOrderId++);
			                    order.setItem(item);
			                                                                                                                                  
								order.setPlannedCapacity(Routing.GetPlannedCapacityPerItem(get_Main().routings, order.getItem(), get_Main().simParams, order));
			                    
			                    int minimumRoutingStep = Routing.GetMinimumStep(get_Main().routings, order.getItem() , get_Main().simParams);
								int maximumRoutingStep = Routing.GetMaximumStep(get_Main().routings, order.getItem() , get_Main().simParams);
						
								order.setMinimumRoutingStep(minimumRoutingStep);
								order.setMaximumRoutingStep(maximumRoutingStep);			
								order.setCurrentRoutingStep(minimumRoutingStep);                                        			                    
			                    
			                                                            
			                    //order.setQuantity(Math.round(iQd.get(p).getQuantity()));
			                    
			                    //traceln("################################## " + iQd.get(p).getQuantity());
			                    
			                    order.setQuantity(Math.ceil(iQd.get(p).getQuantity()));
			                    
			                    order.setCreatedAt(time());			                    
			                    
			                    //get the start and end dates from the RI decision variables			                    
			                    String[] RiSplitted = RI[p][t].getName().split("_");
			                    
			                    traceln(RI[p][t].getName().split("_"));
			                    
			                    //order.setPlannedStart(max(Integer.parseInt(RiSplitted[5]) + time() - item.getSafetyLeadTime(), time()));
			                    //order.setPlannedStart(Integer.parseInt(RiSplitted[5] + time());

			                    //safety leadtime for stochastic scenario
			                    //order.setPlannedStart(max(Integer.parseInt(RiSplitted[5]) + time() - 1, time()));
			                    
			                   // order.setPlannedStart(max(Integer.parseInt(RiSplitted[5]) + time() - 1, time()));
			                    
			                    order.setPlannedStart(max(Integer.parseInt(RiSplitted[5]) + time(), time()));

			                    order.setPlannedEnd(Integer.parseInt(RiSplitted[2]) + time());
			                    
			                    traceln("Start " + order.getPlannedStart() +  " Time " + time());
			                    
			                    long exists = 0;	
			                    		                    
			                    if(order.getPlannedStart() < time())
			                    	exists = 1;
			                    											
				                    if(exists == 0){
				                    	//traceln("Production Order Added");														                    
					                    Routing routingObject = get_Main().routings.stream().filter(e -> e.getItem().getItem() == order.getItem().getItem()).findFirst().get();			
										order.setRouting(routingObject);
										order.setStatus(ProductionOrder.PRODUCTION_ORDER_STATUS_UNPROCESSED);
					                    
					                    get_Main().productionOrders.add(order);	                    						
														                    
				                    }//if
		                    	}// if qty	
		                    	}	                    
		                 }//for            
		            }//for
                        
        if(false) {
			traceln("Production Orders from Optmization Before Removing");
			traceln(ProductionOrder.GetCSVHeader());
			
	        for (ProductionOrder order: get_Main().productionOrders) {
	           traceln(ProductionOrder.GetCSVString(order));
	        }        
			
	        //get_Main().productionOrders.removeIf(e -> e.getPlannedStart() > time());
	
	        traceln("Production Orders from Optmization FOR SIMULATION");
	        traceln(ProductionOrder.GetCSVHeader());
	
	        for (ProductionOrder order: get_Main().productionOrders) {
	            traceln(ProductionOrder.GetCSVString(order));
	        }        
	        traceln("**************************");                							
        }
		
		//get_Main().Function_OrderRelease();
		
		cplex.deleteNames();        
    	if(Tools.Log_CF_Optimization_Values){                 
			cplex.exportModel("model/NV/NewModel" + time() + "_" + bomLevel + ".lp");
		}	
		
		cplex.end();		
	}
	catch (IloException exc) {
         System.err.println("Concert exception '" + exc.getMessage() + "' caught");
         System.exit(-1);
    }

return 0;
]]></Body>
				</Function>
				<Function AccessType="default" StaticFunction="false">
					<ReturnModificator>RETURNS_VALUE</ReturnModificator>
					<ReturnType><![CDATA[int]]></ReturnType>
					<Id>1696238423081</Id>
					<Name><![CDATA[lateProductionOrdersQty]]></Name>
					<X>50</X><Y>440</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Parameter>
						<Name><![CDATA[item]]></Name>
						<Type><![CDATA[int]]></Type>
					</Parameter>
					<Parameter>
						<Name><![CDATA[plannedEnd]]></Name>
						<Type><![CDATA[double]]></Type>
					</Parameter>
					<Body><![CDATA[
int lateOrdersQty;

List<ProductionOrder> lateOrders = main.productionOrders.stream().filter(e -> e.getItem().getItem() == item &&																		
		e.getPlannedEnd() < plannedEnd &&
		(e.getStatus() == ProductionOrder.PRODUCTION_ORDER_WAITING_FOR_MATERIAL || e.getStatus() == ProductionOrder.PRODUCTION_ORDER_STATUS_UNPROCESSED || 
		e.getStatus() == ProductionOrder.PRODUCTION_ORDER_STATUS_RELEASED)
		).collect(Collectors.toList());

lateOrdersQty = (int) lateOrders.stream().mapToDouble(ProductionOrder::getQuantity).sum();																		

if(lateOrdersQty > 0){
	traceln("Found Late Order(s):");
	lateOrders.stream().forEach(order -> traceln(order.getOrderId() + " Planned Start: " + order.getPlannedStart() + " Planned End: " + order.getPlannedEnd() + " Actual Start: " + order.getActualStart() + " Qty: " + order.getQuantity() + " Item: " + order.getItem().getItem()));
}	

return lateOrdersQty;]]></Body>
				</Function>
				<Function AccessType="default" StaticFunction="false">
					<ReturnModificator>RETURNS_VALUE</ReturnModificator>
					<ReturnType><![CDATA[int]]></ReturnType>
					<Id>1696322260172</Id>
					<Name><![CDATA[Function_ClearingFunction2]]></Name>
					<X>50</X><Y>80</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Parameter>
						<Name><![CDATA[itemsToPlan]]></Name>
						<Type><![CDATA[List<MRP>]]></Type>
					</Parameter>
					<Parameter>
						<Name><![CDATA[bomLevel]]></Name>
						<Type><![CDATA[int]]></Type>
					</Parameter>
					<Parameter>
						<Name><![CDATA[inResource]]></Name>
						<Type><![CDATA[Resource]]></Type>
					</Parameter>
					<Parameter>
						<Name><![CDATA[fileSuffix]]></Name>
						<Type><![CDATA[String]]></Type>
					</Parameter>
					<Body><![CDATA[try{

Tools to = new Tools();
							
traceln("----------- Start CF OPTIMIZATION at " + time () + " ----------------");
							
StringBuilder output = new StringBuilder();

int maxCapacity = 1440;
double wipCosts = 0;
double inventoryHoldingCosts = 0;
traceln("Total found Segments: " + ClearingFunctionSegments.size());


/*
Iterator<MRP> iterator = itemsToPlan.iterator();
while (iterator.hasNext()) {
    MRP o = iterator.next();
    if (o.getItem().getItem() == 103 ||     
    o.getItem().getItem() == 111 ||
    o.getItem().getItem() == 115 ||
    o.getItem().getItem() == 119 ||
    o.getItem().getItem() == 123 ||
    o.getItem().getItem() == 127 ||
    o.getItem().getItem() == 131
    ) {
        iterator.remove(); // Safely remove the element from the list
    }
}
*/

	//via the bom level the cf is associated
	List<ClearingFunctionSegments> selectedSegments = new ArrayList();
	Item firstBomItem = itemsToPlan.get(0).getItem();
	wipCosts = firstBomItem.getHoldingCostsWIP();
	inventoryHoldingCosts = firstBomItem.getHoldingCosts();	
	
	//Routing firstRoutingItem = main.routings.stream().filter(e -> e.getItem().getItem() == firstBomItem.getItem()).findFirst().get();	
	//Resource firstResource= main.resources.stream().filter(e -> e.getName().equalsIgnoreCase(firstRoutingItem.getResource())).findFirst().get();
	
	//maxCapacity = inResource.getCapacity();
	//don't map it to the prodction stage 1-4, select the values based on the resource
	traceln("Total found segments: " + selectedSegments);
	
	if(firstBomItem.getLotsizePolicy().equalsIgnoreCase(Item.LOT_POLICY_FOP)) {
		int fop = firstBomItem.getFOPPeriod();	
		traceln("FOP Period:" + fop);	
					
		selectedSegments = ClearingFunctionSegments.stream().filter(e -> e.getLotParameter() == fop &&
							 e.getLotPolicy().equalsIgnoreCase(Item.LOT_POLICY_FOP) && e.getResource().equalsIgnoreCase(inResource.getName()) 
				 && e.getExperiment().equalsIgnoreCase(main.simParams.getExperiment())).collect(Collectors.toList());															 																								
	}
	else if(firstBomItem.getLotsizePolicy().equalsIgnoreCase(Item.LOT_POLICY_FOQ)) {
		int foq = (int)firstBomItem.getFOQQuantity();	
		traceln("FOQ Qty:" + foq);	
					
		selectedSegments = ClearingFunctionSegments.stream().filter(e -> e.getLotParameter() == foq &&
							 e.getLotPolicy().equalsIgnoreCase(Item.LOT_POLICY_FOQ) && e.getResource().equalsIgnoreCase(inResource.getName()) 
				 && e.getExperiment().equalsIgnoreCase(main.simParams.getExperiment())).collect(Collectors.toList());															 																								
	}
				
	traceln("Resource: " + inResource.getName());
	traceln("Resource Stage Number: " + inResource.getStageNumber());
	traceln("Production Stage: " + (bomLevel + 1));
	traceln("Max Capacity: " + maxCapacity);
	
	traceln("Items to Plan: ");
	itemsToPlan.forEach(e -> traceln(e.getItem().getItem() + " eProcessingTime " + e.getItem().getRouting().getEProcessingTime() + ";"));

	traceln("Selected Slopes: ");		
	selectedSegments.forEach(e -> traceln(e.getSlope() + ";"));
	traceln("Selected Intercepts: ");
	
	selectedSegments.forEach(e -> traceln(e.getyIntercept() + ";"));
	
	if(selectedSegments.size() == 0){
		traceln("STOP Simulation: No Segments found!");
		System.exit(0);
	}
	
	to.log("Segment Cnt: " + selectedSegments.size(), Tools.LogCFOptimization);
	
	double intercepts[] = new double[selectedSegments.size()];
	double slopes[] = new double[selectedSegments.size()];
	
	for(int i = 0; i < selectedSegments.size(); i++) {
		slopes[i] = selectedSegments.get(i).getSlope();
		intercepts[i] = selectedSegments.get(i).getyIntercept();
	}		
			
int numberSegments = selectedSegments.size();

double oCosts = 0;
double oFactor = 1000;
double setupTime = 18; //standard = 18
int leadtimeHorizon = main.simParams.getLeadTimeHorizon();


traceln("Leadtime Horizon: " + leadtimeHorizon);

IloCplex cplex = new IloCplex();

     String[][] Inames = new String[itemsToPlan.size()][get_Main().simParams.getMRPPlanningHorizon()];
     String[][] Pnames = new String[itemsToPlan.size()][get_Main().simParams.getMRPPlanningHorizon()];
     String[] PLnames = new String[get_Main().simParams.getMRPPlanningHorizon()];
     String[] Lnames = new String[get_Main().simParams.getMRPPlanningHorizon()];
     String[][] Wnames = new String[itemsToPlan.size()][get_Main().simParams.getMRPPlanningHorizon()];
     String[][] Rnames = new String[itemsToPlan.size()][get_Main().simParams.getMRPPlanningHorizon()];     
     String[][] Bnames = new String[itemsToPlan.size()][get_Main().simParams.getMRPPlanningHorizon()];     
     
     for(int i = 0; i< get_Main().simParams.getMRPPlanningHorizon(); i++){
          for (int p = 0; p < itemsToPlan.size(); p++) {
        	 	Inames[p][i] = "I" + itemsToPlan.get(p).getItem().getItem() + "_" + i; 
        	 	Pnames[p][i] = "P" + itemsToPlan.get(p).getItem().getItem() + "_" + i; 
        	 	Wnames[p][i] = "W" + itemsToPlan.get(p).getItem().getItem() + "_" + i; 
        	 	Rnames[p][i] = "R" + itemsToPlan.get(p).getItem().getItem() + "_" + i; 
        	 	Bnames[p][i] = "B" + itemsToPlan.get(p).getItem().getItem() + "_" + i; 
        	 	PLnames[i] = "PL" + itemsToPlan.get(p).getItem().getItem() + "_" + i; 
        	 	Lnames[i] = "L" + itemsToPlan.get(p).getItem().getItem() + "_" + i; 
	     }
     }

     IloNumVar[] C = new IloNumVar[main.simParams.getMRPPlanningHorizon()];
     for (int t = 0; t < get_Main().simParams.getMRPPlanningHorizon(); t++) {
        C[t] = cplex.numVar(0, Double.MAX_VALUE, "C" + "_" + t);
     }
     
     IloNumVar[][] I = new IloNumVar[itemsToPlan.size()][];
     for (int p = 0; p < itemsToPlan.size(); p++) {
        I[p] = cplex.numVarArray(get_Main().simParams.getMRPPlanningHorizon(), 0, Double.MAX_VALUE, Inames[p]);
        oCosts += itemsToPlan.get(p).getItem().getHoldingCosts();
     }
     
     oCosts = oFactor*oCosts;
     
     IloNumVar[][] P = new IloNumVar[itemsToPlan.size()][];
     for (int p = 0; p < itemsToPlan.size(); p++) {     
        P[p] = cplex.numVarArray(get_Main().simParams.getMRPPlanningHorizon(), 0,  Double.MAX_VALUE, Pnames[p]);        
     }
     
     IloNumVar[] PL = new IloNumVar[leadtimeHorizon];     
     IloNumVar[] L = new IloNumVar[leadtimeHorizon];     
     
     for (int t = 0; t < leadtimeHorizon; t++) {               
     	PL[t] = cplex.numVar(0,  Double.MAX_VALUE, PLnames[t]);
     	L[t] = cplex.numVar(0,  Double.MAX_VALUE, Lnames[t]);
     }
     
                    
     IloNumVar[][] W = new IloNumVar[itemsToPlan.size()][];
     for (int p = 0; p < itemsToPlan.size(); p++) {
        W[p] = cplex.numVarArray(get_Main().simParams.getMRPPlanningHorizon(), 0, Double.MAX_VALUE, Wnames[p]);
     }
		
	 IloNumVar[][] R = new IloNumVar[itemsToPlan.size()][];
     for (int p = 0; p < itemsToPlan.size(); p++) {
        R[p] = cplex.numVarArray(get_Main().simParams.getMRPPlanningHorizon(), 0.0, Double.MAX_VALUE, Rnames[p]);
     }          
     
     IloNumVar[][] B = new IloNumVar[itemsToPlan.size()][];
     for (int p = 0; p < itemsToPlan.size(); p++) {
        B[p] = cplex.numVarArray(get_Main().simParams.getMRPPlanningHorizon(), 0.0, Double.MAX_VALUE, Bnames[p]);
     }
               	
	double[] inventory = new double[itemsToPlan.size()];
	double[] wip = new double[itemsToPlan.size()];
	double[] produce = new double[itemsToPlan.size()];
	double[] tl = new double[itemsToPlan.size()];
		
	int[][] X = new int[itemsToPlan.size()][get_Main().simParams.getMRPPlanningHorizon()];

	List<SpecialObject> iQd = new ArrayList<SpecialObject>();
	List<SpecialObject> runningOrders = new ArrayList<SpecialObject>();
	
     for (int p = 0; p < itemsToPlan.size(); p++) {      	     

     		   inventory[p] = 0;
     		   
     		   //wip[p] = (int)ProductionOrder.GetCurrentWip(get_Main().productionOrders, itemsToPlan.get(p).getItem(), get_Main().simParams);
     		   	wip[p]=0;
     		   
	        	int tmp_item = itemsToPlan.get(p).getItem().getItem();
				     		
     		   produce[p] = 0;
     		   
     		   //tl[p] = itemsToPlan.get(p).getItem().getTransportLotSize();
     	       for (int t = 0; t < get_Main().simParams.getMRPPlanningHorizon(); t++) {               	                          	               	
	               			               		               		               		               	
	               	//int tmp_item = itemsToPlan.get(p).getItem().getItem();
	               	int temp_t = t;
	               	int quantityRunningProductionOrders = remainingProductionOrderQty(tmp_item,t + time());
	               	
	               	MRP mrpItem = get_Main().mrpTable.stream().filter(e -> e.getItem().getItem() == tmp_item
	               	 && e.getTime() == time() && e.getPeriod() == temp_t).findFirst().orElseGet(() -> new MRP());
					
					if(t == 0){
	               		//lateOrders= (int) mrpItem.getPlannedOrderReceipts();	        			
	               	}
					
					if(quantityRunningProductionOrders > 0){
						traceln("RunningProduction Order Qty: " + quantityRunningProductionOrders + " time: " + time() + " t " + t + " item " + tmp_item);
						traceln("old Xpt: " + X[p][t]);
						
						if(t == 0){
							X[p][1] += quantityRunningProductionOrders;
						}else{
							X[p][t] += quantityRunningProductionOrders;
						}															
						
						traceln("Now we have to consider the Remaining Qty for Capacity Consumption of: " + X[p][t]);
						
						SpecialObject runningOrder = new SpecialObject(
	        				mrpItem.getItem().getItem(),
	        				X[p][t], 
	        				t,
	        				quantityRunningProductionOrders);
	        				
	        			runningOrders.add(runningOrder);						
					}
															
					if(t == 1){
						int lateOrders = lateProductionOrdersQty(tmp_item,t + time());
	        			X[p][t] += (int) mrpItem.getPlannedOrderReceipts() + lateOrders;	        				        			
	        		}else if(t > 1){
	        			X[p][t] += (int) mrpItem.getPlannedOrderReceipts();
	        		}

					traceln("X[" + p + "," + t + "] " + X[p][t]);	        				        			        		
	        		if(X[p][t] > 0 && t > 0) {
	        			SpecialObject so = new SpecialObject(
	        				mrpItem.getItem().getItem(),
	        				X[p][t], 
	        				t,
	        				quantityRunningProductionOrders);
	        			iQd.add(so);
	        			
	        			//traceln("~~~~~~~~~~~~~" + so.getItem() + " qty: " + so.getQuantity() + " dd " + so.getDueDate());
	        			
	        		}        		  	        		        		
            }     	      	
     }
          
     String[][] RiNames = new String[iQd.size()][leadtimeHorizon];
     int[][] releaseTmp = new int[iQd.size()][main.simParams.getMRPPlanningHorizon()];
     String[] releaseForX = new String[iQd.size()];

	 // this combinations are constructed .. every time the due date in this case 13, a 0 value is added RI_103_13_106.0_0R103_0
	 
	 //RI_103_13_106.0_0R103_0 + RI_103_13_106.0_0R103_0
       //+ RI_103_13_106.0_0R103_0 + RI_103_13_106.0_1R103_1
       //+ RI_103_13_106.0_2R103_2 + RI_103_13_106.0_3R103_3
       //+ RI_103_13_106.0_4R103_4 + RI_103_13_106.0_5R103_5
       //+ RI_103_13_106.0_6R103_6 + RI_103_13_106.0_7R103_7
       //+ RI_103_13_106.0_8R103_8 + RI_103_13_106.0_9R103_9
       //+ RI_103_13_106.0_10R103_10 + RI_103_13_106.0_11R103_11
       //+ RI_103_13_106.0_12R103_12 + RI_103_13_106.0_13R103_13 
	 
	 //for each Xt > 0 an entry to iQd is added and this represnts all Xts of all planned products!
     for (int p = 0; p < iQd.size(); p++) {
          for(int i = 1; i < leadtimeHorizon; i++){
          		int targetT = (int)(iQd.get(p).getDueDate() - leadtimeHorizon + i + 1);          		
          		
          		if(targetT < 0)
          			targetT = 0; // is 0 as this are values later thaen the due date e.g. 13
          		          		
          		releaseTmp[p][targetT] = i+1;
          		
          		if(targetT > 0){          		          		
        	 		RiNames[p][i] = "RI_" +  iQd.get(p).getItem() + "_" + (int)iQd.get(p).getDueDate() +         	 	
        	 		"_" + iQd.get(p).getQuantity() + "_" + targetT + "R" + iQd.get(p).getItem() + "_" + targetT; 
        	 	}else{
        	 		RiNames[p][i] = "noRelease";// + p + "" + i;
        	 	}        	 	        	 	
        	 	
        	 	//traceln(RiNames[p][i]);
	     }    
     }


	 //for each product we need the individual releases RI.....They are constructed with the above equation.            
	 //traceln("iQd.size " + iQd.size());
     IloNumVar[][] RI = new IloNumVar[iQd.size()][];
     for (int p = 0; p < iQd.size(); p++) {
          	     	
     	//e.g. if we have 8 releases while iqd.size = 8 and this all all the xts, we also need 8 RIs to get an individual decision for each Xt, which must be associated with an Release
     	// in each RiNames the item and due date (item and xt) is coded, consequently this works. 
        RI[p] = cplex.boolVarArray(leadtimeHorizon, RiNames[p]);                
        
     }                                      
            
     	//Objective Function     
		IloLinearNumExpr objFunction  = cplex.linearNumExpr();
	         
        for (int p = 0; p < itemsToPlan.size(); p++) {
           for (int t = 0; t < get_Main().simParams.getMRPPlanningHorizon(); t++) {
              objFunction.addTerm (itemsToPlan.get(p).getItem().getHoldingCosts(), I[p][t]);
            }
         }

        for (int p = 0; p < itemsToPlan.size(); p++) {
           for (int t = 0; t < get_Main().simParams.getMRPPlanningHorizon(); t++) {
             objFunction.addTerm (itemsToPlan.get(p).getItem().getHoldingCostsWIP(), W[p][t]);
            }                     	            
         } 
         
         for (int p = 0; p < itemsToPlan.size(); p++) {
           for (int t = 0; t < get_Main().simParams.getMRPPlanningHorizon(); t++) {
             objFunction.addTerm (itemsToPlan.get(p).getItem().getBacklogCosts(), B[p][t]);
            }                     	            
         } 
         
                  
         for (int t = 0; t < get_Main().simParams.getMRPPlanningHorizon(); t++) {
             objFunction.addTerm (oCosts, C[t]);
         }                     	                              
                                      
         cplex.addMinimize(objFunction); //objective function
       
         for (int p = 0; p < itemsToPlan.size(); p++) {
           		
         	cplex.addEq(I[p][0],0); //Eq7
         	cplex.addEq(P[p][0],0); //Eq8  Pg,0 must be zero to avoid production in this period. this is not possible.                           
         	//cplex.addEq(W[p][0],0); //Eq7
         	cplex.addEq(R[p][0],0); //Eq9
         	cplex.addEq(W[p][0],0); //Eq10
         
            for (int t = 1; t < get_Main().simParams.getMRPPlanningHorizon(); t++) {
	           	cplex.addEq(cplex.sum(cplex.sum(I[p][t], X[p][t]),B[p][t-1]), 
                       cplex.sum(cplex.sum(I[p][t-1], P[p][t-1]),B[p][t]));
        	}
            
              
            cplex.addEq(W[p][0], R[p][0]);
            
            for (int t = 1; t < get_Main().simParams.getMRPPlanningHorizon(); t++) {
               cplex.addEq(cplex.sum(W[p][t], P[p][t-1]), 
                           cplex.sum(W[p][t-1], R[p][t]));   
                                                                                                                                    
            }			             											
         }
         
         //********************* Sum of RI_t == 1 *************************
         // RI_103_13_106.0_0R103_0 + RI_103_13_106.0_0R103_0 + RI_103_13_106.0_0R103_0 + RI_103_13_106.0_1R103_1  + RI_103_13_106.0_2R103_2 + RI_103_13_106.0_3R103_3  + RI_103_13_106.0_4R103_4 + RI_103_13_106.0_5R103_5 .... = 1       
         // CF Article EQ3 
          List<String> unique = new ArrayList();
          
          for (int p = 0; p < iQd.size(); p++) {
            IloLinearNumExpr num_expr_Sum_Binaries = cplex.linearNumExpr();  
            boolean weHaveRI = false;	           
	            for (int t = 1; t < leadtimeHorizon; t++) {	            	
	            	
	            	//int tmp_p = p;
	            	//int tmp_t = t;
	            	//traceln("test auf " + RI[tmp_p][tmp_t].getName());
	            	
	            	//boolean exists = unique.stream().filter(element -> element != null).anyMatch(element -> element.equals(RI[tmp_p][tmp_t].getName()));
	            	            	
	            	//if(!exists) {
	            		//unique.add(RI[tmp_p][tmp_t].getName());
	            		//traceln("p" + p + " t " + t );
	            		
	            		if(RI[p][t] != null){
	            		//traceln("ri not null");
	            		String variableName = RI[p][t].getName();
	            		//char isItRI = "RI";
	            		//traceln("Found variable " + variableName);
	            		
							           		
		            		if(variableName.contains("RI")){
		            			weHaveRI = true;
		            			num_expr_Sum_Binaries.addTerm(1,RI[p][t]);															
		            		}
		            		
	            		}
	            		
	            		
	            		//traceln("add" + RI[tmp_p][tmp_t].getName());
	            	//}else{
	            		//num_expr_Sum_Binaries.addTerm(0,RI[p][t]);															
	            	//}					
	            }
	            	            
	            if(weHaveRI)
	            	cplex.addEq(num_expr_Sum_Binaries,1);
            }
         
         
         //RI structure
         //Eq2 where Rg,t = RIg,t*Xg,t
         //RI_item_Xt_qty_start_lth_...end_lth_Ritem_start_lth...end_lth
         for (int pp = 0; pp < itemsToPlan.size(); pp++) {
         	IloLinearNumExpr cf = cplex.linearNumExpr();				         
	       for (int t = 1; t < main.simParams.getMRPPlanningHorizon()-1; t++) {	            	            
			       	String o = "";
			       	int sizeExpr = 0;
			        IloLinearNumExpr num_expr = cplex.linearNumExpr();
			                    
	                for (int p = 0; p < iQd.size(); p++) {
	                	if(iQd.get(p).getItem()== itemsToPlan.get(pp).getItem().getItem()){
	                	
		            		if(releaseTmp[p][t] > 0){
		            			
		            			o = o + iQd.get(p).getQuantity() + "*" + RI[p][releaseTmp[p][t]-1].getName() +  "+";	            			
		            			num_expr.addTerm(iQd.get(p).getQuantity(),RI[p][releaseTmp[p][t]-1]);
		            					            					            					            			
		            			sizeExpr++;		            					            					            			
		            		}			        
	            		}
					}
					
				if(o.length() > 1){
		            if(sizeExpr > 0){
		            	//Constraint Release Size 
			            cplex.addEq(R[pp][t],num_expr);    
			                  
			        }

				}else{
				         cplex.addEq(R[pp][t],0);          								
				}
																
				num_expr.clear();             														
			}         
         }
         
     /*    
         //sumRIs: represent the RI for the leadtime horizon
         //required for EQ10 and EQ11 to get the setuptime as part of the clearing functions
         IloNumVar[] sumRIs = new IloNumVar[leadtimeHorizon];     
         //IloLinearNumExpr sumRIsI = cplex.linearNumExpr();			
         
           for (int t = 0; t < main.simParams.getMRPPlanningHorizon()-1; t++) {
           	IloLinearNumExpr sumRIsI = cplex.linearNumExpr();			
           	    
               for (int pp = 0; pp < itemsToPlan.size(); pp++) {        	            
		           for (int p = 0; p < iQd.size(); p++) {
		 				    if(iQd.get(p).getItem()== itemsToPlan.get(pp).getItem().getItem()){ 	
		 				    	if(releaseTmp[p][t] > 0){ 				    			
					        	//RI[p] = cplex.boolVarArray(leadtimeHorizon, RiNames[p]);					        	  
					        	  sumRIsI.addTerm(1.0,RI[p][releaseTmp[p][t]-1]); // the -1 allows releases RIt in the same period as Xt
						       	}//if
				       		}//if
				   		}//for
				   		           
	         		}//for
	         		sumRIs[t] = sumRIsI;
	         		sumRIsI.clear();
	         }//for                  
         
        */
        
        
		IloLinearNumExpr[] sumRIs = new IloLinearNumExpr[main.simParams.getMRPPlanningHorizon()];
		
		for (int t = 0; t < main.simParams.getMRPPlanningHorizon(); t++) {
		    IloLinearNumExpr sumRIsI = cplex.linearNumExpr();
		
		    for (int pp = 0; pp < itemsToPlan.size(); pp++) {
		        for (int p = 0; p < iQd.size(); p++) {
		            if (iQd.get(p).getItem() == itemsToPlan.get(pp).getItem().getItem()) {
		                if (releaseTmp[p][t] > 0) {
		                	//traceln("###### " + 1.0 + " :::: " +  RI[p][releaseTmp[p][t] - 1]);		                
		                    sumRIsI.addTerm(1.0, RI[p][releaseTmp[p][t] - 1]);		                    
		                }
		            }
		        }
		    }
		    
		    sumRIs[t] = sumRIsI;		    		    		    
		    //sumRIsI.clear();
		}				
		             
         //Constraint avoiding that RI with later due date, releases order earlier that RI with earlier due date (orders should not overteak each other)
         //The release of order 2 should not before order 1                                         
         // ********************************* Guarantee Release ORDER  ****************************************
         // ***************************************************************************************************
         for (int pp = 0; pp < itemsToPlan.size(); pp++) {        	            
            for (int i = 0; i < leadtimeHorizon; i++) {
                for (int j = 0; j < iQd.size(); j++) {
                    for (int k = j + 1; k < iQd.size(); k++) {
                        IloLinearNumExpr constraint = cplex.linearNumExpr();
                                                                        
                        if(RI[j][i].getName() != "noRelease" && RI[k][i].getName() != "noRelease" && RI[j][i].getName() != null){
	                    
		                    String[] RiSplitted = RI[j][i].getName().split("_");                        
	                        int item =  Integer.parseInt(RiSplitted[1]);
	                        
	                        String[] RiSplitted2 = RI[k][i].getName().split("_");                        
	                        int item2 =  Integer.parseInt(RiSplitted2[1]);
	                        	                    
			                    if(itemsToPlan.get(pp).getItem().getItem() == item && itemsToPlan.get(pp).getItem().getItem() == item2){    
			                        constraint.addTerm(RI[j][i], 1.0); // 1 of set j		                        
			                        constraint.addTerm(RI[k][i], -1.0); // -1 of set k
			                        cplex.addLe(constraint, 0); // set j[i] - set k[i] <= 0
			                     }                                                   
	                        }
	                    }
	                }
	            }
	        }
                          
         //****************** CF SECTION ***************************************
         //*********************************************************************
         
         for (int t = 0; t < main.simParams.getMRPPlanningHorizon(); t++) {	    
         
	     	IloLinearNumExpr cf = cplex.linearNumExpr();				             	    
	     	IloLinearNumExpr cf1 = cplex.linearNumExpr();				             	    
	       	IloLinearNumExpr cf2 = cplex.linearNumExpr();				             	    
		   	IloLinearNumExpr cf3 = cplex.linearNumExpr();				             	    
	       	IloLinearNumExpr cf4 = cplex.linearNumExpr();				             	    

    	    
    	    //Pgt smaller Wgt - Constraint for single item qty
        	 for (int pp = 0; pp < itemsToPlan.size(); pp++) {        	  			
					//merk dir, dass die weiter unten verwendet werden
					//double setupProption = 18.0/106.0;
					double setupProption = 0;
					
	         		cf.addTerm(itemsToPlan.get(pp).getItem().getRouting().getEProcessingTime()+setupProption,P[pp][t]);	         		
	         		
	         		cf1.addTerm(itemsToPlan.get(pp).getItem().getRouting().getEProcessingTime()+setupProption,P[pp][t]); 	         		        		
         			cf2.addTerm(itemsToPlan.get(pp).getItem().getRouting().getEProcessingTime()+setupProption,W[pp][t]);         			         		        			         			
         			
         			cf3.addTerm(itemsToPlan.get(pp).getItem().getRouting().getEProcessingTime()+setupProption,P[pp][t]);         		
         			cf4.addTerm(itemsToPlan.get(pp).getItem().getRouting().getEProcessingTime()+setupProption,W[pp][t]);
         			
         			
         			//***************** Ppt, <= Wp,t ***********************        			         		         			
         			cplex.addLe(
         				//cplex.sum(P[pp][t],cplex.prod(0,sumRIs[t])),//LHS         			
         				cplex.sum(P[pp][t],0),//LHS         			
        				cplex.sum(W[pp][t],0));//RHS         			
        			//****************************************        			         		         				
        				        				        				        			        			        				
        	  }
        	          	  
			  //CF Constraints			           	  
			  //PL <= MC + Ct (Eq12)			  
			  //traceln("setup time " + setupTime + " sum ri " + sumRIs);
         	  //cplex.addLe(cplex.sum(cf,cplex.prod(setupTime,sumRIs)), //LHS         	  
         	  
         	  
         	  // **************** PL und L ausgeben *********************
         	  //keine constraints werden spter so auch nicht wiedervendet
         	  cplex.addEq(PL[t],cf);
         	  cplex.addEq(L[t],cf2);
         	  //********************************************************* 
         	  
         	  
         	  //cplex.addEq(PL[t],cplex.sum(cf,cplex.prod(setupTime,sumRIs)));
         	  //cplex.addEq(L[t],cplex.sum(cf2,cplex.prod(setupTime,sumRIs)));         	           	           	           	  
         	  
         	  /******** PLt <=MC+Ct (Eq14) ************/
         	  if(t==0){         	           	           	           	  
         	  		cplex.addLe(cf,         	  
         	  		cplex.sum(0,C[t]));	//RHS
         	  	}else{
         	  		//cplex.addLe(cf,         	  		
         	  		//traceln("da" + sumRIs[t].toString());
         	  		cplex.addLe(cplex.sum(cf,cplex.prod(setupTime,sumRIs[t])),         	  
         	  		cplex.sum(maxCapacity,C[t]));	//RHS
         	  	}
         	           	           	           	  		         	           	           	  
         	           	           	  
         	  // ---- we have three segments         	           	           	  
			  //CF partition 2 from numerical example
			  //traceln("# segments " + numberSegments);
			  //represent CF as k*x + d -> 
			  for(int i = 0; i < numberSegments; i++){
	         	  cplex.addLe(
    	     	  	cplex.sum(cf1,cplex.prod(setupTime,sumRIs[t])), //LHS				
				
         	  		cplex.sum(cplex.sum(cplex.prod(max(slopes[i],0),         	  	         	  	
         	  		
         	  		cplex.sum(cf2,cplex.prod(setupTime,sumRIs[t]))),intercepts[i]),C[t]));//RHS         	  		         	  						
         	  	
         	  		traceln("Slope (x): " + slopes[i] + " Y-intercept (d) " + intercepts[i]);
         	  		         	  		
         	  	//traceln("sumRIs " + sumRIs + " st " + setupTime);	
         	  }//for
         	           	           	           	  
         	           	           	           	  			           	  
         	  /******************************* PLt <= Lt + Ct (Eq18) *********************/
         	  //Constraint Pl musst be smaller as SL for all t         	           	  
         	  cplex.addLe(
         	  	cplex.sum(cf3,cplex.prod(setupTime,sumRIs[t])), //LHS         	  
	         	cplex.sum(cplex.sum(cf4,cplex.prod(setupTime,sumRIs[t])),C[t]));         	  	         	
	          //***************************************************************************
         	  
			  cf.clear();
			  cf1.clear();
 			  cf2.clear();
 			  cf3.clear();
 			  cf4.clear();
         }



// Create a two-dimensional array of IloNumVars
            int numRows = iQd.size(); // Assuming iQd is a list or array
                        
            // ... Initialize and populate the RI array with IloNumVars ...

            // Find the variable by name in the RI array
            traceln("iQd size: " + iQd.size());
            String targetVariableName = "noRelease";
            boolean isVariableFound = false;
            IloNumVar foundVariable = null;

            for (int i = 0; i < numRows; i++) {
                for (int j = 1; j < RI[i].length-1; j++) {
                    IloNumVar var = RI[i][j];
                    if (var.getName().equals(targetVariableName)) {
                        isVariableFound = true;
                        foundVariable = var;
                        break;
                    }
                }
                if (isVariableFound) {
                    break;
                }
            }
            
            if (isVariableFound) {
                // Add a constraint to enforce the found variable to be zero
                traceln("Yes found");                
                foundVariable.setName("noRelease");                                
                cplex.addEq(foundVariable, 0);
            }
            
            //All Entries represent Running Orders. So the associated
            //RI_...1 must be set to one
            
                                    
            int numberOpenOrders = runningOrders.size();
            isVariableFound = false;
            traceln("Count Running Orders: " + numberOpenOrders);
            traceln("RI length: " + RI.length);
            for (int i = 0; i < numberOpenOrders; i++) {
            	for (int j = 1; j < RI[i].length-1; j++) {
            	
            		//"RI_103_13_106.0_0R103_0"
            					                                		
            	    String[] RiSplitted = RI[i][j].getName().split("_");
			        traceln(RI[i][j].getName().split("_"));
                    
                    IloNumVar var = RI[i][j];
                    
                    if(!var.getName().equals("noRelease")){
                    	
                    	targetVariableName = "RI_" + RiSplitted[1] + "_" + (int) runningOrders.get(i).getDueDate() + "_" + 
                    	runningOrders.get(i).getQuantity() + "_1" + "R" +  RiSplitted[1] + "_1";
                    
                    	traceln("Running Order Target Name ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~: " + targetVariableName);
                    
	                    if (var.getName().equals(targetVariableName)) {
	                        isVariableFound = true;
	                        foundVariable = var;
	                        break;
	                    }
	                 }
                }                        
                
                if (isVariableFound) {	                	                	                
	                cplex.addEq(foundVariable, 1);
	                traceln("Release Variable found " + foundVariable.getName() + " set to 1");
	                isVariableFound = false;
            	}
            }
            
                                                               
    
    //cplex.deleteNames();
    
    //if(time() == 0)
    if(Tools.Log_CF_Optimization_Values){                 
		cplex.exportModel("model/NewModel_" + time() + "_" + bomLevel + "_" + firstBomItem.getItem() +".lp");
	}	
	//cplex.writeSolution("model/NewModel_" + time() + "_" + bomLevel + ".sol");

	//cplex.setParam(IloCplex.BooleanParam.PreInd, true);
	//0.05 were to hard ... 0.1 before
	//cplex.setParam(IloCplex.Param.MIP.Tolerances.MIPGap, 0.05);
	//cplex.setParam(IloCplex.IntParam.DataCheck, 2);	
	cplex.setParam(IloCplex.IntParam.WorkMem, 2000);
						
	if(cplex.solve() && Tools.Log_CF_Optimization_Values){
		    
		    System.out.println("Solution status: " + cplex.getStatus());
            System.out.println();
            System.out.println("Objective Value = " + cplex.getObjValue());
          
            System.out.println("Pieces: Wip, X, Release, P");
            System.out.println("Minutes: PL L, MC, CF1, CF2, CF3");
            System.out.println("\tp\tTime\tt\tWip\tX\tRelease\tP\tPL\tL\tMC\tCF1\tCF2\tCF3\tInv\tIBl\tWB\tObjPP\tCt\tBt\tPTime\tSTime\tPL");
          	
            int[] t_sum_wip = new int[get_Main().simParams.getMRPPlanningHorizon()];
            int[] t_sum_pl = new int[get_Main().simParams.getMRPPlanningHorizon()];
            int[] t_sum_l = new int[get_Main().simParams.getMRPPlanningHorizon()];
            int[] t_sum_load = new int[get_Main().simParams.getMRPPlanningHorizon()];
            int[] t_sum_x = new int[get_Main().simParams.getMRPPlanningHorizon()];
            int[] t_sum_r = new int[get_Main().simParams.getMRPPlanningHorizon()];
            int[] t_sum_p = new int[get_Main().simParams.getMRPPlanningHorizon()];
          	
            for (int p = 0; p < itemsToPlan.size(); p++) {
                        	
               for (int t = 0; t < get_Main().simParams.getMRPPlanningHorizon(); t++) {
               
               double inventoryBalance = 0;
               double wipBalance = 0;

               if(t>0){
                  inventoryBalance = cplex.getValue(I[p][t-1])-X[p][t]+cplex.getValue(P[p][t-1]) - cplex.getValue(B[p][t-1]) + cplex.getValue(B[p][t]);
                  wipBalance = cplex.getValue(W[p][t-1])+cplex.getValue(R[p][t])-cplex.getValue(P[p][t-1]);               
               }
               		
               	  double lt = cplex.getValue(W[p][t])*itemsToPlan.get(p).getItem().getRouting().getEProcessingTime();
               	  double pl = cplex.getValue(P[p][t])*itemsToPlan.get(p).getItem().getRouting().getEProcessingTime();
               	  double objectivePerPeriod = cplex.getValue(W[p][t]) * wipCosts + cplex.getValue(I[p][t]) * inventoryHoldingCosts;
               	  
               	  
               	  int slope2 = -99;
               	  int slope3 = -99;
               	  
               	  if(selectedSegments.size() == 2){
               	  	slope2 = (int)(slopes[1]*lt+intercepts[1]);
               	  }
               	  
              	  if(selectedSegments.size() == 3){
               	  	slope3 = (int)(slopes[2]*lt+intercepts[2]);
               	  }
               	                 	  
               	  int wipForPrintLn = (int)cplex.getValue(W[p][t]);               	                 	                 	  
               	  
                  System.out.println("\t" + itemsToPlan.get(p).getItem().getItem() +
                                     "\t" + (time() + t) +
                                     "\t" + t +
                                     //"\t" + (int)cplex.getValue(W[p][t]) +
                                     "\t" + (int)Math.round(wipForPrintLn) +
                                     "\t" + X[p][t] +
                                     "\t" + (int)Math.round(cplex.getValue(R[p][t])) +       
                                     //"\t" +  +                                                       
                                     "\t" + (int)cplex.getValue(P[p][t]) +
                                     "\t" + (int)Math.round(pl) +
                                     "\t" + (int)Math.round(lt) +
                                     "\t" + maxCapacity + 
                                     "\t" + (int)(slopes[0]*lt+intercepts[0]) + 
                                     "\t" + slope2 + 
                                     "\t" + slope3 +                                      
                                     "\t" + Math.round(cplex.getValue(I[p][t])) +
                                     "\t" + Math.round(inventoryBalance) +
                                     "\t" + (int)Math.round(wipBalance) +
                                     "\t" + (int)Math.round(objectivePerPeriod) +
                                     "\t" + Math.round(cplex.getValue(C[t])) +
                                     "\t" + (int)cplex.getValue(B[p][t]) + 
                                     "\t" + itemsToPlan.get(p).getItem().getRouting().getEProcessingTime() +
                                     "\t" + itemsToPlan.get(p).getItem().getRouting().getESetupTime()  +
                                     "\t" + (int)cplex.getValue(PL[t]) +      
                                     "\t" + (int)cplex.getValue(L[t])       
                                     );                                                                                                 
            
            		//t_sum_wip[t] += wipForPrintLn;
            		
            		t_sum_x[t] += X[p][t];            		
            		t_sum_wip[t] += (int)cplex.getValue(W[p][t]) ;
            		t_sum_r[t] += (int)Math.round(cplex.getValue(R[p][t]));            		
            		t_sum_p[t] += (int)cplex.getValue(P[p][t]);
            		
            		//if(t==0){
            			t_sum_pl[t] = (int)cplex.getValue(PL[t]);
            			t_sum_l[t] = (int)cplex.getValue(L[t]);
            		//}
            			
            		t_sum_load[t] += lt;
                                    
                    //OptimizationResult optResult = new OptimizationResult(time(),itemsToPlan.get(p).getItem().getItem(), t,
                    //cplex.getValue(W[p][t]), cplex.getValue(R[p][t]), 0,cplex.getValue(P[p][t]),
                    //cplex.getValue(I[p][t]) );                    
                    //get_Main().optimizationResults.add(optResult);                                                      
               }                              
            }
            
            System.out.println("\n");
            System.out.println("\tTime\tt\tX\tWip\tR\tP\tPL\tL");           
            for(int t = 0; t < get_Main().simParams.getMRPPlanningHorizon(); t++) {
            
            	System.out.println(
            		"\t" + (time() + t) +
       				"\t" + t +           
       				"\t" + t_sum_x[t] + 		
            		"\t" + t_sum_wip[t] +
            		"\t" + t_sum_r[t] +
            		"\t" + t_sum_p[t] +
	           		"\t" + t_sum_pl[t] +
            		"\t" + t_sum_l[t]            	
            	);            
            }
                 	  
            
            //if(OptimizationResult.WRITE_OPTIMIZATION_RESULTS_TO_XLXS)
			//OptimizationResult.WriteXlsxOptimizationResults(get_Main().optimizationResults, get_Main().simParams);            
            	//traceln("size +++++++++++ " + get_Main().optimizationResults.size());
            
		}else{
			traceln("NO Solution " + cplex.getStatus());
		}												


			/*
        	for (int p = 0; p < iQd.size(); p++) {        	        
               for (int t = 0; t < leadtimeHorizon; t++) {   
                            
                            traceln("da");
					        
					        //double qty = cplex.getValue(RI[p][t]);    			            			            		            
					        double qty = 99;					        					        
							int itemIntTmp = iQd.get(p).getItem();
					        traceln(RI[p][t].getName().split("_"));
					        traceln("item " + itemIntTmp + " p " + p + "t " + t + "qty " + qty);
			}
			}
        	*/
        	
        	for (int p = 0; p < iQd.size(); p++) {        	        
               for (int t = 1; t < leadtimeHorizon; t++) {   
            				            
            				//traceln("da vor qty " + p + " " + t + " " + RI[p][t].getName());            				            				
					        					        				        
					        if(RI[p][t].getName() != "noRelease"){
					        						        
					        double qty = cplex.getValue(RI[p][t]);    			            			            		            
					        //traceln(qty);
					        //traceln("da for if");				               					        
							if(qty > 0.9){
					        //traceln("da");				               					        
								
								//traceln("qty " + qty + " " + RI[p][t].getName());
							
			                    ProductionOrder order = new ProductionOrder();
			                    								
								int itemIntTmp = iQd.get(p).getItem();
									
			                    Item item = get_Main().items.stream().filter(e -> e.getItem() == itemIntTmp).findFirst().get();																		                     
			                    
			                    order.setOrderId(get_Main().prodOrderId++);
			                    order.setItem(item);
			                                                                                                                                  
								order.setPlannedCapacity(Routing.GetPlannedCapacityPerItem(get_Main().routings, order.getItem(), get_Main().simParams, order));
								
								//order.setPlannedCapacity(Routing.GetPlannedCapacityPerItem(routingList, order.getItem(), simParams, order));
								order.setPlannedSetupTime(Routing.GetPlannedSetupTimePerItem(get_Main().routings, order.getItem(), get_Main().simParams, order));								
			                    
			                    int minimumRoutingStep = Routing.GetMinimumStep(get_Main().routings, order.getItem() , get_Main().simParams);
								int maximumRoutingStep = Routing.GetMaximumStep(get_Main().routings, order.getItem() , get_Main().simParams);
						
								order.setMinimumRoutingStep(minimumRoutingStep);
								order.setMaximumRoutingStep(maximumRoutingStep);			
								order.setCurrentRoutingStep(minimumRoutingStep);                                        			                    			                    
			                                                            
			                    //order.setQuantity(Math.round(iQd.get(p).getQuantity()));
			                    
			                    //traceln("################################## " + iQd.get(p).getQuantity());
			                    
			                    
			                    //if we have a running order, we have to reduce the release qty, as it was only required for the decision of release qty
			                    //but the qty itself is already considered for production.
			                    //traceln("X[" + p + "," + t + "] " + X[p][t] + " qty " + iQd.get(p).getQuantity() + " Running Orders Qty: " + iQd.get(p).getQuantityRunning());	        				        			        		
			                    traceln("X qty " + iQd.get(p).getQuantity() + " Running Orders Qty: " + iQd.get(p).getQuantityRunning());	        				        			        		
			                    order.setQuantity(Math.ceil(iQd.get(p).getQuantity()-iQd.get(p).getQuantityRunning()));
			                    traceln("Set Production Order Qty: " + order.getQuantity());
			                    order.setCreatedAt(time());			                    
			                    
			                    //get the start and end dates from the RI decision variables			                    
			                    String[] RiSplitted = RI[p][t].getName().split("_");
			                    
			                    traceln(RI[p][t].getName().split("_"));
			                    
			                    //order.setPlannedStart(max(Integer.parseInt(RiSplitted[5]) + time() - item.getSafetyLeadTime(), time()));
			                    //order.setPlannedStart(Integer.parseInt(RiSplitted[5] + time());

			                    //safety leadtime for stochastic scenario
			                    //order.setPlannedStart(max(Integer.parseInt(RiSplitted[5]) + time() - 1, time()));
			                    
			                   // order.setPlannedStart(max(Integer.parseInt(RiSplitted[5]) + time() - 1, time()));
			                    
			                    order.setPlannedStart(max(Integer.parseInt(RiSplitted[5]) + time(), time()));

			                    order.setPlannedEnd(Integer.parseInt(RiSplitted[2]) + time());
			                    
			                    traceln("Start " + order.getPlannedStart() +  " Time " + time());
			                    
			                    long exists = 0;	
			                    		                    
			                    if(order.getPlannedStart() < time())
			                    	exists = 1;
			                    											
				                    if(exists == 0){
				                    	//traceln("Production Order Added");														                    
					                    Routing routingObject = get_Main().routings.stream().filter(e -> e.getItem().getItem() == order.getItem().getItem()).findFirst().get();			
										order.setRouting(routingObject);
										order.setStatus(ProductionOrder.PRODUCTION_ORDER_STATUS_UNPROCESSED);
					                    
					                    get_Main().productionOrders.add(order);	                    						
														                    
				                    }//if
		                    	}// if qty	
		                    	}	                    
		                 }//for            
		            }//for
                        
        if(false) {
			traceln("Production Orders from Optmization Before Removing");
			traceln(ProductionOrder.GetCSVHeader());
			
	        for (ProductionOrder order: get_Main().productionOrders) {
	           traceln(ProductionOrder.GetCSVString(order));
	        }        
			
	        //get_Main().productionOrders.removeIf(e -> e.getPlannedStart() > time());
	
	        traceln("Production Orders from Optmization FOR SIMULATION");
	        traceln(ProductionOrder.GetCSVHeader());
	
	        for (ProductionOrder order: get_Main().productionOrders) {
	            traceln(ProductionOrder.GetCSVString(order));
	        }        
	        traceln("**************************");                							
        }
		
		//get_Main().Function_OrderRelease();
		
		cplex.deleteNames();        
    	if(Tools.Log_CF_Optimization_Values){                 
			cplex.exportModel("model/NV/NewModel" + time() + "_" + bomLevel + ".lp");
		}	
		
		cplex.end();		
	}
	catch (IloException exc) {
         System.err.println("Concert exception '" + exc.getMessage() + "' caught");
         System.exit(-1);
    }

return 0;
]]></Body>
				</Function>
				<Function AccessType="default" StaticFunction="false">
					<ReturnModificator>RETURNS_VALUE</ReturnModificator>
					<ReturnType><![CDATA[int]]></ReturnType>
					<Id>1698053630953</Id>
					<Name><![CDATA[Function_ClearingFunction3]]></Name>
					<X>490</X><Y>120</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Parameter>
						<Name><![CDATA[itemsToPlan]]></Name>
						<Type><![CDATA[List<MRP>]]></Type>
					</Parameter>
					<Parameter>
						<Name><![CDATA[bomLevel]]></Name>
						<Type><![CDATA[int]]></Type>
					</Parameter>
					<Parameter>
						<Name><![CDATA[inResource]]></Name>
						<Type><![CDATA[Resource]]></Type>
					</Parameter>
					<Parameter>
						<Name><![CDATA[fileSuffix]]></Name>
						<Type><![CDATA[String]]></Type>
					</Parameter>
					<Body><![CDATA[try{

Tools to = new Tools();
							
traceln("----------- Start CF OPTIMIZATION at " + time () + " ----------------");
							
StringBuilder output = new StringBuilder();

int maxCapacity = 1440;
//double wipCosts = 0;
//double inventoryHoldingCosts = 0;
traceln("Total found Segments: " + ClearingFunctionSegments.size());


/*
Iterator<MRP> iterator = itemsToPlan.iterator();
while (iterator.hasNext()) {
    MRP o = iterator.next();
    if (o.getItem().getItem() == 103 ||     
    o.getItem().getItem() == 111 ||
    o.getItem().getItem() == 115 ||
    o.getItem().getItem() == 119 ||
    o.getItem().getItem() == 123 ||
    o.getItem().getItem() == 127 ||
    o.getItem().getItem() == 131
    ) {
        iterator.remove(); // Safely remove the element from the list
    }
}
*/

	//via the bom level the cf is associated
	List<ClearingFunctionSegments> selectedSegments = new ArrayList();
	Item firstBomItem = itemsToPlan.get(0).getItem();
	//wipCosts = firstBomItem.getHoldingCostsWIP();
	//inventoryHoldingCosts = firstBomItem.getHoldingCosts();	
	
	//Routing firstRoutingItem = main.routings.stream().filter(e -> e.getItem().getItem() == firstBomItem.getItem()).findFirst().get();	
	//Resource firstResource= main.resources.stream().filter(e -> e.getName().equalsIgnoreCase(firstRoutingItem.getResource())).findFirst().get();
	
	//maxCapacity = inResource.getCapacity();
	//don't map it to the prodction stage 1-4, select the values based on the resource
	traceln("Total found segments: " + selectedSegments);
	
	if(firstBomItem.getLotsizePolicy().equalsIgnoreCase(Item.LOT_POLICY_FOP)) {
		int fop = firstBomItem.getFOPPeriod();	
		traceln("FOP Period:" + fop);	
					
		selectedSegments = ClearingFunctionSegments.stream().filter(e -> e.getLotParameter() == fop &&
							 e.getLotPolicy().equalsIgnoreCase(Item.LOT_POLICY_FOP) && e.getResource().equalsIgnoreCase(inResource.getName()) 
				 && e.getExperiment().equalsIgnoreCase(main.simParams.getExperiment())).collect(Collectors.toList());															 																								
	}
	else if(firstBomItem.getLotsizePolicy().equalsIgnoreCase(Item.LOT_POLICY_FOQ)) {
		int foq = (int)firstBomItem.getFOQQuantity();	
		traceln("FOQ Qty:" + foq);	
					
		selectedSegments = ClearingFunctionSegments.stream().filter(e -> e.getLotParameter() == foq &&
							 e.getLotPolicy().equalsIgnoreCase(Item.LOT_POLICY_FOQ) && e.getResource().equalsIgnoreCase(inResource.getName()) 
				 && e.getExperiment().equalsIgnoreCase(main.simParams.getExperiment())).collect(Collectors.toList());															 																								
	}
				
	traceln("Resource: " + inResource.getName());
	traceln("Resource Stage Number: " + inResource.getStageNumber());
	traceln("Production Stage: " + (bomLevel + 1));
	traceln("Max Capacity: " + maxCapacity);
	
	traceln("Items to Plan: ");
	itemsToPlan.forEach(e -> traceln(e.getItem().getItem() + " eProcessingTime " + e.getItem().getRouting().getEProcessingTime() + ";"));

	traceln("Selected Slopes: ");		
	selectedSegments.forEach(e -> traceln(e.getSlope() + ";"));
	traceln("Selected Intercepts: ");
	
	selectedSegments.forEach(e -> traceln(e.getyIntercept() + ";"));
	
	if(selectedSegments.size() == 0){
		traceln("STOP Simulation: No Segments found!");
		System.exit(0);
	}
	
	to.log("Segment Cnt: " + selectedSegments.size(), Tools.LogCFOptimization);
	
	double intercepts[] = new double[selectedSegments.size()];
	double slopes[] = new double[selectedSegments.size()];
	
	for(int i = 0; i < selectedSegments.size(); i++) {
		slopes[i] = selectedSegments.get(i).getSlope();
		intercepts[i] = selectedSegments.get(i).getyIntercept();
	}		
			
int numberSegments = selectedSegments.size();

double oCosts = 0;
double oFactor = 1000;
double setupTime = 18; //standard = 18
int leadtimeHorizon = main.simParams.getLeadTimeHorizon();


traceln("Leadtime Horizon: " + leadtimeHorizon);

IloCplex cplex = new IloCplex();

     String[][] Inames = new String[itemsToPlan.size()][get_Main().simParams.getMRPPlanningHorizon()];
     String[][] Pnames = new String[itemsToPlan.size()][get_Main().simParams.getMRPPlanningHorizon()];
     String[] PLnames = new String[get_Main().simParams.getMRPPlanningHorizon()];
     String[] Lnames = new String[get_Main().simParams.getMRPPlanningHorizon()];
     String[][] Wnames = new String[itemsToPlan.size()][get_Main().simParams.getMRPPlanningHorizon()];
     String[][] Rnames = new String[itemsToPlan.size()][get_Main().simParams.getMRPPlanningHorizon()];     
     String[][] Bnames = new String[itemsToPlan.size()][get_Main().simParams.getMRPPlanningHorizon()];     
     String[][] Znames = new String[itemsToPlan.size()][get_Main().simParams.getMRPPlanningHorizon()];     
     
     
     for(int i = 0; i< get_Main().simParams.getMRPPlanningHorizon(); i++){
          for (int p = 0; p < itemsToPlan.size(); p++) {
        	 	Inames[p][i] = "I" + itemsToPlan.get(p).getItem().getItem() + "_" + i; 
        	 	Pnames[p][i] = "P" + itemsToPlan.get(p).getItem().getItem() + "_" + i; 
        	 	Wnames[p][i] = "W" + itemsToPlan.get(p).getItem().getItem() + "_" + i; 
        	 	Rnames[p][i] = "R" + itemsToPlan.get(p).getItem().getItem() + "_" + i; 
        	 	Bnames[p][i] = "B" + itemsToPlan.get(p).getItem().getItem() + "_" + i; 
        	 	PLnames[i] = "PL" + itemsToPlan.get(p).getItem().getItem() + "_" + i; 
        	 	Lnames[i] = "L" + itemsToPlan.get(p).getItem().getItem() + "_" + i;
        	 	Znames[p][i] = "Z" + itemsToPlan.get(p).getItem().getItem() + "_" + i;  
        	 	 
	     }
     }

     IloNumVar[] C = new IloNumVar[main.simParams.getMRPPlanningHorizon()];
     for (int t = 0; t < get_Main().simParams.getMRPPlanningHorizon(); t++) {
        C[t] = cplex.numVar(0, Double.MAX_VALUE, "C" + "_" + t);
     }
     
     IloNumVar[][] I = new IloNumVar[itemsToPlan.size()][];
     for (int p = 0; p < itemsToPlan.size(); p++) {
        I[p] = cplex.numVarArray(get_Main().simParams.getMRPPlanningHorizon(), 0, Double.MAX_VALUE, Inames[p]);
        oCosts += itemsToPlan.get(p).getItem().getHoldingCosts();
     }
     
     oCosts = oFactor*oCosts;
     
     IloNumVar[][] P = new IloNumVar[itemsToPlan.size()][];
     for (int p = 0; p < itemsToPlan.size(); p++) {     
        P[p] = cplex.numVarArray(get_Main().simParams.getMRPPlanningHorizon(), 0,  Double.MAX_VALUE, Pnames[p]);        
     }
     
     IloNumVar[] PL = new IloNumVar[leadtimeHorizon];     
     IloNumVar[] L = new IloNumVar[leadtimeHorizon];     
     
     for (int t = 0; t < leadtimeHorizon; t++) {               
     	PL[t] = cplex.numVar(0,  Double.MAX_VALUE, PLnames[t]);
     	L[t] = cplex.numVar(0,  Double.MAX_VALUE, Lnames[t]);
     }
     
                    
     IloNumVar[][] W = new IloNumVar[itemsToPlan.size()][];
     for (int p = 0; p < itemsToPlan.size(); p++) {
        W[p] = cplex.numVarArray(get_Main().simParams.getMRPPlanningHorizon(), 0, Double.MAX_VALUE, Wnames[p]);
     }
		
	 IloNumVar[][] R = new IloNumVar[itemsToPlan.size()][];
     for (int p = 0; p < itemsToPlan.size(); p++) {
        R[p] = cplex.numVarArray(get_Main().simParams.getMRPPlanningHorizon(), 0.0, Double.MAX_VALUE, Rnames[p]);
     }          
     
     IloNumVar[][] B = new IloNumVar[itemsToPlan.size()][];
     for (int p = 0; p < itemsToPlan.size(); p++) {
        B[p] = cplex.numVarArray(get_Main().simParams.getMRPPlanningHorizon(), 0.0, Double.MAX_VALUE, Bnames[p]);
     }
    
         IloNumVar[][] Z = new IloNumVar[itemsToPlan.size()][];
     for (int p = 0; p < itemsToPlan.size(); p++) {
        Z[p] = cplex.numVarArray(get_Main().simParams.getMRPPlanningHorizon(), 0, Double.MAX_VALUE, Znames[p]);
     }    
               	
	double[] inventory = new double[itemsToPlan.size()];
	double[] wip = new double[itemsToPlan.size()];
	double[] produce = new double[itemsToPlan.size()];
	double[] tl = new double[itemsToPlan.size()];
		
	int[][] X = new int[itemsToPlan.size()][get_Main().simParams.getMRPPlanningHorizon()];

	List<SpecialObject> iQd = new ArrayList<SpecialObject>();
	List<SpecialObject> runningOrders = new ArrayList<SpecialObject>();
	
     for (int p = 0; p < itemsToPlan.size(); p++) {      	     

     		   inventory[p] = 0;
     		   
     		   //wip[p] = (int)ProductionOrder.GetCurrentWip(get_Main().productionOrders, itemsToPlan.get(p).getItem(), get_Main().simParams);
     		   	wip[p]=0;
     		   
	        	int tmp_item = itemsToPlan.get(p).getItem().getItem();
				     		
     		   produce[p] = 0;
     		   
     		   //tl[p] = itemsToPlan.get(p).getItem().getTransportLotSize();
     	       for (int t = 0; t < get_Main().simParams.getMRPPlanningHorizon(); t++) {               	                          	               	
	               			               		               		               		               	
	               	//int tmp_item = itemsToPlan.get(p).getItem().getItem();
	               	int temp_t = t;
	               	int quantityRunningProductionOrders = 0;
	               	int lateOrders = 0;
	               	
	               	MRP mrpItem = null;
	               	
	               	if(t > 0){
		               	mrpItem = get_Main().mrpTable.stream().filter(e -> e.getItem().getItem() == tmp_item
		               	 && e.getTime() == time() && e.getPeriod() == temp_t - 1).findFirst().orElseGet(() -> new MRP());
		               	 
		               	 //traceln("T for running Orders: " + t);
		               	 quantityRunningProductionOrders = remainingProductionOrderQty(tmp_item,t + time());
		               	 
		               	 //late Orders must only be computed in period 1 and not the remaining.
		               	 if(t == 1){
		               	 	lateOrders = lateProductionOrdersQty(tmp_item,t + time());						
		               	 }
		               	 
		               	 //traceln("t " + t + " PlannedOrderReceipts " + (int) mrpItem.getPlannedOrderReceipts()); 
		               	 
		               	 X[p][t] += (int) mrpItem.getPlannedOrderReceipts();
		               	 		               	 
		               	//mrpItem.setPlannedOrderReceipts(mrpItem.getPeriod() + 50);
		               	//traceln("MRP Item for Optimization");
		               	//traceln(MRP.GetCSVHeader());
		               	//traceln(MRP.GetCSVString(mrpItem));
	               	}
															
					if(quantityRunningProductionOrders > 0 || lateOrders > 0){
						traceln("RunningProduction Order Qty: " + quantityRunningProductionOrders + " time: " + time() + " t " + t + " item " + tmp_item);
						traceln("old Xpt: " + X[p][t]);
						
						if(t == 1){
							X[p][1] += (quantityRunningProductionOrders + lateOrders);							
						}else{
							X[p][t] += quantityRunningProductionOrders;
						}															
						
						traceln("new Xpt: " + X[p][t]);
						traceln("Now we have to consider the Remaining Qty for Capacity Consumption of: " + X[p][t]);
						
						SpecialObject runningOrder = new SpecialObject(
	        				mrpItem.getItem().getItem(),
	        				X[p][t], 
	        				t,
	        				quantityRunningProductionOrders + lateOrders);
	        				
	        			runningOrders.add(runningOrder);						
					}
															
					//if(t == 1){						
	        			//X[p][t] += (int) mrpItem.getPlannedOrderReceipts();	        				        			
	        		//}else if(t > 1){	        		
	        		
	        		
	        		//}

	        		if(X[p][t] > 0 && t > 0) {
	        			SpecialObject so = new SpecialObject(
	        				mrpItem.getItem().getItem(),
	        				X[p][t], 
	        				t,
	        				quantityRunningProductionOrders + lateOrders);
	        			iQd.add(so);
	        			traceln("X[" + p + "," + t + "] " + X[p][t]);	        				        			        		
	        			
	        			//traceln("~~~~~~~~~~~~~" + so.getItem() + " qty: " + so.getQuantity() + " dd " + so.getDueDate());
	        			
	        		}        		  	        		        		
            }     	      	
     }
          
     String[][] RiNames = new String[iQd.size()][leadtimeHorizon];
     int[][] releaseTmp = new int[iQd.size()][main.simParams.getMRPPlanningHorizon()];
     String[] releaseForX = new String[iQd.size()];

	 // this combinations are constructed .. every time the due date in this case 13, a 0 value is added RI_103_13_106.0_0R103_0
	 
	 //RI_103_13_106.0_0R103_0 + RI_103_13_106.0_0R103_0
       //+ RI_103_13_106.0_0R103_0 + RI_103_13_106.0_1R103_1
       //+ RI_103_13_106.0_2R103_2 + RI_103_13_106.0_3R103_3
       //+ RI_103_13_106.0_4R103_4 + RI_103_13_106.0_5R103_5
       //+ RI_103_13_106.0_6R103_6 + RI_103_13_106.0_7R103_7
       //+ RI_103_13_106.0_8R103_8 + RI_103_13_106.0_9R103_9
       //+ RI_103_13_106.0_10R103_10 + RI_103_13_106.0_11R103_11
       //+ RI_103_13_106.0_12R103_12 + RI_103_13_106.0_13R103_13 
	 
	 //for each Xt > 0 an entry to iQd is added and this represnts all Xts of all planned products!
     for (int p = 0; p < iQd.size(); p++) {
          for(int i = 1; i < leadtimeHorizon; i++){
          		int targetT = (int)(iQd.get(p).getDueDate() - leadtimeHorizon + i + 1);          		
          		
          		if(targetT < 0)
          			targetT = 0; // is 0 as this are values later thaen the due date e.g. 13
          		          		
          		releaseTmp[p][targetT] = i+1;
          		
          		if(targetT > 0){          		          		
        	 		RiNames[p][i] = "RI_" +  iQd.get(p).getItem() + "_" + (int)iQd.get(p).getDueDate() +         	 	
        	 		"_" + iQd.get(p).getQuantity() + "_" + targetT + "R" + iQd.get(p).getItem() + "_" + targetT; 
        	 	}else{
        	 		RiNames[p][i] = "noRelease";// + p + "" + i;
        	 	}        	 	        	 	
        	 	
        	 	//traceln(RiNames[p][i]);
	     }    
     }


	 //for each product we need the individual releases RI.....They are constructed with the above equation.            
	 //traceln("iQd.size " + iQd.size());
     IloNumVar[][] RI = new IloNumVar[iQd.size()][];
     for (int p = 0; p < iQd.size(); p++) {
          	     	
     	//e.g. if we have 8 releases while iqd.size = 8 and this all all the xts, we also need 8 RIs to get an individual decision for each Xt, which must be associated with an Release
     	// in each RiNames the item and due date (item and xt) is coded, consequently this works. 
        RI[p] = cplex.boolVarArray(leadtimeHorizon, RiNames[p]);                
        
     }                                      
            
     	//Objective Function     
		IloLinearNumExpr objFunction  = cplex.linearNumExpr();
	         
        for (int p = 0; p < itemsToPlan.size(); p++) {
           for (int t = 0; t < get_Main().simParams.getMRPPlanningHorizon(); t++) {
              objFunction.addTerm (itemsToPlan.get(p).getItem().getHoldingCosts(), I[p][t]);
            }
         }

        for (int p = 0; p < itemsToPlan.size(); p++) {
           for (int t = 0; t < get_Main().simParams.getMRPPlanningHorizon(); t++) {
             objFunction.addTerm (itemsToPlan.get(p).getItem().getHoldingCostsWIP(), W[p][t]);
            }                     	            
         } 
         
         for (int p = 0; p < itemsToPlan.size(); p++) {
           for (int t = 0; t < get_Main().simParams.getMRPPlanningHorizon(); t++) {
             objFunction.addTerm (itemsToPlan.get(p).getItem().getBacklogCosts(), B[p][t]);
            }                     	            
         } 
         
                  
         for (int t = 0; t < get_Main().simParams.getMRPPlanningHorizon(); t++) {
             objFunction.addTerm (oCosts, C[t]);
         }                     	                              
                                      
         cplex.addMinimize(objFunction); //objective function
       
         for (int p = 0; p < itemsToPlan.size(); p++) {
           		
         	cplex.addEq(I[p][0],0); //Eq7
         	cplex.addEq(P[p][0],0); //Eq8  Pg,0 must be zero to avoid production in this period. this is not possible.                           
         	//cplex.addEq(W[p][0],0); //Eq7
         	cplex.addEq(R[p][0],0); //Eq9
         	cplex.addEq(W[p][0],0); //Eq10
         
            for (int t = 1; t < get_Main().simParams.getMRPPlanningHorizon(); t++) {
	           	cplex.addEq(cplex.sum(cplex.sum(I[p][t], X[p][t]),B[p][t-1]), 
                       cplex.sum(cplex.sum(I[p][t-1], P[p][t-1]),B[p][t]));
        	}
            
              
            cplex.addEq(W[p][0], R[p][0]);
            
            for (int t = 1; t < get_Main().simParams.getMRPPlanningHorizon(); t++) {
               cplex.addEq(cplex.sum(W[p][t], P[p][t-1]), 
                           cplex.sum(W[p][t-1], R[p][t]));   
                                                                                                                                    
            }			             											
         }
         
         //********************* Sum of RI_t == 1 *************************
         // RI_103_13_106.0_0R103_0 + RI_103_13_106.0_0R103_0 + RI_103_13_106.0_0R103_0 + RI_103_13_106.0_1R103_1  + RI_103_13_106.0_2R103_2 + RI_103_13_106.0_3R103_3  + RI_103_13_106.0_4R103_4 + RI_103_13_106.0_5R103_5 .... = 1       
         // CF Article EQ3 
          List<String> unique = new ArrayList();
          
          for (int p = 0; p < iQd.size(); p++) {
            IloLinearNumExpr num_expr_Sum_Binaries = cplex.linearNumExpr();  
            boolean weHaveRI = false;	           
	            for (int t = 1; t < leadtimeHorizon; t++) {	            	
	            	
	            	//int tmp_p = p;
	            	//int tmp_t = t;
	            	//traceln("test auf " + RI[tmp_p][tmp_t].getName());
	            	
	            	//boolean exists = unique.stream().filter(element -> element != null).anyMatch(element -> element.equals(RI[tmp_p][tmp_t].getName()));
	            	            	
	            	//if(!exists) {
	            		//unique.add(RI[tmp_p][tmp_t].getName());
	            		//traceln("p" + p + " t " + t );
	            		
	            		if(RI[p][t] != null){
	            		//traceln("ri not null");
	            		String variableName = RI[p][t].getName();
	            		//char isItRI = "RI";
	            		//traceln("Found variable " + variableName);
	            		
							           		
		            		if(variableName.contains("RI")){
		            			weHaveRI = true;
		            			num_expr_Sum_Binaries.addTerm(1,RI[p][t]);															
		            		}
		            		
	            		}
	            		
	            		
	            		//traceln("add" + RI[tmp_p][tmp_t].getName());
	            	//}else{
	            		//num_expr_Sum_Binaries.addTerm(0,RI[p][t]);															
	            	//}					
	            }
	            	            
	            if(weHaveRI)
	            	cplex.addEq(num_expr_Sum_Binaries,1);
            }
         
         
         //RI structure
         //Eq2 where Rg,t = RIg,t*Xg,t
         //RI_item_Xt_qty_start_lth_...end_lth_Ritem_start_lth...end_lth
         for (int pp = 0; pp < itemsToPlan.size(); pp++) {
         	IloLinearNumExpr cf = cplex.linearNumExpr();				         
	       for (int t = 1; t < main.simParams.getMRPPlanningHorizon()-1; t++) {	            	            
			       	String o = "";
			       	int sizeExpr = 0;
			        IloLinearNumExpr num_expr = cplex.linearNumExpr();
			                    
	                for (int p = 0; p < iQd.size(); p++) {
	                	if(iQd.get(p).getItem()== itemsToPlan.get(pp).getItem().getItem()){
	                	
		            		if(releaseTmp[p][t] > 0){
		            			
		            			o = o + iQd.get(p).getQuantity() + "*" + RI[p][releaseTmp[p][t]-1].getName() +  "+";	            			
		            			num_expr.addTerm(iQd.get(p).getQuantity(),RI[p][releaseTmp[p][t]-1]);
		            					            					            					            			
		            			sizeExpr++;		            					            					            			
		            		}			        
	            		}
					}
					
				if(o.length() > 1){
		            if(sizeExpr > 0){
		            	//Constraint Release Size 
			            cplex.addEq(R[pp][t],num_expr);    
			                  
			        }

				}else{
				         cplex.addEq(R[pp][t],0);          								
				}
																
				num_expr.clear();             														
			}         
         }
         
     /*    
         //sumRIs: represent the RI for the leadtime horizon
         //required for EQ10 and EQ11 to get the setuptime as part of the clearing functions
         IloNumVar[] sumRIs = new IloNumVar[leadtimeHorizon];     
         //IloLinearNumExpr sumRIsI = cplex.linearNumExpr();			
         
           for (int t = 0; t < main.simParams.getMRPPlanningHorizon()-1; t++) {
           	IloLinearNumExpr sumRIsI = cplex.linearNumExpr();			
           	    
               for (int pp = 0; pp < itemsToPlan.size(); pp++) {        	            
		           for (int p = 0; p < iQd.size(); p++) {
		 				    if(iQd.get(p).getItem()== itemsToPlan.get(pp).getItem().getItem()){ 	
		 				    	if(releaseTmp[p][t] > 0){ 				    			
					        	//RI[p] = cplex.boolVarArray(leadtimeHorizon, RiNames[p]);					        	  
					        	  sumRIsI.addTerm(1.0,RI[p][releaseTmp[p][t]-1]); // the -1 allows releases RIt in the same period as Xt
						       	}//if
				       		}//if
				   		}//for
				   		           
	         		}//for
	         		sumRIs[t] = sumRIsI;
	         		sumRIsI.clear();
	         }//for                  
         
        */
        
        
		IloLinearNumExpr[] sumRIs = new IloLinearNumExpr[main.simParams.getMRPPlanningHorizon()];
		
		for (int t = 0; t < main.simParams.getMRPPlanningHorizon(); t++) {
		    IloLinearNumExpr sumRIsI = cplex.linearNumExpr();
		
		    for (int pp = 0; pp < itemsToPlan.size(); pp++) {
		        for (int p = 0; p < iQd.size(); p++) {
		            if (iQd.get(p).getItem() == itemsToPlan.get(pp).getItem().getItem()) {
		                if (releaseTmp[p][t] > 0) {
		                	//traceln("###### " + 1.0 + " :::: " +  RI[p][releaseTmp[p][t] - 1]);		                
		                    sumRIsI.addTerm(1.0, RI[p][releaseTmp[p][t] - 1]);		                    
		                }
		            }
		        }
		    }
		    
		    sumRIs[t] = sumRIsI;		    		    		    
		    //sumRIsI.clear();
		}				
		             
         //Constraint avoiding that RI with later due date, releases order earlier that RI with earlier due date (orders should not overteak each other)
         //The release of order 2 should not before order 1                                         
         // ********************************* Guarantee Release ORDER  ****************************************
         // ***************************************************************************************************
         if(false){
         for (int pp = 0; pp < itemsToPlan.size(); pp++) {        	            
            for (int i = 0; i < leadtimeHorizon; i++) {
                for (int j = 0; j < iQd.size(); j++) {
                    for (int k = j + 1; k < iQd.size(); k++) {
                        IloLinearNumExpr constraint = cplex.linearNumExpr();
                                                                        
                        if(RI[j][i].getName() != "noRelease" && RI[k][i].getName() != "noRelease" && RI[j][i].getName() != null){
	                    
		                    String[] RiSplitted = RI[j][i].getName().split("_");                        
	                        int item =  Integer.parseInt(RiSplitted[1]);
	                        
	                        String[] RiSplitted2 = RI[k][i].getName().split("_");                        
	                        int item2 =  Integer.parseInt(RiSplitted2[1]);	                       	                        
	                        	                    
			                    if(itemsToPlan.get(pp).getItem().getItem() == item && itemsToPlan.get(pp).getItem().getItem() == item2){    
			                        constraint.addTerm(RI[j][i], 1.0); // 1 of set j		                        
			                        constraint.addTerm(RI[k][i], -1.0); // -1 of set k
			                        cplex.addLe(constraint, 0); // set j[i] - set k[i] <= 0
			                        //cplex.addGe(constraint, 0); // set j[i] - set k[i] <= 0
			                     }                                                   
	                        }
	                    }
	                }
	            }
	        }
            }
            
            
//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
// Constraint avoiding that RI with later due date, releases order earlier that
// RI with earlier due date (orders should not overteak each other) The release
// of order 2 should not before order 1
traceln("iQd size " + iQd.size());
for (int p = 0; p < iQd.size(); p++) {
    // traceln("~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~");
    // for(int i = 0; i < leadtimeHorizon; i++){
    // for(int i = 0; i < 1; i++){
    // if(cplex.getValue(RI[p][i]) > 0){

    int i = 0;
    for (int k = 1; k <= leadtimeHorizon; k++) {
        // traceln("Name Go ??????? " + RI[p][k].getName());
        if (RI[p][k].getName().contains("RI")) {
            i = k;
            break;
        }
    }

    // traceln("Selected i " + i);
    // traceln("Name 1 ??????? " + RI[p][i].getName());

    if (RI[p][i].getName() != null && RI[p][i].getName() != "noRelease") {
        // traceln("Name 1 ??????? " + RI[p][i].getName());
        String[] RiSplitted = RI[p][i].getName().split("_");

        int endDate = Integer.parseInt(RiSplitted[2]); // enddate (Xt)
        int item = Integer.parseInt(RiSplitted[1]); // item (Xt)
        int startDate = Integer.parseInt(RiSplitted[5]); // startdate (Xt)
        traceln("item " + item + " startDate "+ startDate +  " endDate " + endDate);

		if(endDate == 1 && startDate == 1)
			continue;

        // check if another RIs with a later endDate (Xt) exists
        // we iterate again over all RIs, avoid this only one iteration per RI
        boolean found = false;
        for (int p2 = 0; p2 < iQd.size(); p2++) {
            int i2 = 0;

            for (int k = 1; k <= leadtimeHorizon; k++) {
                if (RI[p2][k].getName().contains("RI")) {
                    i2 = k;
                    found = true;
                    break;
                }
            }

            String[] RiSplittedSuccessor = RI[p2][i2].getName().split("_");

            // traceln("Name 2 ??????? " + RI[p2][i2].getName());

            if (RI[p2][i2].getName() != null
                && RI[p2][i2].getName() != "noRelease") {
                int endDateSuccessor =
                    Integer.parseInt(RiSplittedSuccessor[2]); // enddate (Xt)
                int itemSuccessor =
                    Integer.parseInt(RiSplittedSuccessor[1]); // enddate (Xt)

                // traceln("item Succ " +itemSuccessor + " endDate " +
                // endDateSuccessor);
                //if (endDate < endDateSuccessor
                  //  && itemSuccessor
                    //    == item) { // don't iterate over the same RI
				if (endDate < endDateSuccessor) {
                    int RiendDateSuccessor = Integer.parseInt(
                        RiSplittedSuccessor[2]); // enddate (Xt) RI successor
                    // traceln(" ----> Overlapping Successor " + itemSuccessor +
                    // " end date " + endDateSuccessor + " " +
                    //RI[p2][i2].getName());
                    int overlappingStart = (endDateSuccessor - leadtimeHorizon);
                    
                    
                    // traceln("overlapping start " + overlappingStart);
                    // traceln("overlapping end " + endDate);

                    IloLinearNumExpr lhs = cplex.linearNumExpr();
                    IloLinearNumExpr rhs = cplex.linearNumExpr();

                    // traceln("Start Index " + RIstartIndex);
                    int overlappingPeriods = endDate - overlappingStart;
                    
                    //if(startDate == endDate)
                    	//overlappingPeriods = endDateSuccessor;

                    int RIstartIndex =
                        max(0, (leadtimeHorizon - overlappingPeriods));                                            

                    StringBuilder lhsOut = new StringBuilder();
                    StringBuilder rhsOut = new StringBuilder();
                    
                    int multiplier = 0;
                   // boolean lhsGoIn = true;
                    for (int o = 0; o < overlappingPeriods; o++) {
                        // traceln(" p " + p);
                        // traceln(" p2 " + p2);
                        // traceln(RI[p][0]);
                        // traceln(RI[p2][0]);
                        // traceln(RIstartIndex + o);
					
                        if (RI[p][RIstartIndex + o].getName().contains("RI")) {
							
							//if(lhsGoIn) {
	                            lhs.addTerm(
	                                multiplier + 1, RI[p][RIstartIndex + o]);
	                                
	                            lhsOut.append(multiplier + 1 + " "
	                                + RI[p][RIstartIndex + o].getName() + "+");
	                                
	                                //if(endDate == startDate && o > 0)
	                                	//lhsGoIn = false;
							//}

                            rhs.addTerm(multiplier + 1, RI[p2][o]);
                            rhsOut.append(multiplier + 1 + " "
                                + RI[p2][o].getName() + "+");

                            multiplier++;
                        }
                    }

                    cplex.addLe(lhs, rhs);

                    traceln("Overlapping:");
                    traceln(lhsOut.toString() + "<=");
                    traceln(rhsOut.toString());
                    
                    if(found){
                    	break;
                    }
                }
            }
        }
    }
}
                       
//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~            
                                                                                                
            
         //****************** CF SECTION ***************************************
         //*********************************************************************
         
         for (int t = 0; t < main.simParams.getMRPPlanningHorizon(); t++) {	    
         
	     	IloLinearNumExpr cf = cplex.linearNumExpr();				             	    
	     	IloLinearNumExpr cf1 = cplex.linearNumExpr();				             	    
	       	IloLinearNumExpr cf2 = cplex.linearNumExpr();				             	    
		   	IloLinearNumExpr cf3 = cplex.linearNumExpr();				             	    
	       	IloLinearNumExpr cf4 = cplex.linearNumExpr();				             	    

    	    
    	    //Pgt smaller Wgt - Constraint for single item qty
        	 for (int pp = 0; pp < itemsToPlan.size(); pp++) {        	  			
					//merk dir, dass die weiter unten verwendet werden
					//double setupProption = 18.0/106.0;
					double setupProption = 0;
					
	         		cf.addTerm(itemsToPlan.get(pp).getItem().getRouting().getEProcessingTime()+setupProption,P[pp][t]);	         		
	         		
	         		cf1.addTerm(itemsToPlan.get(pp).getItem().getRouting().getEProcessingTime()+setupProption,P[pp][t]); 	         		        		
         			cf2.addTerm(itemsToPlan.get(pp).getItem().getRouting().getEProcessingTime()+setupProption,W[pp][t]);         			         		        			         			
         			
         			cf3.addTerm(itemsToPlan.get(pp).getItem().getRouting().getEProcessingTime()+setupProption,P[pp][t]);         		
         			cf4.addTerm(itemsToPlan.get(pp).getItem().getRouting().getEProcessingTime()+setupProption,W[pp][t]);
         			
         			
         			//***************** Ppt, <= Wp,t ***********************        			         		         			
         			cplex.addLe(
         				//cplex.sum(P[pp][t],cplex.prod(0,sumRIs[t])),//LHS         			
         				cplex.sum(P[pp][t],0),//LHS         			
        				cplex.sum(W[pp][t],0));//RHS         			
        			//****************************************        			         		         				
        				        				        				        			        			        				
        	  }
        	          	  
			  //CF Constraints			           	  
			  //PL <= MC + Ct (Eq12)			  
			  //traceln("setup time " + setupTime + " sum ri " + sumRIs);
         	  //cplex.addLe(cplex.sum(cf,cplex.prod(setupTime,sumRIs)), //LHS         	  
         	  
         	  
         	  // **************** PL und L ausgeben *********************
         	  //keine constraints werden spter so auch nicht wiedervendet
         	  cplex.addEq(PL[t],cf);
         	  cplex.addEq(L[t],cf2);
         	  //********************************************************* 
         	  
         	  
         	  //cplex.addEq(PL[t],cplex.sum(cf,cplex.prod(setupTime,sumRIs)));
         	  //cplex.addEq(L[t],cplex.sum(cf2,cplex.prod(setupTime,sumRIs)));         	           	           	           	  
         	  
         	  /******** PLt <=MC+Ct (Eq14) ************/
         	  if(t==0){         	           	           	           	  
         	  		cplex.addLe(cf,         	  
         	  		cplex.sum(0,C[t]));	//RHS
         	  	}else{
         	  		//cplex.addLe(cf,         	  		
         	  		//traceln("da" + sumRIs[t].toString());
         	  		cplex.addLe(cplex.sum(cf,cplex.prod(setupTime,sumRIs[t])),         	  
         	  		cplex.sum(maxCapacity,C[t]));	//RHS
         	  	}
         	           	           	           	  		         	           	           	  
         	           	           	  
         	  // ---- we have three segments         	           	           	  
			  //CF partition 2 from numerical example
			  //traceln("# segments " + numberSegments);
			  //represent CF as k*x + d -> 
			  for(int i = 0; i < numberSegments; i++){
	         	  cplex.addLe(
    	     	  	cplex.sum(cf1,cplex.prod(setupTime,sumRIs[t])), //LHS				
				
         	  		cplex.sum(cplex.sum(cplex.prod(max(slopes[i],0),         	  	         	  	
         	  		
         	  		cplex.sum(cf2,cplex.prod(setupTime,sumRIs[t]))),intercepts[i]),C[t]));//RHS         	  		         	  						
         	  	
         	  		traceln("Slope (x): " + slopes[i] + " Y-intercept (d) " + intercepts[i]);
         	  		         	  		
         	  	//traceln("sumRIs " + sumRIs + " st " + setupTime);	
         	  }//for
         	           	           	           	  
         	           	           	           	  			           	  
         	  /******************************* PLt <= Lt + Ct (Eq18) *********************/
         	  //Constraint Pl musst be smaller as SL for all t         	           	  
         	  cplex.addLe(
         	  	cplex.sum(cf3,cplex.prod(setupTime,sumRIs[t])), //LHS         	  
	         	cplex.sum(cplex.sum(cf4,cplex.prod(setupTime,sumRIs[t])),C[t]));         	  	         	
	          //***************************************************************************
         	  
			  cf.clear();
			  cf1.clear();
 			  cf2.clear();
 			  cf3.clear();
 			  cf4.clear();
         }



			// Create a two-dimensional array of IloNumVars
            int numRows = iQd.size(); // Assuming iQd is a list or array
                        
            // ... Initialize and populate the RI array with IloNumVars ...

            // Find the variable by name in the RI array
            traceln("iQd size: " + iQd.size());
            String targetVariableName = "noRelease";
            boolean isVariableFound = false;
            IloNumVar foundVariable = null;

            for (int i = 0; i < numRows; i++) {
                for (int j = 1; j < RI[i].length-1; j++) {
                    IloNumVar var = RI[i][j];
                    if (var.getName().equals(targetVariableName)) {
                        isVariableFound = true;
                        foundVariable = var;
                        break;
                    }
                }
                if (isVariableFound) {
                    break;
                }
            }
            
            if (isVariableFound) {
                // Add a constraint to enforce the found variable to be zero
                traceln("Yes found");                
                foundVariable.setName("noRelease");                                
                cplex.addEq(foundVariable, 0);
            }
            
            //All Entries represent Running Orders. So the associated
            //RI_...1 must be set to one
            
                                    
            int numberOpenOrders = runningOrders.size();
            for(SpecialObject o : runningOrders){
            	traceln(o.getItem() + " " + o.getQuantity() + " " + o.getQuantityRunning());
            }
            
            isVariableFound = false;
            traceln("Count Running Orders: " + numberOpenOrders);
            traceln("RI length: " + RI.length);
            for (int i = 0; i < numberOpenOrders; i++) {
            	for (int j = 1; j < RI[i].length-1; j++) {
            	
            		//"RI_103_13_106.0_0R103_0"
            					                                		
            	    String[] RiSplitted = RI[i][j].getName().split("_");
			        traceln(RI[i][j].getName().split("_"));
                    
                    IloNumVar var = RI[i][j];
                    
                    if(!var.getName().equals("noRelease")){
                    	
                    	targetVariableName = "RI_" + RiSplitted[1] + "_" + (int) runningOrders.get(i).getDueDate() + "_" + 
                    	runningOrders.get(i).getQuantity() + "_1" + "R" +  RiSplitted[1] + "_1";
                    
                    	traceln("Running Order Target Name ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~: " + targetVariableName);
                    
	                    if (var.getName().equals(targetVariableName)) {
	                        isVariableFound = true;
	                        foundVariable = var;
	                        break;
	                    }
	                 }
                }                        
                
                if (isVariableFound) {	                	                	                
	                cplex.addEq(foundVariable, 1);
	                traceln("Release Variable found " + foundVariable.getName() + " set to 1");
	                isVariableFound = false;
            	}
            }
            
                                                               
    
    //cplex.deleteNames();
    
    //if(time() == 0)
    if(Tools.Log_CF_Optimization_Values){                 
		cplex.exportModel("model/NewModel_" + time() + "_" + bomLevel + "_" + firstBomItem.getItem() +".lp");
	}	
	//cplex.writeSolution("model/NewModel_" + time() + "_" + bomLevel + ".sol");

	//cplex.setParam(IloCplex.BooleanParam.PreInd, true);
	//0.05 were to hard ... 0.1 before
	//cplex.setParam(IloCplex.Param.MIP.Tolerances.MIPGap, 0.05);
	//cplex.setParam(IloCplex.IntParam.DataCheck, 2);	
	cplex.setParam(IloCplex.IntParam.WorkMem, 2000);
						
	if(cplex.solve() && Tools.Log_CF_Optimization_Values){
		    
		    System.out.println("Solution status: " + cplex.getStatus());
            System.out.println();
            System.out.println("Objective Value = " + cplex.getObjValue());
          
            System.out.println("Pieces: Wip, X, Release, P");
            System.out.println("Minutes: PL L, MC, CF1, CF2, CF3");
            System.out.println("\tp\tTime\tt\tWip\tX\tRelease\tP\tPL\tL\tMC\tCF1\tCF2\tCF3\tInv\tIBl\tWB\tObjPP\tCt\tBt\tPTime\tSTime\tPL\tLt\tICo\tWCo\tBco\tCo");
          	
            int[] t_sum_wip = new int[get_Main().simParams.getMRPPlanningHorizon()];
            int[] t_sum_pl = new int[get_Main().simParams.getMRPPlanningHorizon()];
            int[] t_sum_l = new int[get_Main().simParams.getMRPPlanningHorizon()];
            int[] t_sum_load = new int[get_Main().simParams.getMRPPlanningHorizon()];
            int[] t_sum_x = new int[get_Main().simParams.getMRPPlanningHorizon()];
            int[] t_sum_r = new int[get_Main().simParams.getMRPPlanningHorizon()];
            int[] t_sum_p = new int[get_Main().simParams.getMRPPlanningHorizon()];
          	
            for (int p = 0; p < itemsToPlan.size(); p++) {
                        	
               for (int t = 0; t < get_Main().simParams.getMRPPlanningHorizon(); t++) {
               
               double inventoryBalance = 0;
               double wipBalance = 0;

               if(t>0){
                  inventoryBalance = cplex.getValue(I[p][t-1])-X[p][t]+cplex.getValue(P[p][t-1]) - cplex.getValue(B[p][t-1]) + cplex.getValue(B[p][t]);
                  wipBalance = cplex.getValue(W[p][t-1])+cplex.getValue(R[p][t])-cplex.getValue(P[p][t-1]);               
               }
               		
               	  double lt = cplex.getValue(W[p][t])*itemsToPlan.get(p).getItem().getRouting().getEProcessingTime();
               	  double pl = cplex.getValue(P[p][t])*itemsToPlan.get(p).getItem().getRouting().getEProcessingTime();
               	  
               	  double objectivePerPeriod = cplex.getValue(W[p][t]) * itemsToPlan.get(p).getItem().getHoldingCostsWIP() + 
               	  							  cplex.getValue(I[p][t]) * itemsToPlan.get(p).getItem().getHoldingCosts() + 
               	  							  cplex.getValue(B[p][t]) * itemsToPlan.get(p).getItem().getBacklogCosts() +
               	  							  cplex.getValue(C[t]) * oCosts;  
               	  							  
               	  							  
               	 // traceln(cplex.getValue(W[p][t]) + "*" + itemsToPlan.get(p).getItem().getHoldingCostsWIP() + " = " + cplex.getValue(W[p][t]) * itemsToPlan.get(p).getItem().getHoldingCostsWIP());							               	  
               	 // traceln(cplex.getValue(I[p][t]) + "*" + itemsToPlan.get(p).getItem().getHoldingCosts() + " = "  + cplex.getValue(I[p][t]) * itemsToPlan.get(p).getItem().getHoldingCosts());							               	  
               	 // traceln(cplex.getValue(B[p][t]) + "*" + itemsToPlan.get(p).getItem().getBacklogCosts() + " = " + cplex.getValue(B[p][t]) * itemsToPlan.get(p).getItem().getBacklogCosts());							               	  
               	 // traceln(cplex.getValue(C[t]) + "*" + oCosts + " = " + cplex.getValue(C[t]) * oCosts);							               	  
               	  
               	  int slope2 = -99;
               	  int slope3 = -99;
               	  
               	  if(selectedSegments.size() == 2){
               	  	slope2 = (int)(slopes[1]*lt+intercepts[1]);
               	  }
               	  
              	  if(selectedSegments.size() == 3){
               	  	slope3 = (int)(slopes[2]*lt+intercepts[2]);
               	  }
               	                 	  
               	  int wipForPrintLn = (int)cplex.getValue(W[p][t]);               	                 	                 	  
               	  
                  System.out.println("\t" + itemsToPlan.get(p).getItem().getItem() +
                                     "\t" + (time() + t -1) +
                                     "\t" + t +                                     
                                     "\t" + (int)Math.round(wipForPrintLn) +
                                     "\t" + X[p][t] +
                                     "\t" + (int)Math.round(cplex.getValue(R[p][t])) +                                            
                                     "\t" + cplex.getValue(P[p][t]) +
                                     //"\t" + (int)Math.round(pl) +
                                     //"\t" + (int)Math.round(lt) +                                     
                                     "\t" + cplex.getValue(PL[t]) +      
                                     "\t" + cplex.getValue(L[t])  +
                                     "\t" + maxCapacity + 
                                     "\t" + (int)(slopes[0]*lt+intercepts[0]) + 
                                     "\t" + slope2 + 
                                     "\t" + slope3 +                                      
                                     "\t" + Math.round(cplex.getValue(I[p][t])) +
                                     "\t" + Math.round(inventoryBalance) +
                                     "\t" + (int)Math.round(wipBalance) +
                                     "\t" + (int)Math.round(objectivePerPeriod) +
                                     "\t" + Math.round(cplex.getValue(C[t])) +
                                     "\t" + (int)cplex.getValue(B[p][t]) + 
                                     "\t" + itemsToPlan.get(p).getItem().getRouting().getEProcessingTime() +
                                     "\t" + itemsToPlan.get(p).getItem().getRouting().getESetupTime()  +
                                     "\t" + cplex.getValue(PL[t]) +      
                                     "\t" + cplex.getValue(L[t])  +
                                     "\t" + (int)itemsToPlan.get(p).getItem().getHoldingCosts() +
                                     "\t" + (int)itemsToPlan.get(p).getItem().getHoldingCostsWIP() +
                                     "\t" + (int)itemsToPlan.get(p).getItem().getBacklogCosts() +
                                     "\t" + (int)oCosts                                                                              
                                     );                                                                                                 
            
            		//t_sum_wip[t] += wipForPrintLn;
            		
            		t_sum_x[t] += X[p][t];            		
            		t_sum_wip[t] += (int)cplex.getValue(W[p][t]) ;
            		t_sum_r[t] += (int)Math.round(cplex.getValue(R[p][t]));            		
            		t_sum_p[t] += (int)cplex.getValue(P[p][t]);
            		
            		//if(t==0){
            			t_sum_pl[t] = (int)cplex.getValue(PL[t]);
            			t_sum_l[t] = (int)cplex.getValue(L[t]);
            		//}
            			
            		t_sum_load[t] += lt;
	                                    
			if(OptimizationResult.WRITE_OPTIMIZATION_RESULTS_TO_XLXS){                    
                    OptimizationResult optResult = new OptimizationResult(                                        
                                        
	                   					itemsToPlan.get(p).getItem().getItem(),
	                                     (time() + t -1),
	                                     t,                                     
	                                     (int)Math.round(wipForPrintLn),
	                                     X[p][t],
	                                     Math.round(cplex.getValue(R[p][t])),                                            
	                                     cplex.getValue(P[p][t]),
	                                     cplex.getValue(PL[t]),      
	                                     cplex.getValue(L[t]),
	                                      maxCapacity,
	                                     (int)(slopes[0]*lt+intercepts[0]),
	                                      slope2,
	                                      slope3,                                      
	                                      (int)Math.round(cplex.getValue(I[p][t])),
	                                      (int)Math.round(inventoryBalance),
	                                      (int)Math.round(wipBalance),
	                                      (int)Math.round(objectivePerPeriod),
	                                      (int)Math.round(cplex.getValue(C[t])),
	                                      (int)cplex.getValue(B[p][t]), 
	                                     (double) itemsToPlan.get(p).getItem().getRouting().getEProcessingTime(),
	                                     (double) itemsToPlan.get(p).getItem().getRouting().getESetupTime(),
	                                     cplex.getValue(PL[t]),      
	                                     cplex.getValue(L[t]),
	                                     (int)itemsToPlan.get(p).getItem().getHoldingCosts(),
	                                     (int)itemsToPlan.get(p).getItem().getHoldingCostsWIP(),
	                                     (int)itemsToPlan.get(p).getItem().getBacklogCosts(),
	                                     (int)oCosts,
	                                     cplex.getValue(Z[p][t])
	                    );
                                                            
	                    get_Main().optimizationResults.add(optResult);                                                      
	                 }   
               }                              
            }
            
            System.out.println("\n");
            System.out.println("\tTime\tt\tX\tWip\tR\tP\tPL\tL");           
            for(int t = 0; t < get_Main().simParams.getMRPPlanningHorizon(); t++) {
            
            	System.out.println(
            		"\t" + (time() + t) +
       				"\t" + t +           
       				"\t" + t_sum_x[t] + 		
            		"\t" + t_sum_wip[t] +
            		"\t" + t_sum_r[t] +
            		"\t" + t_sum_p[t] +
	           		"\t" + t_sum_pl[t] +
            		"\t" + t_sum_l[t]            	
            	);            
            }
                 	  
            
            //if(OptimizationResult.WRITE_OPTIMIZATION_RESULTS_TO_XLXS)
			//OptimizationResult.WriteXlsxOptimizationResults(get_Main().optimizationResults, get_Main().simParams);            
            	//traceln("size +++++++++++ " + get_Main().optimizationResults.size());
            
		}else{
			traceln("NO Solution " + cplex.getStatus());
		}												


			/*
        	for (int p = 0; p < iQd.size(); p++) {        	        
               for (int t = 0; t < leadtimeHorizon; t++) {   
                            
                            traceln("da");
					        
					        //double qty = cplex.getValue(RI[p][t]);    			            			            		            
					        double qty = 99;					        					        
							int itemIntTmp = iQd.get(p).getItem();
					        traceln(RI[p][t].getName().split("_"));
					        traceln("item " + itemIntTmp + " p " + p + "t " + t + "qty " + qty);
			}
			}
        	*/
        	
        	for (int p = 0; p < iQd.size(); p++) {        	        
               for (int t = 1; t < leadtimeHorizon; t++) {   
            				            
            				//traceln("da vor qty " + p + " " + t + " " + RI[p][t].getName());            				            				
					        					        				        
					        if(RI[p][t].getName() != "noRelease"){
					        						        
					        double qty = cplex.getValue(RI[p][t]);    			            			            		            
					        //traceln(qty);
					        //traceln("da for if");				               					        
							if(qty > 0.9){
					        //traceln("da");				               					        
								
								//traceln("qty " + qty + " " + RI[p][t].getName());
								
								
								//if we have a running order, we have to reduce the release qty, as it was only required for the decision of release qty
			                    //but the qty itself is already considered for production.
			                    //traceln("X[" + p + "," + t + "] " + X[p][t] + " qty " + iQd.get(p).getQuantity() + " Running Orders Qty: " + iQd.get(p).getQuantityRunning());	        				        			        		
			                    traceln("X qty " + iQd.get(p).getQuantity() + " Running Orders Qty: " + iQd.get(p).getQuantityRunning());	        				        			        		
			                    
			                    double qtyFinal = Math.ceil(iQd.get(p).getQuantity()-iQd.get(p).getQuantityRunning());
			                    traceln("Final Qty: " + qtyFinal);
			                    if(qtyFinal > 0){
				                    ProductionOrder order = new ProductionOrder();			                    			                    
				                    
				                    order.setQuantity(qtyFinal);			                    			                    
				                    
				                    traceln("Set Production Order Qty: " + order.getQuantity());
				                    order.setCreatedAt(time());
												                    				                    								
									int itemIntTmp = iQd.get(p).getItem();
										
				                    Item item = get_Main().items.stream().filter(e -> e.getItem() == itemIntTmp).findFirst().get();																		                     
				                    
				                    order.setOrderId(get_Main().prodOrderId++);
				                    order.setItem(item);
				                                                                                                                                  
									order.setPlannedCapacity(Routing.GetPlannedCapacityPerItem(get_Main().routings, order.getItem(), get_Main().simParams, order));
									
									//order.setPlannedCapacity(Routing.GetPlannedCapacityPerItem(routingList, order.getItem(), simParams, order));
									order.setPlannedSetupTime(Routing.GetPlannedSetupTimePerItem(get_Main().routings, order.getItem(), get_Main().simParams, order));								
				                    
				                    int minimumRoutingStep = Routing.GetMinimumStep(get_Main().routings, order.getItem() , get_Main().simParams);
									int maximumRoutingStep = Routing.GetMaximumStep(get_Main().routings, order.getItem() , get_Main().simParams);
							
									order.setMinimumRoutingStep(minimumRoutingStep);
									order.setMaximumRoutingStep(maximumRoutingStep);			
									order.setCurrentRoutingStep(minimumRoutingStep);                                        			                    			                    
				                                                            
				                    //order.setQuantity(Math.round(iQd.get(p).getQuantity()));
				                    
				                    //traceln("################################## " + iQd.get(p).getQuantity());
				                    				                    				                    				                    
				                    //get the start and end dates from the RI decision variables			                    
				                    String[] RiSplitted = RI[p][t].getName().split("_");
				                    
				                    traceln(RI[p][t].getName().split("_"));
				                    
				                    //order.setPlannedStart(max(Integer.parseInt(RiSplitted[5]) + time() - item.getSafetyLeadTime(), time()));
				                    //order.setPlannedStart(Integer.parseInt(RiSplitted[5] + time());
	
				                    //safety leadtime for stochastic scenario
				                    //order.setPlannedStart(max(Integer.parseInt(RiSplitted[5]) + time() - 1, time()));
				                    
				                   // order.setPlannedStart(max(Integer.parseInt(RiSplitted[5]) + time() - 1, time()));
				                    
				                    //Optimization Starts with 0, so we have to subract -1 from the result to meet the correct MRP Periods
				                    order.setPlannedStart(max(Integer.parseInt(RiSplitted[5]) + time() - 1, time()));
				                    order.setPlannedEnd(Integer.parseInt(RiSplitted[2]) + time() - 1);
				                    
				                    traceln("Planned Start: " + order.getPlannedStart() +  " Planne End:" + order.getPlannedEnd() + " Time " + time());			                    			                            
				                    
				                    long exists = 0;				
				                                   			                    
				                    if(order.getPlannedStart() < time())
				                    	exists = 1;			                    											
					                    if(exists == 0){
					                    	//traceln("Production Order Added");														                    
						                    Routing routingObject = get_Main().routings.stream().filter(e -> e.getItem().getItem() == order.getItem().getItem()).findFirst().get();			
											order.setRouting(routingObject);
											order.setStatus(ProductionOrder.PRODUCTION_ORDER_STATUS_UNPROCESSED);
						                    
						                    get_Main().productionOrders.add(order);	                    						
															                    
					                    }//if
					                }    
		                    	}// if qty	
		                    	}	                    
		                 }//for            
		            }//for
                        
        if(false) {
			traceln("Production Orders from Optmization Before Removing");
			traceln(ProductionOrder.GetCSVHeader());
			
	        for (ProductionOrder order: get_Main().productionOrders) {
	           traceln(ProductionOrder.GetCSVString(order));
	        }        
			
	        //get_Main().productionOrders.removeIf(e -> e.getPlannedStart() > time());
	
	        traceln("Production Orders from Optmization FOR SIMULATION");
	        traceln(ProductionOrder.GetCSVHeader());
	
	        for (ProductionOrder order: get_Main().productionOrders) {
	            traceln(ProductionOrder.GetCSVString(order));
	        }        
	        traceln("**************************");                							
        }
		
		//get_Main().Function_OrderRelease();
		
		cplex.deleteNames();        
    	if(Tools.Log_CF_Optimization_Values){                 
			cplex.exportModel("model/NV/NewModel" + time() + "_" + bomLevel + ".lp");
		}	
		
		cplex.end();		
	}
	catch (IloException exc) {
         System.err.println("Concert exception '" + exc.getMessage() + "' caught");
         System.exit(-1);
    }

return 0;
]]></Body>
				</Function>
				<Function AccessType="default" StaticFunction="false">
					<ReturnModificator>RETURNS_VALUE</ReturnModificator>
					<ReturnType><![CDATA[IloNumVar]]></ReturnType>
					<Id>1698133495514</Id>
					<Name><![CDATA[Function_FindeRIVarialbe]]></Name>
					<X>910</X><Y>70</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Parameter>
						<Name><![CDATA[iQdSize]]></Name>
						<Type><![CDATA[int]]></Type>
					</Parameter>
					<Parameter>
						<Name><![CDATA[RI]]></Name>
						<Type><![CDATA[IloNumVar[][]]]></Type>
					</Parameter>
					<Parameter>
						<Name><![CDATA[item]]></Name>
						<Type><![CDATA[int]]></Type>
					</Parameter>
					<Parameter>
						<Name><![CDATA[dueDate]]></Name>
						<Type><![CDATA[int]]></Type>
					</Parameter>
					<Parameter>
						<Name><![CDATA[startDate]]></Name>
						<Type><![CDATA[int]]></Type>
					</Parameter>
					<Parameter>
						<Name><![CDATA[qty]]></Name>
						<Type><![CDATA[double]]></Type>
					</Parameter>
					<Body><![CDATA[                       
//traceln("RI length: " + RI.length);
//traceln("input item " + item + " dueDate " + dueDate + " startDate " + startDate + " qty " + qty);
for (int i = 0; i < iQdSize; i++) {
	for (int j = 1; j < RI[i].length; j++) {
	
		//"RI_103_13_106.0_0R103_0"
					                                		
	    String[] RiSplitted = RI[i][j].getName().split("_");
        //traceln(RI[i][j].getName().split("_"));
        
        IloNumVar var = RI[i][j];
        
        if(!var.getName().equals("noRelease")){
        	
        	String targetVariableName = "RI_" + item + "_" + dueDate + "_" + 
        	qty + "_" + startDate + "R" +  item + "_" + startDate;
        
        	//traceln("RI Target Name ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~: " + targetVariableName + " var Name " + var.getName());
        	
            if (var.getName().equals(targetVariableName)) {              	              
                //traceln("Release Variable found " + var.getName() + " target " +  targetVariableName);
                return var;
            }//if
         }//if
    }//for                                    
}//for            	
return null;]]></Body>
				</Function>
				<Function AccessType="default" StaticFunction="false">
					<ReturnModificator>RETURNS_VALUE</ReturnModificator>
					<ReturnType><![CDATA[int[]]]></ReturnType>
					<Id>1698139103173</Id>
					<Name><![CDATA[Function_SplitRI]]></Name>
					<X>910</X><Y>100</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Parameter>
						<Name><![CDATA[RI]]></Name>
						<Type><![CDATA[IloNumVar]]></Type>
					</Parameter>
					<Body><![CDATA[int[] output = new int[3];
String[] RiSplitted = RI.getName().split("_");

        int endDate = Integer.parseInt(RiSplitted[2]); // enddate (Xt)
        int item = Integer.parseInt(RiSplitted[1]); // item (Xt)
        int startDate = Integer.parseInt(RiSplitted[5]); // startdate (Xt)
        
        output[0] = item;
        output[1] = startDate;
        output[2] = endDate;
        
        traceln("item " + item + " startDate "+ startDate +  " endDate " + endDate);
        
return output;        ]]></Body>
				</Function>
				<Function AccessType="default" StaticFunction="false">
					<ReturnModificator>RETURNS_VALUE</ReturnModificator>
					<ReturnType><![CDATA[int]]></ReturnType>
					<Id>1698668757178</Id>
					<Name><![CDATA[Function_ClearingFunction4_mrp_horizon]]></Name>
					<X>490</X><Y>190</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Parameter>
						<Name><![CDATA[itemsToPlan]]></Name>
						<Type><![CDATA[List<MRP>]]></Type>
					</Parameter>
					<Parameter>
						<Name><![CDATA[bomLevel]]></Name>
						<Type><![CDATA[int]]></Type>
					</Parameter>
					<Parameter>
						<Name><![CDATA[inResource]]></Name>
						<Type><![CDATA[Resource]]></Type>
					</Parameter>
					<Parameter>
						<Name><![CDATA[fileSuffix]]></Name>
						<Type><![CDATA[String]]></Type>
					</Parameter>
					<Body><![CDATA[try{

Tools to = new Tools();
							
traceln("----------- Start CF OPTIMIZATION at " + time () + " ----------------");
							
StringBuilder output = new StringBuilder();

int maxCapacity = 1440;
//double wipCosts = 0;
//double inventoryHoldingCosts = 0;
traceln("Total found Segments: " + ClearingFunctionSegments.size());


/*
Iterator<MRP> iterator = itemsToPlan.iterator();
while (iterator.hasNext()) {
    MRP o = iterator.next();
    if (o.getItem().getItem() == 103 ||     
    o.getItem().getItem() == 111 ||
    o.getItem().getItem() == 115 ||
    o.getItem().getItem() == 119 ||
    o.getItem().getItem() == 123 ||
    o.getItem().getItem() == 127 ||
    o.getItem().getItem() == 131
    ) {
        iterator.remove(); // Safely remove the element from the list
    }
}
*/

	//via the bom level the cf is associated
	List<ClearingFunctionSegments> selectedSegments = new ArrayList();
	Item firstBomItem = itemsToPlan.get(0).getItem();
	//wipCosts = firstBomItem.getHoldingCostsWIP();
	//inventoryHoldingCosts = firstBomItem.getHoldingCosts();	
	
	//Routing firstRoutingItem = main.routings.stream().filter(e -> e.getItem().getItem() == firstBomItem.getItem()).findFirst().get();	
	//Resource firstResource= main.resources.stream().filter(e -> e.getName().equalsIgnoreCase(firstRoutingItem.getResource())).findFirst().get();
	
	//maxCapacity = inResource.getCapacity();
	//don't map it to the prodction stage 1-4, select the values based on the resource
	traceln("Total found segments: " + selectedSegments);
	
	if(firstBomItem.getLotsizePolicy().equalsIgnoreCase(Item.LOT_POLICY_FOP)) {
		int fop = firstBomItem.getFOPPeriod();	
		traceln("FOP Period:" + fop);	
					
		selectedSegments = ClearingFunctionSegments.stream().filter(e -> e.getLotParameter() == fop &&
							 e.getLotPolicy().equalsIgnoreCase(Item.LOT_POLICY_FOP) && e.getResource().equalsIgnoreCase(inResource.getName()) 
				 && e.getExperiment().equalsIgnoreCase(main.simParams.getExperiment())).collect(Collectors.toList());															 																								
	}
	else if(firstBomItem.getLotsizePolicy().equalsIgnoreCase(Item.LOT_POLICY_FOQ)) {
		int foq = (int)firstBomItem.getFOQQuantity();	
		traceln("FOQ Qty:" + foq);	
					
		selectedSegments = ClearingFunctionSegments.stream().filter(e -> e.getLotParameter() == foq &&
							 e.getLotPolicy().equalsIgnoreCase(Item.LOT_POLICY_FOQ) && e.getResource().equalsIgnoreCase(inResource.getName()) 
				 && e.getExperiment().equalsIgnoreCase(main.simParams.getExperiment())).collect(Collectors.toList());															 																								
	}
				
	traceln("Resource: " + inResource.getName());
	traceln("Resource Stage Number: " + inResource.getStageNumber());
	traceln("Production Stage: " + (bomLevel + 1));
	traceln("Max Capacity: " + maxCapacity);
	
	traceln("Items to Plan: ");
	itemsToPlan.forEach(e -> traceln(e.getItem().getItem() + " eProcessingTime " + e.getItem().getRouting().getEProcessingTime() + ";"));

	traceln("Selected Slopes: ");		
	selectedSegments.forEach(e -> traceln(e.getSlope() + ";"));
	traceln("Selected Intercepts: ");
	
	selectedSegments.forEach(e -> traceln(e.getyIntercept() + ";"));
	
	if(selectedSegments.size() == 0){
		traceln("STOP Simulation: No Segments found!");
		System.exit(0);
	}
	
	to.log("Segment Cnt: " + selectedSegments.size(), Tools.LogCFOptimization);
	
	double intercepts[] = new double[selectedSegments.size()];
	double slopes[] = new double[selectedSegments.size()];
	
	for(int i = 0; i < selectedSegments.size(); i++) {
		slopes[i] = selectedSegments.get(i).getSlope();
		intercepts[i] = selectedSegments.get(i).getyIntercept();
	}		
			
int numberSegments = selectedSegments.size();

double oCosts = 0;
double oFactor = 1000;
double setupTime = 18; //standard = 18
int leadtimeHorizon = main.simParams.getLeadTimeHorizon();


traceln("Leadtime Horizon: " + leadtimeHorizon);

IloCplex cplex = new IloCplex();

     String[][] Inames = new String[itemsToPlan.size()][get_Main().simParams.getMRPPlanningHorizon()];
     String[][] Pnames = new String[itemsToPlan.size()][get_Main().simParams.getMRPPlanningHorizon()];
     String[] PLnames = new String[get_Main().simParams.getMRPPlanningHorizon()];
     String[] Lnames = new String[get_Main().simParams.getMRPPlanningHorizon()];
     String[][] Wnames = new String[itemsToPlan.size()][get_Main().simParams.getMRPPlanningHorizon()];
     String[][] Rnames = new String[itemsToPlan.size()][get_Main().simParams.getMRPPlanningHorizon()];     
     String[][] Bnames = new String[itemsToPlan.size()][get_Main().simParams.getMRPPlanningHorizon()];     
     String[][] Znames = new String[itemsToPlan.size()][get_Main().simParams.getMRPPlanningHorizon()];     
     
     
     for(int i = 0; i< get_Main().simParams.getMRPPlanningHorizon(); i++){
          for (int p = 0; p < itemsToPlan.size(); p++) {
        	 	Inames[p][i] = "I" + itemsToPlan.get(p).getItem().getItem() + "_" + i; 
        	 	Pnames[p][i] = "P" + itemsToPlan.get(p).getItem().getItem() + "_" + i; 
        	 	Wnames[p][i] = "W" + itemsToPlan.get(p).getItem().getItem() + "_" + i; 
        	 	Rnames[p][i] = "R" + itemsToPlan.get(p).getItem().getItem() + "_" + i; 
        	 	Bnames[p][i] = "B" + itemsToPlan.get(p).getItem().getItem() + "_" + i; 
        	 	PLnames[i] = "PL" + itemsToPlan.get(p).getItem().getItem() + "_" + i; 
        	 	Lnames[i] = "L" + itemsToPlan.get(p).getItem().getItem() + "_" + i;
         	 	Znames[p][i] = "Z" + itemsToPlan.get(p).getItem().getItem() + "_" + i;  
        	 	 
	     }
     }

     IloNumVar[] C = new IloNumVar[main.simParams.getMRPPlanningHorizon()];
     for (int t = 0; t < get_Main().simParams.getMRPPlanningHorizon(); t++) {
        C[t] = cplex.numVar(0, Double.MAX_VALUE, "C" + "_" + t);
     }
     
     IloNumVar[][] I = new IloNumVar[itemsToPlan.size()][];
     for (int p = 0; p < itemsToPlan.size(); p++) {
        I[p] = cplex.numVarArray(get_Main().simParams.getMRPPlanningHorizon(), 0, Double.MAX_VALUE, Inames[p]);
        oCosts += itemsToPlan.get(p).getItem().getHoldingCosts();
     }
     
     oCosts = oFactor*oCosts;
     
     IloNumVar[][] P = new IloNumVar[itemsToPlan.size()][];
     for (int p = 0; p < itemsToPlan.size(); p++) {     
        P[p] = cplex.numVarArray(get_Main().simParams.getMRPPlanningHorizon(), 0,  Double.MAX_VALUE, Pnames[p]);        
     }
     
     IloNumVar[] PL = new IloNumVar[leadtimeHorizon];     
     IloNumVar[] L = new IloNumVar[leadtimeHorizon];     
     
     for (int t = 0; t < leadtimeHorizon; t++) {               
     	PL[t] = cplex.numVar(0,  Double.MAX_VALUE, PLnames[t]);
     	L[t] = cplex.numVar(0,  Double.MAX_VALUE, Lnames[t]);
     }
     
                    
     IloNumVar[][] W = new IloNumVar[itemsToPlan.size()][];
     for (int p = 0; p < itemsToPlan.size(); p++) {
        W[p] = cplex.numVarArray(get_Main().simParams.getMRPPlanningHorizon(), 0, Double.MAX_VALUE, Wnames[p]);
     }
		
	 IloNumVar[][] R = new IloNumVar[itemsToPlan.size()][];
     for (int p = 0; p < itemsToPlan.size(); p++) {
        R[p] = cplex.numVarArray(get_Main().simParams.getMRPPlanningHorizon(), 0.0, Double.MAX_VALUE, Rnames[p]);
     }          
     
     IloNumVar[][] B = new IloNumVar[itemsToPlan.size()][];
     for (int p = 0; p < itemsToPlan.size(); p++) {
        B[p] = cplex.numVarArray(get_Main().simParams.getMRPPlanningHorizon(), 0.0, Double.MAX_VALUE, Bnames[p]);
     }
             
          IloNumVar[][] Z = new IloNumVar[itemsToPlan.size()][];
     for (int p = 0; p < itemsToPlan.size(); p++) {
        Z[p] = cplex.numVarArray(get_Main().simParams.getMRPPlanningHorizon(), 0, Double.MAX_VALUE, Znames[p]);
     }            
               	
	double[] inventory = new double[itemsToPlan.size()];
	double[] wip = new double[itemsToPlan.size()];
	double[] produce = new double[itemsToPlan.size()];
	double[] tl = new double[itemsToPlan.size()];
		
	int[][] X = new int[itemsToPlan.size()][get_Main().simParams.getMRPPlanningHorizon()];

	List<SpecialObject> iQd = new ArrayList<SpecialObject>();
	List<SpecialObject> runningOrders = new ArrayList<SpecialObject>();
	
     for (int p = 0; p < itemsToPlan.size(); p++) {      	     

     		   inventory[p] = 0;
     		   
     		   //wip[p] = (int)ProductionOrder.GetCurrentWip(get_Main().productionOrders, itemsToPlan.get(p).getItem(), get_Main().simParams);
     		   	wip[p]=0;
     		   
	        	int tmp_item = itemsToPlan.get(p).getItem().getItem();
				     		
     		   produce[p] = 0;
     		   
     		   //tl[p] = itemsToPlan.get(p).getItem().getTransportLotSize();
     	       for (int t = 0; t < get_Main().simParams.getMRPPlanningHorizon(); t++) {               	                          	               	
	               			               		               		               		               	
	               	//int tmp_item = itemsToPlan.get(p).getItem().getItem();
	               	int temp_t = t;
	               	int quantityRunningProductionOrders = 0;
	               	int lateOrders = 0;
	               	
	               	MRP mrpItem = null;
	               	
	               	if(t > 0){
		               	mrpItem = get_Main().mrpTable.stream().filter(e -> e.getItem().getItem() == tmp_item
		               	 && e.getTime() == time() && e.getPeriod() == temp_t - 1).findFirst().orElseGet(() -> new MRP());
		               	 
		               	 //traceln("T for running Orders: " + t);
		               	 quantityRunningProductionOrders = remainingProductionOrderQty(tmp_item,t + time());
		               	 
		               	 //late Orders must only be computed in period 1 and not the remaining.
		               	 if(t == 1){
		               	 	lateOrders = lateProductionOrdersQty(tmp_item,t + time());						
		               	 }
		               	 
		               	 //traceln("t " + t + " PlannedOrderReceipts " + (int) mrpItem.getPlannedOrderReceipts()); 
		               	 
		               	 X[p][t] += (int) mrpItem.getPlannedOrderReceipts();
		               	 		               	 
		               	//mrpItem.setPlannedOrderReceipts(mrpItem.getPeriod() + 50);
		               	//traceln("MRP Item for Optimization");
		               	//traceln(MRP.GetCSVHeader());
		               	//traceln(MRP.GetCSVString(mrpItem));
	               	}
															
					if(quantityRunningProductionOrders > 0 || lateOrders > 0){
						traceln("RunningProduction Order Qty: " + quantityRunningProductionOrders + " time: " + time() + " t " + t + " item " + tmp_item);
						traceln("old Xpt: " + X[p][t]);
						
						if(t == 1){
							X[p][1] += (quantityRunningProductionOrders + lateOrders);							
						}else{
							X[p][t] += quantityRunningProductionOrders;
						}															
						
						traceln("new Xpt: " + X[p][t]);
						traceln("Now we have to consider the Remaining Qty for Capacity Consumption of: " + X[p][t]);
						
						SpecialObject runningOrder = new SpecialObject(
	        				mrpItem.getItem().getItem(),
	        				X[p][t], 
	        				t,
	        				quantityRunningProductionOrders + lateOrders);
	        				
	        			runningOrders.add(runningOrder);						
					}
															
					//if(t == 1){						
	        			//X[p][t] += (int) mrpItem.getPlannedOrderReceipts();	        				        			
	        		//}else if(t > 1){	        		
	        		
	        		
	        		//}

	        		if(X[p][t] > 0 && t > 0) {
	        			SpecialObject so = new SpecialObject(
	        				mrpItem.getItem().getItem(),
	        				X[p][t], 
	        				t,
	        				quantityRunningProductionOrders + lateOrders);
	        			iQd.add(so);
	        			traceln("X[" + p + "," + t + "] " + X[p][t] + " " + mrpItem.getItem().getItem());	        				        			        		
	        			
	        			//traceln("~~~~~~~~~~~~~" + so.getItem() + " qty: " + so.getQuantity() + " dd " + so.getDueDate());
	        			
	        		}        		  	        		        		
            }     	      	
     }                                        
     
     //if(iQd.size() == 0){     	
     	//throw new ProblemFoundException("No Planned order Receipts found.");
     //}
     	
               
     String[][] RiNames = new String[iQd.size()][leadtimeHorizon];
     int[][] releaseTmp = new int[iQd.size()][main.simParams.getMRPPlanningHorizon()];
     String[] releaseForX = new String[iQd.size()];

	 // this combinations are constructed .. every time the due date in this case 13, a 0 value is added RI_103_13_106.0_0R103_0
	 
	 //RI_103_13_106.0_0R103_0 + RI_103_13_106.0_0R103_0
       //+ RI_103_13_106.0_0R103_0 + RI_103_13_106.0_1R103_1
       //+ RI_103_13_106.0_2R103_2 + RI_103_13_106.0_3R103_3
       //+ RI_103_13_106.0_4R103_4 + RI_103_13_106.0_5R103_5
       //+ RI_103_13_106.0_6R103_6 + RI_103_13_106.0_7R103_7
       //+ RI_103_13_106.0_8R103_8 + RI_103_13_106.0_9R103_9
       //+ RI_103_13_106.0_10R103_10 + RI_103_13_106.0_11R103_11
       //+ RI_103_13_106.0_12R103_12 + RI_103_13_106.0_13R103_13 
	 
	 //for each Xt > 0 an entry to iQd is added and this represnts all Xts of all planned products!
     for (int p = 0; p < iQd.size(); p++) {
          for(int i = 1; i < leadtimeHorizon; i++){
          		int targetT = (int)(iQd.get(p).getDueDate() - leadtimeHorizon + i + 1);          		
          		
          		if(targetT < 0)
          			targetT = 0; // is 0 as this are values later thaen the due date e.g. 13
          		          		
          		releaseTmp[p][targetT] = i+1;
          		
          		if(targetT > 0){          		          		
        	 		RiNames[p][i] = "RI_" +  iQd.get(p).getItem() + "_" + (int)iQd.get(p).getDueDate() +         	 	
        	 		"_" + iQd.get(p).getQuantity() + "_" + targetT + "R" + iQd.get(p).getItem() + "_" + targetT; 
        	 	}else{
        	 		RiNames[p][i] = "noRelease";// + p + "" + i;
        	 	}        	 	        	 	
        	 	
        	 	//traceln(RiNames[p][i]);
	     }    
     }


	 //for each product we need the individual releases RI.....They are constructed with the above equation.            
	 //traceln("iQd.size " + iQd.size());
     IloNumVar[][] RI = new IloNumVar[iQd.size()][];
     for (int p = 0; p < iQd.size(); p++) {
          	     	
     	//e.g. if we have 8 releases while iqd.size = 8 and this all all the xts, we also need 8 RIs to get an individual decision for each Xt, which must be associated with an Release
     	// in each RiNames the item and due date (item and xt) is coded, consequently this works. 
        RI[p] = cplex.boolVarArray(leadtimeHorizon, RiNames[p]);                
        
     }                                      
            
     	//Objective Function     
		IloLinearNumExpr objFunction  = cplex.linearNumExpr();
	         
        for (int p = 0; p < itemsToPlan.size(); p++) {
           for (int t = 0; t < get_Main().simParams.getMRPPlanningHorizon(); t++) {
              objFunction.addTerm (itemsToPlan.get(p).getItem().getHoldingCosts(), I[p][t]);
            }
         }

        for (int p = 0; p < itemsToPlan.size(); p++) {
           for (int t = 0; t < get_Main().simParams.getMRPPlanningHorizon(); t++) {
             objFunction.addTerm (itemsToPlan.get(p).getItem().getHoldingCostsWIP(), W[p][t]);
            }                     	            
         } 
         
         for (int p = 0; p < itemsToPlan.size(); p++) {
           for (int t = 0; t < get_Main().simParams.getMRPPlanningHorizon(); t++) {
             objFunction.addTerm (itemsToPlan.get(p).getItem().getBacklogCosts(), B[p][t]);
            }                     	            
         } 
         
                  
         for (int t = 0; t < get_Main().simParams.getMRPPlanningHorizon(); t++) {
             objFunction.addTerm (oCosts, C[t]);
         }                     	                              
                                      
         cplex.addMinimize(objFunction); //objective function
       
         for (int p = 0; p < itemsToPlan.size(); p++) {
           		
         	cplex.addEq(I[p][0],0); //Eq7
         	cplex.addEq(P[p][0],0); //Eq8  Pg,0 must be zero to avoid production in this period. this is not possible.                           
         	//cplex.addEq(W[p][0],0); //Eq7
         	cplex.addEq(R[p][0],0); //Eq9
         	cplex.addEq(W[p][0],0); //Eq10
         
            for (int t = 1; t < get_Main().simParams.getMRPPlanningHorizon(); t++) {
	           	cplex.addEq(cplex.sum(cplex.sum(I[p][t], X[p][t]),B[p][t-1]), 
                       cplex.sum(cplex.sum(I[p][t-1], P[p][t-1]),B[p][t]));
        	}
            
              
            cplex.addEq(W[p][0], R[p][0]);
            
            for (int t = 1; t < get_Main().simParams.getMRPPlanningHorizon(); t++) {
               cplex.addEq(cplex.sum(W[p][t], P[p][t-1]), 
                           cplex.sum(W[p][t-1], R[p][t]));   
                                                                                                                                    
            }			             											
         }
         
         //********************* Sum of RI_t == 1 *************************
         // RI_103_13_106.0_0R103_0 + RI_103_13_106.0_0R103_0 + RI_103_13_106.0_0R103_0 + RI_103_13_106.0_1R103_1  + RI_103_13_106.0_2R103_2 + RI_103_13_106.0_3R103_3  + RI_103_13_106.0_4R103_4 + RI_103_13_106.0_5R103_5 .... = 1       
         // CF Article EQ3 
          List<String> unique = new ArrayList();
          
          for (int p = 0; p < iQd.size(); p++) {
            IloLinearNumExpr num_expr_Sum_Binaries = cplex.linearNumExpr();  
            boolean weHaveRI = false;	           
	            for (int t = 1; t < leadtimeHorizon; t++) {	            	
	            	
	            	//int tmp_p = p;
	            	//int tmp_t = t;
	            	//traceln("test auf " + RI[tmp_p][tmp_t].getName());
	            	
	            	//boolean exists = unique.stream().filter(element -> element != null).anyMatch(element -> element.equals(RI[tmp_p][tmp_t].getName()));
	            	            	
	            	//if(!exists) {
	            		//unique.add(RI[tmp_p][tmp_t].getName());
	            		//traceln("p" + p + " t " + t );
	            		
	            		if(RI[p][t] != null){
	            		//traceln("ri not null");
	            		String variableName = RI[p][t].getName();
	            		//char isItRI = "RI";
	            		//traceln("Found variable " + variableName);
	            		
							           		
		            		if(variableName.contains("RI")){
		            			weHaveRI = true;
		            			num_expr_Sum_Binaries.addTerm(1,RI[p][t]);															
		            		}
		            		
	            		}
	            		
	            		
	            		//traceln("add" + RI[tmp_p][tmp_t].getName());
	            	//}else{
	            		//num_expr_Sum_Binaries.addTerm(0,RI[p][t]);															
	            	//}					
	            }
	            	            
	            if(weHaveRI)
	            	cplex.addEq(num_expr_Sum_Binaries,1);
            }
         
         
         //RI structure
         //Eq2 where Rg,t = RIg,t*Xg,t
         //RI_item_Xt_qty_start_lth_...end_lth_Ritem_start_lth...end_lth
         for (int pp = 0; pp < itemsToPlan.size(); pp++) {
         	IloLinearNumExpr cf = cplex.linearNumExpr();				         
	       for (int t = 1; t < main.simParams.getMRPPlanningHorizon()-1; t++) {	            	            
			       	String o = "";
			       	int sizeExpr = 0;
			        IloLinearNumExpr num_expr = cplex.linearNumExpr();
			                    
	                for (int p = 0; p < iQd.size(); p++) {
	                	if(iQd.get(p).getItem()== itemsToPlan.get(pp).getItem().getItem()){
	                	
		            		if(releaseTmp[p][t] > 0){
		            			
		            			o = o + iQd.get(p).getQuantity() + "*" + RI[p][releaseTmp[p][t]-1].getName() +  "+";	            			
		            			num_expr.addTerm(iQd.get(p).getQuantity(),RI[p][releaseTmp[p][t]-1]);
		            					            					            					            			
		            			sizeExpr++;		            					            					            			
		            		}			        
	            		}
					}
					
				if(o.length() > 1){
		            if(sizeExpr > 0){
		            	//Constraint Release Size 
			            cplex.addEq(R[pp][t],num_expr);    
			                  
			        }

				}else{
				         cplex.addEq(R[pp][t],0);          								
				}
																
				num_expr.clear();             														
			}         
         }
                         
		IloLinearNumExpr[] sumRIs = new IloLinearNumExpr[main.simParams.getMRPPlanningHorizon()];
		
		for (int t = 0; t < main.simParams.getMRPPlanningHorizon(); t++) {
		    IloLinearNumExpr sumRIsI = cplex.linearNumExpr();
		
		    for (int pp = 0; pp < itemsToPlan.size(); pp++) {
		        for (int p = 0; p < iQd.size(); p++) {
		            if (iQd.get(p).getItem() == itemsToPlan.get(pp).getItem().getItem()) {
		                if (releaseTmp[p][t] > 0) {
		                	//traceln("###### " + 1.0 + " :::: " +  RI[p][releaseTmp[p][t] - 1]);		                
		                    sumRIsI.addTerm(1.0, RI[p][releaseTmp[p][t] - 1]);		                    
		                }
		            }
		        }
		    }
		    
		    sumRIs[t] = sumRIsI;		    		    		    
		    //sumRIsI.clear();
		}				
		             


            
//Constraint avoiding that RI with later due date, releases order earlier that RI with earlier due date (orders should not overteak each other)
//The release of order 2 should not before order 1                                         
// ********************************* Guarantee Release ORDER  ****************************************
// ***************************************************************************************************            
//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
// Constraint avoiding that RI with later due date, releases order earlier that
// RI with earlier due date (orders should not overteak each other) The release
// of order 2 should not before order 1

//daher
traceln("iQd size " + iQd.size());

List<SpecialObject> iQdSorted = iQd;

Collections.sort(iQdSorted, Comparator.comparing(SpecialObject::getDueDate).thenComparing(SpecialObject::getItem));
//Collections.sort(iQdSorted, Comparator.comparing(SpecialObject::getItem).thenComparing(SpecialObject::getDueDate));

traceln("IQd sorted:");
for(SpecialObject o : iQdSorted){
	traceln(o.getDueDate()  + " " + o.getItem() + " " + o.getQuantity());						
}

for(int i = 0; i < iQdSorted.size() -1; i++){
//now take the first succesor:
		SpecialObject currentiQd = iQdSorted.get(i);		
		SpecialObject succesoriQd = iQdSorted.get(i+1);
		
		if(currentiQd.getDueDate() <= succesoriQd.getDueDate() && currentiQd.getDueDate() > 1){
						
			int overlappingStart = max((int)succesoriQd.getDueDate() - leadtimeHorizon,0);
			//traceln("overlapping start" + (int)succesoriQd.getDueDate()  + " -" + leadtimeHorizon + "=" + overlappingStart);
			// for the overlapping time we have to generate the RI comparisions:			
			IloLinearNumExpr lhs = cplex.linearNumExpr();
	        IloLinearNumExpr rhs = cplex.linearNumExpr();

             // traceln("Start Index " + RIstartIndex);
            int overlappingPeriods = (int)currentiQd.getDueDate() - overlappingStart;
			
			int RIstartIndex =  max(0, (leadtimeHorizon - overlappingPeriods));                                            

            StringBuilder lhsOut = new StringBuilder();
            StringBuilder rhsOut = new StringBuilder();
                          
            int multiplier = 0;                   
            //traceln("Overlapping Periods " + overlappingPeriods);
            //traceln("Overlapping Start "  + overlappingStart);            
            
            for (int o = 0; o < overlappingPeriods; o++) {
				
				IloNumVar found = Function_FindeRIVarialbe(iQdSorted.size(), RI, currentiQd.getItem(), (int)currentiQd.getDueDate(), o+1, (int)currentiQd.getQuantity());
				
				IloNumVar foundSuccessor = Function_FindeRIVarialbe(iQdSorted.size(), RI, succesoriQd.getItem(), (int)succesoriQd.getDueDate(), o+1, (int)succesoriQd.getQuantity());
				
                //if (RI[p][RIstartIndex + o].getName().contains("RI")) {
                //traceln("found" + found.getName());
                if (found.getName().contains("RI")) {
                
                	lhs.addTerm(multiplier + 1, found);
                	lhsOut.append(multiplier + 1 + " " + found.getName()  + " + ");
                	
                	rhs.addTerm(multiplier + 1, foundSuccessor);
                	rhsOut.append(multiplier + 1 + " " + foundSuccessor.getName() + " + ");
                	                
                	multiplier++;
                }
            }
            
            //for the remaining periods we have to extend the rhs:
            
            
            for (int o = 0; o < succesoriQd.getDueDate() - overlappingPeriods; o++) {
												
				IloNumVar foundSuccessor = Function_FindeRIVarialbe(iQdSorted.size(), RI, succesoriQd.getItem(), (int)succesoriQd.getDueDate(), overlappingPeriods + o + 1, (int)succesoriQd.getQuantity());								
				
                //if (RI[p][RIstartIndex + o].getName().contains("RI")) {
                //traceln("found" + found.getName());
                if (foundSuccessor.getName().contains("RI")) {                                
                	
                	rhs.addTerm(multiplier + 1, foundSuccessor);
                	rhsOut.append(multiplier + 1 + " " + foundSuccessor.getName() + " + ");
                	                
                	multiplier++;
                }
            }
            
            
            cplex.addLe(lhs, rhs);

         traceln("Overlapping:");
         traceln(lhsOut.toString() + "<=");
         traceln(rhsOut.toString());             						
		
		}													
}
         
//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~            
                                                                                                
            
         //****************** CF SECTION ***************************************
         //*********************************************************************
         
         for (int t = 0; t < main.simParams.getMRPPlanningHorizon(); t++) {	    
         
	     	IloLinearNumExpr cf = cplex.linearNumExpr();				             	    
	     	IloLinearNumExpr cf1 = cplex.linearNumExpr();				             	    
	       	IloLinearNumExpr cf2 = cplex.linearNumExpr();				             	    
		   	IloLinearNumExpr cf3 = cplex.linearNumExpr();				             	    
	       	IloLinearNumExpr cf4 = cplex.linearNumExpr();				             	    

    	    
    	    //Pgt smaller Wgt - Constraint for single item qty
        	 for (int pp = 0; pp < itemsToPlan.size(); pp++) {        	  			
					//merk dir, dass die weiter unten verwendet werden
					//double setupProption = 18.0/106.0;
					double setupProption = 0;
					
	         		cf.addTerm(itemsToPlan.get(pp).getItem().getRouting().getEProcessingTime()+setupProption,P[pp][t]);	         		
	         		
	         		cf1.addTerm(itemsToPlan.get(pp).getItem().getRouting().getEProcessingTime()+setupProption,P[pp][t]); 	         		        		
         			cf2.addTerm(itemsToPlan.get(pp).getItem().getRouting().getEProcessingTime()+setupProption,W[pp][t]);         			         		        			         			
         			
         			cf3.addTerm(itemsToPlan.get(pp).getItem().getRouting().getEProcessingTime()+setupProption,P[pp][t]);         		
         			cf4.addTerm(itemsToPlan.get(pp).getItem().getRouting().getEProcessingTime()+setupProption,W[pp][t]);
         			
         			
         			//***************** Ppt, <= Wp,t ***********************        			         		         			
         			cplex.addLe(
         				//cplex.sum(P[pp][t],cplex.prod(0,sumRIs[t])),//LHS         			
         				cplex.sum(P[pp][t],0),//LHS         			
        				cplex.sum(W[pp][t],0));//RHS         			
        			//****************************************        			         		         				
        				        				        				        			        			        				
        	  }
        	          	  
			  //CF Constraints			           	  
			  //PL <= MC + Ct (Eq12)			  
			  //traceln("setup time " + setupTime + " sum ri " + sumRIs);
         	  //cplex.addLe(cplex.sum(cf,cplex.prod(setupTime,sumRIs)), //LHS         	  
         	  
         	  
         	  // **************** PL und L ausgeben *********************
         	  //keine constraints werden spter so auch nicht wiedervendet
         	  cplex.addEq(PL[t],cf);
         	  cplex.addEq(L[t],cf2);
         	  //********************************************************* 
         	  
         	  
         	  //cplex.addEq(PL[t],cplex.sum(cf,cplex.prod(setupTime,sumRIs)));
         	  //cplex.addEq(L[t],cplex.sum(cf2,cplex.prod(setupTime,sumRIs)));         	           	           	           	  
         	  
         	  /******** PLt <=MC+Ct (Eq14) ************/
         	  if(t==0){         	           	           	           	  
         	  		cplex.addLe(cf,         	  
         	  		cplex.sum(0,C[t]));	//RHS
         	  	}else{
         	  		//cplex.addLe(cf,         	  		
         	  		//traceln("da" + sumRIs[t].toString());
         	  		cplex.addLe(cplex.sum(cf,cplex.prod(setupTime,sumRIs[t])),         	  
         	  		cplex.sum(maxCapacity,C[t]));	//RHS
         	  	}
         	           	           	           	  		         	           	           	  
         	           	           	  
         	  // ---- we have three segments         	           	           	  
			  //CF partition 2 from numerical example
			  //traceln("# segments " + numberSegments);
			  //represent CF as k*x + d -> 
			  for(int i = 0; i < numberSegments; i++){
	         	  cplex.addLe(
    	     	  	cplex.sum(cf1,cplex.prod(setupTime,sumRIs[t])), //LHS				
				
         	  		cplex.sum(cplex.sum(cplex.prod(max(slopes[i],0),         	  	         	  	
         	  		
         	  		cplex.sum(cf2,cplex.prod(setupTime,sumRIs[t]))),intercepts[i]),C[t]));//RHS         	  		         	  						
         	  	
         	  		traceln("Slope (x): " + slopes[i] + " Y-intercept (d) " + intercepts[i]);
         	  		         	  		
         	  	//traceln("sumRIs " + sumRIs + " st " + setupTime);	
         	  }//for
         	           	           	           	  
         	           	           	           	  			           	  
         	  /******************************* PLt <= Lt + Ct (Eq18) *********************/
         	  //Constraint Pl musst be smaller as SL for all t         	           	  
         	  cplex.addLe(
         	  	cplex.sum(cf3,cplex.prod(setupTime,sumRIs[t])), //LHS         	  
	         	cplex.sum(cplex.sum(cf4,cplex.prod(setupTime,sumRIs[t])),C[t]));         	  	         	
	          //***************************************************************************
         	  
			  cf.clear();
			  cf1.clear();
 			  cf2.clear();
 			  cf3.clear();
 			  cf4.clear();
         }



			// Create a two-dimensional array of IloNumVars
            int numRows = iQd.size(); // Assuming iQd is a list or array
                        
            // ... Initialize and populate the RI array with IloNumVars ...

            // Find the variable by name in the RI array
            traceln("iQd size: " + iQd.size());
            String targetVariableName = "noRelease";
            boolean isVariableFound = false;
            IloNumVar foundVariable = null;

            for (int i = 0; i < numRows; i++) {
                for (int j = 1; j < RI[i].length-1; j++) {
                    IloNumVar var = RI[i][j];
                    if (var.getName().equals(targetVariableName)) {
                        isVariableFound = true;
                        foundVariable = var;
                        break;
                    }
                }
                if (isVariableFound) {
                    break;
                }
            }
            
            if (isVariableFound) {
                // Add a constraint to enforce the found variable to be zero
                traceln("Yes found set no release to 0");                
                foundVariable.setName("noRelease");                                
                cplex.addEq(foundVariable, 0);
            }
            
            //All Entries represent Running Orders. So the associated
            //RI_...1 must be set to one
            
                                    
            int numberOpenOrders = runningOrders.size();
            for(SpecialObject o : runningOrders){
            	traceln(o.getItem() + " " + o.getQuantity() + " " + o.getQuantityRunning());
            }
            
            
            traceln("Count Running Orders: " + numberOpenOrders);
            traceln("RI length: " + RI.length);
            if(iQd.size() > 0){
            for (int i = 0; i < iQd.size(); i++) {
            	isVariableFound = false;            	
            	if(iQd.get(i).getQuantityRunning() > 0){
            		traceln("search " + iQd.get(i).getItem() + " " + iQd.get(i).getDueDate() + " " + iQd.get(i).getQuantity() + " " + iQd.get(i).getQuantityRunning());
	            	for(int a=0; a < iQd.size(); a++){
	            	for (int j = 1; j < RI[a].length; j++) {
	            	
	            		//"RI_103_13_106.0_0R103_0"
	            					                                		
	            	    String[] RiSplitted = RI[a][j].getName().split("_");
				        //traceln(RI[a][j].getName().split("_"));
	                    
	                    IloNumVar var = RI[a][j];
	                    
	                    if(!var.getName().equals("noRelease")){
	                    	
	                    	targetVariableName = "RI_" + iQd.get(i).getItem() + "_" + (int) iQd.get(i).getDueDate() + "_" + 
	                    	iQd.get(i).getQuantity() + "_1" + "R" +  iQd.get(i).getItem() + "_1";
	                    
	                    	//traceln("Running Order Target Name ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~: " + targetVariableName);
	                    
		                    if (var.getName().equals(targetVariableName)) {
		                        isVariableFound = true;
		                        foundVariable = var;
		                        break;
		                    }//if
		                 }//if
	                }//for
	                
	                if(isVariableFound){
	                	break;
	                }
	                
	               }//for                         
				}//if
				                
                if (isVariableFound) {	                	                	                
	                cplex.addEq(foundVariable, 1);
	                traceln("Release Variable found " + foundVariable.getName() + " set to 1");
	                isVariableFound = false;
            	}
            }//for
            }//if
                                                               
    
    //cplex.deleteNames();
    
    //if(time() == 0)
    if(Tools.Log_CF_Optimization_Values){                 
		cplex.exportModel("model/NewModel_" + time() + "_" + bomLevel + "_" + firstBomItem.getItem() +".lp");
	}	
	//cplex.writeSolution("model/NewModel_" + time() + "_" + bomLevel + ".sol");

	//cplex.setParam(IloCplex.BooleanParam.PreInd, true);
	//0.05 were to hard ... 0.1 before
	//cplex.setParam(IloCplex.Param.MIP.Tolerances.MIPGap, 0.05);
	//cplex.setParam(IloCplex.IntParam.DataCheck, 2);	
	cplex.setParam(IloCplex.IntParam.WorkMem, 2000);
						
	if(cplex.solve() && Tools.Log_CF_Optimization_Values){
		    
		    System.out.println("Solution status: " + cplex.getStatus());
            System.out.println();
            System.out.println("Objective Value = " + cplex.getObjValue());
          
            System.out.println("Pieces: Wip, X, Release, P");
            System.out.println("Minutes: PL L, MC, CF1, CF2, CF3");
            System.out.println("\tp\tTime\tt\tWip\tX\tRelease\tP\tPL\tL\tMC\tCF1\tCF2\tCF3\tInv\tIBl\tWB\tObjPP\tCt\tBt\tPTime\tSTime\tPL\tLt\tICo\tWCo\tBco\tCo");
          	
            int[] t_sum_wip = new int[get_Main().simParams.getMRPPlanningHorizon()];
            int[] t_sum_pl = new int[get_Main().simParams.getMRPPlanningHorizon()];
            int[] t_sum_l = new int[get_Main().simParams.getMRPPlanningHorizon()];
            int[] t_sum_load = new int[get_Main().simParams.getMRPPlanningHorizon()];
            int[] t_sum_x = new int[get_Main().simParams.getMRPPlanningHorizon()];
            int[] t_sum_r = new int[get_Main().simParams.getMRPPlanningHorizon()];
            int[] t_sum_p = new int[get_Main().simParams.getMRPPlanningHorizon()];
          	
            for (int p = 0; p < itemsToPlan.size(); p++) {
                        	
               for (int t = 0; t < get_Main().simParams.getMRPPlanningHorizon(); t++) {
               
               double inventoryBalance = 0;
               double wipBalance = 0;

               if(t>0){
                  inventoryBalance = cplex.getValue(I[p][t-1])-X[p][t]+cplex.getValue(P[p][t-1]) - cplex.getValue(B[p][t-1]) + cplex.getValue(B[p][t]);
                  wipBalance = cplex.getValue(W[p][t-1])+cplex.getValue(R[p][t])-cplex.getValue(P[p][t-1]);               
               }
               		
               	  double lt = cplex.getValue(W[p][t])*itemsToPlan.get(p).getItem().getRouting().getEProcessingTime();
               	  double pl = cplex.getValue(P[p][t])*itemsToPlan.get(p).getItem().getRouting().getEProcessingTime();
               	  
               	  double objectivePerPeriod = cplex.getValue(W[p][t]) * itemsToPlan.get(p).getItem().getHoldingCostsWIP() + 
               	  							  cplex.getValue(I[p][t]) * itemsToPlan.get(p).getItem().getHoldingCosts() + 
               	  							  cplex.getValue(B[p][t]) * itemsToPlan.get(p).getItem().getBacklogCosts() +
               	  							  cplex.getValue(C[t]) * oCosts;  
               	  							  
               	  							  
               	 // traceln(cplex.getValue(W[p][t]) + "*" + itemsToPlan.get(p).getItem().getHoldingCostsWIP() + " = " + cplex.getValue(W[p][t]) * itemsToPlan.get(p).getItem().getHoldingCostsWIP());							               	  
               	 // traceln(cplex.getValue(I[p][t]) + "*" + itemsToPlan.get(p).getItem().getHoldingCosts() + " = "  + cplex.getValue(I[p][t]) * itemsToPlan.get(p).getItem().getHoldingCosts());							               	  
               	 // traceln(cplex.getValue(B[p][t]) + "*" + itemsToPlan.get(p).getItem().getBacklogCosts() + " = " + cplex.getValue(B[p][t]) * itemsToPlan.get(p).getItem().getBacklogCosts());							               	  
               	 // traceln(cplex.getValue(C[t]) + "*" + oCosts + " = " + cplex.getValue(C[t]) * oCosts);							               	  
               	  
               	  int slope2 = -99;
               	  int slope3 = -99;
               	  
               	  if(selectedSegments.size() == 2){
               	  	slope2 = (int)(slopes[1]*lt+intercepts[1]);
               	  }
               	  
              	  if(selectedSegments.size() == 3){
               	  	slope3 = (int)(slopes[2]*lt+intercepts[2]);
               	  }
               	                 	  
               	  int wipForPrintLn = (int)cplex.getValue(W[p][t]);               	                 	                 	  
               	  
                  System.out.println("\t" + itemsToPlan.get(p).getItem().getItem() +
                                     "\t" + (time() + t -1) +
                                     "\t" + t +                                     
                                     "\t" + (int)Math.round(wipForPrintLn) +
                                     "\t" + X[p][t] +
                                     "\t" + (int)Math.round(cplex.getValue(R[p][t])) +                                            
                                     "\t" + cplex.getValue(P[p][t]) +
                                     //"\t" + (int)Math.round(pl) +
                                     //"\t" + (int)Math.round(lt) +                                     
                                     "\t" + cplex.getValue(PL[t]) +      
                                     "\t" + cplex.getValue(L[t])  +
                                     "\t" + maxCapacity + 
                                     "\t" + (int)(slopes[0]*lt+intercepts[0]) + 
                                     "\t" + slope2 + 
                                     "\t" + slope3 +                                      
                                     "\t" + Math.round(cplex.getValue(I[p][t])) +
                                     "\t" + Math.round(inventoryBalance) +
                                     "\t" + (int)Math.round(wipBalance) +
                                     "\t" + (int)Math.round(objectivePerPeriod) +
                                     "\t" + Math.round(cplex.getValue(C[t])) +
                                     "\t" + (int)cplex.getValue(B[p][t]) + 
                                     "\t" + itemsToPlan.get(p).getItem().getRouting().getEProcessingTime() +
                                     "\t" + itemsToPlan.get(p).getItem().getRouting().getESetupTime()  +
                                     "\t" + cplex.getValue(PL[t]) +      
                                     "\t" + cplex.getValue(L[t])  +
                                     "\t" + (int)itemsToPlan.get(p).getItem().getHoldingCosts() +
                                     "\t" + (int)itemsToPlan.get(p).getItem().getHoldingCostsWIP() +
                                     "\t" + (int)itemsToPlan.get(p).getItem().getBacklogCosts() +
                                     "\t" + (int)oCosts                                                                              
                                     );                                                                                                 
            
            		//t_sum_wip[t] += wipForPrintLn;
            		
            		t_sum_x[t] += X[p][t];            		
            		t_sum_wip[t] += (int)cplex.getValue(W[p][t]) ;
            		t_sum_r[t] += (int)Math.round(cplex.getValue(R[p][t]));            		
            		t_sum_p[t] += (int)cplex.getValue(P[p][t]);
            		
            		//if(t==0){
            			t_sum_pl[t] = (int)cplex.getValue(PL[t]);
            			t_sum_l[t] = (int)cplex.getValue(L[t]);
            		//}
            			
            		t_sum_load[t] += lt;
	                                    
			if(OptimizationResult.WRITE_OPTIMIZATION_RESULTS_TO_XLXS){                    
                    OptimizationResult optResult = new OptimizationResult(                                        
                                        
	                   					itemsToPlan.get(p).getItem().getItem(),
	                                     (time() + t -1),
	                                     t,                                     
	                                     (int)Math.round(wipForPrintLn),
	                                     X[p][t],
	                                     Math.round(cplex.getValue(R[p][t])),                                            
	                                     cplex.getValue(P[p][t]),
	                                     cplex.getValue(PL[t]),      
	                                     cplex.getValue(L[t]),
	                                      maxCapacity,
	                                     (int)(slopes[0]*lt+intercepts[0]),
	                                      slope2,
	                                      slope3,                                      
	                                      (int)Math.round(cplex.getValue(I[p][t])),
	                                      (int)Math.round(inventoryBalance),
	                                      (int)Math.round(wipBalance),
	                                      (int)Math.round(objectivePerPeriod),
	                                      (int)Math.round(cplex.getValue(C[t])),
	                                      (int)cplex.getValue(B[p][t]), 
	                                     (double) itemsToPlan.get(p).getItem().getRouting().getEProcessingTime(),
	                                     (double) itemsToPlan.get(p).getItem().getRouting().getESetupTime(),
	                                     cplex.getValue(PL[t]),      
	                                     cplex.getValue(L[t]),
	                                     (int)itemsToPlan.get(p).getItem().getHoldingCosts(),
	                                     (int)itemsToPlan.get(p).getItem().getHoldingCostsWIP(),
	                                     (int)itemsToPlan.get(p).getItem().getBacklogCosts(),
	                                     (int)oCosts,
	                                     cplex.getValue(Z[p][t])                                                                                                                                                                                                                                                                                                                      
	                    );
                                                            
	                    get_Main().optimizationResults.add(optResult);                                                      
	                 }   
               }                              
            }
            
            System.out.println("\n");
            System.out.println("\tTime\tt\tX\tWip\tR\tP\tPL\tL");           
            for(int t = 0; t < get_Main().simParams.getMRPPlanningHorizon(); t++) {
            
            	System.out.println(
            		"\t" + (time() + t) +
       				"\t" + t +           
       				"\t" + t_sum_x[t] + 		
            		"\t" + t_sum_wip[t] +
            		"\t" + t_sum_r[t] +
            		"\t" + t_sum_p[t] +
	           		"\t" + t_sum_pl[t] +
            		"\t" + t_sum_l[t]            	
            	);            
            }
                 	  
            
            //if(OptimizationResult.WRITE_OPTIMIZATION_RESULTS_TO_XLXS)
			//OptimizationResult.WriteXlsxOptimizationResults(get_Main().optimizationResults, get_Main().simParams);            
            	//traceln("size +++++++++++ " + get_Main().optimizationResults.size());
            
		}else{
			traceln("NO Solution " + cplex.getStatus());
		}															
        	
        	for (int p = 0; p < iQd.size(); p++) {        	        
               for (int t = 1; t < leadtimeHorizon; t++) {   
            				            
            				//traceln("da vor qty " + p + " " + t + " " + RI[p][t].getName());            				            				
					        					        				        
					        if(RI[p][t].getName() != "noRelease"){
					        						        
					        double qty = cplex.getValue(RI[p][t]);    			            			            		            
					        //traceln(qty);
					        //traceln("da for if");				               					        
							if(qty > 0.9){
					        //traceln("da");				               					        
								
								//traceln("qty " + qty + " " + RI[p][t].getName());
								
								
								//if we have a running order, we have to reduce the release qty, as it was only required for the decision of release qty
			                    //but the qty itself is already considered for production.
			                    //traceln("X[" + p + "," + t + "] " + X[p][t] + " qty " + iQd.get(p).getQuantity() + " Running Orders Qty: " + iQd.get(p).getQuantityRunning());	        				        			        		
			                    traceln("X qty " + iQd.get(p).getQuantity() + " Running Orders Qty: " + iQd.get(p).getQuantityRunning());	        				        			        		
			                    
			                    double qtyFinal = Math.ceil(iQd.get(p).getQuantity()-iQd.get(p).getQuantityRunning());
			                    traceln("Final Qty: " + qtyFinal);
			                    if(qtyFinal > 0){
				                    ProductionOrder order = new ProductionOrder();			                    			                    
				                    
				                    order.setQuantity(qtyFinal);			                    			                    
				                    
				                    traceln("Set Production Order Qty: " + order.getQuantity());
				                    order.setCreatedAt(time());
												                    				                    								
									int itemIntTmp = iQd.get(p).getItem();
										
				                    Item item = get_Main().items.stream().filter(e -> e.getItem() == itemIntTmp).findFirst().get();																		                     
				                    
				                    order.setOrderId(get_Main().prodOrderId++);
				                    order.setItem(item);
				                                                                                                                                  
									order.setPlannedCapacity(Routing.GetPlannedCapacityPerItem(get_Main().routings, order.getItem(), get_Main().simParams, order));
									
									//order.setPlannedCapacity(Routing.GetPlannedCapacityPerItem(routingList, order.getItem(), simParams, order));
									order.setPlannedSetupTime(Routing.GetPlannedSetupTimePerItem(get_Main().routings, order.getItem(), get_Main().simParams, order));								
				                    
				                    int minimumRoutingStep = Routing.GetMinimumStep(get_Main().routings, order.getItem() , get_Main().simParams);
									int maximumRoutingStep = Routing.GetMaximumStep(get_Main().routings, order.getItem() , get_Main().simParams);
							
									order.setMinimumRoutingStep(minimumRoutingStep);
									order.setMaximumRoutingStep(maximumRoutingStep);			
									order.setCurrentRoutingStep(minimumRoutingStep);                                        			                    			                    
				                                                            
				                    //order.setQuantity(Math.round(iQd.get(p).getQuantity()));
				                    
				                    //traceln("################################## " + iQd.get(p).getQuantity());
				                    				                    				                    				                    
				                    //get the start and end dates from the RI decision variables			                    
				                    String[] RiSplitted = RI[p][t].getName().split("_");
				                    
				                    traceln(RI[p][t].getName().split("_"));
				                    
				                    //order.setPlannedStart(max(Integer.parseInt(RiSplitted[5]) + time() - item.getSafetyLeadTime(), time()));
				                    //order.setPlannedStart(Integer.parseInt(RiSplitted[5] + time());
	
				                    //safety leadtime for stochastic scenario
				                    //order.setPlannedStart(max(Integer.parseInt(RiSplitted[5]) + time() - 1, time()));
				                    
				                   // order.setPlannedStart(max(Integer.parseInt(RiSplitted[5]) + time() - 1, time()));
				                    
				                    //Optimization Starts with 0, so we have to subract -1 from the result to meet the correct MRP Periods
				                    order.setPlannedStart(max(Integer.parseInt(RiSplitted[5]) + time() - 1, time()));
				                    order.setPlannedEnd(Integer.parseInt(RiSplitted[2]) + time() - 1);
				                    
				                    traceln("Planned Start: " + order.getPlannedStart() +  " Planne End:" + order.getPlannedEnd() + " Time " + time());			                    			                            
				                    
				                    long exists = 0;				
				                                   			                    
				                    if(order.getPlannedStart() < time())
				                    	exists = 1;			                    											
					                    if(exists == 0){
					                    	//traceln("Production Order Added");														                    
						                    Routing routingObject = get_Main().routings.stream().filter(e -> e.getItem().getItem() == order.getItem().getItem()).findFirst().get();			
											order.setRouting(routingObject);
											order.setStatus(ProductionOrder.PRODUCTION_ORDER_STATUS_UNPROCESSED);
						                    
						                    get_Main().productionOrders.add(order);	                    						
															                    
					                    }//if
					                }    
		                    	}// if qty	
		                    	}	                    
		                 }//for            
		            }//for
                        
        if(false) {
			traceln("Production Orders from Optmization Before Removing");
			traceln(ProductionOrder.GetCSVHeader());
			
	        for (ProductionOrder order: get_Main().productionOrders) {
	           traceln(ProductionOrder.GetCSVString(order));
	        }        
			
	        //get_Main().productionOrders.removeIf(e -> e.getPlannedStart() > time());
	
	        traceln("Production Orders from Optmization FOR SIMULATION");
	        traceln(ProductionOrder.GetCSVHeader());
	
	        for (ProductionOrder order: get_Main().productionOrders) {
	            traceln(ProductionOrder.GetCSVString(order));
	        }        
	        traceln("**************************");                							
        }
		
		//get_Main().Function_OrderRelease();
		
		cplex.deleteNames();        
    	if(Tools.Log_CF_Optimization_Values){                 
			cplex.exportModel("model/NV/NewModel" + time() + "_" + bomLevel + ".lp");
		}			
		cplex.end();
	}				
	catch (IloException exc) {
         System.err.println("Concert exception '" + exc.getMessage() + "' caught");
         System.exit(-1);
    }
    //catch (ProblemFoundException exc) {
      //   System.err.println("Expection'" + exc.getMessage() + "' caught");
         //System.exit(-1);
    //}
    
return 0;


]]></Body>
				</Function>
				<Function AccessType="default" StaticFunction="false">
					<ReturnModificator>RETURNS_VALUE</ReturnModificator>
					<ReturnType><![CDATA[int]]></ReturnType>
					<Id>1700674633413</Id>
					<Name><![CDATA[Function_ClearingFunction]]></Name>
					<X>490</X><Y>270</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Parameter>
						<Name><![CDATA[itemsToPlan]]></Name>
						<Type><![CDATA[List<MRP>]]></Type>
					</Parameter>
					<Parameter>
						<Name><![CDATA[bomLevel]]></Name>
						<Type><![CDATA[int]]></Type>
					</Parameter>
					<Parameter>
						<Name><![CDATA[inResource]]></Name>
						<Type><![CDATA[Resource]]></Type>
					</Parameter>
					<Parameter>
						<Name><![CDATA[fileSuffix]]></Name>
						<Type><![CDATA[String]]></Type>
					</Parameter>
					<Body><![CDATA[try{

Tools to = new Tools();
							
traceln("----------- Start Release Order (RO) CF OPTIMIZATION at DEFAULT Version incl. Exta Capacity " + time () + " ----------------");
							
StringBuilder output = new StringBuilder();

int maxCapacity = 1440;//1440; //864=60%

traceln("Total found Segments: " + ClearingFunctionSegments.size());

	//via the bom level the cf is associated
	List<ClearingFunctionSegments> selectedSegments = new ArrayList();
	Item firstBomItem = itemsToPlan.get(0).getItem();
		
	//don't map it to the prodction stage 1-4, select the values based on the resource
	traceln("Total found segments: " + selectedSegments);
	int fopPeriod = 0;
	if(firstBomItem.getLotsizePolicy().equalsIgnoreCase(Item.LOT_POLICY_FOP)) {
		int fop = firstBomItem.getFOPPeriod();
		fopPeriod = fop;	
		traceln("FOP Period:" + fop);	
					
		selectedSegments = ClearingFunctionSegments.stream().filter(e -> e.getLotParameter() == fop &&
							 e.getLotPolicy().equalsIgnoreCase(Item.LOT_POLICY_FOP) && e.getResource().equalsIgnoreCase(inResource.getName()) 
				 && e.getExperiment().equalsIgnoreCase(main.simParams.getExperiment())).collect(Collectors.toList());															 																								
	}
	else if(firstBomItem.getLotsizePolicy().equalsIgnoreCase(Item.LOT_POLICY_FOQ)) {
		int foq = (int)firstBomItem.getFOQQuantity();	
		traceln("FOQ Qty:" + foq);	
					
		selectedSegments = ClearingFunctionSegments.stream().filter(e -> e.getLotParameter() == foq &&
							 e.getLotPolicy().equalsIgnoreCase(Item.LOT_POLICY_FOQ) && e.getResource().equalsIgnoreCase(inResource.getName()) 
				 && e.getExperiment().equalsIgnoreCase(main.simParams.getExperiment())).collect(Collectors.toList());															 																								
	}
	
	traceln("ESetupTime Of First BoM Level Item: " + firstBomItem.getRouting().getESetupTime());
	traceln("Resource: " + inResource.getName());
	traceln("Resource Stage Number: " + inResource.getStageNumber());
	traceln("Production Stage: " + (bomLevel + 1));
	traceln("Max Capacity: " + maxCapacity);
	
	traceln("Items to Plan: ");
	itemsToPlan.forEach(e -> traceln(e.getItem().getItem() + " eProcessingTime " + e.getItem().getRouting().getEProcessingTime() + ";"));

	traceln("Selected Slopes: ");		
	selectedSegments.forEach(e -> traceln(e.getSlope() + ";"));
	traceln("Selected Intercepts: ");
	
	selectedSegments.forEach(e -> traceln(e.getyIntercept() + ";"));
	
	if(selectedSegments.size() == 0){
		traceln("STOP Simulation: No Segments found!");
		//System.exit(0);
	}
	
	to.log("Segment Cnt: " + selectedSegments.size(), Tools.LogCFOptimization);
	
	double intercepts[] = new double[selectedSegments.size()];
	double slopes[] = new double[selectedSegments.size()];
	
	for(int i = 0; i < selectedSegments.size(); i++) {
		slopes[i] = selectedSegments.get(i).getSlope();
		intercepts[i] = selectedSegments.get(i).getyIntercept();
	}		
			
int numberSegments = selectedSegments.size();
double oCosts = 0;
double oFactor = 1000;//1000
double setupTime = firstBomItem.getRouting().getESetupTime();			

//double setupTime = 72; //standard = 18
int leadtimeHorizon = main.simParams.getLeadTimeHorizon();

traceln("Leadtime Horizon: " + leadtimeHorizon);

IloCplex cplex = new IloCplex();

     String[][] Inames = new String[itemsToPlan.size()][get_Main().simParams.getMRPPlanningHorizon()];
     String[][] Pnames = new String[itemsToPlan.size()][get_Main().simParams.getMRPPlanningHorizon()];
     String[] PLnames = new String[get_Main().simParams.getMRPPlanningHorizon()];
     String[] Lnames = new String[get_Main().simParams.getMRPPlanningHorizon()];
     String[][] Wnames = new String[itemsToPlan.size()][get_Main().simParams.getMRPPlanningHorizon()];
     String[][] Rnames = new String[itemsToPlan.size()][get_Main().simParams.getMRPPlanningHorizon()];     
     String[][] Bnames = new String[itemsToPlan.size()][get_Main().simParams.getMRPPlanningHorizon()];     
     
     for(int i = 0; i< get_Main().simParams.getMRPPlanningHorizon(); i++){
          for (int p = 0; p < itemsToPlan.size(); p++) {
        	 	Inames[p][i] = "I" + itemsToPlan.get(p).getItem().getItem() + "_" + i; 
        	 	Pnames[p][i] = "P" + itemsToPlan.get(p).getItem().getItem() + "_" + i; 
        	 	Wnames[p][i] = "W" + itemsToPlan.get(p).getItem().getItem() + "_" + i; 
        	 	Rnames[p][i] = "R" + itemsToPlan.get(p).getItem().getItem() + "_" + i; 
        	 	Bnames[p][i] = "B" + itemsToPlan.get(p).getItem().getItem() + "_" + i; 
        	 	PLnames[i] = "PL" + itemsToPlan.get(p).getItem().getItem() + "_" + i;
        	 	Lnames[i] = "L" + itemsToPlan.get(p).getItem().getItem() + "_" + i; 
	     }
     }


     IloNumVar[] C = new IloNumVar[main.simParams.getMRPPlanningHorizon()]; 
     for (int t = 0; t < get_Main().simParams.getMRPPlanningHorizon(); t++) {
        C[t] = cplex.numVar(0, Double.MAX_VALUE, "C" + "_" + t); 
     }
     
     IloNumVar[][] I = new IloNumVar[itemsToPlan.size()][];
     for (int p = 0; p < itemsToPlan.size(); p++) {
        I[p] = cplex.numVarArray(get_Main().simParams.getMRPPlanningHorizon(), 0, Double.MAX_VALUE, Inames[p]);
        oCosts += itemsToPlan.get(p).getItem().getHoldingCosts();
     }
     
     oCosts = oFactor*oCosts;
     
     IloNumVar[][] P = new IloNumVar[itemsToPlan.size()][];
     for (int p = 0; p < itemsToPlan.size(); p++) {     
        P[p] = cplex.numVarArray(get_Main().simParams.getMRPPlanningHorizon(), 0,  Double.MAX_VALUE, Pnames[p]);        
     }
     
     IloNumVar[] PL = new IloNumVar[leadtimeHorizon];     
     IloNumVar[] L = new IloNumVar[leadtimeHorizon];     
     
     for (int t = 0; t < leadtimeHorizon; t++) {               
     	PL[t] = cplex.numVar(0,  Double.MAX_VALUE, PLnames[t]);
     	L[t] = cplex.numVar(0,  Double.MAX_VALUE, Lnames[t]);
     }
     
                    
     IloNumVar[][] W = new IloNumVar[itemsToPlan.size()][];
     for (int p = 0; p < itemsToPlan.size(); p++) {
        W[p] = cplex.numVarArray(get_Main().simParams.getMRPPlanningHorizon(), 0, Double.MAX_VALUE, Wnames[p]);
     }
		
	 IloNumVar[][] R = new IloNumVar[itemsToPlan.size()][];
     for (int p = 0; p < itemsToPlan.size(); p++) {
        R[p] = cplex.numVarArray(get_Main().simParams.getMRPPlanningHorizon(), 0.0, Double.MAX_VALUE, Rnames[p]);
     }          
     
     IloNumVar[][] B = new IloNumVar[itemsToPlan.size()][];
     for (int p = 0; p < itemsToPlan.size(); p++) {
        B[p] = cplex.numVarArray(get_Main().simParams.getMRPPlanningHorizon(), 0.0, Double.MAX_VALUE, Bnames[p]);
     }
            	
	double[] inventory = new double[itemsToPlan.size()];
	double[] wip = new double[itemsToPlan.size()];
	double[] produce = new double[itemsToPlan.size()];
	double[] tl = new double[itemsToPlan.size()];
		
	int[][] X = new int[itemsToPlan.size()][get_Main().simParams.getMRPPlanningHorizon()];

	List<SpecialObject> iQd = new ArrayList<SpecialObject>();
	List<SpecialObject> runningOrders = new ArrayList<SpecialObject>();
	
     for (int p = 0; p < itemsToPlan.size(); p++) {      	     

     		   inventory[p] = 0;
     		   
     		   	wip[p]=0;
     		   
	        	int tmp_item = itemsToPlan.get(p).getItem().getItem();
				     		
     		   produce[p] = 0;
     		   
     	       for (int t = 0; t < get_Main().simParams.getMRPPlanningHorizon(); t++) {               	                          	               	
	               			               		               		               		               	
	               	//int tmp_item = itemsToPlan.get(p).getItem().getItem();
	               	int temp_t = t;
	               	int quantityRunningProductionOrders = 0;
	               	int lateOrders = 0;
	               	
	               	MRP mrpItem = null;	               		               		               	
	               	
	               	if(t > 0){
		               	mrpItem = get_Main().mrpTable.stream().filter(e -> e.getItem().getItem() == tmp_item
		               	 && e.getTime() == time() && e.getPeriod() == temp_t-1).findFirst().orElseGet(() -> new MRP());
		               	 
		               	 quantityRunningProductionOrders = remainingProductionOrderQty(tmp_item,t + time());
		               	 
		               	 //late Orders must only be computed in period 1 and not the remaining.
		               	 if(t == 1){
		               	 	lateOrders = lateProductionOrdersQty(tmp_item,t + time());						
		               	 }
		               	 		               	 
		               	 X[p][t] += (int) mrpItem.getPlannedOrderReceipts();
		               	 
		               	 if(time() == 28) {
		               	 	traceln("T = 28 Testausgabe.");
	               			traceln(MRP.GetCSVString(mrpItem));
	               		}
		               	 		               	 
	               	}
															
					if(quantityRunningProductionOrders > 0 || lateOrders > 0){
						traceln("RunningProduction Order Qty: " + quantityRunningProductionOrders + " time: " + time() + " t " + t + " item " + tmp_item);
						
						if(t == 1){
							X[p][1] += (quantityRunningProductionOrders + lateOrders);							
						}else{
							X[p][t] += quantityRunningProductionOrders;
						}															
						
						traceln("new Xpt: " + X[p][t]);
						traceln("Now we have to consider the Remaining Qty for Capacity Consumption of: " + X[p][t]);
						
						SpecialObject runningOrder = new SpecialObject(
	        				mrpItem.getItem().getItem(),
	        				X[p][t], 
	        				t,
	        				quantityRunningProductionOrders + lateOrders);
	        				
	        			runningOrders.add(runningOrder);						
					}

	        		if(X[p][t] > 0 && t > 0) {
	        			SpecialObject so = new SpecialObject(
	        				mrpItem.getItem().getItem(),
	        				X[p][t], 
	        				t,
	        				quantityRunningProductionOrders + lateOrders);
	        			iQd.add(so);
	        			traceln("X[" + p + "," + t + "] " + X[p][t] + " " + mrpItem.getItem().getItem());	        				        			        			        				        			
	        		}        		  	        		        		
            }     	      	
     }                                        
     
               
     String[][] RiNames = new String[iQd.size()][leadtimeHorizon];
     int[][] releaseTmp = new int[iQd.size()][main.simParams.getMRPPlanningHorizon()];
     String[] releaseForX = new String[iQd.size()];

	 // this combinations are constructed .. every time the due date in this case 13, a 0 value is added RI_103_13_106.0_0R103_0
	 
	 //RI_103_13_106.0_0R103_0 + RI_103_13_106.0_0R103_0
       //+ RI_103_13_106.0_0R103_0 + RI_103_13_106.0_1R103_1
       //+ RI_103_13_106.0_2R103_2 + RI_103_13_106.0_3R103_3
       //+ RI_103_13_106.0_4R103_4 + RI_103_13_106.0_5R103_5
       //+ RI_103_13_106.0_6R103_6 + RI_103_13_106.0_7R103_7
       //+ RI_103_13_106.0_8R103_8 + RI_103_13_106.0_9R103_9
       //+ RI_103_13_106.0_10R103_10 + RI_103_13_106.0_11R103_11
       //+ RI_103_13_106.0_12R103_12 + RI_103_13_106.0_13R103_13 
	 
	 //for each Xt > 0 an entry to iQd is added and this represnts all Xts of all planned products!
     for (int p = 0; p < iQd.size(); p++) {
          for(int i = 1; i < leadtimeHorizon; i++){
          		int targetT = (int)(iQd.get(p).getDueDate() - leadtimeHorizon + i + 1);          		
          		
          		if(targetT < 0)
          			targetT = 0; // is 0 as this are values later thaen the due date e.g. 13
          		          		
          		releaseTmp[p][targetT] = i+1;
          		
          		if(targetT > 0){          		          		
        	 		RiNames[p][i] = "RI_" +  iQd.get(p).getItem() + "_" + (int)iQd.get(p).getDueDate() +         	 	
        	 		"_" + iQd.get(p).getQuantity() + "_" + targetT + "R" + iQd.get(p).getItem() + "_" + targetT; 
        	 	}else{
        	 		RiNames[p][i] = "noRelease";// + p + "" + i;
        	 	}        	 	        	 	        	 	
	     }    
     }


	 //for each product we need the individual releases RI.....They are constructed with the above equation.            
	 //traceln("iQd.size " + iQd.size());
     IloNumVar[][] RI = new IloNumVar[iQd.size()][];
     for (int p = 0; p < iQd.size(); p++) {
          	     	
     	//e.g. if we have 8 releases while iqd.size = 8 and this all all the xts, we also need 8 RIs to get an individual decision for each Xt, which must be associated with an Release
     	// in each RiNames the item and due date (item and xt) is coded, consequently this works. 
        RI[p] = cplex.boolVarArray(leadtimeHorizon, RiNames[p]);                
        
     }                                      
            
     	//Objective Function     
		IloLinearNumExpr objFunction  = cplex.linearNumExpr();
	         
        for (int p = 0; p < itemsToPlan.size(); p++) {
           for (int t = 0; t < get_Main().simParams.getMRPPlanningHorizon(); t++) {
              objFunction.addTerm (itemsToPlan.get(p).getItem().getHoldingCosts(), I[p][t]);
            }
         }

        for (int p = 0; p < itemsToPlan.size(); p++) {
           for (int t = 0; t < get_Main().simParams.getMRPPlanningHorizon(); t++) {
             objFunction.addTerm (itemsToPlan.get(p).getItem().getHoldingCostsWIP(), W[p][t]);
            }                     	            
         } 
         
         for (int p = 0; p < itemsToPlan.size(); p++) {
           for (int t = 0; t < get_Main().simParams.getMRPPlanningHorizon(); t++) {
             objFunction.addTerm (itemsToPlan.get(p).getItem().getBacklogCosts(), B[p][t]);
            }                     	            
         } 
         
                  
         for (int t = 0; t < get_Main().simParams.getMRPPlanningHorizon(); t++) {
             objFunction.addTerm (oCosts, C[t]); 
         }                     	                              
                                      
         cplex.addMinimize(objFunction); //objective function
       
         for (int p = 0; p < itemsToPlan.size(); p++) {
           		
         	cplex.addEq(I[p][0],0); //Eq7
         	cplex.addEq(P[p][0],0); //Eq8  Pg,0 must be zero to avoid production in this period. this is not possible.                           
         	cplex.addEq(R[p][0],0); //Eq9
         	cplex.addEq(W[p][0],0); //Eq10
         
            for (int t = 1; t < get_Main().simParams.getMRPPlanningHorizon(); t++) {
	           	cplex.addEq(cplex.sum(cplex.sum(I[p][t], X[p][t]),B[p][t-1]), 
                       cplex.sum(cplex.sum(I[p][t-1], P[p][t-1]),B[p][t]));
        	}
            
              
            cplex.addEq(W[p][0], R[p][0]);
            
            for (int t = 1; t < get_Main().simParams.getMRPPlanningHorizon(); t++) {
               cplex.addEq(cplex.sum(W[p][t], P[p][t-1]), 
                           cplex.sum(W[p][t-1], R[p][t]));   
                                                                                                                                    
            }			             											
         }
         
         //********************* Sum of RI_t == 1 *************************
         // RI_103_13_106.0_0R103_0 + RI_103_13_106.0_0R103_0 + RI_103_13_106.0_0R103_0 + RI_103_13_106.0_1R103_1  + RI_103_13_106.0_2R103_2 + RI_103_13_106.0_3R103_3  + RI_103_13_106.0_4R103_4 + RI_103_13_106.0_5R103_5 .... = 1       
         // CF Article EQ3 
          List<String> unique = new ArrayList();
          
          for (int p = 0; p < iQd.size(); p++) {
            IloLinearNumExpr num_expr_Sum_Binaries = cplex.linearNumExpr();  
            boolean weHaveRI = false;	           
	            for (int t = 1; t < leadtimeHorizon; t++) {	            	
	            	
	            	//int tmp_p = p;
	            	//int tmp_t = t;
	            	//traceln("test auf " + RI[tmp_p][tmp_t].getName());
	            	
	            	//boolean exists = unique.stream().filter(element -> element != null).anyMatch(element -> element.equals(RI[tmp_p][tmp_t].getName()));
	            	            	
	            	//if(!exists) {
	            		//unique.add(RI[tmp_p][tmp_t].getName());
	            		//traceln("p" + p + " t " + t );
	            		
	            		if(RI[p][t] != null){
	            		//traceln("ri not null");
	            		String variableName = RI[p][t].getName();
	            		//char isItRI = "RI";
	            		//traceln("Found variable " + variableName);
	            		
							           		
		            		if(variableName.contains("RI")){
		            			weHaveRI = true;
		            			num_expr_Sum_Binaries.addTerm(1,RI[p][t]);															
		            		}
		            		
	            		}
	            		
	            		
	            		//traceln("add" + RI[tmp_p][tmp_t].getName());
	            	//}else{
	            		//num_expr_Sum_Binaries.addTerm(0,RI[p][t]);															
	            	//}					
	            }
	            	            
	            if(weHaveRI)
	            	cplex.addEq(num_expr_Sum_Binaries,1);
            }
         
         
         //RI structure
         //Eq2 where Rg,t = RIg,t*Xg,t
         //RI_item_Xt_qty_start_lth_...end_lth_Ritem_start_lth...end_lth
         for (int pp = 0; pp < itemsToPlan.size(); pp++) {
         	IloLinearNumExpr cf = cplex.linearNumExpr();				         
	       for (int t = 1; t < main.simParams.getMRPPlanningHorizon()-1; t++) {	            	            
			       	String o = "";
			       	int sizeExpr = 0;
			        IloLinearNumExpr num_expr = cplex.linearNumExpr();
			                    
	                for (int p = 0; p < iQd.size(); p++) {
	                	if(iQd.get(p).getItem()== itemsToPlan.get(pp).getItem().getItem()){
	                	
		            		if(releaseTmp[p][t] > 0){
		            			
		            			o = o + iQd.get(p).getQuantity() + "*" + RI[p][releaseTmp[p][t]-1].getName() +  "+";	            			
		            			num_expr.addTerm(iQd.get(p).getQuantity(),RI[p][releaseTmp[p][t]-1]);
		            					            					            					            			
		            			sizeExpr++;		            					            					            			
		            		}			        
	            		}
					}
					
				if(o.length() > 1){
		            if(sizeExpr > 0){
		            	//Constraint Release Size 
			            cplex.addEq(R[pp][t],num_expr);    
			                  
			        }

				}else{
				         cplex.addEq(R[pp][t],0);          								
				}
																
				num_expr.clear();             														
			}         
         }
                         
		IloLinearNumExpr[] sumRIs = new IloLinearNumExpr[main.simParams.getMRPPlanningHorizon()];
		
		for (int t = 0; t < main.simParams.getMRPPlanningHorizon(); t++) {
		    IloLinearNumExpr sumRIsI = cplex.linearNumExpr();
		
		    for (int pp = 0; pp < itemsToPlan.size(); pp++) {
		        for (int p = 0; p < iQd.size(); p++) {
		            if (iQd.get(p).getItem() == itemsToPlan.get(pp).getItem().getItem()) {
		                if (releaseTmp[p][t] > 0) {
		                	//traceln("###### " + 1.0 + " :::: " +  RI[p][releaseTmp[p][t] - 1]);		                
		                    sumRIsI.addTerm(1.0, RI[p][releaseTmp[p][t] - 1]);		                    
		                }
		            }
		        }
		    }
		    
		    sumRIs[t] = sumRIsI;		    		    		    
		    //sumRIsI.clear();
		}				
		             
            
//Constraint avoiding that RI with later due date, releases order earlier that RI with earlier due date (orders should not overteak each other)
//The release of order 2 should not before order 1                                         
// ********************************* Guarantee Release ORDER  ****************************************
// ***************************************************************************************************            
//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
// Constraint avoiding that RI with later due date, releases order earlier that
// RI with earlier due date (orders should not overteak each other) The release
// of order 2 should not before order 1

//daher
//traceln("iQd size " + iQd.size());

List<SpecialObject> iQdSorted = iQd;
if(main.simParams.getROFormulation() == 1){
	Collections.sort(iQdSorted, Comparator.comparing(SpecialObject::getDueDate).thenComparing(SpecialObject::getItem));
	
	for(int i = 0; i < iQdSorted.size() -1; i++){
	//now take the first succesor:
			SpecialObject currentiQd = iQdSorted.get(i);		
			SpecialObject succesoriQd = iQdSorted.get(i+1);
			
			if(currentiQd.getDueDate() <= succesoriQd.getDueDate() && currentiQd.getDueDate() > 1){
							
				int overlappingStart = max((int)succesoriQd.getDueDate() - leadtimeHorizon,0);
				//traceln("overlapping start" + (int)succesoriQd.getDueDate()  + " -" + leadtimeHorizon + "=" + overlappingStart);
				// for the overlapping time we have to generate the RI comparisions:			
				IloLinearNumExpr lhs = cplex.linearNumExpr();
		        IloLinearNumExpr rhs = cplex.linearNumExpr();
	
	             // traceln("Start Index " + RIstartIndex);
	            int overlappingPeriods = (int)currentiQd.getDueDate() - overlappingStart;
				
				int RIstartIndex =  max(0, (leadtimeHorizon - overlappingPeriods));                                            
	
	            StringBuilder lhsOut = new StringBuilder();
	            StringBuilder rhsOut = new StringBuilder();
	                          
	            int multiplier = 0;                              
	            
	            for (int o = 0; o < overlappingPeriods; o++) {
					
					IloNumVar found = Function_FindeRIVarialbe(iQdSorted.size(), RI, currentiQd.getItem(), (int)currentiQd.getDueDate(), o+1, (int)currentiQd.getQuantity());
					
					IloNumVar foundSuccessor = Function_FindeRIVarialbe(iQdSorted.size(), RI, succesoriQd.getItem(), (int)succesoriQd.getDueDate(), o+1, (int)succesoriQd.getQuantity());
					

	                if (found.getName().contains("RI")) {
	                
	                	lhs.addTerm(multiplier + 1, found);
	                	lhsOut.append(multiplier + 1 + " " + found.getName()  + " + ");
	                	
	                	rhs.addTerm(multiplier + 1, foundSuccessor);
	                	rhsOut.append(multiplier + 1 + " " + foundSuccessor.getName() + " + ");
	                	                
	                	multiplier++;
	                }
	            }
	            
	            //for the remaining periods we have to extend the rhs:
	            
	            
	            for (int o = 0; o < succesoriQd.getDueDate() - overlappingPeriods; o++) {
													
					IloNumVar foundSuccessor = Function_FindeRIVarialbe(iQdSorted.size(), RI, succesoriQd.getItem(), (int)succesoriQd.getDueDate(), overlappingPeriods + o + 1, (int)succesoriQd.getQuantity());								
					
	                if (foundSuccessor.getName().contains("RI")) {                                
	                	
	                	rhs.addTerm(multiplier + 1, foundSuccessor);
	                	rhsOut.append(multiplier + 1 + " " + foundSuccessor.getName() + " + ");
	                	                
	                	multiplier++;
	                }
	            }	            
	            
	            cplex.addLe(lhs, rhs);            						
			
			}													
	}
}// END - if guaranteee release order         
//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~            

         //****************** CF SECTION ***************************************
         //*********************************************************************
     	IloLinearNumExpr cf = cplex.linearNumExpr();				             	    
     	IloLinearNumExpr cf1 = cplex.linearNumExpr();				             	    
       	IloLinearNumExpr cf2 = cplex.linearNumExpr();				             	    
	   	IloLinearNumExpr cf3 = cplex.linearNumExpr();				             	    
       	IloLinearNumExpr cf4 = cplex.linearNumExpr();
       	
         for (int t = 0; t < main.simParams.getMRPPlanningHorizon(); t++) {	    
          					             	        	    
    	    //Pgt smaller Wgt - Constraint for single item qty
        	 for (int pp = 0; pp < itemsToPlan.size(); pp++) {        	  			
					//merk dir, dass die weiter unten verwendet werden
					//double setupProption = 18.0/106.0;
					//double setupProption = itemsToPlan.get(pp).getItem().getRouting().getESetupTime();
					double setupProption = 0;
	         		cf.addTerm(itemsToPlan.get(pp).getItem().getRouting().getEProcessingTime()+setupProption,P[pp][t]);	         		
	         		
	         		if(get_Main().simParams.getCFSegments() > 0){	         		
	         			cf1.addTerm(itemsToPlan.get(pp).getItem().getRouting().getEProcessingTime()+setupProption,P[pp][t]); 	         		        		
         				cf2.addTerm(itemsToPlan.get(pp).getItem().getRouting().getEProcessingTime()+setupProption,W[pp][t]);         			         		        			         			
         			}
         			
         			cf3.addTerm(itemsToPlan.get(pp).getItem().getRouting().getEProcessingTime()+setupProption,P[pp][t]);         		
         			cf4.addTerm(itemsToPlan.get(pp).getItem().getRouting().getEProcessingTime()+setupProption,W[pp][t]);
         			
         			
         			//***************** Ppt, <= Wp,t ***********************        			         		         			
         			cplex.addLe(
         				//cplex.sum(P[pp][t],cplex.prod(0,sumRIs[t])),//LHS         			
         				cplex.sum(P[pp][t],0),//LHS         			
        				cplex.sum(W[pp][t],0),"Ppt<=Wpt");//RHS         			
        			//****************************************
        			  			        			         		         				
        				        				        				        			        			        				
        	  }//for (int pp = 0; pp < itemsToPlan.size(); pp++) {        	  			
        	  
        	          	  
			  //CF Constraints			           	  
			  //PL <= MC + Ct (Eq12)			  
			  //traceln("setup time " + setupTime + " sum ri " + sumRIs);
         	  //cplex.addLe(cplex.sum(cf,cplex.prod(setupTime,sumRIs)), //LHS         	  
         	  
         	  
         	  // **************** PL und L ausgeben *********************
         	  //keine constraints werden spter so auch nicht wiedervendet
         	  cplex.addEq(PL[t],cf,"PL ausgeben");
         	  cplex.addEq(L[t],cf2,"SL ausgeben");
         	  //********************************************************* 
         	  
         	  
         	  //cplex.addEq(PL[t],cplex.sum(cf,cplex.prod(setupTime,sumRIs)));
         	  //cplex.addEq(L[t],cplex.sum(cf2,cplex.prod(setupTime,sumRIs)));         	           	           	           	  
         	  
         	  /******** PLt <=MC+Ct (Eq14) ************/
         	  //This is also the reason why in the .lp file the maximum capacity is not available for t=0
         	  if(t==0){         	           	           	           	  
         	  		cplex.addLe(cf,         	  
         	  		cplex.sum(0,C[t]),"MaxCapa");	//RHS
         	  	}else{         	  	
         	  		cplex.addLe(cplex.sum(cf,cplex.prod(setupTime,sumRIs[t])),         	  
         	  		cplex.sum(maxCapacity,C[t]),"MaxCapa");	//RHS
         	  	}
         	           	           	           	  		         	           	           	  
         	           	           	  
         	  // ---- we have three segments         	           	           	  
			  //CF partition 2 from numerical example
			  //traceln("# segments " + numberSegments);
			  //represent CF as k*x + d -> 
			  
			  traceln("Config Value of CF Segments: " +  get_Main().simParams.getCFSegments());
			  if(get_Main().simParams.getCFSegments() == 0){
			  	numberSegments = 0;			  	
			  }
			  
			  traceln("Number Segments for CF Segment Loop: " + numberSegments);
			  
			  for(int i = 0; i < numberSegments; i++){
			  
		  		//slopes[i] = 0.1;
		  		//intercepts[i] = 1;
			    traceln("In For: Slope (x): " + slopes[i] + " Y-intercept (d) " + intercepts[i]);
			  
	         	  cplex.addLe(
	         	  
    	     	  	cplex.sum(cf1,cplex.prod(setupTime,sumRIs[t])), //LHS				
				
         	  		cplex.sum(cplex.sum(cplex.prod(max(slopes[i],0),         	  	         	  	
         	  		
         	  		cplex.sum(cf2,cplex.prod(setupTime,sumRIs[t]))),intercepts[i]),C[t]),"CFSegment" + i);//RHS         	  		         	  						
         	  	
         	  		         	  		
         	  	//traceln("sumRIs " + sumRIs + " st " + setupTime);	
         	  }//for
         	           	           	           	  			           	  
         	  /******************************* PLt <= Lt + Ct (Eq18) *********************/
         	  //Constraint Pl musst be smaller as SL for all t         	           	  
         	  
         	  cplex.addLe(
         	  	cplex.sum(cf3,cplex.prod(setupTime,sumRIs[t])), //LHS         	  
	         	cplex.sum(cplex.sum(cf4,cplex.prod(setupTime,sumRIs[t])),C[t]),"PL<=SL");         	  	         		         		         		         	
	         	
	         	
	         	/*
	         	cplex.addLe(
         	  	cplex.sum(cf3,cplex.prod(setupTime,sumRIs[t])), //LHS         	  
	         	cplex.sum(cplex.sum(cf4,cplex.prod(setupTime,sumRIs[t])),0));         	  	         	
	         	*/
	         	
	          //***************************************************************************
         	  
			  cf.clear();
			  cf1.clear();
 			  cf2.clear();
 			  cf3.clear();
 			  cf4.clear();
         }



			// Create a two-dimensional array of IloNumVars
            int numRows = iQd.size(); // Assuming iQd is a list or array
                        
            // ... Initialize and populate the RI array with IloNumVars ...

            // Find the variable by name in the RI array
            //traceln("iQd size: " + iQd.size());
            String targetVariableName = "noRelease";
            boolean isVariableFound = false;
            IloNumVar foundVariable = null;

            for (int i = 0; i < numRows; i++) {
                for (int j = 1; j < RI[i].length-1; j++) {
                    IloNumVar var = RI[i][j];
                    if (var.getName().equals(targetVariableName)) {
                        isVariableFound = true;
                        foundVariable = var;
                        break;
                    }
                }
                if (isVariableFound) {
                    break;
                }
            }
            
            if (isVariableFound) {
                // Add a constraint to enforce the found variable to be zero
                //traceln("Yes found set no release to 0");                
                foundVariable.setName("noRelease");                                
                cplex.addEq(foundVariable, 0);
            }
            
            //All Entries represent Running Orders. So the associated
            //RI_...1 must be set to one
            
                                    
            int numberOpenOrders = runningOrders.size();
           // for(SpecialObject o : runningOrders){
            	//traceln(o.getItem() + " " + o.getQuantity() + " " + o.getQuantityRunning());
            //}
            
            
            traceln("Count Running Orders: " + numberOpenOrders);
            traceln("RI length: " + RI.length);
            if(iQd.size() > 0){
            for (int i = 0; i < iQd.size(); i++) {
            	isVariableFound = false;            	
            	if(iQd.get(i).getQuantityRunning() > 0){
            		//traceln("search " + iQd.get(i).getItem() + " " + iQd.get(i).getDueDate() + " " + iQd.get(i).getQuantity() + " " + iQd.get(i).getQuantityRunning());
	            	for(int a=0; a < iQd.size(); a++){
	            	for (int j = 1; j < RI[a].length; j++) {
	            	
	            		//"RI_103_13_106.0_0R103_0"
	            					                                		
	            	    String[] RiSplitted = RI[a][j].getName().split("_");
				        //traceln(RI[a][j].getName().split("_"));
	                    
	                    IloNumVar var = RI[a][j];
	                    
	                    if(!var.getName().equals("noRelease")){
	                    	
	                    	targetVariableName = "RI_" + iQd.get(i).getItem() + "_" + (int) iQd.get(i).getDueDate() + "_" + 
	                    	iQd.get(i).getQuantity() + "_1" + "R" +  iQd.get(i).getItem() + "_1";
	                    
	                    	//traceln("Running Order Target Name ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~: " + targetVariableName);
	                    
		                    if (var.getName().equals(targetVariableName)) {
		                        isVariableFound = true;
		                        foundVariable = var;
		                        break;
		                    }//if
		                 }//if
	                }//for
	                
	                if(isVariableFound){
	                	break;
	                }
	                
	               }//for                         
				}//if
				                
                if (isVariableFound) {	                	                	                
	                cplex.addEq(foundVariable, 1);
	                //traceln("Release Variable found " + foundVariable.getName() + " set to 1");
	                isVariableFound = false;
            	}
            }//for
            }//if
                                                               
    
    //cplex.deleteNames();
    
    //if(time() == 0)
    if(Tools.Log_CF_Lp_Files){                 
		cplex.exportModel("model/NewModel_" + time() + "_" + bomLevel + "_" + firstBomItem.getItem() +".lp");
	}	
	//cplex.writeSolution("model/NewModel_" + time() + "_" + bomLevel + ".sol");

	//cplex.setParam(IloCplex.BooleanParam.PreInd, true);
	//0.05 were to hard ... 0.1 before	
	cplex.setParam(IloCplex.Param.MIP.Tolerances.MIPGap, 0.00);
	//cplex.setParam(IloCplex.IntParam.DataCheck, 2);	
	cplex.setParam(IloCplex.IntParam.WorkMem, 2000);
	cplex.setParam(IloCplex.Param.Threads, 4);
	
	
						
	if(cplex.solve() && Tools.Log_CF_Optimization_Values){
		    
		    System.out.println("Solution status: " + cplex.getStatus());
            System.out.println();
            System.out.println("Objective Value = " + cplex.getObjValue());
          
            System.out.println("Pieces: Wip, X, Release, P");
            System.out.println("Minutes: PL L, MC, CF1, CF2, CF3");
            
            String header = 
            "\tp\tTime\tt\tWip\tX\tRelease\tP\tPL\tL\tMC\tCF1\tCF2\tCF3\tInv\tIBl\tWB\tObjPP\tCt\tBt\tPTime\tSTime\tICo\tWCo\tBco\tCo\tZt";
          	
          	System.out.println(header);
          	
            int[] t_sum_wip = new int[get_Main().simParams.getMRPPlanningHorizon()];
            int[] t_sum_pl = new int[get_Main().simParams.getMRPPlanningHorizon()];
            int[] t_sum_l = new int[get_Main().simParams.getMRPPlanningHorizon()];
            int[] t_sum_load = new int[get_Main().simParams.getMRPPlanningHorizon()];
            int[] t_sum_x = new int[get_Main().simParams.getMRPPlanningHorizon()];
            int[] t_sum_r = new int[get_Main().simParams.getMRPPlanningHorizon()];
            double[] t_sum_p = new double[get_Main().simParams.getMRPPlanningHorizon()];
            int[] t_sum_z = new int[get_Main().simParams.getMRPPlanningHorizon()];
          	
            for (int p = 0; p < itemsToPlan.size(); p++) {
                        	
               for (int t = 0; t < get_Main().simParams.getMRPPlanningHorizon(); t++) {
               
               double inventoryBalance = 0;
               double wipBalance = 0;

               if(t>0){
                  inventoryBalance = cplex.getValue(I[p][t-1])-X[p][t]+cplex.getValue(P[p][t-1]) - cplex.getValue(B[p][t-1]) + cplex.getValue(B[p][t]);
                  wipBalance = cplex.getValue(W[p][t-1])+cplex.getValue(R[p][t])-cplex.getValue(P[p][t-1]);               
               }
               		
               	  double lt = cplex.getValue(W[p][t])*itemsToPlan.get(p).getItem().getRouting().getEProcessingTime();
               	  double pl = cplex.getValue(P[p][t])*itemsToPlan.get(p).getItem().getRouting().getEProcessingTime();               	                 	  
               	  
               	  double objectivePerPeriod = cplex.getValue(W[p][t]) * itemsToPlan.get(p).getItem().getHoldingCostsWIP() + 
               	  							  cplex.getValue(I[p][t]) * itemsToPlan.get(p).getItem().getHoldingCosts() + 
               	  							  cplex.getValue(B[p][t]) * itemsToPlan.get(p).getItem().getBacklogCosts() +
               	  							  cplex.getValue(C[t]) * oCosts;  
               	  							  
             	  
               	  int slope2 = -99;
               	  int slope3 = -99;
               	  
               	  if(selectedSegments.size() == 2){
               	  	slope2 = (int)(slopes[1]*lt+intercepts[1]);
               	  }
               	  
              	  if(selectedSegments.size() == 3){
              	    slope2 = (int)(slopes[1]*lt+intercepts[1]);
               	  	slope3 = (int)(slopes[2]*lt+intercepts[2]);
               	  }
               	                 	  
               	  int wipForPrintLn = (int)cplex.getValue(W[p][t]);               	                 	                 	  
               	  
                  String dataOutput = "\t" + itemsToPlan.get(p).getItem().getItem() +
                                     "\t" + (time() + t -1) + "|" + time() +
                                     "\t" + t +                                     
                                     "\t" + (int)Math.round(wipForPrintLn) +
                                     "\t" + X[p][t] +
                                     "\t" + (int)Math.round(cplex.getValue(R[p][t])) +                                            
                                     "\t" + cplex.getValue(P[p][t]) +
                                     //"\t" + (int)Math.round(pl) +
                                     //"\t" + (int)Math.round(lt) +                                     
                                     "\t" + cplex.getValue(PL[t]) +      
                                     "\t" + cplex.getValue(L[t])  +
                                     "\t" + maxCapacity + 
                                     "\t" + (int)(slopes[0]*lt+intercepts[0]) + 
                                     "\t" + slope2 + 
                                     "\t" + slope3 +                                      
                                     "\t" + Math.round(cplex.getValue(I[p][t])) +
                                     "\t" + Math.round(inventoryBalance) +
                                     "\t" + (int)Math.round(wipBalance) +
                                     "\t" + (int)Math.round(objectivePerPeriod) +
                                     "\t" + Math.round(cplex.getValue(C[t])) +
                                     "\t" + (int)cplex.getValue(B[p][t]) + 
                                     "\t" + itemsToPlan.get(p).getItem().getRouting().getEProcessingTime() +
                                     "\t" + itemsToPlan.get(p).getItem().getRouting().getESetupTime()  +
                                    // "\t" + cplex.getValue(PL[t]) +      
                                    // "\t" + cplex.getValue(L[t])  +
                                     "\t" + (int)itemsToPlan.get(p).getItem().getHoldingCosts() +
                                     "\t" + (int)itemsToPlan.get(p).getItem().getHoldingCostsWIP() +
                                     "\t" + (int)itemsToPlan.get(p).getItem().getBacklogCosts() +
                                     "\t" + (int)oCosts;
                                                                                                                                      
            		System.out.println(dataOutput);
            		
            		
					if(OptimizationResult.OPTIMIZATION_RESULT_FOR_PERIOD == time() && 
            			(itemsToPlan.get(p).getItem().getItem() >= 100 ||
            			itemsToPlan.get(p).getItem().getItem() <= 131)
            			&& false
            		) {
            		
            		    Set<String> excludeColumns = new HashSet<>();
        				excludeColumns.add("Time");
            		
						ExcelWriter excelWriter = new ExcelWriter();
						excelWriter.writeOutputToExcel(header, dataOutput,
						OptimizationResult.OPTIMIZATION_RESULTS_FOR_PERIOD_EXCEL_FOLDER + "\\ACF_vs_RO " 
						+ main.optimizationParameters.getVersion() + ".xlsx",
						"RO FOP=" + fopPeriod,
						excludeColumns);
            		}
            		            		
            		t_sum_x[t] += X[p][t];            		
            		t_sum_wip[t] += (int)cplex.getValue(W[p][t]) ;
            		t_sum_r[t] += (int)Math.round(cplex.getValue(R[p][t]));            		
            		t_sum_p[t] += cplex.getValue(P[p][t]);
            		t_sum_pl[t] = (int)cplex.getValue(PL[t]);
            		t_sum_l[t] = (int)cplex.getValue(L[t]);
            		t_sum_load[t] += lt;
	                                    
			if(OptimizationResult.WRITE_OPTIMIZATION_RESULTS_TO_XLXS){                    
                    OptimizationResult optResult = new OptimizationResult(                                        
                                        
	                   					itemsToPlan.get(p).getItem().getItem(),
	                                     (time() + t -1),
	                                     t,                                     
	                                     (int)Math.round(wipForPrintLn),
	                                     X[p][t],
	                                     Math.round(cplex.getValue(R[p][t])),                                            
	                                     cplex.getValue(P[p][t]),
	                                     cplex.getValue(PL[t]),      
	                                     cplex.getValue(L[t]),
	                                      maxCapacity,
	                                     (int)(slopes[0]*lt+intercepts[0]),
	                                      slope2,
	                                      slope3,                                      
	                                      (int)Math.round(cplex.getValue(I[p][t])),
	                                      (int)Math.round(inventoryBalance),
	                                      (int)Math.round(wipBalance),
	                                      (int)Math.round(objectivePerPeriod),
	                                      cplex.getValue(C[t]),
	                                      (int)cplex.getValue(B[p][t]), 
	                                     (double) itemsToPlan.get(p).getItem().getRouting().getEProcessingTime(),
	                                     (double) itemsToPlan.get(p).getItem().getRouting().getESetupTime(),
	                                     cplex.getValue(PL[t]),      
	                                     cplex.getValue(L[t]),
	                                     (int)itemsToPlan.get(p).getItem().getHoldingCosts(),
	                                     (int)itemsToPlan.get(p).getItem().getHoldingCostsWIP(),
	                                     (int)itemsToPlan.get(p).getItem().getBacklogCosts(),
	                                     (int)oCosts,
	                                     0
	                    );
                                                            
	                    get_Main().optimizationResults.add(optResult);                                                      
	                 }   
               }                              
            }
            
            System.out.println("\n");
            System.out.println("\tTime\tt\tX\tWip\tR\tP\tPL\tL\tZ");           
            for(int t = 0; t < get_Main().simParams.getMRPPlanningHorizon(); t++) {
            
            	System.out.println(
            		"\t" + (time() + t) +
       				"\t" + t +           
       				"\t" + t_sum_x[t] + 		
            		"\t" + t_sum_wip[t] +
            		"\t" + t_sum_r[t] +
            		"\t" + t_sum_p[t] +
	           		"\t" + t_sum_pl[t] +
            		"\t" + t_sum_l[t] +
            		"\t" + t_sum_z[t]            		           	
            	);            
            }
                 	  
            
            //if(OptimizationResult.WRITE_OPTIMIZATION_RESULTS_TO_XLXS)
			//OptimizationResult.WriteXlsxOptimizationResults(get_Main().optimizationResults, get_Main().simParams);            
            	//traceln("size +++++++++++ " + get_Main().optimizationResults.size());
            
		}else{
			traceln("NO Solution " + cplex.getStatus());
		}															
        	
        	for (int p = 0; p < iQd.size(); p++) {        	        
               for (int t = 1; t < leadtimeHorizon; t++) {   
            				            
            				//traceln("da vor qty " + p + " " + t + " " + RI[p][t].getName());            				            				
					        					        				        
					        if(RI[p][t].getName() != "noRelease"){
					        						        
					        double qty = cplex.getValue(RI[p][t]);    			            			            		            
					        //traceln(qty);
					        //traceln("da for if");				               					        
							if(qty > 0.9){
					        //traceln("da");				               					        
								
								//traceln("qty " + qty + " " + RI[p][t].getName());
								
								
								//if we have a running order, we have to reduce the release qty, as it was only required for the decision of release qty
			                    //but the qty itself is already considered for production.
			                    //traceln("X[" + p + "," + t + "] " + X[p][t] + " qty " + iQd.get(p).getQuantity() + " Running Orders Qty: " + iQd.get(p).getQuantityRunning());	        				        			        		
			                    
			                    String[] RiSplitted = RI[p][t].getName().split("_");
			                    //traceln(RI[p][t].getName().split("_"));
			                    
			                    double qtyXt = Double.parseDouble(RiSplitted[3]);
			                    int itemIntTmp = Integer.parseInt(RiSplitted[1]);
			                    int plannedEnd = Integer.parseInt(RiSplitted[2]);
			                    			                    			                    			                    
			                    SpecialObject sp = iQd.stream().filter(e -> e.getItem() == itemIntTmp && e.getDueDate() == plannedEnd).findFirst().get();
			                    
			                    traceln("X qty " + iQd.get(p).getQuantity() + " Running Orders Qty: " + iQd.get(p).getQuantityRunning() + " item " + iQd.get(p).getItem() + "DD " + iQd.get(p).getDueDate());	        				        			        					                    
			                    traceln("Xqtyn " + qtyXt + " Running Orders Qty: " + sp.getQuantityRunning() + " item " + sp.getItem() + " DD " + sp.getDueDate());
			                    
			                    //double qtyFinal = Math.ceil(iQd.get(p).getQuantity()-iQd.get(p).getQuantityRunning());
			                    double qtyFinal = Math.ceil(qtyXt - sp.getQuantityRunning());
			                    
			                    //traceln("Final Qty: " + qtyFinal);
			                    //traceln("Final QtyN: " + qtyFinalN);
			                    if(qtyFinal > 0){
			                    		                    
				                    ProductionOrder order = new ProductionOrder();			                    			                    
				                    
				                    order.setQuantity(qtyFinal);			                    			                    
				                    
				                    //traceln("Set Production Order Qty: " + order.getQuantity());
				                    order.setCreatedAt(time());
												                    				                    								
									//int itemIntTmp = iQd.get(p).getItem();
										
				                    //Item item = get_Main().items.stream().filter(e -> e.getItem() == itemIntTmp).findFirst().get();																		                     
				                    Item item = get_Main().items.stream().filter(e -> e.getItem() == itemIntTmp).findFirst().get();																		                     
				                    
				                    order.setOrderId(get_Main().prodOrderId++);
				                    order.setItem(item);
				                                                                                                                                  
									order.setPlannedCapacity(Routing.GetPlannedCapacityPerItem(get_Main().routings, order.getItem(), get_Main().simParams, order));
									
									//order.setPlannedCapacity(Routing.GetPlannedCapacityPerItem(routingList, order.getItem(), simParams, order));
									order.setPlannedSetupTime(Routing.GetPlannedSetupTimePerItem(get_Main().routings, order.getItem(), get_Main().simParams, order));								
				                    
				                    int minimumRoutingStep = Routing.GetMinimumStep(get_Main().routings, order.getItem() , get_Main().simParams);
									int maximumRoutingStep = Routing.GetMaximumStep(get_Main().routings, order.getItem() , get_Main().simParams);
							
									order.setMinimumRoutingStep(minimumRoutingStep);
									order.setMaximumRoutingStep(maximumRoutingStep);			
									order.setCurrentRoutingStep(minimumRoutingStep);                                        			                    			                    
				                                                            
				                    //order.setQuantity(Math.round(iQd.get(p).getQuantity()));
				                    
				                    //traceln("################################## " + iQd.get(p).getQuantity());
				                    				                    				                    				                    
				                    //get the start and end dates from the RI decision variables			                    
				                    
				                    
				                    //order.setPlannedStart(max(Integer.parseInt(RiSplitted[5]) + time() - item.getSafetyLeadTime(), time()));
				                    //order.setPlannedStart(Integer.parseInt(RiSplitted[5] + time());
	
				                    //safety leadtime for stochastic scenario
				                    //order.setPlannedStart(max(Integer.parseInt(RiSplitted[5]) + time() - 1, time()));
				                    
				                   // order.setPlannedStart(max(Integer.parseInt(RiSplitted[5]) + time() - 1, time()));
				                    
				                    //Optimization Starts with 0, so we have to subract -1 from the result to meet the correct MRP Periods
				                    //order.setPlannedStart(max(Integer.parseInt(RiSplitted[5]) + time() + MRP.PERIOD_BALANCING - 1, time()));
				                    
				                    
				                    
									int roundedStart = (int) Math.round(Double.parseDouble(RiSplitted[5]));
									double plannedStart =  roundedStart + time() + (MRP.PERIOD_BALANCING - 1);
									order.setPlannedStart(Math.max(plannedStart, time()));
				                    
				                    traceln("time " + time() + " risplitted " + RiSplitted[5] + " rounded start " + roundedStart);
				                    
				                    //int plannedStart = (int) (Integer.parseInt(RiSplitted[5]) + time() + MRP.PERIOD_BALANCING - 1);
									//order.setPlannedStart(Math.max(plannedStart, time()));
				                    

				                    //order.setPlannedStart(order.getPlannedStart() + MRP.PERIOD_BALANCING);
				                    order.setPlannedEnd(Integer.parseInt(RiSplitted[2]) + time() - 1);
				                    
				                    traceln("Created Order in CF: " + order.getOrderId() + " Planned Start: " + order.getPlannedStart() +  " Planne End:" + order.getPlannedEnd() + " Time " + time());			                    			                            
				                    
				                    long exists = 0;				
				                                   			                    
				                    if(order.getPlannedStart() < time()){
				                    	traceln(ProductionOrder.GetCSVString(order));
				                    	exists = 1;
				                    }		
				                    			                    											
					                    if(exists == 0){
					                    	//traceln("Production Order Added");														                    
						                    Routing routingObject = get_Main().routings.stream().filter(e -> e.getItem().getItem() == order.getItem().getItem()).findFirst().get();			
											order.setRouting(routingObject);
											order.setStatus(ProductionOrder.PRODUCTION_ORDER_STATUS_UNPROCESSED);
						                    
						                    get_Main().productionOrders.add(order);	                    						
															                    
					                    }//if
					                }    
		                    	}// if qty	
		                    	}	                    
		                 }//for            
		            }//for
                        
        if(true) {
			traceln("Production Orders from Optmization Before Removing");
			traceln(ProductionOrder.GetCSVHeader());
			
	        for (ProductionOrder order: get_Main().productionOrders) {
	           traceln(ProductionOrder.GetCSVString(order));
	        }        			       
	        traceln("**************************");                							
        }
		
		//get_Main().Function_OrderRelease();
		
		cplex.deleteNames();        
    	if(Tools.Log_CF_Lp_Files){                 
			cplex.exportModel("model/NV/NewModel" + time() + "_" + bomLevel + ".lp");
		}			
		cplex.end();
	}				
	catch (IloException exc) {
         System.err.println("Concert exception '" + exc.getMessage() + "' caught");
         System.exit(-1);
    }
    //catch (ProblemFoundException exc) {
      //   System.err.println("Expection'" + exc.getMessage() + "' caught");
         //System.exit(-1);
    //}
    
return 0;


]]></Body>
				</Function>
				<Function AccessType="default" StaticFunction="false">
					<ReturnModificator>RETURNS_VALUE</ReturnModificator>
					<ReturnType><![CDATA[int]]></ReturnType>
					<Id>1713952009400</Id>
					<Name><![CDATA[Function_ClearingFunction_Version_BeforRehasConstraint]]></Name>
					<X>490</X><Y>250</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Parameter>
						<Name><![CDATA[itemsToPlan]]></Name>
						<Type><![CDATA[List<MRP>]]></Type>
					</Parameter>
					<Parameter>
						<Name><![CDATA[bomLevel]]></Name>
						<Type><![CDATA[int]]></Type>
					</Parameter>
					<Parameter>
						<Name><![CDATA[inResource]]></Name>
						<Type><![CDATA[Resource]]></Type>
					</Parameter>
					<Parameter>
						<Name><![CDATA[fileSuffix]]></Name>
						<Type><![CDATA[String]]></Type>
					</Parameter>
					<Body><![CDATA[try{

Tools to = new Tools();
							
traceln("----------- Start CF OPTIMIZATION at DEFAULT Version incl. Exta Capacity " + time () + " ----------------");
							
StringBuilder output = new StringBuilder();

int maxCapacity = 1440;
//double wipCosts = 0;
//double inventoryHoldingCosts = 0;
traceln("Total found Segments: " + ClearingFunctionSegments.size());


/*
Iterator<MRP> iterator = itemsToPlan.iterator();
while (iterator.hasNext()) {
    MRP o = iterator.next();
    if (o.getItem().getItem() == 103 ||     
    o.getItem().getItem() == 111 ||
    o.getItem().getItem() == 115 ||
    o.getItem().getItem() == 119 ||
    o.getItem().getItem() == 123 ||
    o.getItem().getItem() == 127 ||
    o.getItem().getItem() == 131
    ) {
        iterator.remove(); // Safely remove the element from the list
    }
}
*/

	//via the bom level the cf is associated
	List<ClearingFunctionSegments> selectedSegments = new ArrayList();
	Item firstBomItem = itemsToPlan.get(0).getItem();
	//wipCosts = firstBomItem.getHoldingCostsWIP();
	//inventoryHoldingCosts = firstBomItem.getHoldingCosts();	
	
	//Routing firstRoutingItem = main.routings.stream().filter(e -> e.getItem().getItem() == firstBomItem.getItem()).findFirst().get();	
	//Resource firstResource= main.resources.stream().filter(e -> e.getName().equalsIgnoreCase(firstRoutingItem.getResource())).findFirst().get();
	
	//maxCapacity = inResource.getCapacity();
	//don't map it to the prodction stage 1-4, select the values based on the resource
	traceln("Total found segments: " + selectedSegments);
	
	if(firstBomItem.getLotsizePolicy().equalsIgnoreCase(Item.LOT_POLICY_FOP)) {
		int fop = firstBomItem.getFOPPeriod();	
		traceln("FOP Period:" + fop);	
					
		selectedSegments = ClearingFunctionSegments.stream().filter(e -> e.getLotParameter() == fop &&
							 e.getLotPolicy().equalsIgnoreCase(Item.LOT_POLICY_FOP) && e.getResource().equalsIgnoreCase(inResource.getName()) 
				 && e.getExperiment().equalsIgnoreCase(main.simParams.getExperiment())).collect(Collectors.toList());															 																								
	}
	else if(firstBomItem.getLotsizePolicy().equalsIgnoreCase(Item.LOT_POLICY_FOQ)) {
		int foq = (int)firstBomItem.getFOQQuantity();	
		traceln("FOQ Qty:" + foq);	
					
		selectedSegments = ClearingFunctionSegments.stream().filter(e -> e.getLotParameter() == foq &&
							 e.getLotPolicy().equalsIgnoreCase(Item.LOT_POLICY_FOQ) && e.getResource().equalsIgnoreCase(inResource.getName()) 
				 && e.getExperiment().equalsIgnoreCase(main.simParams.getExperiment())).collect(Collectors.toList());															 																								
	}
				
	traceln("Resource: " + inResource.getName());
	traceln("Resource Stage Number: " + inResource.getStageNumber());
	traceln("Production Stage: " + (bomLevel + 1));
	traceln("Max Capacity: " + maxCapacity);
	
	traceln("Items to Plan: ");
	itemsToPlan.forEach(e -> traceln(e.getItem().getItem() + " eProcessingTime " + e.getItem().getRouting().getEProcessingTime() + ";"));

	traceln("Selected Slopes: ");		
	selectedSegments.forEach(e -> traceln(e.getSlope() + ";"));
	traceln("Selected Intercepts: ");
	
	selectedSegments.forEach(e -> traceln(e.getyIntercept() + ";"));
	
	if(selectedSegments.size() == 0){
		traceln("STOP Simulation: No Segments found!");
		System.exit(0);
	}
	
	to.log("Segment Cnt: " + selectedSegments.size(), Tools.LogCFOptimization);
	
	double intercepts[] = new double[selectedSegments.size()];
	double slopes[] = new double[selectedSegments.size()];
	
	for(int i = 0; i < selectedSegments.size(); i++) {
		slopes[i] = selectedSegments.get(i).getSlope();
		intercepts[i] = selectedSegments.get(i).getyIntercept();
	}		
			
int numberSegments = selectedSegments.size();

double oCosts = 0;
double oFactor = 1000;//1000
double setupTime = 18; //standard = 18
int leadtimeHorizon = main.simParams.getLeadTimeHorizon();

traceln("Leadtime Horizon: " + leadtimeHorizon);

IloCplex cplex = new IloCplex();

     String[][] Inames = new String[itemsToPlan.size()][get_Main().simParams.getMRPPlanningHorizon()];
     String[][] Pnames = new String[itemsToPlan.size()][get_Main().simParams.getMRPPlanningHorizon()];
     String[] PLnames = new String[get_Main().simParams.getMRPPlanningHorizon()];
     String[] Lnames = new String[get_Main().simParams.getMRPPlanningHorizon()];
     String[][] Wnames = new String[itemsToPlan.size()][get_Main().simParams.getMRPPlanningHorizon()];
     String[][] Rnames = new String[itemsToPlan.size()][get_Main().simParams.getMRPPlanningHorizon()];     
     String[][] Bnames = new String[itemsToPlan.size()][get_Main().simParams.getMRPPlanningHorizon()];     
     String[][] Znames = new String[itemsToPlan.size()][get_Main().simParams.getMRPPlanningHorizon()];     
     
     
     for(int i = 0; i< get_Main().simParams.getMRPPlanningHorizon(); i++){
          for (int p = 0; p < itemsToPlan.size(); p++) {
        	 	Inames[p][i] = "I" + itemsToPlan.get(p).getItem().getItem() + "_" + i; 
        	 	Pnames[p][i] = "P" + itemsToPlan.get(p).getItem().getItem() + "_" + i; 
        	 	Wnames[p][i] = "W" + itemsToPlan.get(p).getItem().getItem() + "_" + i; 
        	 	Rnames[p][i] = "R" + itemsToPlan.get(p).getItem().getItem() + "_" + i; 
        	 	Bnames[p][i] = "B" + itemsToPlan.get(p).getItem().getItem() + "_" + i; 
        	 	PLnames[i] = "PL" + itemsToPlan.get(p).getItem().getItem() + "_" + i; 
        	 	Lnames[i] = "L" + itemsToPlan.get(p).getItem().getItem() + "_" + i;
         	 	Znames[p][i] = "Z" + itemsToPlan.get(p).getItem().getItem() + "_" + i;  
        	 	 
	     }
     }


     IloNumVar[] C = new IloNumVar[main.simParams.getMRPPlanningHorizon()]; 
     for (int t = 0; t < get_Main().simParams.getMRPPlanningHorizon(); t++) {
        C[t] = cplex.numVar(0, Double.MAX_VALUE, "C" + "_" + t); 
     }
     
     IloNumVar[][] I = new IloNumVar[itemsToPlan.size()][];
     for (int p = 0; p < itemsToPlan.size(); p++) {
        I[p] = cplex.numVarArray(get_Main().simParams.getMRPPlanningHorizon(), 0, Double.MAX_VALUE, Inames[p]);
        oCosts += itemsToPlan.get(p).getItem().getHoldingCosts();
     }
     
     oCosts = oFactor*oCosts;
     //oCosts = oFactor;
     
     IloNumVar[][] P = new IloNumVar[itemsToPlan.size()][];
     for (int p = 0; p < itemsToPlan.size(); p++) {     
        P[p] = cplex.numVarArray(get_Main().simParams.getMRPPlanningHorizon(), 0,  Double.MAX_VALUE, Pnames[p]);        
     }
     
     IloNumVar[] PL = new IloNumVar[leadtimeHorizon];     
     IloNumVar[] L = new IloNumVar[leadtimeHorizon];     
     
     for (int t = 0; t < leadtimeHorizon; t++) {               
     	PL[t] = cplex.numVar(0,  Double.MAX_VALUE, PLnames[t]);
     	L[t] = cplex.numVar(0,  Double.MAX_VALUE, Lnames[t]);
     }
     
                    
     IloNumVar[][] W = new IloNumVar[itemsToPlan.size()][];
     for (int p = 0; p < itemsToPlan.size(); p++) {
        W[p] = cplex.numVarArray(get_Main().simParams.getMRPPlanningHorizon(), 0, Double.MAX_VALUE, Wnames[p]);
     }
		
	 IloNumVar[][] R = new IloNumVar[itemsToPlan.size()][];
     for (int p = 0; p < itemsToPlan.size(); p++) {
        R[p] = cplex.numVarArray(get_Main().simParams.getMRPPlanningHorizon(), 0.0, Double.MAX_VALUE, Rnames[p]);
     }          
     
     IloNumVar[][] B = new IloNumVar[itemsToPlan.size()][];
     for (int p = 0; p < itemsToPlan.size(); p++) {
        B[p] = cplex.numVarArray(get_Main().simParams.getMRPPlanningHorizon(), 0.0, Double.MAX_VALUE, Bnames[p]);
     }
     
     IloNumVar[][] Z = new IloNumVar[itemsToPlan.size()][];
     for (int p = 0; p < itemsToPlan.size(); p++) {
        Z[p] = cplex.numVarArray(get_Main().simParams.getMRPPlanningHorizon(), 0, Double.MAX_VALUE, Znames[p]);
     }     
               	
	double[] inventory = new double[itemsToPlan.size()];
	double[] wip = new double[itemsToPlan.size()];
	double[] produce = new double[itemsToPlan.size()];
	double[] tl = new double[itemsToPlan.size()];
		
	int[][] X = new int[itemsToPlan.size()][get_Main().simParams.getMRPPlanningHorizon()];

	List<SpecialObject> iQd = new ArrayList<SpecialObject>();
	List<SpecialObject> runningOrders = new ArrayList<SpecialObject>();
	
     for (int p = 0; p < itemsToPlan.size(); p++) {      	     

     		   inventory[p] = 0;
     		   
     		   //wip[p] = (int)ProductionOrder.GetCurrentWip(get_Main().productionOrders, itemsToPlan.get(p).getItem(), get_Main().simParams);
     		   	wip[p]=0;
     		   
	        	int tmp_item = itemsToPlan.get(p).getItem().getItem();
				     		
     		   produce[p] = 0;
     		   
     		   //tl[p] = itemsToPlan.get(p).getItem().getTransportLotSize();
     	       for (int t = 0; t < get_Main().simParams.getMRPPlanningHorizon(); t++) {               	                          	               	
	               			               		               		               		               	
	               	//int tmp_item = itemsToPlan.get(p).getItem().getItem();
	               	int temp_t = t;
	               	int quantityRunningProductionOrders = 0;
	               	int lateOrders = 0;
	               	
	               	MRP mrpItem = null;
	               	
	               	if(t > 0){
		               	mrpItem = get_Main().mrpTable.stream().filter(e -> e.getItem().getItem() == tmp_item
		               	 && e.getTime() == time() && e.getPeriod() == temp_t-1).findFirst().orElseGet(() -> new MRP());
		               	 
		               	 //traceln("T for running Orders: " + t);
		               	 quantityRunningProductionOrders = remainingProductionOrderQty(tmp_item,t + time());
		               	 
		               	 //late Orders must only be computed in period 1 and not the remaining.
		               	 if(t == 1){
		               	 	lateOrders = lateProductionOrdersQty(tmp_item,t + time());						
		               	 }
		               	 
		               	 //traceln("t " + t + " PlannedOrderReceipts " + (int) mrpItem.getPlannedOrderReceipts()); 
		               	 
		               	 X[p][t] += (int) mrpItem.getPlannedOrderReceipts();
		               	 		               	 
		               	//mrpItem.setPlannedOrderReceipts(mrpItem.getPeriod() + 50);
		               	//traceln("MRP Item for Optimization");
		               	//traceln(MRP.GetCSVHeader());
		               	//traceln(MRP.GetCSVString(mrpItem));
	               	}
															
					if(quantityRunningProductionOrders > 0 || lateOrders > 0){
						traceln("RunningProduction Order Qty: " + quantityRunningProductionOrders + " time: " + time() + " t " + t + " item " + tmp_item);
						traceln("old Xpt: " + X[p][t]);
						
						if(t == 1){
							X[p][1] += (quantityRunningProductionOrders + lateOrders);							
						}else{
							X[p][t] += quantityRunningProductionOrders;
						}															
						
						traceln("new Xpt: " + X[p][t]);
						traceln("Now we have to consider the Remaining Qty for Capacity Consumption of: " + X[p][t]);
						
						SpecialObject runningOrder = new SpecialObject(
	        				mrpItem.getItem().getItem(),
	        				X[p][t], 
	        				t,
	        				quantityRunningProductionOrders + lateOrders);
	        				
	        			runningOrders.add(runningOrder);						
					}
															
					//if(t == 1){						
	        			//X[p][t] += (int) mrpItem.getPlannedOrderReceipts();	        				        			
	        		//}else if(t > 1){	        		
	        		
	        		
	        		//}

	        		if(X[p][t] > 0 && t > 0) {
	        			SpecialObject so = new SpecialObject(
	        				mrpItem.getItem().getItem(),
	        				X[p][t], 
	        				t,
	        				quantityRunningProductionOrders + lateOrders);
	        			iQd.add(so);
	        			traceln("X[" + p + "," + t + "] " + X[p][t] + " " + mrpItem.getItem().getItem());	        				        			        		
	        			
	        			//traceln("~~~~~~~~~~~~~" + so.getItem() + " qty: " + so.getQuantity() + " dd " + so.getDueDate());
	        			
	        		}        		  	        		        		
            }     	      	
     }                                        
     
     //if(iQd.size() == 0){     	
     	//throw new ProblemFoundException("No Planned order Receipts found.");
     //}
     	
               
     String[][] RiNames = new String[iQd.size()][leadtimeHorizon];
     int[][] releaseTmp = new int[iQd.size()][main.simParams.getMRPPlanningHorizon()];
     String[] releaseForX = new String[iQd.size()];

	 // this combinations are constructed .. every time the due date in this case 13, a 0 value is added RI_103_13_106.0_0R103_0
	 
	 //RI_103_13_106.0_0R103_0 + RI_103_13_106.0_0R103_0
       //+ RI_103_13_106.0_0R103_0 + RI_103_13_106.0_1R103_1
       //+ RI_103_13_106.0_2R103_2 + RI_103_13_106.0_3R103_3
       //+ RI_103_13_106.0_4R103_4 + RI_103_13_106.0_5R103_5
       //+ RI_103_13_106.0_6R103_6 + RI_103_13_106.0_7R103_7
       //+ RI_103_13_106.0_8R103_8 + RI_103_13_106.0_9R103_9
       //+ RI_103_13_106.0_10R103_10 + RI_103_13_106.0_11R103_11
       //+ RI_103_13_106.0_12R103_12 + RI_103_13_106.0_13R103_13 
	 
	 //for each Xt > 0 an entry to iQd is added and this represnts all Xts of all planned products!
     for (int p = 0; p < iQd.size(); p++) {
          for(int i = 1; i < leadtimeHorizon; i++){
          		int targetT = (int)(iQd.get(p).getDueDate() - leadtimeHorizon + i + 1);          		
          		
          		if(targetT < 0)
          			targetT = 0; // is 0 as this are values later thaen the due date e.g. 13
          		          		
          		releaseTmp[p][targetT] = i+1;
          		
          		if(targetT > 0){          		          		
        	 		RiNames[p][i] = "RI_" +  iQd.get(p).getItem() + "_" + (int)iQd.get(p).getDueDate() +         	 	
        	 		"_" + iQd.get(p).getQuantity() + "_" + targetT + "R" + iQd.get(p).getItem() + "_" + targetT; 
        	 	}else{
        	 		RiNames[p][i] = "noRelease";// + p + "" + i;
        	 	}        	 	        	 	
        	 	
        	 	//traceln(RiNames[p][i]);
	     }    
     }


	 //for each product we need the individual releases RI.....They are constructed with the above equation.            
	 //traceln("iQd.size " + iQd.size());
     IloNumVar[][] RI = new IloNumVar[iQd.size()][];
     for (int p = 0; p < iQd.size(); p++) {
          	     	
     	//e.g. if we have 8 releases while iqd.size = 8 and this all all the xts, we also need 8 RIs to get an individual decision for each Xt, which must be associated with an Release
     	// in each RiNames the item and due date (item and xt) is coded, consequently this works. 
        RI[p] = cplex.boolVarArray(leadtimeHorizon, RiNames[p]);                
        
     }                                      
            
     	//Objective Function     
		IloLinearNumExpr objFunction  = cplex.linearNumExpr();
	         
        for (int p = 0; p < itemsToPlan.size(); p++) {
           for (int t = 0; t < get_Main().simParams.getMRPPlanningHorizon(); t++) {
              objFunction.addTerm (itemsToPlan.get(p).getItem().getHoldingCosts(), I[p][t]);
            }
         }

        for (int p = 0; p < itemsToPlan.size(); p++) {
           for (int t = 0; t < get_Main().simParams.getMRPPlanningHorizon(); t++) {
             objFunction.addTerm (itemsToPlan.get(p).getItem().getHoldingCostsWIP(), W[p][t]);
            }                     	            
         } 
         
         for (int p = 0; p < itemsToPlan.size(); p++) {
           for (int t = 0; t < get_Main().simParams.getMRPPlanningHorizon(); t++) {
             objFunction.addTerm (itemsToPlan.get(p).getItem().getBacklogCosts(), B[p][t]);
            }                     	            
         } 
         
                  
         for (int t = 0; t < get_Main().simParams.getMRPPlanningHorizon(); t++) {
             objFunction.addTerm (oCosts, C[t]); 
         }                     	                              
                                      
         cplex.addMinimize(objFunction); //objective function
       
         for (int p = 0; p < itemsToPlan.size(); p++) {
           		
         	cplex.addEq(I[p][0],0); //Eq7
         	cplex.addEq(P[p][0],0); //Eq8  Pg,0 must be zero to avoid production in this period. this is not possible.                           
         	//cplex.addEq(W[p][0],0); //Eq7
         	cplex.addEq(R[p][0],0); //Eq9
         	cplex.addEq(W[p][0],0); //Eq10
         
            for (int t = 1; t < get_Main().simParams.getMRPPlanningHorizon(); t++) {
	           	cplex.addEq(cplex.sum(cplex.sum(I[p][t], X[p][t]),B[p][t-1]), 
                       cplex.sum(cplex.sum(I[p][t-1], P[p][t-1]),B[p][t]));
        	}
            
              
            cplex.addEq(W[p][0], R[p][0]);
            
            for (int t = 1; t < get_Main().simParams.getMRPPlanningHorizon(); t++) {
               cplex.addEq(cplex.sum(W[p][t], P[p][t-1]), 
                           cplex.sum(W[p][t-1], R[p][t]));   
                                                                                                                                    
            }			             											
         }
         
         //********************* Sum of RI_t == 1 *************************
         // RI_103_13_106.0_0R103_0 + RI_103_13_106.0_0R103_0 + RI_103_13_106.0_0R103_0 + RI_103_13_106.0_1R103_1  + RI_103_13_106.0_2R103_2 + RI_103_13_106.0_3R103_3  + RI_103_13_106.0_4R103_4 + RI_103_13_106.0_5R103_5 .... = 1       
         // CF Article EQ3 
          List<String> unique = new ArrayList();
          
          for (int p = 0; p < iQd.size(); p++) {
            IloLinearNumExpr num_expr_Sum_Binaries = cplex.linearNumExpr();  
            boolean weHaveRI = false;	           
	            for (int t = 1; t < leadtimeHorizon; t++) {	            	
	            	
	            	//int tmp_p = p;
	            	//int tmp_t = t;
	            	//traceln("test auf " + RI[tmp_p][tmp_t].getName());
	            	
	            	//boolean exists = unique.stream().filter(element -> element != null).anyMatch(element -> element.equals(RI[tmp_p][tmp_t].getName()));
	            	            	
	            	//if(!exists) {
	            		//unique.add(RI[tmp_p][tmp_t].getName());
	            		//traceln("p" + p + " t " + t );
	            		
	            		if(RI[p][t] != null){
	            		//traceln("ri not null");
	            		String variableName = RI[p][t].getName();
	            		//char isItRI = "RI";
	            		//traceln("Found variable " + variableName);
	            		
							           		
		            		if(variableName.contains("RI")){
		            			weHaveRI = true;
		            			num_expr_Sum_Binaries.addTerm(1,RI[p][t]);															
		            		}
		            		
	            		}
	            		
	            		
	            		//traceln("add" + RI[tmp_p][tmp_t].getName());
	            	//}else{
	            		//num_expr_Sum_Binaries.addTerm(0,RI[p][t]);															
	            	//}					
	            }
	            	            
	            if(weHaveRI)
	            	cplex.addEq(num_expr_Sum_Binaries,1);
            }
         
         
         //RI structure
         //Eq2 where Rg,t = RIg,t*Xg,t
         //RI_item_Xt_qty_start_lth_...end_lth_Ritem_start_lth...end_lth
         for (int pp = 0; pp < itemsToPlan.size(); pp++) {
         	IloLinearNumExpr cf = cplex.linearNumExpr();				         
	       for (int t = 1; t < main.simParams.getMRPPlanningHorizon()-1; t++) {	            	            
			       	String o = "";
			       	int sizeExpr = 0;
			        IloLinearNumExpr num_expr = cplex.linearNumExpr();
			                    
	                for (int p = 0; p < iQd.size(); p++) {
	                	if(iQd.get(p).getItem()== itemsToPlan.get(pp).getItem().getItem()){
	                	
		            		if(releaseTmp[p][t] > 0){
		            			
		            			o = o + iQd.get(p).getQuantity() + "*" + RI[p][releaseTmp[p][t]-1].getName() +  "+";	            			
		            			num_expr.addTerm(iQd.get(p).getQuantity(),RI[p][releaseTmp[p][t]-1]);
		            					            					            					            			
		            			sizeExpr++;		            					            					            			
		            		}			        
	            		}
					}
					
				if(o.length() > 1){
		            if(sizeExpr > 0){
		            	//Constraint Release Size 
			            cplex.addEq(R[pp][t],num_expr);    
			                  
			        }

				}else{
				         cplex.addEq(R[pp][t],0);          								
				}
																
				num_expr.clear();             														
			}         
         }
                         
		IloLinearNumExpr[] sumRIs = new IloLinearNumExpr[main.simParams.getMRPPlanningHorizon()];
		
		for (int t = 0; t < main.simParams.getMRPPlanningHorizon(); t++) {
		    IloLinearNumExpr sumRIsI = cplex.linearNumExpr();
		
		    for (int pp = 0; pp < itemsToPlan.size(); pp++) {
		        for (int p = 0; p < iQd.size(); p++) {
		            if (iQd.get(p).getItem() == itemsToPlan.get(pp).getItem().getItem()) {
		                if (releaseTmp[p][t] > 0) {
		                	//traceln("###### " + 1.0 + " :::: " +  RI[p][releaseTmp[p][t] - 1]);		                
		                    sumRIsI.addTerm(1.0, RI[p][releaseTmp[p][t] - 1]);		                    
		                }
		            }
		        }
		    }
		    
		    sumRIs[t] = sumRIsI;		    		    		    
		    //sumRIsI.clear();
		}				
		             
            
//Constraint avoiding that RI with later due date, releases order earlier that RI with earlier due date (orders should not overteak each other)
//The release of order 2 should not before order 1                                         
// ********************************* Guarantee Release ORDER  ****************************************
// ***************************************************************************************************            
//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
// Constraint avoiding that RI with later due date, releases order earlier that
// RI with earlier due date (orders should not overteak each other) The release
// of order 2 should not before order 1

//daher
traceln("iQd size " + iQd.size());

List<SpecialObject> iQdSorted = iQd;

Collections.sort(iQdSorted, Comparator.comparing(SpecialObject::getDueDate).thenComparing(SpecialObject::getItem));
//Collections.sort(iQdSorted, Comparator.comparing(SpecialObject::getItem).thenComparing(SpecialObject::getDueDate));

traceln("IQd sorted:");
for(SpecialObject o : iQdSorted){
	traceln(o.getDueDate()  + " " + o.getItem() + " " + o.getQuantity());						
}

for(int i = 0; i < iQdSorted.size() -1; i++){
//now take the first succesor:
		SpecialObject currentiQd = iQdSorted.get(i);		
		SpecialObject succesoriQd = iQdSorted.get(i+1);
		
		if(currentiQd.getDueDate() <= succesoriQd.getDueDate() && currentiQd.getDueDate() > 1){
						
			int overlappingStart = max((int)succesoriQd.getDueDate() - leadtimeHorizon,0);
			//traceln("overlapping start" + (int)succesoriQd.getDueDate()  + " -" + leadtimeHorizon + "=" + overlappingStart);
			// for the overlapping time we have to generate the RI comparisions:			
			IloLinearNumExpr lhs = cplex.linearNumExpr();
	        IloLinearNumExpr rhs = cplex.linearNumExpr();

             // traceln("Start Index " + RIstartIndex);
            int overlappingPeriods = (int)currentiQd.getDueDate() - overlappingStart;
			
			int RIstartIndex =  max(0, (leadtimeHorizon - overlappingPeriods));                                            

            StringBuilder lhsOut = new StringBuilder();
            StringBuilder rhsOut = new StringBuilder();
                          
            int multiplier = 0;                   
            //traceln("Overlapping Periods " + overlappingPeriods);
            //traceln("Overlapping Start "  + overlappingStart);            
            
            for (int o = 0; o < overlappingPeriods; o++) {
				
				IloNumVar found = Function_FindeRIVarialbe(iQdSorted.size(), RI, currentiQd.getItem(), (int)currentiQd.getDueDate(), o+1, (int)currentiQd.getQuantity());
				
				IloNumVar foundSuccessor = Function_FindeRIVarialbe(iQdSorted.size(), RI, succesoriQd.getItem(), (int)succesoriQd.getDueDate(), o+1, (int)succesoriQd.getQuantity());
				
                //if (RI[p][RIstartIndex + o].getName().contains("RI")) {
                //traceln("found" + found.getName());
                if (found.getName().contains("RI")) {
                
                	lhs.addTerm(multiplier + 1, found);
                	lhsOut.append(multiplier + 1 + " " + found.getName()  + " + ");
                	
                	rhs.addTerm(multiplier + 1, foundSuccessor);
                	rhsOut.append(multiplier + 1 + " " + foundSuccessor.getName() + " + ");
                	                
                	multiplier++;
                }
            }
            
            //for the remaining periods we have to extend the rhs:
            
            
            for (int o = 0; o < succesoriQd.getDueDate() - overlappingPeriods; o++) {
												
				IloNumVar foundSuccessor = Function_FindeRIVarialbe(iQdSorted.size(), RI, succesoriQd.getItem(), (int)succesoriQd.getDueDate(), overlappingPeriods + o + 1, (int)succesoriQd.getQuantity());								
				
                //if (RI[p][RIstartIndex + o].getName().contains("RI")) {
                //traceln("found" + found.getName());
                if (foundSuccessor.getName().contains("RI")) {                                
                	
                	rhs.addTerm(multiplier + 1, foundSuccessor);
                	rhsOut.append(multiplier + 1 + " " + foundSuccessor.getName() + " + ");
                	                
                	multiplier++;
                }
            }
            
            
            cplex.addLe(lhs, rhs);

         traceln("Overlapping:");
         traceln(lhsOut.toString() + "<=");
         traceln(rhsOut.toString());             						
		
		}													
}
         
//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~            
                                                                                                
            
         //****************** CF SECTION ***************************************
         //*********************************************************************
         
         for (int t = 0; t < main.simParams.getMRPPlanningHorizon(); t++) {	    
         
	     	IloLinearNumExpr cf = cplex.linearNumExpr();				             	    
	     	IloLinearNumExpr cf1 = cplex.linearNumExpr();				             	    
	       	IloLinearNumExpr cf2 = cplex.linearNumExpr();				             	    
		   	IloLinearNumExpr cf3 = cplex.linearNumExpr();				             	    
	       	IloLinearNumExpr cf4 = cplex.linearNumExpr();				             	    

    	    
    	    //Pgt smaller Wgt - Constraint for single item qty
        	 for (int pp = 0; pp < itemsToPlan.size(); pp++) {        	  			
					//merk dir, dass die weiter unten verwendet werden
					//double setupProption = 18.0/106.0;
					double setupProption = 0;
					
	         		cf.addTerm(itemsToPlan.get(pp).getItem().getRouting().getEProcessingTime()+setupProption,P[pp][t]);	         		
	         		
	         		if(get_Main().simParams.getCFSegments() > 0){	         		
	         			cf1.addTerm(itemsToPlan.get(pp).getItem().getRouting().getEProcessingTime()+setupProption,P[pp][t]); 	         		        		
         				cf2.addTerm(itemsToPlan.get(pp).getItem().getRouting().getEProcessingTime()+setupProption,W[pp][t]);         			         		        			         			
         			}
         			
         			cf3.addTerm(itemsToPlan.get(pp).getItem().getRouting().getEProcessingTime()+setupProption,P[pp][t]);         		
         			cf4.addTerm(itemsToPlan.get(pp).getItem().getRouting().getEProcessingTime()+setupProption,W[pp][t]);
         			
         			
         			//***************** Ppt, <= Wp,t ***********************        			         		         			
         			cplex.addLe(
         				//cplex.sum(P[pp][t],cplex.prod(0,sumRIs[t])),//LHS         			
         				cplex.sum(P[pp][t],0),//LHS         			
        				cplex.sum(W[pp][t],0));//RHS         			
        			//****************************************        			         		         				
        				        				        				        			        			        				
        	  }
        	          	  
			  //CF Constraints			           	  
			  //PL <= MC + Ct (Eq12)			  
			  //traceln("setup time " + setupTime + " sum ri " + sumRIs);
         	  //cplex.addLe(cplex.sum(cf,cplex.prod(setupTime,sumRIs)), //LHS         	  
         	  
         	  
         	  // **************** PL und L ausgeben *********************
         	  //keine constraints werden spter so auch nicht wiedervendet
         	  cplex.addEq(PL[t],cf);
         	  cplex.addEq(L[t],cf2);
         	  //********************************************************* 
         	  
         	  
         	  //cplex.addEq(PL[t],cplex.sum(cf,cplex.prod(setupTime,sumRIs)));
         	  //cplex.addEq(L[t],cplex.sum(cf2,cplex.prod(setupTime,sumRIs)));         	           	           	           	  
         	  
         	  /******** PLt <=MC+Ct (Eq14) ************/
         	  //This is also the reason why in the .lp file the maximum capacity is not available for t=0
         	  if(t==0){         	           	           	           	  
         	  		cplex.addLe(cf,         	  
         	  		cplex.sum(0,C[t]));	//RHS
         	  	}else{         	  	
         	  		cplex.addLe(cplex.sum(cf,cplex.prod(setupTime,sumRIs[t])),         	  
         	  		cplex.sum(maxCapacity,C[t]));	//RHS
         	  	}
         	           	           	           	  		         	           	           	  
         	           	           	  
         	  // ---- we have three segments         	           	           	  
			  //CF partition 2 from numerical example
			  //traceln("# segments " + numberSegments);
			  //represent CF as k*x + d -> 
			  
			  if(get_Main().simParams.getCFSegments() == 0){
			  	numberSegments = 0;			  	
			  }
			  
			  traceln("Number Segments: " + numberSegments);
			  
			  for(int i = 0; i < numberSegments; i++){
	         	  cplex.addLe(
    	     	  	cplex.sum(cf1,cplex.prod(setupTime,sumRIs[t])), //LHS				
				
         	  		cplex.sum(cplex.sum(cplex.prod(max(slopes[i],0),         	  	         	  	
         	  		
         	  		cplex.sum(cf2,cplex.prod(setupTime,sumRIs[t]))),intercepts[i]),C[t]));//RHS         	  		         	  						
         	  	
         	  		traceln("Slope (x): " + slopes[i] + " Y-intercept (d) " + intercepts[i]);
         	  		         	  		
         	  	//traceln("sumRIs " + sumRIs + " st " + setupTime);	
         	  }//for
         	           	           	           	  
         	           	           	           	  			           	  
         	  /******************************* PLt <= Lt + Ct (Eq18) *********************/
         	  //Constraint Pl musst be smaller as SL for all t         	           	  
         	  
         	  cplex.addLe(
         	  	cplex.sum(cf3,cplex.prod(setupTime,sumRIs[t])), //LHS         	  
	         	cplex.sum(cplex.sum(cf4,cplex.prod(setupTime,sumRIs[t])),C[t]));         	  	         		         		         		         	
	         	
	         	
	         	/*
	         	cplex.addLe(
         	  	cplex.sum(cf3,cplex.prod(setupTime,sumRIs[t])), //LHS         	  
	         	cplex.sum(cplex.sum(cf4,cplex.prod(setupTime,sumRIs[t])),0));         	  	         	
	         	*/
	         	
	          //***************************************************************************
         	  
			  cf.clear();
			  cf1.clear();
 			  cf2.clear();
 			  cf3.clear();
 			  cf4.clear();
         }



			// Create a two-dimensional array of IloNumVars
            int numRows = iQd.size(); // Assuming iQd is a list or array
                        
            // ... Initialize and populate the RI array with IloNumVars ...

            // Find the variable by name in the RI array
            traceln("iQd size: " + iQd.size());
            String targetVariableName = "noRelease";
            boolean isVariableFound = false;
            IloNumVar foundVariable = null;

            for (int i = 0; i < numRows; i++) {
                for (int j = 1; j < RI[i].length-1; j++) {
                    IloNumVar var = RI[i][j];
                    if (var.getName().equals(targetVariableName)) {
                        isVariableFound = true;
                        foundVariable = var;
                        break;
                    }
                }
                if (isVariableFound) {
                    break;
                }
            }
            
            if (isVariableFound) {
                // Add a constraint to enforce the found variable to be zero
                traceln("Yes found set no release to 0");                
                foundVariable.setName("noRelease");                                
                cplex.addEq(foundVariable, 0);
            }
            
            //All Entries represent Running Orders. So the associated
            //RI_...1 must be set to one
            
                                    
            int numberOpenOrders = runningOrders.size();
            for(SpecialObject o : runningOrders){
            	traceln(o.getItem() + " " + o.getQuantity() + " " + o.getQuantityRunning());
            }
            
            
            traceln("Count Running Orders: " + numberOpenOrders);
            traceln("RI length: " + RI.length);
            if(iQd.size() > 0){
            for (int i = 0; i < iQd.size(); i++) {
            	isVariableFound = false;            	
            	if(iQd.get(i).getQuantityRunning() > 0){
            		traceln("search " + iQd.get(i).getItem() + " " + iQd.get(i).getDueDate() + " " + iQd.get(i).getQuantity() + " " + iQd.get(i).getQuantityRunning());
	            	for(int a=0; a < iQd.size(); a++){
	            	for (int j = 1; j < RI[a].length; j++) {
	            	
	            		//"RI_103_13_106.0_0R103_0"
	            					                                		
	            	    String[] RiSplitted = RI[a][j].getName().split("_");
				        //traceln(RI[a][j].getName().split("_"));
	                    
	                    IloNumVar var = RI[a][j];
	                    
	                    if(!var.getName().equals("noRelease")){
	                    	
	                    	targetVariableName = "RI_" + iQd.get(i).getItem() + "_" + (int) iQd.get(i).getDueDate() + "_" + 
	                    	iQd.get(i).getQuantity() + "_1" + "R" +  iQd.get(i).getItem() + "_1";
	                    
	                    	//traceln("Running Order Target Name ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~: " + targetVariableName);
	                    
		                    if (var.getName().equals(targetVariableName)) {
		                        isVariableFound = true;
		                        foundVariable = var;
		                        break;
		                    }//if
		                 }//if
	                }//for
	                
	                if(isVariableFound){
	                	break;
	                }
	                
	               }//for                         
				}//if
				                
                if (isVariableFound) {	                	                	                
	                cplex.addEq(foundVariable, 1);
	                traceln("Release Variable found " + foundVariable.getName() + " set to 1");
	                isVariableFound = false;
            	}
            }//for
            }//if
                                                               
    
    //cplex.deleteNames();
    
    //if(time() == 0)
    if(Tools.Log_CF_Optimization_Values){                 
		cplex.exportModel("model/NewModel_" + time() + "_" + bomLevel + "_" + firstBomItem.getItem() +".lp");
	}	
	//cplex.writeSolution("model/NewModel_" + time() + "_" + bomLevel + ".sol");

	//cplex.setParam(IloCplex.BooleanParam.PreInd, true);
	//0.05 were to hard ... 0.1 before	
	cplex.setParam(IloCplex.Param.MIP.Tolerances.MIPGap, 0.05);
	//cplex.setParam(IloCplex.IntParam.DataCheck, 2);	
	cplex.setParam(IloCplex.IntParam.WorkMem, 2000);
	cplex.setParam(IloCplex.Param.Threads, 4);
	
	
						
	if(cplex.solve() && Tools.Log_CF_Optimization_Values){
		    
		    System.out.println("Solution status: " + cplex.getStatus());
            System.out.println();
            System.out.println("Objective Value = " + cplex.getObjValue());
          
            System.out.println("Pieces: Wip, X, Release, P");
            System.out.println("Minutes: PL L, MC, CF1, CF2, CF3");
            System.out.println("\tp\tTime\tt\tWip\tX\tRelease\tP\tPL\tL\tMC\tCF1\tCF2\tCF3\tInv\tIBl\tWB\tObjPP\tCt\tBt\tPTime\tSTime\tPL\tLt\tICo\tWCo\tBco\tCo");
          	
            int[] t_sum_wip = new int[get_Main().simParams.getMRPPlanningHorizon()];
            int[] t_sum_pl = new int[get_Main().simParams.getMRPPlanningHorizon()];
            int[] t_sum_l = new int[get_Main().simParams.getMRPPlanningHorizon()];
            int[] t_sum_load = new int[get_Main().simParams.getMRPPlanningHorizon()];
            int[] t_sum_x = new int[get_Main().simParams.getMRPPlanningHorizon()];
            int[] t_sum_r = new int[get_Main().simParams.getMRPPlanningHorizon()];
            int[] t_sum_p = new int[get_Main().simParams.getMRPPlanningHorizon()];
          	
            for (int p = 0; p < itemsToPlan.size(); p++) {
                        	
               for (int t = 0; t < get_Main().simParams.getMRPPlanningHorizon(); t++) {
               
               double inventoryBalance = 0;
               double wipBalance = 0;

               if(t>0){
                  inventoryBalance = cplex.getValue(I[p][t-1])-X[p][t]+cplex.getValue(P[p][t-1]) - cplex.getValue(B[p][t-1]) + cplex.getValue(B[p][t]);
                  wipBalance = cplex.getValue(W[p][t-1])+cplex.getValue(R[p][t])-cplex.getValue(P[p][t-1]);               
               }
               		
               	  double lt = cplex.getValue(W[p][t])*itemsToPlan.get(p).getItem().getRouting().getEProcessingTime();
               	  double pl = cplex.getValue(P[p][t])*itemsToPlan.get(p).getItem().getRouting().getEProcessingTime();
               	  
               	  double objectivePerPeriod = cplex.getValue(W[p][t]) * itemsToPlan.get(p).getItem().getHoldingCostsWIP() + 
               	  							  cplex.getValue(I[p][t]) * itemsToPlan.get(p).getItem().getHoldingCosts() + 
               	  							  cplex.getValue(B[p][t]) * itemsToPlan.get(p).getItem().getBacklogCosts() +
               	  							  cplex.getValue(C[t]) * oCosts;  
               	  							  
               	  							  
               	 // traceln(cplex.getValue(W[p][t]) + "*" + itemsToPlan.get(p).getItem().getHoldingCostsWIP() + " = " + cplex.getValue(W[p][t]) * itemsToPlan.get(p).getItem().getHoldingCostsWIP());							               	  
               	 // traceln(cplex.getValue(I[p][t]) + "*" + itemsToPlan.get(p).getItem().getHoldingCosts() + " = "  + cplex.getValue(I[p][t]) * itemsToPlan.get(p).getItem().getHoldingCosts());							               	  
               	 // traceln(cplex.getValue(B[p][t]) + "*" + itemsToPlan.get(p).getItem().getBacklogCosts() + " = " + cplex.getValue(B[p][t]) * itemsToPlan.get(p).getItem().getBacklogCosts());							               	  
               	 // traceln(cplex.getValue(C[t]) + "*" + oCosts + " = " + cplex.getValue(C[t]) * oCosts);							               	  
               	  
               	  int slope2 = -99;
               	  int slope3 = -99;
               	  
               	  if(selectedSegments.size() == 2){
               	  	slope2 = (int)(slopes[1]*lt+intercepts[1]);
               	  }
               	  
              	  if(selectedSegments.size() == 3){
               	  	slope3 = (int)(slopes[2]*lt+intercepts[2]);
               	  }
               	                 	  
               	  int wipForPrintLn = (int)cplex.getValue(W[p][t]);               	                 	                 	  
               	  
                  System.out.println("\t" + itemsToPlan.get(p).getItem().getItem() +
                                     "\t" + (time() + t -1) +
                                     "\t" + t +                                     
                                     "\t" + (int)Math.round(wipForPrintLn) +
                                     "\t" + X[p][t] +
                                     "\t" + (int)Math.round(cplex.getValue(R[p][t])) +                                            
                                     "\t" + cplex.getValue(P[p][t]) +
                                     //"\t" + (int)Math.round(pl) +
                                     //"\t" + (int)Math.round(lt) +                                     
                                     "\t" + cplex.getValue(PL[t]) +      
                                     "\t" + cplex.getValue(L[t])  +
                                     "\t" + maxCapacity + 
                                     "\t" + (int)(slopes[0]*lt+intercepts[0]) + 
                                     "\t" + slope2 + 
                                     "\t" + slope3 +                                      
                                     "\t" + Math.round(cplex.getValue(I[p][t])) +
                                     "\t" + Math.round(inventoryBalance) +
                                     "\t" + (int)Math.round(wipBalance) +
                                     "\t" + (int)Math.round(objectivePerPeriod) +
                                     "\t" + Math.round(cplex.getValue(C[t])) +
                                     "\t" + (int)cplex.getValue(B[p][t]) + 
                                     "\t" + itemsToPlan.get(p).getItem().getRouting().getEProcessingTime() +
                                     "\t" + itemsToPlan.get(p).getItem().getRouting().getESetupTime()  +
                                     "\t" + cplex.getValue(PL[t]) +      
                                     "\t" + cplex.getValue(L[t])  +
                                     "\t" + (int)itemsToPlan.get(p).getItem().getHoldingCosts() +
                                     "\t" + (int)itemsToPlan.get(p).getItem().getHoldingCostsWIP() +
                                     "\t" + (int)itemsToPlan.get(p).getItem().getBacklogCosts() +
                                     "\t" + (int)oCosts                                                                              
                                     );                                                                                                 
            
            		//t_sum_wip[t] += wipForPrintLn;
            		
            		t_sum_x[t] += X[p][t];            		
            		t_sum_wip[t] += (int)cplex.getValue(W[p][t]) ;
            		t_sum_r[t] += (int)Math.round(cplex.getValue(R[p][t]));            		
            		t_sum_p[t] += (int)cplex.getValue(P[p][t]);
            		
            		//if(t==0){
            			t_sum_pl[t] = (int)cplex.getValue(PL[t]);
            			t_sum_l[t] = (int)cplex.getValue(L[t]);
            		//}
            			
            		t_sum_load[t] += lt;
	                                    
			if(OptimizationResult.WRITE_OPTIMIZATION_RESULTS_TO_XLXS){                    
                    OptimizationResult optResult = new OptimizationResult(                                        
                                        
	                   					itemsToPlan.get(p).getItem().getItem(),
	                                     (time() + t -1),
	                                     t,                                     
	                                     (int)Math.round(wipForPrintLn),
	                                     X[p][t],
	                                     Math.round(cplex.getValue(R[p][t])),                                            
	                                     cplex.getValue(P[p][t]),
	                                     cplex.getValue(PL[t]),      
	                                     cplex.getValue(L[t]),
	                                      maxCapacity,
	                                     (int)(slopes[0]*lt+intercepts[0]),
	                                      slope2,
	                                      slope3,                                      
	                                      (int)Math.round(cplex.getValue(I[p][t])),
	                                      (int)Math.round(inventoryBalance),
	                                      (int)Math.round(wipBalance),
	                                      (int)Math.round(objectivePerPeriod),
	                                      cplex.getValue(C[t]),
	                                      (int)cplex.getValue(B[p][t]), 
	                                     (double) itemsToPlan.get(p).getItem().getRouting().getEProcessingTime(),
	                                     (double) itemsToPlan.get(p).getItem().getRouting().getESetupTime(),
	                                     cplex.getValue(PL[t]),      
	                                     cplex.getValue(L[t]),
	                                     (int)itemsToPlan.get(p).getItem().getHoldingCosts(),
	                                     (int)itemsToPlan.get(p).getItem().getHoldingCostsWIP(),
	                                     (int)itemsToPlan.get(p).getItem().getBacklogCosts(),
	                                     (int)oCosts,
	                                     cplex.getValue(Z[p][t])                                                                                                                                                                                                                                                                                                                      
	                    );
                                                            
	                    get_Main().optimizationResults.add(optResult);                                                      
	                 }   
               }                              
            }
            
            System.out.println("\n");
            System.out.println("\tTime\tt\tX\tWip\tR\tP\tPL\tL");           
            for(int t = 0; t < get_Main().simParams.getMRPPlanningHorizon(); t++) {
            
            	System.out.println(
            		"\t" + (time() + t) +
       				"\t" + t +           
       				"\t" + t_sum_x[t] + 		
            		"\t" + t_sum_wip[t] +
            		"\t" + t_sum_r[t] +
            		"\t" + t_sum_p[t] +
	           		"\t" + t_sum_pl[t] +
            		"\t" + t_sum_l[t]            	
            	);            
            }
                 	  
            
            //if(OptimizationResult.WRITE_OPTIMIZATION_RESULTS_TO_XLXS)
			//OptimizationResult.WriteXlsxOptimizationResults(get_Main().optimizationResults, get_Main().simParams);            
            	//traceln("size +++++++++++ " + get_Main().optimizationResults.size());
            
		}else{
			traceln("NO Solution " + cplex.getStatus());
		}															
        	
        	for (int p = 0; p < iQd.size(); p++) {        	        
               for (int t = 1; t < leadtimeHorizon; t++) {   
            				            
            				//traceln("da vor qty " + p + " " + t + " " + RI[p][t].getName());            				            				
					        					        				        
					        if(RI[p][t].getName() != "noRelease"){
					        						        
					        double qty = cplex.getValue(RI[p][t]);    			            			            		            
					        //traceln(qty);
					        //traceln("da for if");				               					        
							if(qty > 0.9){
					        //traceln("da");				               					        
								
								//traceln("qty " + qty + " " + RI[p][t].getName());
								
								
								//if we have a running order, we have to reduce the release qty, as it was only required for the decision of release qty
			                    //but the qty itself is already considered for production.
			                    //traceln("X[" + p + "," + t + "] " + X[p][t] + " qty " + iQd.get(p).getQuantity() + " Running Orders Qty: " + iQd.get(p).getQuantityRunning());	        				        			        		
			                    
			                    String[] RiSplitted = RI[p][t].getName().split("_");
			                    traceln(RI[p][t].getName().split("_"));
			                    
			                    double qtyXt = Double.parseDouble(RiSplitted[3]);
			                    int itemIntTmp = Integer.parseInt(RiSplitted[1]);
			                    int plannedEnd = Integer.parseInt(RiSplitted[2]);
			                    			                    			                    			                    
			                    SpecialObject sp = iQd.stream().filter(e -> e.getItem() == itemIntTmp && e.getDueDate() == plannedEnd).findFirst().get();
			                    
			                    //traceln("X qty " + iQd.get(p).getQuantity() + " Running Orders Qty: " + iQd.get(p).getQuantityRunning() + " item " + iQd.get(p).getItem() + "DD " + iQd.get(p).getDueDate());	        				        			        					                    
			                    traceln("Xqtyn " + qtyXt + " Running Orders Qty: " + sp.getQuantityRunning() + " item " + sp.getItem() + " DD " + sp.getDueDate());
			                    
			                    //double qtyFinal = Math.ceil(iQd.get(p).getQuantity()-iQd.get(p).getQuantityRunning());
			                    double qtyFinal = Math.ceil(qtyXt - sp.getQuantityRunning());
			                    
			                    traceln("Final Qty: " + qtyFinal);
			                    //traceln("Final QtyN: " + qtyFinalN);
			                    if(qtyFinal > 0){
			                    
			                    	
			                    				                    
				                    ProductionOrder order = new ProductionOrder();			                    			                    
				                    
				                    order.setQuantity(qtyFinal);			                    			                    
				                    
				                    traceln("Set Production Order Qty: " + order.getQuantity());
				                    order.setCreatedAt(time());
												                    				                    								
									//int itemIntTmp = iQd.get(p).getItem();
										
				                    //Item item = get_Main().items.stream().filter(e -> e.getItem() == itemIntTmp).findFirst().get();																		                     
				                    Item item = get_Main().items.stream().filter(e -> e.getItem() == itemIntTmp).findFirst().get();																		                     
				                    
				                    order.setOrderId(get_Main().prodOrderId++);
				                    order.setItem(item);
				                                                                                                                                  
									order.setPlannedCapacity(Routing.GetPlannedCapacityPerItem(get_Main().routings, order.getItem(), get_Main().simParams, order));
									
									//order.setPlannedCapacity(Routing.GetPlannedCapacityPerItem(routingList, order.getItem(), simParams, order));
									order.setPlannedSetupTime(Routing.GetPlannedSetupTimePerItem(get_Main().routings, order.getItem(), get_Main().simParams, order));								
				                    
				                    int minimumRoutingStep = Routing.GetMinimumStep(get_Main().routings, order.getItem() , get_Main().simParams);
									int maximumRoutingStep = Routing.GetMaximumStep(get_Main().routings, order.getItem() , get_Main().simParams);
							
									order.setMinimumRoutingStep(minimumRoutingStep);
									order.setMaximumRoutingStep(maximumRoutingStep);			
									order.setCurrentRoutingStep(minimumRoutingStep);                                        			                    			                    
				                                                            
				                    //order.setQuantity(Math.round(iQd.get(p).getQuantity()));
				                    
				                    //traceln("################################## " + iQd.get(p).getQuantity());
				                    				                    				                    				                    
				                    //get the start and end dates from the RI decision variables			                    
				                    
				                    
				                    //order.setPlannedStart(max(Integer.parseInt(RiSplitted[5]) + time() - item.getSafetyLeadTime(), time()));
				                    //order.setPlannedStart(Integer.parseInt(RiSplitted[5] + time());
	
				                    //safety leadtime for stochastic scenario
				                    //order.setPlannedStart(max(Integer.parseInt(RiSplitted[5]) + time() - 1, time()));
				                    
				                   // order.setPlannedStart(max(Integer.parseInt(RiSplitted[5]) + time() - 1, time()));
				                    
				                    //Optimization Starts with 0, so we have to subract -1 from the result to meet the correct MRP Periods
				                    order.setPlannedStart(max(Integer.parseInt(RiSplitted[5]) + time() - 1, time()));
				                    order.setPlannedEnd(Integer.parseInt(RiSplitted[2]) + time() - 1);
				                    
				                    traceln("Planned Start: " + order.getPlannedStart() +  " Planne End:" + order.getPlannedEnd() + " Time " + time());			                    			                            
				                    
				                    long exists = 0;				
				                                   			                    
				                    if(order.getPlannedStart() < time())
				                    	exists = 1;			                    											
					                    if(exists == 0){
					                    	//traceln("Production Order Added");														                    
						                    Routing routingObject = get_Main().routings.stream().filter(e -> e.getItem().getItem() == order.getItem().getItem()).findFirst().get();			
											order.setRouting(routingObject);
											order.setStatus(ProductionOrder.PRODUCTION_ORDER_STATUS_UNPROCESSED);
						                    
						                    get_Main().productionOrders.add(order);	                    						
															                    
					                    }//if
					                }    
		                    	}// if qty	
		                    	}	                    
		                 }//for            
		            }//for
                        
        if(false) {
			traceln("Production Orders from Optmization Before Removing");
			traceln(ProductionOrder.GetCSVHeader());
			
	        for (ProductionOrder order: get_Main().productionOrders) {
	           traceln(ProductionOrder.GetCSVString(order));
	        }        
			
	        //get_Main().productionOrders.removeIf(e -> e.getPlannedStart() > time());
	
	        traceln("Production Orders from Optmization FOR SIMULATION");
	        traceln(ProductionOrder.GetCSVHeader());
	
	        for (ProductionOrder order: get_Main().productionOrders) {
	            traceln(ProductionOrder.GetCSVString(order));
	        }        
	        traceln("**************************");                							
        }
		
		//get_Main().Function_OrderRelease();
		
		cplex.deleteNames();        
    	if(Tools.Log_CF_Optimization_Values){                 
			cplex.exportModel("model/NV/NewModel" + time() + "_" + bomLevel + ".lp");
		}			
		cplex.end();
	}				
	catch (IloException exc) {
         System.err.println("Concert exception '" + exc.getMessage() + "' caught");
         System.exit(-1);
    }
    //catch (ProblemFoundException exc) {
      //   System.err.println("Expection'" + exc.getMessage() + "' caught");
         //System.exit(-1);
    //}
    
return 0;


]]></Body>
				</Function>
				<Function AccessType="default" StaticFunction="false">
					<ReturnModificator>RETURNS_VALUE</ReturnModificator>
					<ReturnType><![CDATA[int]]></ReturnType>
					<Id>1714984232961</Id>
					<Name><![CDATA[Function_ClearingFunction_ACF]]></Name>
					<X>490</X><Y>300</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Parameter>
						<Name><![CDATA[itemsToPlan]]></Name>
						<Type><![CDATA[List<MRP>]]></Type>
					</Parameter>
					<Parameter>
						<Name><![CDATA[bomLevel]]></Name>
						<Type><![CDATA[int]]></Type>
					</Parameter>
					<Parameter>
						<Name><![CDATA[inResource]]></Name>
						<Type><![CDATA[Resource]]></Type>
					</Parameter>
					<Parameter>
						<Name><![CDATA[fileSuffix]]></Name>
						<Type><![CDATA[String]]></Type>
					</Parameter>
					<Body><![CDATA[try{

Tools to = new Tools();
							
traceln("----------- Start ACF OPTIMIZATION incl. Exta Capacity " + time () + " ----------------");
							
StringBuilder output = new StringBuilder();
int fopPeriod = 0;
int maxCapacity = 1440;
traceln("Total found Segments: " + ClearingFunctionSegments.size());			
		
	//via the bom level the cf is associated
	List<ClearingFunctionSegments> selectedSegments = new ArrayList();
	Item firstBomItem = itemsToPlan.get(0).getItem();
	
	if(firstBomItem.getLotsizePolicy().equalsIgnoreCase(Item.LOT_POLICY_FOP)) {
		int fop = firstBomItem.getFOPPeriod();
		fopPeriod = fop;
		traceln("FOP Period:" + fop  + " REsource: " + inResource.getName());	
					
		selectedSegments = ClearingFunctionSegments.stream().filter(e -> e.getLotParameter() == fop &&
							 e.getLotPolicy().equalsIgnoreCase(Item.LOT_POLICY_FOP) && e.getResource().equalsIgnoreCase(inResource.getName()) 
				 && e.getExperiment().equalsIgnoreCase(main.simParams.getExperiment())).collect(Collectors.toList());															 																								
	}
	else if(firstBomItem.getLotsizePolicy().equalsIgnoreCase(Item.LOT_POLICY_FOQ)) {
		int foq = (int)firstBomItem.getFOQQuantity();	
		traceln("FOQ Qty:" + foq);	
					
		selectedSegments = ClearingFunctionSegments.stream().filter(e -> e.getLotParameter() == foq &&
							 e.getLotPolicy().equalsIgnoreCase(Item.LOT_POLICY_FOQ) && e.getResource().equalsIgnoreCase(inResource.getName()) 
				 && e.getExperiment().equalsIgnoreCase(main.simParams.getExperiment())).collect(Collectors.toList());															 																								
	}
				
	traceln("Resource: " + inResource.getName());
	traceln("Resource Stage Number: " + inResource.getStageNumber());
	traceln("Production Stage: " + (bomLevel + 1));
	traceln("Max Capacity: " + maxCapacity);
	
	traceln("Items to Plan: ");
	itemsToPlan.forEach(e -> traceln(e.getItem().getItem() + " eProcessingTime " + e.getItem().getRouting().getEProcessingTime() + ";"));

	traceln("Selected Slopes: ");		
	selectedSegments.forEach(e -> traceln(e.getSlope() + ";"));
	traceln("Selected Intercepts: ");
	
	selectedSegments.forEach(e -> traceln(e.getyIntercept() + ";"));
	
	if(selectedSegments.size() == 0){
		traceln("STOP Simulation: No Segments found!");
		System.exit(0);
	}
	
	to.log("Segment Cnt: " + selectedSegments.size(), Tools.LogCFOptimization);
	
	double intercepts[] = new double[selectedSegments.size()];
	double slopes[] = new double[selectedSegments.size()];
	
	for(int i = 0; i < selectedSegments.size(); i++) {
		slopes[i] = selectedSegments.get(i).getSlope();
		intercepts[i] = selectedSegments.get(i).getyIntercept();
	}		
			
int numberSegments = selectedSegments.size();

double oCosts = 0;
double oFactor = 1000;//1000
double setupTime = 72; //standard = 18
int leadtimeHorizon = main.simParams.getLeadTimeHorizon();

traceln("Leadtime Horizon: " + leadtimeHorizon);

IloCplex cplex = new IloCplex();
	            cplex.setParam(IloCplex.Param.Advance, 0);


     String[][] Inames = new String[itemsToPlan.size()][get_Main().simParams.getMRPPlanningHorizon()];
     String[][] Pnames = new String[itemsToPlan.size()][get_Main().simParams.getMRPPlanningHorizon()];
     String[] PLnames = new String[get_Main().simParams.getMRPPlanningHorizon()];
     String[] Lnames = new String[get_Main().simParams.getMRPPlanningHorizon()];
     String[][] Wnames = new String[itemsToPlan.size()][get_Main().simParams.getMRPPlanningHorizon()];
     String[][] Rnames = new String[itemsToPlan.size()][get_Main().simParams.getMRPPlanningHorizon()];     
     String[][] Bnames = new String[itemsToPlan.size()][get_Main().simParams.getMRPPlanningHorizon()];     
     String[][] Znames = new String[itemsToPlan.size()][get_Main().simParams.getMRPPlanningHorizon()];     
     
     for(int i = 0; i< get_Main().simParams.getMRPPlanningHorizon(); i++){
          for (int p = 0; p < itemsToPlan.size(); p++) {
        	 	Inames[p][i] = "I" + itemsToPlan.get(p).getItem().getItem() + "_" + i; 
        	 	Pnames[p][i] = "P" + itemsToPlan.get(p).getItem().getItem() + "_" + i; 
        	 	Wnames[p][i] = "W" + itemsToPlan.get(p).getItem().getItem() + "_" + i; 
        	 	Rnames[p][i] = "R" + itemsToPlan.get(p).getItem().getItem() + "_" + i; 
        	 	Bnames[p][i] = "B" + itemsToPlan.get(p).getItem().getItem() + "_" + i; 
        	 	PLnames[i] = "PL" + itemsToPlan.get(p).getItem().getItem() + "_" + i;
        	 	Znames[p][i] = "Z" + itemsToPlan.get(p).getItem().getItem() + "_" + i;  
        	 	Lnames[i] = "L" + itemsToPlan.get(p).getItem().getItem() + "_" + i; 
	     }
     }


     IloNumVar[] C = new IloNumVar[main.simParams.getMRPPlanningHorizon()]; 
     for (int t = 0; t < get_Main().simParams.getMRPPlanningHorizon(); t++) {
        C[t] = cplex.numVar(0, Double.MAX_VALUE, "C" + "_" + t); 
     }
     
     IloNumVar[][] I = new IloNumVar[itemsToPlan.size()][];
     for (int p = 0; p < itemsToPlan.size(); p++) {
        I[p] = cplex.numVarArray(get_Main().simParams.getMRPPlanningHorizon(), 0, Double.MAX_VALUE, Inames[p]);
        oCosts += itemsToPlan.get(p).getItem().getHoldingCosts();
     }
     
     oCosts = oFactor*oCosts;
     
     IloNumVar[][] P = new IloNumVar[itemsToPlan.size()][];
     for (int p = 0; p < itemsToPlan.size(); p++) {     
        P[p] = cplex.numVarArray(get_Main().simParams.getMRPPlanningHorizon(), 0,  Double.MAX_VALUE, Pnames[p]);        
     }
     
     IloNumVar[] PL = new IloNumVar[leadtimeHorizon];     
     IloNumVar[] L = new IloNumVar[leadtimeHorizon];     
     
     for (int t = 0; t < leadtimeHorizon; t++) {               
     	PL[t] = cplex.numVar(0,  Double.MAX_VALUE, PLnames[t]);
     	L[t] = cplex.numVar(0,  Double.MAX_VALUE, Lnames[t]);
     }
                    
     IloNumVar[][] W = new IloNumVar[itemsToPlan.size()][];
     for (int p = 0; p < itemsToPlan.size(); p++) {
        W[p] = cplex.numVarArray(get_Main().simParams.getMRPPlanningHorizon(), 0, Double.MAX_VALUE, Wnames[p]);
     }
		
	 IloNumVar[][] R = new IloNumVar[itemsToPlan.size()][];
     for (int p = 0; p < itemsToPlan.size(); p++) {
        R[p] = cplex.numVarArray(get_Main().simParams.getMRPPlanningHorizon(), 0.0, Double.MAX_VALUE, Rnames[p]);
     }          
     
     IloNumVar[][] B = new IloNumVar[itemsToPlan.size()][];
     for (int p = 0; p < itemsToPlan.size(); p++) {
        B[p] = cplex.numVarArray(get_Main().simParams.getMRPPlanningHorizon(), 0.0, Double.MAX_VALUE, Bnames[p]);
     }
     
     IloNumVar[][] Z = new IloNumVar[itemsToPlan.size()][];
     for (int p = 0; p < itemsToPlan.size(); p++) {
        Z[p] = cplex.numVarArray(get_Main().simParams.getMRPPlanningHorizon(), 0.0, Double.MAX_VALUE, Znames[p]);
     }          	
               	
	double[] inventory = new double[itemsToPlan.size()];
	double[] wip = new double[itemsToPlan.size()];
	double[] produce = new double[itemsToPlan.size()];
	double[] tl = new double[itemsToPlan.size()];
		
	int[][] X = new int[itemsToPlan.size()][get_Main().simParams.getMRPPlanningHorizon()];

	List<SpecialObject> iQd = new ArrayList<SpecialObject>();
	List<SpecialObject> runningOrders = new ArrayList<SpecialObject>();
	
     for (int p = 0; p < itemsToPlan.size(); p++) {      	     

     		   inventory[p] = 0;
     		   
     		   	wip[p]=0;
     		   
	        	int tmp_item = itemsToPlan.get(p).getItem().getItem();
				     		
     		   produce[p] = 0;
     		   
     	       for (int t = 0; t < get_Main().simParams.getMRPPlanningHorizon(); t++) {               	                          	               	
	               			               		               		               		               	
	               	int temp_t = t;
	               	int quantityRunningProductionOrders = 0;
	               	int lateOrders = 0;
	               	
	               	MRP mrpItem = null;
	               	
	               	if(t > 0){
		               	mrpItem = get_Main().mrpTable.stream().filter(e -> e.getItem().getItem() == tmp_item
		               	 && e.getTime() == time() && e.getPeriod() == temp_t-1).findFirst().orElseGet(() -> new MRP());
		               	 
		               	 quantityRunningProductionOrders = remainingProductionOrderQty(tmp_item,t + time());
		               	 
		               	 //late Orders must only be computed in period 1 and not the remaining.
		               	 if(t == 1){
		               	 	lateOrders = lateProductionOrdersQty(tmp_item,t + time());						
		               	 }
		               	
		               	 X[p][t] += (int) mrpItem.getPlannedOrderReceipts();
		               	 		               	 
	               	}
															
					if(quantityRunningProductionOrders > 0 || lateOrders > 0){
						traceln("RunningProduction Order Qty: " + quantityRunningProductionOrders + " time: " + time() + " t " + t + " item " + tmp_item);
						traceln("old Xpt: " + X[p][t]);
						
						if(t == 1){
							X[p][1] += (quantityRunningProductionOrders + lateOrders);							
						}else{
							X[p][t] += quantityRunningProductionOrders;
						}															
						
						traceln("new Xpt: " + X[p][t]);
						traceln("Now we have to consider the Remaining Qty for Capacity Consumption of: " + X[p][t]);
						
						SpecialObject runningOrder = new SpecialObject(
	        				mrpItem.getItem().getItem(),
	        				X[p][t], 
	        				t,
	        				quantityRunningProductionOrders + lateOrders);
	        				
	        			runningOrders.add(runningOrder);						
					}
															
					//if(t == 1){						
	        			//X[p][t] += (int) mrpItem.getPlannedOrderReceipts();	        				        			
	        		//}else if(t > 1){	        		
	        		
	        		
	        		//}

	        		if(X[p][t] > 0 && t > 0) {
	        			SpecialObject so = new SpecialObject(
	        				mrpItem.getItem().getItem(),
	        				X[p][t], 
	        				t,
	        				quantityRunningProductionOrders + lateOrders);
	        			iQd.add(so);
	        			traceln("X[" + p + "," + t + "] " + X[p][t] + " " + mrpItem.getItem().getItem());	        				        			        		
	        			
	        			//traceln("~~~~~~~~~~~~~" + so.getItem() + " qty: " + so.getQuantity() + " dd " + so.getDueDate());
	        			
	        		}        		  	        		        		
            }     	      	
     }                                        
     
     //if(iQd.size() == 0){     	
     	//throw new ProblemFoundException("No Planned order Receipts found.");
     //}
     	
               
     String[][] RiNames = new String[iQd.size()][leadtimeHorizon];
     int[][] releaseTmp = new int[iQd.size()][main.simParams.getMRPPlanningHorizon()];
     String[] releaseForX = new String[iQd.size()];

	 // this combinations are constructed .. every time the due date in this case 13, a 0 value is added RI_103_13_106.0_0R103_0
	 
	 //RI_103_13_106.0_0R103_0 + RI_103_13_106.0_0R103_0
       //+ RI_103_13_106.0_0R103_0 + RI_103_13_106.0_1R103_1
       //+ RI_103_13_106.0_2R103_2 + RI_103_13_106.0_3R103_3
       //+ RI_103_13_106.0_4R103_4 + RI_103_13_106.0_5R103_5
       //+ RI_103_13_106.0_6R103_6 + RI_103_13_106.0_7R103_7
       //+ RI_103_13_106.0_8R103_8 + RI_103_13_106.0_9R103_9
       //+ RI_103_13_106.0_10R103_10 + RI_103_13_106.0_11R103_11
       //+ RI_103_13_106.0_12R103_12 + RI_103_13_106.0_13R103_13 
	 
	 //for each Xt > 0 an entry to iQd is added and this represnts all Xts of all planned products!
     for (int p = 0; p < iQd.size(); p++) {
          for(int i = 1; i < leadtimeHorizon; i++){
          		int targetT = (int)(iQd.get(p).getDueDate() - leadtimeHorizon + i + 1);          		
          		
          		if(targetT < 0)
          			targetT = 0; // is 0 as this are values later thaen the due date e.g. 13
          		          		
          		releaseTmp[p][targetT] = i+1;
          		
          		if(targetT > 0){          		          		
        	 		RiNames[p][i] = "RI_" +  iQd.get(p).getItem() + "_" + (int)iQd.get(p).getDueDate() +         	 	
        	 		"_" + iQd.get(p).getQuantity() + "_" + targetT + "R" + iQd.get(p).getItem() + "_" + targetT; 
        	 	}else{
        	 		RiNames[p][i] = "noRelease";// + p + "" + i;
        	 	}        	 	        	 	
        	 	
        	 	//traceln(RiNames[p][i]);
	     }    
     }


	 //for each product we need the individual releases RI.....They are constructed with the above equation.            
	 //traceln("iQd.size " + iQd.size());
     IloNumVar[][] RI = new IloNumVar[iQd.size()][];
     for (int p = 0; p < iQd.size(); p++) {
          	     	
     	//e.g. if we have 8 releases while iqd.size = 8 and this all all the xts, we also need 8 RIs to get an individual decision for each Xt, which must be associated with an Release
     	// in each RiNames the item and due date (item and xt) is coded, consequently this works. 
        RI[p] = cplex.boolVarArray(leadtimeHorizon, RiNames[p]);                
        
     }                                      
            
     	//Objective Function     
		IloLinearNumExpr objFunction  = cplex.linearNumExpr();
	         
        for (int p = 0; p < itemsToPlan.size(); p++) {
           for (int t = 0; t < get_Main().simParams.getMRPPlanningHorizon(); t++) {
              objFunction.addTerm (itemsToPlan.get(p).getItem().getHoldingCosts(), I[p][t]);
            }
         }

        for (int p = 0; p < itemsToPlan.size(); p++) {
           for (int t = 0; t < get_Main().simParams.getMRPPlanningHorizon(); t++) {
             objFunction.addTerm (itemsToPlan.get(p).getItem().getHoldingCostsWIP(), W[p][t]);
            }                     	            
         } 
         
         for (int p = 0; p < itemsToPlan.size(); p++) {
           for (int t = 0; t < get_Main().simParams.getMRPPlanningHorizon(); t++) {
             objFunction.addTerm (itemsToPlan.get(p).getItem().getBacklogCosts(), B[p][t]);
            }                     	            
         } 
         
                  
         for (int t = 0; t < get_Main().simParams.getMRPPlanningHorizon(); t++) {
             objFunction.addTerm (oCosts, C[t]); 
         }                     	                              
                                      
         cplex.addMinimize(objFunction); //objective function
       
         for (int p = 0; p < itemsToPlan.size(); p++) {
           		
         	cplex.addEq(I[p][0],0); //Eq7
         	cplex.addEq(P[p][0],0); //Eq8  Pg,0 must be zero to avoid production in this period. this is not possible.                           
         	//cplex.addEq(W[p][0],0); //Eq7
         	cplex.addEq(R[p][0],0); //Eq9
         	cplex.addEq(W[p][0],0); //Eq10
         
            for (int t = 1; t < get_Main().simParams.getMRPPlanningHorizon(); t++) {
	           	cplex.addEq(cplex.sum(cplex.sum(I[p][t], X[p][t]),B[p][t-1]), 
                       cplex.sum(cplex.sum(I[p][t-1], P[p][t-1]),B[p][t]));
        	}
            
              
            cplex.addEq(W[p][0], R[p][0]);
            
            for (int t = 1; t < get_Main().simParams.getMRPPlanningHorizon(); t++) {
               cplex.addEq(cplex.sum(W[p][t], P[p][t-1]), 
                           cplex.sum(W[p][t-1], R[p][t]));   
                                                                                                                                    
            }			             											
         }
         
         //********************* Sum of RI_t == 1 *************************
         // RI_103_13_106.0_0R103_0 + RI_103_13_106.0_0R103_0 + RI_103_13_106.0_0R103_0 + RI_103_13_106.0_1R103_1  + RI_103_13_106.0_2R103_2 + RI_103_13_106.0_3R103_3  + RI_103_13_106.0_4R103_4 + RI_103_13_106.0_5R103_5 .... = 1       
         // CF Article EQ3 
          List<String> unique = new ArrayList();
          
          for (int p = 0; p < iQd.size(); p++) {
            IloLinearNumExpr num_expr_Sum_Binaries = cplex.linearNumExpr();  
            boolean weHaveRI = false;	           
	            for (int t = 1; t < leadtimeHorizon; t++) {	            	
	            
	            		
	            		if(RI[p][t] != null){
	            		String variableName = RI[p][t].getName();
							           		
		            		if(variableName.contains("RI")){
		            			weHaveRI = true;
		            			num_expr_Sum_Binaries.addTerm(1,RI[p][t]);															
		            		}
		            		
	            		}
	            }
	            	            
	            if(weHaveRI)
	            	cplex.addEq(num_expr_Sum_Binaries,1);
            }
         
         
         //RI structure
         //Eq2 where Rg,t = RIg,t*Xg,t
         //RI_item_Xt_qty_start_lth_...end_lth_Ritem_start_lth...end_lth
         for (int pp = 0; pp < itemsToPlan.size(); pp++) {
         	IloLinearNumExpr cf = cplex.linearNumExpr();				         
	       for (int t = 1; t < main.simParams.getMRPPlanningHorizon()-1; t++) {	            	            
			       	String o = "";
			       	int sizeExpr = 0;
			        IloLinearNumExpr num_expr = cplex.linearNumExpr();
			                    
	                for (int p = 0; p < iQd.size(); p++) {
	                	if(iQd.get(p).getItem()== itemsToPlan.get(pp).getItem().getItem()){
	                	
		            		if(releaseTmp[p][t] > 0){
		            			
		            			o = o + iQd.get(p).getQuantity() + "*" + RI[p][releaseTmp[p][t]-1].getName() +  "+";	            			
		            			num_expr.addTerm(iQd.get(p).getQuantity(),RI[p][releaseTmp[p][t]-1]);
		            					            					            					            			
		            			sizeExpr++;		            					            					            			
		            		}			        
	            		}
					}
					
				if(o.length() > 1){
		            if(sizeExpr > 0){
		            	//Constraint Release Size 
			            cplex.addEq(R[pp][t],num_expr);    
			                  
			        }

				}else{
				         cplex.addEq(R[pp][t],0);          								
				}
																
				num_expr.clear();             														
			}         
         }
                         
		IloLinearNumExpr[] sumRIs = new IloLinearNumExpr[main.simParams.getMRPPlanningHorizon()];
		
		for (int t = 0; t < main.simParams.getMRPPlanningHorizon(); t++) {
		    IloLinearNumExpr sumRIsI = cplex.linearNumExpr();
		
		    for (int pp = 0; pp < itemsToPlan.size(); pp++) {
		        for (int p = 0; p < iQd.size(); p++) {
		            if (iQd.get(p).getItem() == itemsToPlan.get(pp).getItem().getItem()) {
		                if (releaseTmp[p][t] > 0) {
		                	//traceln("###### " + 1.0 + " :::: " +  RI[p][releaseTmp[p][t] - 1]);		                
		                    sumRIsI.addTerm(1.0, RI[p][releaseTmp[p][t] - 1]);		                    
		                }
		            }
		        }
		    }
		    
		    sumRIs[t] = sumRIsI;		    		    		    
		    //sumRIsI.clear();
		}				
		             
            
//Constraint avoiding that RI with later due date, releases order earlier that RI with earlier due date (orders should not overteak each other)
//The release of order 2 should not before order 1                                         
// ********************************* Guarantee Release ORDER  ****************************************
// ***************************************************************************************************            
//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
// Constraint avoiding that RI with later due date, releases order earlier that
// RI with earlier due date (orders should not overteak each other) The release
// of order 2 should not before order 1

traceln("iQd size " + iQd.size());

List<SpecialObject> iQdSorted = iQd;
if(main.simParams.getROFormulation() == 1){
	Collections.sort(iQdSorted, Comparator.comparing(SpecialObject::getDueDate).thenComparing(SpecialObject::getItem));
	//Collections.sort(iQdSorted, Comparator.comparing(SpecialObject::getItem).thenComparing(SpecialObject::getDueDate));
	
	traceln("IQd sorted:");
	for(SpecialObject o : iQdSorted){
		traceln(o.getDueDate()  + " " + o.getItem() + " " + o.getQuantity());						
	}
	
	for(int i = 0; i < iQdSorted.size() -1; i++){
	//now take the first succesor:
			SpecialObject currentiQd = iQdSorted.get(i);		
			SpecialObject succesoriQd = iQdSorted.get(i+1);
			
			if(currentiQd.getDueDate() <= succesoriQd.getDueDate() && currentiQd.getDueDate() > 1){
							
				int overlappingStart = max((int)succesoriQd.getDueDate() - leadtimeHorizon,0);
				// for the overlapping time we have to generate the RI comparisions:			
				IloLinearNumExpr lhs = cplex.linearNumExpr();
		        IloLinearNumExpr rhs = cplex.linearNumExpr();
	
	            int overlappingPeriods = (int)currentiQd.getDueDate() - overlappingStart;
				
				int RIstartIndex =  max(0, (leadtimeHorizon - overlappingPeriods));                                            
	
	            StringBuilder lhsOut = new StringBuilder();
	            StringBuilder rhsOut = new StringBuilder();
	                          
	            int multiplier = 0;                             
	            
	            for (int o = 0; o < overlappingPeriods; o++) {
					
					IloNumVar found = Function_FindeRIVarialbe(iQdSorted.size(), RI, currentiQd.getItem(), (int)currentiQd.getDueDate(), o+1, (int)currentiQd.getQuantity());
					
					IloNumVar foundSuccessor = Function_FindeRIVarialbe(iQdSorted.size(), RI, succesoriQd.getItem(), (int)succesoriQd.getDueDate(), o+1, (int)succesoriQd.getQuantity());
					
	                if (found.getName().contains("RI")) {
	                
	                	lhs.addTerm(multiplier + 1, found);
	                	lhsOut.append(multiplier + 1 + " " + found.getName()  + " + ");
	                	
	                	rhs.addTerm(multiplier + 1, foundSuccessor);
	                	rhsOut.append(multiplier + 1 + " " + foundSuccessor.getName() + " + ");
	                	                
	                	multiplier++;
	                }
	            }
	            
	            
	            for (int o = 0; o < succesoriQd.getDueDate() - overlappingPeriods; o++) {
													
					IloNumVar foundSuccessor = Function_FindeRIVarialbe(iQdSorted.size(), RI, succesoriQd.getItem(), (int)succesoriQd.getDueDate(), overlappingPeriods + o + 1, (int)succesoriQd.getQuantity());								
					
	                if (foundSuccessor.getName().contains("RI")) {                                
	                	
	                	rhs.addTerm(multiplier + 1, foundSuccessor);
	                	rhsOut.append(multiplier + 1 + " " + foundSuccessor.getName() + " + ");
	                	                
	                	multiplier++;
	                }
	            }
	            
	            
	            cplex.addLe(lhs, rhs);
	
	         traceln("Overlapping:");
	         traceln(lhsOut.toString() + "<=");
	         traceln(rhsOut.toString());             						
			
			}													
	}
}// END - if guaranteee release order         
//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~            
//--- Reha ALCF
         if(main.simParams.getALCFormulation() == 1){
			IloLinearNumExpr ziSum;
			  for (int t = 1; t < get_Main().simParams.getMRPPlanningHorizon(); t++) {          
			    ziSum = cplex.linearNumExpr(); // Create a new expression for each item p            	   
				for (int p = 0; p < itemsToPlan.size(); p++) {  
			        ziSum.addTerm(1, Z[p][t]); // Correct the order of parameters, should be (coefficient, variable)
			    }
			    cplex.addEq(ziSum, 1); // Add the constraint Z_i_t = 1 for each p  
      		            	
			} 	      	         	         	         	         	         	         	         	
          }//if true
         //****************** CF SECTION ***************************************
         //*********************************************************************
       	
         for (int t = 0; t < main.simParams.getMRPPlanningHorizon(); t++) {	                 	        	    
    	    //Pgt smaller Wgt - Constraint for single item qty
    	    //zgt = cplex.linearNumExpr();
    	    IloLinearNumExpr cf3 = cplex.linearNumExpr();				             	    
			IloLinearNumExpr cf4 = cplex.linearNumExpr();
			IloLinearNumExpr cf = cplex.linearNumExpr();				             	    
			IloLinearNumExpr cf1 = cplex.linearNumExpr();  //LHS			             	    
			IloLinearNumExpr cf2 = cplex.linearNumExpr(); //RHS		
        	 for (int pp = 0; pp < itemsToPlan.size(); pp++) {  
		             	    

        	       	  			
					//merk dir, dass die weiter unten verwendet werden
					//double setupProption = 18.0/106.0;
					double setupProption = 0;
					
	         		cf.addTerm(itemsToPlan.get(pp).getItem().getRouting().getEProcessingTime()+setupProption,P[pp][t]);	         		
	         		
	         		if(get_Main().simParams.getCFSegments() > 0){	         		

	         			cf1.addTerm(itemsToPlan.get(pp).getItem().getRouting().getEProcessingTime()+setupProption,P[pp][t]); 	         		        		
         				cf2.addTerm(itemsToPlan.get(pp).getItem().getRouting().getEProcessingTime()+setupProption,W[pp][t]);         			         		        			         					        			         			
         			}
         			
         			cf3.addTerm(itemsToPlan.get(pp).getItem().getRouting().getEProcessingTime()+setupProption,P[pp][t]);         		
         			cf4.addTerm(itemsToPlan.get(pp).getItem().getRouting().getEProcessingTime()+setupProption,W[pp][t]);
         			
         			
         			//***************** Ppt, <= Wp,t ***********************        			         		         			
         			//cplex.addLe(
         			//	cplex.sum(P[pp][t],0),//LHS         			
        			//	cplex.sum(W[pp][t],0));//RHS         			
        			//****************************************
        			
       				//represent CF as k*x + d -> 
					  if(get_Main().simParams.getCFSegments() == 0){
					  	numberSegments = 0;			  	
					  }
        			
        			//****************************************
					//traceln("Number Segments: " + numberSegments);
					for (int i = 0; i < numberSegments; i++) {
					    //traceln("Setuptime: " + setupTime);
					    //slopes[i] = 1;
					    //intercepts[i] = 0.1;
					    // cplex.addLe defines a constraint with a left-hand side (LHS) and right-hand side (RHS)
					   // traceln("slolpe: -> " + slopes[i]);
					    //traceln("intercept: -> " + intercepts[i]);
					    if(i == numberSegments - 1 ){
					    
							cplex.addLe(
					        	cplex.sum(cf1,cplex.prod(setupTime, sumRIs[t])), // LHS
					        	cplex.sum(
					            	cplex.sum(
					                	cplex.prod(Math.max(slopes[i], 0), cplex.sum(cf2, cplex.prod(setupTime, sumRIs[t]))),
					                	cplex.prod(Z[pp][t],intercepts[i])),C[t])					            
					         // RHS
					    ,"CF segment " + i);
					    
					    }else{
					    
						cplex.addLe(
					        cplex.sum(cf1, cplex.prod(setupTime, sumRIs[t])), // LHS
					        cplex.sum(
					            cplex.sum(
					                cplex.prod(Math.max(slopes[i], 0), cplex.sum(cf2, cplex.prod(setupTime, sumRIs[t]))),
					                cplex.prod(intercepts[i], Z[pp][t])
					            ),
					            0
					        ) // RHS
					    ,"CF segment " + i);
					    
					    }//else
					    
					    //traceln("Slope (x): " + slopes[i] + " Y-intercept (d): " + intercepts[i]);
					}
        			//*****************************************
		       
    	  			
        	            	         	  
         	  
         	  // **************** PL und Lt ausgeben *********************
         	  //keine constraints werden spter so auch nicht wiedervendet
         	  //cplex.addEq(PL[t],cf);
         	  //cplex.addEq(L[t],cf2);


			  //cplex.addEq(PL[t],0);
         	  //cplex.addEq(L[t],0);



         	  //*********************************************************       	           	           	           	  
         	  
         	  /******** PLt <=MC+Ct (Eq14) ************/
         	  //This is also the reason why in the .lp file the maximum capacity is not available for t=0
         	  //if(t==0){         	           	           	           	  
         	  	//	cplex.addLe(cf,         	  
         	  		//cplex.sum(0,C[t]));	//RHS
         	  	//}else{         	  	
         	  		//cplex.addLe(cplex.sum(cf,cplex.prod(setupTime,sumRIs[t])),         	  
         	  		//cplex.sum(maxCapacity,C[t]));	//RHS
         	  	//}
         	           	           	           	  		         	           	           	        	  			           	  
         	  /******************************* PLt <= Lt + Ct (Eq18) *********************/
         	  //Constraint Pl musst be smaller as SL for all t         	           	           	  
         	  //cplex.addLe(
         	  	//cplex.sum(cf3,cplex.prod(setupTime,sumRIs[t])), //LHS         	  
	         	//cplex.sum(cplex.sum(cf4,cplex.prod(setupTime,sumRIs[t])),C[t]));         	  	         		         		         		         	         		         	
	          //***************************************************************************
         	  
		           	 cf3 = cplex.linearNumExpr();				             	    
			 		 cf4 = cplex.linearNumExpr();
					 cf = cplex.linearNumExpr();				             	    
			     	 cf1 = cplex.linearNumExpr();  //LHS			             	    
			       	 cf2 = cplex.linearNumExpr(); //RHS		 			         		         				
        				        				        				        			        			        				
        	  }//for (int pp = 0; pp < itemsToPlan.size(); pp++) {    
         }


			// Create a two-dimensional array of IloNumVars
            int numRows = iQd.size(); // Assuming iQd is a list or array
                        
            // ... Initialize and populate the RI array with IloNumVars ...

            // Find the variable by name in the RI array
            traceln("iQd size: " + iQd.size());
            String targetVariableName = "noRelease";
            boolean isVariableFound = false;
            IloNumVar foundVariable = null;

            for (int i = 0; i < numRows; i++) {
                for (int j = 1; j < RI[i].length-1; j++) {
                    IloNumVar var = RI[i][j];
                    if (var.getName().equals(targetVariableName)) {
                        isVariableFound = true;
                        foundVariable = var;
                        break;
                    }
                }
                if (isVariableFound) {
                    break;
                }
            }
            
            if (isVariableFound) {
                // Add a constraint to enforce the found variable to be zero
                traceln("Yes found set no release to 0");                
                foundVariable.setName("noRelease");                                
                cplex.addEq(foundVariable, 0);
            }
            
            //All Entries represent Running Orders. So the associated
            //RI_...1 must be set to one
            
                                    
            int numberOpenOrders = runningOrders.size();
            for(SpecialObject o : runningOrders){
            	traceln(o.getItem() + " " + o.getQuantity() + " " + o.getQuantityRunning());
            }
            
            
            traceln("Count Running Orders: " + numberOpenOrders);
            traceln("RI length: " + RI.length);
            if(iQd.size() > 0){
            for (int i = 0; i < iQd.size(); i++) {
            	isVariableFound = false;            	
            	if(iQd.get(i).getQuantityRunning() > 0){
            		traceln("search " + iQd.get(i).getItem() + " " + iQd.get(i).getDueDate() + " " + iQd.get(i).getQuantity() + " " + iQd.get(i).getQuantityRunning());
	            	for(int a=0; a < iQd.size(); a++){
	            	for (int j = 1; j < RI[a].length; j++) {
	            	
	            		//"RI_103_13_106.0_0R103_0"
	            					                                		
	            	    String[] RiSplitted = RI[a][j].getName().split("_");
				        //traceln(RI[a][j].getName().split("_"));
	                    
	                    IloNumVar var = RI[a][j];
	                    
	                    if(!var.getName().equals("noRelease")){
	                    	
	                    	targetVariableName = "RI_" + iQd.get(i).getItem() + "_" + (int) iQd.get(i).getDueDate() + "_" + 
	                    	iQd.get(i).getQuantity() + "_1" + "R" +  iQd.get(i).getItem() + "_1";
	                    
	                    	//traceln("Running Order Target Name ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~: " + targetVariableName);
	                    
		                    if (var.getName().equals(targetVariableName)) {
		                        isVariableFound = true;
		                        foundVariable = var;
		                        break;
		                    }//if
		                 }//if
	                }//for
	                
	                if(isVariableFound){
	                	break;
	                }
	                
	               }//for                         
				}//if
				                
                if (isVariableFound) {	                	                	                
	                cplex.addEq(foundVariable, 1);
	                traceln("Release Variable found " + foundVariable.getName() + " set to 1");
	                isVariableFound = false;
            	}
            }//for
            }//if
                                                               
    
    //cplex.deleteNames();
    
    //if(time() == 0)
    if(Tools.Log_CF_Optimization_Values){                 
		cplex.exportModel("model/NewModel_" + time() + "_" + bomLevel + "_" + firstBomItem.getItem() +".lp");
	}	
	//cplex.writeSolution("model/NewModel_" + time() + "_" + bomLevel + ".sol");

	//cplex.setParam(IloCplex.BooleanParam.PreInd, true);
	//0.05 were to hard ... 0.1 before	
	//cplex.setParam(IloCplex.Param.MIP.Tolerances.MIPGap, 0.1);
	//cplex.setParam(IloCplex.IntParam.DataCheck, 2);	
	cplex.setParam(IloCplex.IntParam.WorkMem, 2000);
	cplex.setParam(IloCplex.Param.Threads, 4);
	

	if(cplex.solve() && Tools.Log_CF_Optimization_Values){
		    
    		//DecimalFormat f = new DecimalFormat("##.00");
		    
		    System.out.println("Solution status: " + cplex.getStatus());
            System.out.println();
            System.out.println("Objective Value = " + cplex.getObjValue());
          
            System.out.println("Pieces: Wip, X, Release, P");
            System.out.println("Minutes: PL L, MC, CF1, CF2, CF3");
            String header = "\tp\tTime\tt\tWip\tX\tRelease\tP\tPL\tL\tMC\tCF1\tCF2\tCF3\tInv\tIBl\tWB\tObjPP\tCt\tBt\tPTime\tSTime\tICo\tWCo\tBco\tCo\tZt\tMachine";
          	System.out.println(header);
          	
            int[] t_sum_wip = new int[get_Main().simParams.getMRPPlanningHorizon()];
            int[] t_sum_pl = new int[get_Main().simParams.getMRPPlanningHorizon()];
            int[] t_sum_l = new int[get_Main().simParams.getMRPPlanningHorizon()];
            int[] t_sum_load = new int[get_Main().simParams.getMRPPlanningHorizon()];
            int[] t_sum_x = new int[get_Main().simParams.getMRPPlanningHorizon()];
            int[] t_sum_r = new int[get_Main().simParams.getMRPPlanningHorizon()];
            double[] t_sum_p = new double[get_Main().simParams.getMRPPlanningHorizon()];
            double[] t_sum_z = new double[get_Main().simParams.getMRPPlanningHorizon()];
          	
            for (int p = 0; p < itemsToPlan.size(); p++) {
               for (int t = 0; t < get_Main().simParams.getMRPPlanningHorizon(); t++) {
                        	
               double inventoryBalance = 0;
               double wipBalance = 0;

               if(t>0){
                  inventoryBalance = cplex.getValue(I[p][t-1])-X[p][t]+cplex.getValue(P[p][t-1]) - cplex.getValue(B[p][t-1]) + cplex.getValue(B[p][t]);
                  wipBalance = cplex.getValue(W[p][t-1])+cplex.getValue(R[p][t])-cplex.getValue(P[p][t-1]);               
               }
               		
               	  double lt = 0;
               	  double pl = 0;
               	  
               	  for (int ps = 0; ps < itemsToPlan.size(); ps++) {
               	  	lt += cplex.getValue(W[ps][t])*itemsToPlan.get(ps).getItem().getRouting().getEProcessingTime();
               	  	pl += cplex.getValue(P[ps][t])*itemsToPlan.get(ps).getItem().getRouting().getEProcessingTime();               	                 	  
               	  }
               	  
               	  
               	  double objectivePerPeriod = cplex.getValue(W[p][t]) * itemsToPlan.get(p).getItem().getHoldingCostsWIP() + 
               	  							  cplex.getValue(I[p][t]) * itemsToPlan.get(p).getItem().getHoldingCosts() + 
               	  							  cplex.getValue(B[p][t]) * itemsToPlan.get(p).getItem().getBacklogCosts() +
               	  							  cplex.getValue(C[t]) * oCosts;  
               	  							  						               	  
               	  int slope2 = -99;
               	  int slope3 = -99;
               	  
               	  if(selectedSegments.size() == 2){
               	  	slope2 = (int)(slopes[1]*lt+intercepts[1]);
               	  }
               	  
              	  if(selectedSegments.size() == 3){
              	    slope2 = (int)(slopes[1]*lt+intercepts[1]);
               	  	slope3 = (int)(slopes[2]*lt+intercepts[2]);
               	  }
               	                 	  
               	  int wipForPrintLn = (int)cplex.getValue(W[p][t]);  
               	  
               	  boolean zPt_Exists = true;// OptimizationResult.checkVariableExists(cplex, "Z["+p+"]["+t+"]"); 
         	                 	                 	  
               	  double zPTValue = OptimizationResult.getValueOrDefault(cplex, Z, p, t, 0.0);
               	  
               	  String dataOutput ="\t" + itemsToPlan.get(p).getItem().getItem() +
                                     "\t" + (time() + t -1) +
                                     "\t" + t +                                     
                                     "\t" + (int)Math.round(wipForPrintLn) +
                                     "\t" + X[p][t] +
                                     "\t" + (int)Math.round(cplex.getValue(R[p][t])) +                                            
                                     "\t" + cplex.getValue(P[p][t]) +                                  
                                     "\t" + pl +//cplex.getValue(PL[t]),      
	                                 "\t" + lt +//cplex.getValue(L[t]),
                                     "\t" + maxCapacity + 
                                     "\t" + (int)(slopes[0]*lt+intercepts[0]) + 
                                     "\t" + slope2 + 
                                     "\t" + slope3 +                                      
                                     "\t" + Math.round(cplex.getValue(I[p][t])) +
                                     "\t" + Math.round(inventoryBalance) +
                                     "\t" + (int)Math.round(wipBalance) +
                                     "\t" + (int)Math.round(objectivePerPeriod) +
                                     "\t" + Math.round(cplex.getValue(C[t])) +
                                     "\t" + (int)cplex.getValue(B[p][t]) + 
                                     "\t" + itemsToPlan.get(p).getItem().getRouting().getEProcessingTime() +
                                     "\t" + itemsToPlan.get(p).getItem().getRouting().getESetupTime()  +
                                     "\t" + (int)itemsToPlan.get(p).getItem().getHoldingCosts() +
                                     "\t" + (int)itemsToPlan.get(p).getItem().getHoldingCostsWIP() +
                                     "\t" + (int)itemsToPlan.get(p).getItem().getBacklogCosts() +
                                     "\t" + (int)oCosts +
                                     "\t" + zPTValue + 
                                     "\t" + inResource.getName()
                                                                                                                
                                     ;                                                                                                 
            		System.out.println(dataOutput);
            		
					if(OptimizationResult.OPTIMIZATION_RESULT_FOR_PERIOD == time() && 
            			(itemsToPlan.get(p).getItem().getItem() >= 100 ||
            			itemsToPlan.get(p).getItem().getItem() <= 131)
            		) {
            		
            		    Set<String> excludeColumns = new HashSet<>();
        				excludeColumns.add("Time");
            		
						ExcelWriter excelWriter = new ExcelWriter();
						excelWriter.writeOutputToExcel(header, dataOutput,
						OptimizationResult.OPTIMIZATION_RESULTS_FOR_PERIOD_EXCEL_FOLDER + "\\ACF_vs_RO " 
						+ main.optimizationParameters.getVersion() + ".xlsx",
						"ACF FOP=" + fopPeriod,
						excludeColumns);
            		}
            		
            		t_sum_x[t] += X[p][t];            		
            		t_sum_wip[t] += (int)cplex.getValue(W[p][t]) ;
            		t_sum_r[t] += (int)Math.round(cplex.getValue(R[p][t]));            		
            		t_sum_p[t] += cplex.getValue(P[p][t]);
            		t_sum_z[t] += zPTValue;          			
            		t_sum_pl[t] = (int)pl;
            		t_sum_l[t] = (int)lt;       			
            		t_sum_load[t] += lt;
	                                    
			if(OptimizationResult.WRITE_OPTIMIZATION_RESULTS_TO_XLXS){                    
                    OptimizationResult optResult = new OptimizationResult(                                        
                                        
	                   					itemsToPlan.get(p).getItem().getItem(),
	                                     (time() + t -1),
	                                     t,                                     
	                                     (int)Math.round(wipForPrintLn),
	                                     X[p][t],
	                                     Math.round(cplex.getValue(R[p][t])),                                            
	                                     cplex.getValue(P[p][t]),
	                                     pl,//cplex.getValue(PL[t]),      
	                                     lt,//cplex.getValue(L[t]),
	                                      maxCapacity,
	                                     (int)(slopes[0]*lt+intercepts[0]),
	                                      slope2,
	                                      slope3,                                      
	                                      (int)Math.round(cplex.getValue(I[p][t])),
	                                      (int)Math.round(inventoryBalance),
	                                      (int)Math.round(wipBalance),
	                                      (int)Math.round(objectivePerPeriod),
	                                      cplex.getValue(C[t]),
	                                      (int)cplex.getValue(B[p][t]), 
	                                     (double) itemsToPlan.get(p).getItem().getRouting().getEProcessingTime(),
	                                     (double) itemsToPlan.get(p).getItem().getRouting().getESetupTime(),
	                                     pl,//cplex.getValue(PL[t]),      
	                                     lt,//cplex.getValue(L[t]),
	                                     (int)itemsToPlan.get(p).getItem().getHoldingCosts(),
	                                     (int)itemsToPlan.get(p).getItem().getHoldingCostsWIP(),
	                                     (int)itemsToPlan.get(p).getItem().getBacklogCosts(),
	                                     (int)oCosts,
	                                     zPTValue                                                                                                                                                           
	                    );
                                                            
	                    get_Main().optimizationResults.add(optResult);                                                      
	                 }   
               }                              
            }
            
            System.out.println("\n");
            System.out.println("\tTime\tt\tX\tWip\tR\tP\tPL\tL\tZ");           
            for(int t = 0; t < get_Main().simParams.getMRPPlanningHorizon(); t++) {
            
            	System.out.println(
            		"\t" + (time() + t) +
       				"\t" + t +           
       				"\t" + t_sum_x[t] + 		
            		"\t" + t_sum_wip[t] +
            		"\t" + t_sum_r[t] +
            		"\t" + t_sum_p[t] +
	           		"\t" + t_sum_pl[t] +
            		"\t" + t_sum_l[t] +
            		"\t" + t_sum_z[t]            		           	
            	);            
            }
                 	  
            
            //if(OptimizationResult.WRITE_OPTIMIZATION_RESULTS_TO_XLXS)
			//OptimizationResult.WriteXlsxOptimizationResults(get_Main().optimizationResults, get_Main().simParams);            
            	//traceln("size +++++++++++ " + get_Main().optimizationResults.size());
            
		}else{
			traceln("NO Solution " + cplex.getStatus());
		}															
        	
        	for (int p = 0; p < iQd.size(); p++) {        	        
               for (int t = 1; t < leadtimeHorizon; t++) {   
            				            
            				//traceln("da vor qty " + p + " " + t + " " + RI[p][t].getName());            				            				
					        					        				        
					        if(RI[p][t].getName() != "noRelease"){
					        						        
					        double qty = cplex.getValue(RI[p][t]);    			            			            		            
					        //traceln(qty);
					        //traceln("da for if");				               					        
							if(qty > 0.9){
					        //traceln("da");				               					        
								
								//traceln("qty " + qty + " " + RI[p][t].getName());
								
								
								//if we have a running order, we have to reduce the release qty, as it was only required for the decision of release qty
			                    //but the qty itself is already considered for production.
			                    //traceln("X[" + p + "," + t + "] " + X[p][t] + " qty " + iQd.get(p).getQuantity() + " Running Orders Qty: " + iQd.get(p).getQuantityRunning());	        				        			        		
			                    
			                    String[] RiSplitted = RI[p][t].getName().split("_");
			                    //traceln(RI[p][t].getName().split("_"));
			                    
			                    double qtyXt = Double.parseDouble(RiSplitted[3]);
			                    int itemIntTmp = Integer.parseInt(RiSplitted[1]);
			                    int plannedEnd = Integer.parseInt(RiSplitted[2]);
			                    			                    			                    			                    
			                    SpecialObject sp = iQd.stream().filter(e -> e.getItem() == itemIntTmp && e.getDueDate() == plannedEnd).findFirst().get();
			                    
			                    //traceln("X qty " + iQd.get(p).getQuantity() + " Running Orders Qty: " + iQd.get(p).getQuantityRunning() + " item " + iQd.get(p).getItem() + "DD " + iQd.get(p).getDueDate());	        				        			        					                    
			                   // traceln("Xqtyn " + qtyXt + " Running Orders Qty: " + sp.getQuantityRunning() + " item " + sp.getItem() + " DD " + sp.getDueDate());
			                    
			                    //double qtyFinal = Math.ceil(iQd.get(p).getQuantity()-iQd.get(p).getQuantityRunning());
			                    double qtyFinal = Math.ceil(qtyXt - sp.getQuantityRunning());
			                    
			                    //traceln("Final Qty: " + qtyFinal);
			                    //traceln("Final QtyN: " + qtyFinalN);
			                    if(qtyFinal > 0){
			                    
			                    	
			                    				                    
				                    ProductionOrder order = new ProductionOrder();			                    			                    
				                    
				                    order.setQuantity(qtyFinal);			                    			                    
				                    
				                   // traceln("Set Production Order Qty: " + order.getQuantity());
				                    order.setCreatedAt(time());
												                    				                    								
									//int itemIntTmp = iQd.get(p).getItem();
										
				                    //Item item = get_Main().items.stream().filter(e -> e.getItem() == itemIntTmp).findFirst().get();																		                     
				                    Item item = get_Main().items.stream().filter(e -> e.getItem() == itemIntTmp).findFirst().get();																		                     
				                    
				                    order.setOrderId(get_Main().prodOrderId++);
				                    order.setItem(item);
				                                                                                                                                  
									order.setPlannedCapacity(Routing.GetPlannedCapacityPerItem(get_Main().routings, order.getItem(), get_Main().simParams, order));
									
									//order.setPlannedCapacity(Routing.GetPlannedCapacityPerItem(routingList, order.getItem(), simParams, order));
									order.setPlannedSetupTime(Routing.GetPlannedSetupTimePerItem(get_Main().routings, order.getItem(), get_Main().simParams, order));								
				                    
				                    int minimumRoutingStep = Routing.GetMinimumStep(get_Main().routings, order.getItem() , get_Main().simParams);
									int maximumRoutingStep = Routing.GetMaximumStep(get_Main().routings, order.getItem() , get_Main().simParams);
							
									order.setMinimumRoutingStep(minimumRoutingStep);
									order.setMaximumRoutingStep(maximumRoutingStep);			
									order.setCurrentRoutingStep(minimumRoutingStep);                                        			                    			                    
				                                                            
				                    //order.setQuantity(Math.round(iQd.get(p).getQuantity()));
				                    
				                    //traceln("################################## " + iQd.get(p).getQuantity());
				                    				                    				                    				                    
				                    //get the start and end dates from the RI decision variables			                    
				                    
				                    
				                    //order.setPlannedStart(max(Integer.parseInt(RiSplitted[5]) + time() - item.getSafetyLeadTime(), time()));
				                    //order.setPlannedStart(Integer.parseInt(RiSplitted[5] + time());
	
				                    //safety leadtime for stochastic scenario
				                    //order.setPlannedStart(max(Integer.parseInt(RiSplitted[5]) + time() - 1, time()));
				                    
				                   // order.setPlannedStart(max(Integer.parseInt(RiSplitted[5]) + time() - 1, time()));
				                    
				                    //Optimization Starts with 0, so we have to subract -1 from the result to meet the correct MRP Periods
				                    order.setPlannedStart(max(Integer.parseInt(RiSplitted[5]) + time() - 1, time()));
				                    order.setPlannedEnd(Integer.parseInt(RiSplitted[2]) + time() - 1);
				                    
				                   // traceln("Planned Start: " + order.getPlannedStart() +  " Planne End:" + order.getPlannedEnd() + " Time " + time());			                    			                            
				                    
				                    long exists = 0;				
				                                   			                    
				                    if(order.getPlannedStart() < time())
				                    	exists = 1;			                    											
					                    if(exists == 0){
					                    	//traceln("Production Order Added");														                    
						                    Routing routingObject = get_Main().routings.stream().filter(e -> e.getItem().getItem() == order.getItem().getItem()).findFirst().get();			
											order.setRouting(routingObject);
											order.setStatus(ProductionOrder.PRODUCTION_ORDER_STATUS_UNPROCESSED);
						                    
						                    get_Main().productionOrders.add(order);	                    						
															                    
					                    }//if
					                }    
		                    	}// if qty	
		                    	}	                    
		                 }//for            
		            }//for
                        
        if(true) {
			traceln("Production Orders from Optmization Before Removing");
			traceln(ProductionOrder.GetCSVHeader());
			
	        for (ProductionOrder order: get_Main().productionOrders) {
	           traceln(ProductionOrder.GetCSVString(order));
	        }        
			
	        //get_Main().productionOrders.removeIf(e -> e.getPlannedStart() > time());
	
	        //traceln("Production Orders from Optmization FOR SIMULATION");
	        //traceln(ProductionOrder.GetCSVHeader());
	
	        //for (ProductionOrder order: get_Main().productionOrders) {
	           // traceln(ProductionOrder.GetCSVString(order));
	        //}        
	        traceln("**************************");                							
        }
		
		//get_Main().Function_OrderRelease();
		
		cplex.deleteNames();        
    	if(Tools.Log_CF_Optimization_Values){                 
			cplex.exportModel("model/NV/NewModel" + time() + "_" + bomLevel + ".lp");
		}			
		cplex.end();
	}				
	catch (IloException exc) {
         System.err.println("Concert exception '" + exc.getMessage() + "' caught");
         System.exit(-1);
    }
    //catch (ProblemFoundException exc) {
      //   System.err.println("Expection'" + exc.getMessage() + "' caught");
         //System.exit(-1);
    //}
    
return 0;


]]></Body>
				</Function>
				<Function AccessType="default" StaticFunction="false">
					<ReturnModificator>RETURNS_VALUE</ReturnModificator>
					<ReturnType><![CDATA[int]]></ReturnType>
					<Id>1714984462109</Id>
					<Name><![CDATA[Function_ClearingFunction_ACF_before_Reha_Feedback]]></Name>
					<X>490</X><Y>160</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Parameter>
						<Name><![CDATA[itemsToPlan]]></Name>
						<Type><![CDATA[List<MRP>]]></Type>
					</Parameter>
					<Parameter>
						<Name><![CDATA[bomLevel]]></Name>
						<Type><![CDATA[int]]></Type>
					</Parameter>
					<Parameter>
						<Name><![CDATA[inResource]]></Name>
						<Type><![CDATA[Resource]]></Type>
					</Parameter>
					<Parameter>
						<Name><![CDATA[fileSuffix]]></Name>
						<Type><![CDATA[String]]></Type>
					</Parameter>
					<Body><![CDATA[try{

Tools to = new Tools();
							
traceln("----------- Start CF ALC Without Ct at " + time () + " ----------------");
							
StringBuilder output = new StringBuilder();

int maxCapacity = 1440;
//double wipCosts = 0;
//double inventoryHoldingCosts = 0;
traceln("Total found Segments: " + ClearingFunctionSegments.size());


/*
Iterator<MRP> iterator = itemsToPlan.iterator();
while (iterator.hasNext()) {
    MRP o = iterator.next();
    if (o.getItem().getItem() == 103 ||     
    o.getItem().getItem() == 111 ||
    o.getItem().getItem() == 115 ||
    o.getItem().getItem() == 119 ||
    o.getItem().getItem() == 123 ||
    o.getItem().getItem() == 127 ||
    o.getItem().getItem() == 131
    ) {
        iterator.remove(); // Safely remove the element from the list
    }
}
*/

	//via the bom level the cf is associated
	List<ClearingFunctionSegments> selectedSegments = new ArrayList();
	Item firstBomItem = itemsToPlan.get(0).getItem();
	//wipCosts = firstBomItem.getHoldingCostsWIP();
	//inventoryHoldingCosts = firstBomItem.getHoldingCosts();	
	
	//Routing firstRoutingItem = main.routings.stream().filter(e -> e.getItem().getItem() == firstBomItem.getItem()).findFirst().get();	
	//Resource firstResource= main.resources.stream().filter(e -> e.getName().equalsIgnoreCase(firstRoutingItem.getResource())).findFirst().get();
	
	//maxCapacity = inResource.getCapacity();
	//don't map it to the prodction stage 1-4, select the values based on the resource
	traceln("Total found segments: " + selectedSegments);
	
	if(firstBomItem.getLotsizePolicy().equalsIgnoreCase(Item.LOT_POLICY_FOP)) {
		int fop = firstBomItem.getFOPPeriod();	
		traceln("FOP Period:" + fop);	
					
		selectedSegments = ClearingFunctionSegments.stream().filter(e -> e.getLotParameter() == fop &&
							 e.getLotPolicy().equalsIgnoreCase(Item.LOT_POLICY_FOP) && e.getResource().equalsIgnoreCase(inResource.getName()) 
				 && e.getExperiment().equalsIgnoreCase(main.simParams.getExperiment())).collect(Collectors.toList());															 																								
	}
	else if(firstBomItem.getLotsizePolicy().equalsIgnoreCase(Item.LOT_POLICY_FOQ)) {
		int foq = (int)firstBomItem.getFOQQuantity();	
		traceln("FOQ Qty:" + foq);	
					
		selectedSegments = ClearingFunctionSegments.stream().filter(e -> e.getLotParameter() == foq &&
							 e.getLotPolicy().equalsIgnoreCase(Item.LOT_POLICY_FOQ) && e.getResource().equalsIgnoreCase(inResource.getName()) 
				 && e.getExperiment().equalsIgnoreCase(main.simParams.getExperiment())).collect(Collectors.toList());															 																								
	}
				
	traceln("Resource: " + inResource.getName());
	traceln("Resource Stage Number: " + inResource.getStageNumber());
	traceln("Production Stage: " + (bomLevel + 1));
	traceln("Max Capacity: " + maxCapacity);
	
	traceln("Items to Plan: ");
	itemsToPlan.forEach(e -> traceln(e.getItem().getItem() + " eProcessingTime " + e.getItem().getRouting().getEProcessingTime() + ";"));

	traceln("Selected Slopes: ");		
	selectedSegments.forEach(e -> traceln(e.getSlope() + ";"));
	traceln("Selected Intercepts: ");
	
	selectedSegments.forEach(e -> traceln(e.getyIntercept() + ";"));
	
	if(selectedSegments.size() == 0){
		traceln("STOP Simulation: No Segments found!");
		System.exit(0);
	}
	
	to.log("Segment Cnt: " + selectedSegments.size(), Tools.LogCFOptimization);
	
	double intercepts[] = new double[selectedSegments.size()];
	double slopes[] = new double[selectedSegments.size()];
	
	for(int i = 0; i < selectedSegments.size(); i++) {
		slopes[i] = selectedSegments.get(i).getSlope();
		intercepts[i] = selectedSegments.get(i).getyIntercept();
	}		
			
int numberSegments = selectedSegments.size();

//double oCosts = 0;
//double oFactor = 0;//1000
double setupTime = 18; //standard = 18
int leadtimeHorizon = main.simParams.getLeadTimeHorizon();


traceln("Leadtime Horizon: " + leadtimeHorizon);

IloCplex cplex = new IloCplex();

     String[][] Inames = new String[itemsToPlan.size()][get_Main().simParams.getMRPPlanningHorizon()];
     String[][] Pnames = new String[itemsToPlan.size()][get_Main().simParams.getMRPPlanningHorizon()];
     String[] PLnames = new String[get_Main().simParams.getMRPPlanningHorizon()];
     String[] Lnames = new String[get_Main().simParams.getMRPPlanningHorizon()];
     String[][] Wnames = new String[itemsToPlan.size()][get_Main().simParams.getMRPPlanningHorizon()];
     String[][] Rnames = new String[itemsToPlan.size()][get_Main().simParams.getMRPPlanningHorizon()];     
     String[][] Bnames = new String[itemsToPlan.size()][get_Main().simParams.getMRPPlanningHorizon()];     
     String[][] Znames = new String[itemsToPlan.size()][get_Main().simParams.getMRPPlanningHorizon()];     
     
     
     for(int i = 0; i< get_Main().simParams.getMRPPlanningHorizon(); i++){
          for (int p = 0; p < itemsToPlan.size(); p++) {
        	 	Inames[p][i] = "I" + itemsToPlan.get(p).getItem().getItem() + "_" + i; 
        	 	Pnames[p][i] = "P" + itemsToPlan.get(p).getItem().getItem() + "_" + i; 
        	 	Wnames[p][i] = "W" + itemsToPlan.get(p).getItem().getItem() + "_" + i; 
        	 	Rnames[p][i] = "R" + itemsToPlan.get(p).getItem().getItem() + "_" + i; 
        	 	Bnames[p][i] = "B" + itemsToPlan.get(p).getItem().getItem() + "_" + i; 
        	 	PLnames[i] = "PL" + itemsToPlan.get(p).getItem().getItem() + "_" + i; 
        	 	Lnames[i] = "L" + itemsToPlan.get(p).getItem().getItem() + "_" + i;
	    	 	Znames[p][i] = "Z" + itemsToPlan.get(p).getItem().getItem() + "_" + i;  
        	 	 
	     }
     }


  //   IloNumVar[] C = new IloNumVar[main.simParams.getMRPPlanningHorizon()]; cweg
     for (int t = 0; t < get_Main().simParams.getMRPPlanningHorizon(); t++) {
//        C[t] = cplex.numVar(0, Double.MAX_VALUE, "C" + "_" + t); cweg
     }
     
     IloNumVar[][] I = new IloNumVar[itemsToPlan.size()][];
     for (int p = 0; p < itemsToPlan.size(); p++) {
        I[p] = cplex.numVarArray(get_Main().simParams.getMRPPlanningHorizon(), 0, Double.MAX_VALUE, Inames[p]);
        //oCosts += itemsToPlan.get(p).getItem().getHoldingCosts();
     }
     
     //oCosts = oFactor*oCosts;
     
     IloNumVar[][] P = new IloNumVar[itemsToPlan.size()][];
     for (int p = 0; p < itemsToPlan.size(); p++) {     
        P[p] = cplex.numVarArray(get_Main().simParams.getMRPPlanningHorizon(), 0,  Double.MAX_VALUE, Pnames[p]);        
     }
     
     IloNumVar[] PL = new IloNumVar[leadtimeHorizon];     
     IloNumVar[] L = new IloNumVar[leadtimeHorizon];     
     
     for (int t = 0; t < leadtimeHorizon; t++) {               
     	PL[t] = cplex.numVar(0,  Double.MAX_VALUE, PLnames[t]);
     	L[t] = cplex.numVar(0,  Double.MAX_VALUE, Lnames[t]);
     }
     
                    
     IloNumVar[][] W = new IloNumVar[itemsToPlan.size()][];
     for (int p = 0; p < itemsToPlan.size(); p++) {
        W[p] = cplex.numVarArray(get_Main().simParams.getMRPPlanningHorizon(), 0, Double.MAX_VALUE, Wnames[p]);
     }
		
	 IloNumVar[][] R = new IloNumVar[itemsToPlan.size()][];
     for (int p = 0; p < itemsToPlan.size(); p++) {
        R[p] = cplex.numVarArray(get_Main().simParams.getMRPPlanningHorizon(), 0.0, Double.MAX_VALUE, Rnames[p]);
     }          
     
     //IloNumVar[][] B = new IloNumVar[itemsToPlan.size()][];
     for (int p = 0; p < itemsToPlan.size(); p++) {
        //B[p] = cplex.numVarArray(get_Main().simParams.getMRPPlanningHorizon(), 0.0, Double.MAX_VALUE, Bnames[p]);
     }
     
     IloNumVar[][] Z = new IloNumVar[itemsToPlan.size()][];
     for (int p = 0; p < itemsToPlan.size(); p++) {
        Z[p] = cplex.numVarArray(get_Main().simParams.getMRPPlanningHorizon(), 0, Double.MAX_VALUE, Znames[p]);
     }    
               	
	double[] inventory = new double[itemsToPlan.size()];
	double[] wip = new double[itemsToPlan.size()];
	double[] produce = new double[itemsToPlan.size()];
	double[] tl = new double[itemsToPlan.size()];
		
	int[][] X = new int[itemsToPlan.size()][get_Main().simParams.getMRPPlanningHorizon()];

	List<SpecialObject> iQd = new ArrayList<SpecialObject>();
	List<SpecialObject> runningOrders = new ArrayList<SpecialObject>();
	
     for (int p = 0; p < itemsToPlan.size(); p++) {      	     

     		   inventory[p] = 0;
     		   
     		   //wip[p] = (int)ProductionOrder.GetCurrentWip(get_Main().productionOrders, itemsToPlan.get(p).getItem(), get_Main().simParams);
     		   	wip[p]=0;
     		   
	        	int tmp_item = itemsToPlan.get(p).getItem().getItem();
				     		
     		   produce[p] = 0;
     		   
     		   //tl[p] = itemsToPlan.get(p).getItem().getTransportLotSize();
     	       for (int t = 0; t < get_Main().simParams.getMRPPlanningHorizon(); t++) {               	                          	               	
	               			               		               		               		               	
	               	//int tmp_item = itemsToPlan.get(p).getItem().getItem();
	               	int temp_t = t;
	               	int quantityRunningProductionOrders = 0;
	               	int lateOrders = 0;
	               	
	               	MRP mrpItem = null;
	               	
	               	if(t > 0){
		               	mrpItem = get_Main().mrpTable.stream().filter(e -> e.getItem().getItem() == tmp_item
		               	 && e.getTime() == time() && e.getPeriod() == temp_t-1).findFirst().orElseGet(() -> new MRP());
		               	 
		               	 //traceln("T for running Orders: " + t);
		               	 quantityRunningProductionOrders = remainingProductionOrderQty(tmp_item,t + time());
		               	 
		               	 //late Orders must only be computed in period 1 and not the remaining.
		               	 if(t == 1){
		               	 	lateOrders = lateProductionOrdersQty(tmp_item,t + time());						
		               	 }
		               	 
		               	 //traceln("t " + t + " PlannedOrderReceipts " + (int) mrpItem.getPlannedOrderReceipts()); 
		               	 
		               	 X[p][t] += (int) mrpItem.getPlannedOrderReceipts();
		               	 		               	 
		               	//mrpItem.setPlannedOrderReceipts(mrpItem.getPeriod() + 50);
		               	//traceln("MRP Item for Optimization");
		               	//traceln(MRP.GetCSVHeader());
		               	//traceln(MRP.GetCSVString(mrpItem));
	               	}
															
					if(quantityRunningProductionOrders > 0 || lateOrders > 0){
						traceln("RunningProduction Order Qty: " + quantityRunningProductionOrders + " time: " + time() + " t " + t + " item " + tmp_item);
						traceln("old Xpt: " + X[p][t]);
						
						if(t == 1){
							X[p][1] += (quantityRunningProductionOrders + lateOrders);							
						}else{
							X[p][t] += quantityRunningProductionOrders;
						}															
						
						traceln("new Xpt: " + X[p][t]);
						traceln("Now we have to consider the Remaining Qty for Capacity Consumption of: " + X[p][t]);
						
						SpecialObject runningOrder = new SpecialObject(
	        				mrpItem.getItem().getItem(),
	        				X[p][t], 
	        				t,
	        				quantityRunningProductionOrders + lateOrders);
	        				
	        			runningOrders.add(runningOrder);						
					}
															
					//if(t == 1){						
	        			//X[p][t] += (int) mrpItem.getPlannedOrderReceipts();	        				        			
	        		//}else if(t > 1){	        		
	        		
	        		
	        		//}

	        		if(X[p][t] > 0 && t > 0) {
	        			SpecialObject so = new SpecialObject(
	        				mrpItem.getItem().getItem(),
	        				X[p][t], 
	        				t,
	        				quantityRunningProductionOrders + lateOrders);
	        			iQd.add(so);
	        			traceln("X[" + p + "," + t + "] " + X[p][t] + " " + mrpItem.getItem().getItem());	        				        			        		
	        			
	        			//traceln("~~~~~~~~~~~~~" + so.getItem() + " qty: " + so.getQuantity() + " dd " + so.getDueDate());
	        			
	        		}        		  	        		        		
            }     	      	
     }                                        
     
     //if(iQd.size() == 0){     	
     	//throw new ProblemFoundException("No Planned order Receipts found.");
     //}
     	
               
     String[][] RiNames = new String[iQd.size()][leadtimeHorizon];
     int[][] releaseTmp = new int[iQd.size()][main.simParams.getMRPPlanningHorizon()];
     String[] releaseForX = new String[iQd.size()];

	 // this combinations are constructed .. every time the due date in this case 13, a 0 value is added RI_103_13_106.0_0R103_0
	 
	 //RI_103_13_106.0_0R103_0 + RI_103_13_106.0_0R103_0
       //+ RI_103_13_106.0_0R103_0 + RI_103_13_106.0_1R103_1
       //+ RI_103_13_106.0_2R103_2 + RI_103_13_106.0_3R103_3
       //+ RI_103_13_106.0_4R103_4 + RI_103_13_106.0_5R103_5
       //+ RI_103_13_106.0_6R103_6 + RI_103_13_106.0_7R103_7
       //+ RI_103_13_106.0_8R103_8 + RI_103_13_106.0_9R103_9
       //+ RI_103_13_106.0_10R103_10 + RI_103_13_106.0_11R103_11
       //+ RI_103_13_106.0_12R103_12 + RI_103_13_106.0_13R103_13 
	 
	 //for each Xt > 0 an entry to iQd is added and this represnts all Xts of all planned products!
     for (int p = 0; p < iQd.size(); p++) {
          for(int i = 1; i < leadtimeHorizon; i++){
          		int targetT = (int)(iQd.get(p).getDueDate() - leadtimeHorizon + i + 1);          		
          		
          		if(targetT < 0)
          			targetT = 0; // is 0 as this are values later thaen the due date e.g. 13
          		          		
          		releaseTmp[p][targetT] = i+1;
          		
          		if(targetT > 0){          		          		
        	 		RiNames[p][i] = "RI_" +  iQd.get(p).getItem() + "_" + (int)iQd.get(p).getDueDate() +         	 	
        	 		"_" + iQd.get(p).getQuantity() + "_" + targetT + "R" + iQd.get(p).getItem() + "_" + targetT; 
        	 	}else{
        	 		RiNames[p][i] = "noRelease";// + p + "" + i;
        	 	}        	 	        	 	
        	 	
        	 	//traceln(RiNames[p][i]);
	     }    
     }


	 //for each product we need the individual releases RI.....They are constructed with the above equation.            
	 //traceln("iQd.size " + iQd.size());
     IloNumVar[][] RI = new IloNumVar[iQd.size()][];
     for (int p = 0; p < iQd.size(); p++) {
          	     	
     	//e.g. if we have 8 releases while iqd.size = 8 and this all all the xts, we also need 8 RIs to get an individual decision for each Xt, which must be associated with an Release
     	// in each RiNames the item and due date (item and xt) is coded, consequently this works. 
        RI[p] = cplex.boolVarArray(leadtimeHorizon, RiNames[p]);                
        
     }                                      
            
     	//Objective Function     
		IloLinearNumExpr objFunction  = cplex.linearNumExpr();
	    
	     for (int p = 0; p < itemsToPlan.size(); p++) {
           for (int t = 0; t < get_Main().simParams.getMRPPlanningHorizon(); t++) {
             	objFunction.addTerm (itemsToPlan.get(p).getItem().getHoldingCosts(), R[p][t]);
            }                     	            
         }  
         
         for (int p = 0; p < itemsToPlan.size(); p++) {
           for (int t = 0; t < get_Main().simParams.getMRPPlanningHorizon(); t++) {
             objFunction.addTerm (itemsToPlan.get(p).getItem().getHoldingCosts(), P[p][t]);
            }                     	            
         } 
	    
	         
        for (int p = 0; p < itemsToPlan.size(); p++) {
           for (int t = 0; t < get_Main().simParams.getMRPPlanningHorizon(); t++) {
              objFunction.addTerm (itemsToPlan.get(p).getItem().getHoldingCosts(), I[p][t]);
            }
         }

        for (int p = 0; p < itemsToPlan.size(); p++) {
           for (int t = 0; t < get_Main().simParams.getMRPPlanningHorizon(); t++) {
             objFunction.addTerm (itemsToPlan.get(p).getItem().getHoldingCostsWIP(), W[p][t]);
            }                     	            
         } 
         
         for (int p = 0; p < itemsToPlan.size(); p++) {
           for (int t = 0; t < get_Main().simParams.getMRPPlanningHorizon(); t++) {
             //objFunction.addTerm (itemsToPlan.get(p).getItem().getBacklogCosts(), B[p][t]);
            }                     	            
         }
         
                  
         for (int t = 0; t < get_Main().simParams.getMRPPlanningHorizon(); t++) {
             //objFunction.addTerm (oCosts, C[t]); cweg
         }                     	                              
                                      
         cplex.addMinimize(objFunction); //objective function
       
         for (int p = 0; p < itemsToPlan.size(); p++) {
           		
         	cplex.addEq(I[p][0],0); //Eq7
         	cplex.addEq(P[p][0],0); //Eq8  Pg,0 must be zero to avoid production in this period. this is not possible.                           
         	//cplex.addEq(W[p][0],0); //Eq7
         	cplex.addEq(R[p][0],0); //Eq9
         	cplex.addEq(W[p][0],0); //Eq10
         
            for (int t = 1; t < get_Main().simParams.getMRPPlanningHorizon(); t++) {
	           	cplex.addEq(cplex.sum(I[p][t], X[p][t]),
	           				cplex.sum(I[p][t-1], P[p][t-1])
	           	);				                                              
        	}
            
              
            cplex.addEq(W[p][0], R[p][0]);
            
            for (int t = 1; t < get_Main().simParams.getMRPPlanningHorizon(); t++) {
               cplex.addEq(cplex.sum(W[p][t], P[p][t-1]), 
                           cplex.sum(W[p][t-1], R[p][t]));   
                                                                                                                                    
            }			             											
         }

if(false){         
         //********************* Sum of RI_t == 1 *************************
         // RI_103_13_106.0_0R103_0 + RI_103_13_106.0_0R103_0 + RI_103_13_106.0_0R103_0 + RI_103_13_106.0_1R103_1  + RI_103_13_106.0_2R103_2 + RI_103_13_106.0_3R103_3  + RI_103_13_106.0_4R103_4 + RI_103_13_106.0_5R103_5 .... = 1       
         // CF Article EQ3 
          List<String> unique = new ArrayList();
          
          for (int p = 0; p < iQd.size(); p++) {
            IloLinearNumExpr num_expr_Sum_Binaries = cplex.linearNumExpr();  
            boolean weHaveRI = false;	           
	            for (int t = 1; t < leadtimeHorizon; t++) {	            	
	            	
	            	//int tmp_p = p;
	            	//int tmp_t = t;
	            	//traceln("test auf " + RI[tmp_p][tmp_t].getName());
	            	
	            	//boolean exists = unique.stream().filter(element -> element != null).anyMatch(element -> element.equals(RI[tmp_p][tmp_t].getName()));
	            	            	
	            	//if(!exists) {
	            		//unique.add(RI[tmp_p][tmp_t].getName());
	            		//traceln("p" + p + " t " + t );
	            		
	            		if(RI[p][t] != null){
	            		//traceln("ri not null");
	            		String variableName = RI[p][t].getName();
	            		//char isItRI = "RI";
	            		//traceln("Found variable " + variableName);
	            		
							           		
		            		if(variableName.contains("RI")){
		            			weHaveRI = true;
		            			num_expr_Sum_Binaries.addTerm(1,RI[p][t]);															
		            		}
		            		
	            		}
	            		
	            		
	            		//traceln("add" + RI[tmp_p][tmp_t].getName());
	            	//}else{
	            		//num_expr_Sum_Binaries.addTerm(0,RI[p][t]);															
	            	//}					
	            }
	            	            
	            if(weHaveRI)
	            	cplex.addEq(num_expr_Sum_Binaries,1);
            }
         
         //RI structure
         //Eq2 where Rg,t = RIg,t*Xg,t
         //RI_item_Xt_qty_start_lth_...end_lth_Ritem_start_lth...end_lth
         for (int pp = 0; pp < itemsToPlan.size(); pp++) {
         	IloLinearNumExpr cf = cplex.linearNumExpr();				         
	       for (int t = 1; t < main.simParams.getMRPPlanningHorizon()-1; t++) {	            	            
			       	String o = "";
			       	int sizeExpr = 0;
			        IloLinearNumExpr num_expr = cplex.linearNumExpr();
			                    
	                for (int p = 0; p < iQd.size(); p++) {
	                	if(iQd.get(p).getItem()== itemsToPlan.get(pp).getItem().getItem()){
	                	
		            		if(releaseTmp[p][t] > 0){
		            			
		            			o = o + iQd.get(p).getQuantity() + "*" + RI[p][releaseTmp[p][t]-1].getName() +  "+";	            			
		            			num_expr.addTerm(iQd.get(p).getQuantity(),RI[p][releaseTmp[p][t]-1]);
		            					            					            					            			
		            			sizeExpr++;		            					            					            			
		            		}			        
	            		}
					}
					
				if(o.length() > 1){
		            if(sizeExpr > 0){
		            	//Constraint Release Size 
			            cplex.addEq(R[pp][t],num_expr);    
			                  
			        }

				}else{
				         cplex.addEq(R[pp][t],0);          								
				}
																
				num_expr.clear();             														
			}         
         }
                         
		IloLinearNumExpr[] sumRIs = new IloLinearNumExpr[main.simParams.getMRPPlanningHorizon()];
		
		for (int t = 0; t < main.simParams.getMRPPlanningHorizon(); t++) {
		    IloLinearNumExpr sumRIsI = cplex.linearNumExpr();
		
		    for (int pp = 0; pp < itemsToPlan.size(); pp++) {
		        for (int p = 0; p < iQd.size(); p++) {
		            if (iQd.get(p).getItem() == itemsToPlan.get(pp).getItem().getItem()) {
		                if (releaseTmp[p][t] > 0) {
		                	//traceln("###### " + 1.0 + " :::: " +  RI[p][releaseTmp[p][t] - 1]);		                
		                    sumRIsI.addTerm(1.0, RI[p][releaseTmp[p][t] - 1]);		                    
		                }
		            }
		        }
		    }
		    
		    sumRIs[t] = sumRIsI;		    		    		    
		    //sumRIsI.clear();
		}				
		             


}//if true(false)            
//Constraint avoiding that RI with later due date, releases order earlier that RI with earlier due date (orders should not overteak each other)
//The release of order 2 should not before order 1                                         
// ********************************* Guarantee Release ORDER  ****************************************
// ***************************************************************************************************            
//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
// Constraint avoiding that RI with later due date, releases order earlier that
// RI with earlier due date (orders should not overteak each other) The release
// of order 2 should not before order 1

//daher

if(false){
traceln("iQd size " + iQd.size());

List<SpecialObject> iQdSorted = iQd;

Collections.sort(iQdSorted, Comparator.comparing(SpecialObject::getDueDate).thenComparing(SpecialObject::getItem));
//Collections.sort(iQdSorted, Comparator.comparing(SpecialObject::getItem).thenComparing(SpecialObject::getDueDate));

traceln("IQd sorted:");
for(SpecialObject o : iQdSorted){
	traceln(o.getDueDate()  + " " + o.getItem() + " " + o.getQuantity());						
}

for(int i = 0; i < iQdSorted.size() -1; i++){
//now take the first succesor:
		SpecialObject currentiQd = iQdSorted.get(i);		
		SpecialObject succesoriQd = iQdSorted.get(i+1);
		
		if(currentiQd.getDueDate() <= succesoriQd.getDueDate() && currentiQd.getDueDate() > 1){
						
			int overlappingStart = max((int)succesoriQd.getDueDate() - leadtimeHorizon,0);
			//traceln("overlapping start" + (int)succesoriQd.getDueDate()  + " -" + leadtimeHorizon + "=" + overlappingStart);
			// for the overlapping time we have to generate the RI comparisions:			
			IloLinearNumExpr lhs = cplex.linearNumExpr();
	        IloLinearNumExpr rhs = cplex.linearNumExpr();

             // traceln("Start Index " + RIstartIndex);
            int overlappingPeriods = (int)currentiQd.getDueDate() - overlappingStart;
			
			int RIstartIndex =  max(0, (leadtimeHorizon - overlappingPeriods));                                            

            StringBuilder lhsOut = new StringBuilder();
            StringBuilder rhsOut = new StringBuilder();
                          
            int multiplier = 0;                   
            //traceln("Overlapping Periods " + overlappingPeriods);
            //traceln("Overlapping Start "  + overlappingStart);            
            
            for (int o = 0; o < overlappingPeriods; o++) {
				
				IloNumVar found = Function_FindeRIVarialbe(iQdSorted.size(), RI, currentiQd.getItem(), (int)currentiQd.getDueDate(), o+1, (int)currentiQd.getQuantity());
				
				IloNumVar foundSuccessor = Function_FindeRIVarialbe(iQdSorted.size(), RI, succesoriQd.getItem(), (int)succesoriQd.getDueDate(), o+1, (int)succesoriQd.getQuantity());
				
                //if (RI[p][RIstartIndex + o].getName().contains("RI")) {
                //traceln("found" + found.getName());
                if (found.getName().contains("RI")) {
                
                	lhs.addTerm(multiplier + 1, found);
                	lhsOut.append(multiplier + 1 + " " + found.getName()  + " + ");
                	
                	rhs.addTerm(multiplier + 1, foundSuccessor);
                	rhsOut.append(multiplier + 1 + " " + foundSuccessor.getName() + " + ");
                	                
                	multiplier++;
                }
            }
            
            //for the remaining periods we have to extend the rhs:
            
            
            for (int o = 0; o < succesoriQd.getDueDate() - overlappingPeriods; o++) {
												
				IloNumVar foundSuccessor = Function_FindeRIVarialbe(iQdSorted.size(), RI, succesoriQd.getItem(), (int)succesoriQd.getDueDate(), overlappingPeriods + o + 1, (int)succesoriQd.getQuantity());								
				
                //if (RI[p][RIstartIndex + o].getName().contains("RI")) {
                //traceln("found" + found.getName());
                if (foundSuccessor.getName().contains("RI")) {                                
                	
                	rhs.addTerm(multiplier + 1, foundSuccessor);
                	rhsOut.append(multiplier + 1 + " " + foundSuccessor.getName() + " + ");
                	                
                	multiplier++;
                }
            }
            
            
            cplex.addLe(lhs, rhs);

         traceln("Overlapping:");
         traceln(lhsOut.toString() + "<=");
         traceln(rhsOut.toString());             						
		
		}													
	}
}// if false         
//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~            
                                                                                                
if(false) {            
         //****************** CF SECTION ***************************************
         //*********************************************************************
         
         for (int t = 0; t < main.simParams.getMRPPlanningHorizon(); t++) {	    
         
	     	IloLinearNumExpr cf = cplex.linearNumExpr();				             	    
	     	IloLinearNumExpr cf1 = cplex.linearNumExpr();				             	    
	       	IloLinearNumExpr cf2 = cplex.linearNumExpr();				             	    
		   	IloLinearNumExpr cf3 = cplex.linearNumExpr();				             	    
	       	IloLinearNumExpr cf4 = cplex.linearNumExpr();				             	    

    	    
    	    //Pgt smaller Wgt - Constraint for single item qty
        	 for (int pp = 0; pp < itemsToPlan.size(); pp++) {        	  			
					//merk dir, dass die weiter unten verwendet werden
					//double setupProption = 18.0/106.0;
					double setupProption = 0;
					
	         		cf.addTerm(itemsToPlan.get(pp).getItem().getRouting().getEProcessingTime()+setupProption,P[pp][t]);	         		
	         		
	         		cf1.addTerm(itemsToPlan.get(pp).getItem().getRouting().getEProcessingTime()+setupProption,P[pp][t]); 	         		        		
         			cf2.addTerm(itemsToPlan.get(pp).getItem().getRouting().getEProcessingTime()+setupProption,W[pp][t]);         			         		        			         			
         			
         			cf3.addTerm(itemsToPlan.get(pp).getItem().getRouting().getEProcessingTime()+setupProption,P[pp][t]);         		
         			cf4.addTerm(itemsToPlan.get(pp).getItem().getRouting().getEProcessingTime()+setupProption,W[pp][t]);
         			
         			
         			//***************** Ppt, <= Wp,t ***********************        			         		         			
         			cplex.addLe(
         				//cplex.sum(P[pp][t],cplex.prod(0,sumRIs[t])),//LHS         			
         				cplex.sum(P[pp][t],0),//LHS         			
        				cplex.sum(W[pp][t],0));//RHS         			
        			//****************************************        			         		         				
        				        				        				        			        			        				
        	  }
        	          	  
			  //CF Constraints			           	  
			  //PL <= MC + Ct (Eq12)			  
			  //traceln("setup time " + setupTime + " sum ri " + sumRIs);
         	  //cplex.addLe(cplex.sum(cf,cplex.prod(setupTime,sumRIs)), //LHS         	  
         	  
         	  
         	  // **************** PL und L ausgeben *********************
         	  //keine constraints werden spter so auch nicht wiedervendet
         	  cplex.addEq(PL[t],cf);
         	  cplex.addEq(L[t],cf2);
         	  //********************************************************* 
         	  
         	  
         	  //cplex.addEq(PL[t],cplex.sum(cf,cplex.prod(setupTime,sumRIs)));
         	  //cplex.addEq(L[t],cplex.sum(cf2,cplex.prod(setupTime,sumRIs)));         	           	           	           	  
         	  
         	  /******** PLt <=MC+Ct (Eq14) ************/
         	  /*
         	  if(t==0){         	           	           	           	  
         	  		cplex.addLe(cf,0);	//RHS
         	  	}else{
         	  		//cplex.addLe(cf,         	  		
         	  		//traceln("da" + sumRIs[t].toString());
         	  		cplex.addLe(cplex.sum(cf,cplex.prod(setupTime,sumRIs[t])),         	  
         	  		maxCapacity);	//RHS
         	  	}
         	   */        	           	           	  		         	           	           	  
         	           	           	  
         	  // ---- we have three segments         	           	           	  
			  //CF partition 2 from numerical example
			  //traceln("# segments " + numberSegments);
			  //represent CF as k*x + d -> 
			  for(int i = 0; i < numberSegments; i++){
	         	  //cplex.addLe(
    	     	  	//cplex.sum(cf1,cplex.prod(setupTime,sumRIs[t])), //LHS				
				
         	  		//cplex.sum(cplex.sum(cplex.prod(max(slopes[i],0),         	  	         	  	
         	  		
         	  		//cplex.sum(cf2,cplex.prod(setupTime,sumRIs[t]))),intercepts[i]),0));//RHS         	  		         	  						
         	  	
         	  		traceln("Slope (x): " + slopes[i] + " Y-intercept (d) " + intercepts[i]);
         	  		         	  		
         	  	//traceln("sumRIs " + sumRIs + " st " + setupTime);	
         	  }//for
         	           	           	           	  
         	           	           	           	  			           	  
         	  /******************************* PLt <= Lt + Ct (Eq18) *********************/
         	  //Constraint Pl musst be smaller as SL for all t         	           	  
         	  //cplex.addLe(
         	  	//cplex.sum(cf3,cplex.prod(setupTime,sumRIs[t])), //LHS         	  
	         	//cplex.sum(cplex.sum(cf4,cplex.prod(setupTime,sumRIs[t])),0));         	  	         	
	          //***************************************************************************
         	  
			  cf.clear();
			  cf1.clear();
 			  cf2.clear();
 			  cf3.clear();
 			  cf4.clear();
         }



			// Create a two-dimensional array of IloNumVars
            int numRows = iQd.size(); // Assuming iQd is a list or array
                        
            // ... Initialize and populate the RI array with IloNumVars ...

            // Find the variable by name in the RI array
            traceln("iQd size: " + iQd.size());
            String targetVariableName = "noRelease";
            boolean isVariableFound = false;
            IloNumVar foundVariable = null;

            for (int i = 0; i < numRows; i++) {
                for (int j = 1; j < RI[i].length-1; j++) {
                    IloNumVar var = RI[i][j];
                    if (var.getName().equals(targetVariableName)) {
                        isVariableFound = true;
                        foundVariable = var;
                        break;
                    }
                }
                if (isVariableFound) {
                    break;
                }
            }
            
            if (isVariableFound) {
                // Add a constraint to enforce the found variable to be zero
                traceln("Yes found set no release to 0");                
                foundVariable.setName("noRelease");                                
                cplex.addEq(foundVariable, 0);
            }
            
            //All Entries represent Running Orders. So the associated
            //RI_...1 must be set to one
            
                                    
            int numberOpenOrders = runningOrders.size();
            for(SpecialObject o : runningOrders){
            	traceln(o.getItem() + " " + o.getQuantity() + " " + o.getQuantityRunning());
            }
            
            
            traceln("Count Running Orders: " + numberOpenOrders);
            traceln("RI length: " + RI.length);
            if(iQd.size() > 0){
            for (int i = 0; i < iQd.size(); i++) {
            	isVariableFound = false;            	
            	if(iQd.get(i).getQuantityRunning() > 0){
            		traceln("search " + iQd.get(i).getItem() + " " + iQd.get(i).getDueDate() + " " + iQd.get(i).getQuantity() + " " + iQd.get(i).getQuantityRunning());
	            	for(int a=0; a < iQd.size(); a++){
	            	for (int j = 1; j < RI[a].length; j++) {
	            	
	            		//"RI_103_13_106.0_0R103_0"
	            					                                		
	            	    String[] RiSplitted = RI[a][j].getName().split("_");
				        //traceln(RI[a][j].getName().split("_"));
	                    
	                    IloNumVar var = RI[a][j];
	                    
	                    if(!var.getName().equals("noRelease")){
	                    	
	                    	targetVariableName = "RI_" + iQd.get(i).getItem() + "_" + (int) iQd.get(i).getDueDate() + "_" + 
	                    	iQd.get(i).getQuantity() + "_1" + "R" +  iQd.get(i).getItem() + "_1";
	                    
	                    	//traceln("Running Order Target Name ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~: " + targetVariableName);
	                    
		                    if (var.getName().equals(targetVariableName)) {
		                        isVariableFound = true;
		                        foundVariable = var;
		                        break;
		                    }//if
		                 }//if
	                }//for
	                
	                if(isVariableFound){
	                	break;
	                }
	                
	               }//for                         
				}//if
				                
                if (isVariableFound) {	                	                	                
	                cplex.addEq(foundVariable, 1);
	                traceln("Release Variable found " + foundVariable.getName() + " set to 1");
	                isVariableFound = false;
            	}
            }//for
            }//if
                                                               
    
    //cplex.deleteNames();
    }//if(false) cf section
    //if(time() == 0)
    //if(Tools.Log_CF_Optimization_Values){                 
		cplex.exportModel("model/NewModel_" + time() + "_" + bomLevel + "_" + firstBomItem.getItem() +".lp");
	//}	
	//cplex.writeSolution("model/NewModel_" + time() + "_" + bomLevel + ".sol");

	//cplex.setParam(IloCplex.BooleanParam.PreInd, true);
	//0.05 were to hard ... 0.1 before
	//cplex.setParam(IloCplex.Param.MIP.Tolerances.MIPGap, 0.05);
	//cplex.setParam(IloCplex.IntParam.DataCheck, 2);	
	cplex.setParam(IloCplex.Param.Threads, 4);
	cplex.setParam(IloCplex.IntParam.WorkMem, 2000);
		
	if(false){					
	//if(cplex.solve() && Tools.Log_CF_Optimization_Values){
		    
		    System.out.println("Solution status: " + cplex.getStatus());
            System.out.println();
            System.out.println("Objective Value = " + cplex.getObjValue());
          
            System.out.println("Pieces: Wip, X, Release, P");
            System.out.println("Minutes: PL L, MC, CF1, CF2, CF3");
            System.out.println("\tp\tTime\tt\tWip\tX\tRelease\tP\tPL\tL\tMC\tCF1\tCF2\tCF3\tInv\tIBl\tWB\tObjPP\tCt\tBt\tPTime\tSTime\tPL\tLt\tICo\tWCo\tBco\tCo");
          	
            int[] t_sum_wip = new int[get_Main().simParams.getMRPPlanningHorizon()];
            int[] t_sum_pl = new int[get_Main().simParams.getMRPPlanningHorizon()];
            int[] t_sum_l = new int[get_Main().simParams.getMRPPlanningHorizon()];
            int[] t_sum_load = new int[get_Main().simParams.getMRPPlanningHorizon()];
            int[] t_sum_x = new int[get_Main().simParams.getMRPPlanningHorizon()];
            int[] t_sum_r = new int[get_Main().simParams.getMRPPlanningHorizon()];
            int[] t_sum_p = new int[get_Main().simParams.getMRPPlanningHorizon()];
          	
            for (int p = 0; p < itemsToPlan.size(); p++) {
                        	
               for (int t = 0; t < get_Main().simParams.getMRPPlanningHorizon(); t++) {
               
               double inventoryBalance = 0;
               double wipBalance = 0;

               if(t>0){
                  //inventoryBalance = cplex.getValue(I[p][t-1])-X[p][t]+cplex.getValue(P[p][t-1]) - cplex.getValue(B[p][t-1]) + cplex.getValue(B[p][t]);
                  inventoryBalance = cplex.getValue(I[p][t-1])-X[p][t]+cplex.getValue(P[p][t-1]);
                  wipBalance = cplex.getValue(W[p][t-1])+cplex.getValue(R[p][t])-cplex.getValue(P[p][t-1]);               
               }
               		
               	  double lt = cplex.getValue(W[p][t])*itemsToPlan.get(p).getItem().getRouting().getEProcessingTime();
               	  double pl = cplex.getValue(P[p][t])*itemsToPlan.get(p).getItem().getRouting().getEProcessingTime();
               	  
               	  double objectivePerPeriod = cplex.getValue(W[p][t]) * itemsToPlan.get(p).getItem().getHoldingCostsWIP() + 
               	  							  cplex.getValue(I[p][t]) * itemsToPlan.get(p).getItem().getHoldingCosts()  
               	  							  // + cplex.getValue(B[p][t]) * itemsToPlan.get(p).getItem().getBacklogCosts() 
               	  							  ;  
               	  							  
               	  							  
               	 // traceln(cplex.getValue(W[p][t]) + "*" + itemsToPlan.get(p).getItem().getHoldingCostsWIP() + " = " + cplex.getValue(W[p][t]) * itemsToPlan.get(p).getItem().getHoldingCostsWIP());							               	  
               	 // traceln(cplex.getValue(I[p][t]) + "*" + itemsToPlan.get(p).getItem().getHoldingCosts() + " = "  + cplex.getValue(I[p][t]) * itemsToPlan.get(p).getItem().getHoldingCosts());							               	  
               	 // traceln(cplex.getValue(B[p][t]) + "*" + itemsToPlan.get(p).getItem().getBacklogCosts() + " = " + cplex.getValue(B[p][t]) * itemsToPlan.get(p).getItem().getBacklogCosts());							               	  
               	 // traceln(cplex.getValue(C[t]) + "*" + oCosts + " = " + cplex.getValue(C[t]) * oCosts);							               	  
               	  
               	  int slope2 = -99;
               	  int slope3 = -99;
               	  
               	  if(selectedSegments.size() == 2){
               	  	slope2 = (int)(slopes[1]*lt+intercepts[1]);
               	  }
               	  
              	  if(selectedSegments.size() == 3){
               	  	slope3 = (int)(slopes[2]*lt+intercepts[2]);
               	  }
               	                 	  
               	  int wipForPrintLn = (int)cplex.getValue(W[p][t]);               	                 	                 	  
               	  
                  System.out.println("\t" + itemsToPlan.get(p).getItem().getItem() +
                                     "\t" + (time() + t -1) +
                                     "\t" + t +                                     
                                     "\t" + (int)Math.round(wipForPrintLn) +
                                     "\t" + X[p][t] +
                                     "\t" + (int)Math.round(cplex.getValue(R[p][t])) +                                            
                                     "\t" + cplex.getValue(P[p][t]) +
                                     //"\t" + (int)Math.round(pl) +
                                     //"\t" + (int)Math.round(lt) +                                     
                                     "\t" + cplex.getValue(PL[t]) +      
                                     "\t" + cplex.getValue(L[t])  +
                                     "\t" + maxCapacity + 
                                     "\t" + (int)(slopes[0]*lt+intercepts[0]) + 
                                     "\t" + slope2 + 
                                     "\t" + slope3 +                                      
                                     "\t" + Math.round(cplex.getValue(I[p][t])) +
                                     "\t" + Math.round(inventoryBalance) +
                                     "\t" + (int)Math.round(wipBalance) +
                                     "\t" + (int)Math.round(objectivePerPeriod) +
                                     "\t -555" +  
                                     "\t -44 " + //(int)cplex.getValue(B[p][t]) + 
                                     "\t" + itemsToPlan.get(p).getItem().getRouting().getEProcessingTime() +
                                     "\t" + itemsToPlan.get(p).getItem().getRouting().getESetupTime()  +
                                     "\t" + cplex.getValue(PL[t]) +      
                                     "\t" + cplex.getValue(L[t])  +
                                     "\t" + (int)itemsToPlan.get(p).getItem().getHoldingCosts() +
                                     "\t" + (int)itemsToPlan.get(p).getItem().getHoldingCostsWIP() +
                                     "\t" + (int)itemsToPlan.get(p).getItem().getBacklogCosts() +
                                     "\t" + (int)-55                                                                              
                                     );                                                                                                 
            
            		//t_sum_wip[t] += wipForPrintLn;
            		
            		t_sum_x[t] += X[p][t];            		
            		t_sum_wip[t] += (int)cplex.getValue(W[p][t]) ;
            		t_sum_r[t] += (int)Math.round(cplex.getValue(R[p][t]));            		
            		t_sum_p[t] += (int)cplex.getValue(P[p][t]);
            		
            		//if(t==0){
            			t_sum_pl[t] = (int)cplex.getValue(PL[t]);
            			t_sum_l[t] = (int)cplex.getValue(L[t]);
            		//}
            			
            		t_sum_load[t] += lt;
	                                    
			if(OptimizationResult.WRITE_OPTIMIZATION_RESULTS_TO_XLXS){                    
                    OptimizationResult optResult = new OptimizationResult(                                        
                                        
	                   					itemsToPlan.get(p).getItem().getItem(),
	                                     (time() + t -1),
	                                     t,                                     
	                                     (int)Math.round(wipForPrintLn),
	                                     X[p][t],
	                                     Math.round(cplex.getValue(R[p][t])),                                            
	                                     cplex.getValue(P[p][t]),
	                                     cplex.getValue(PL[t]),      
	                                     cplex.getValue(L[t]),
	                                      maxCapacity,
	                                     (int)(slopes[0]*lt+intercepts[0]),
	                                      slope2,
	                                      slope3,                                      
	                                      (int)Math.round(cplex.getValue(I[p][t])),
	                                      (int)Math.round(inventoryBalance),
	                                      (int)Math.round(wipBalance),
	                                      (int)Math.round(objectivePerPeriod),
	                                      -55,
	                                      -66,//(int)cplex.getValue(B[p][t]), 
	                                     (double) itemsToPlan.get(p).getItem().getRouting().getEProcessingTime(),
	                                     (double) itemsToPlan.get(p).getItem().getRouting().getESetupTime(),
	                                     cplex.getValue(PL[t]),      
	                                     cplex.getValue(L[t]),
	                                     (int)itemsToPlan.get(p).getItem().getHoldingCosts(),
	                                     (int)itemsToPlan.get(p).getItem().getHoldingCostsWIP(),
	                                     (int)itemsToPlan.get(p).getItem().getBacklogCosts(),
	                                     (int)-55,
	                                     cplex.getValue(Z[p][t])                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            
	                    );
                                                            
	                    get_Main().optimizationResults.add(optResult);                                                      
	                 }   
               }                              
            }
            
            System.out.println("\n");
            System.out.println("\tTime\tt\tX\tWip\tR\tP\tPL\tL");           
            for(int t = 0; t < get_Main().simParams.getMRPPlanningHorizon(); t++) {
            
            	System.out.println(
            		"\t" + (time() + t) +
       				"\t" + t +           
       				"\t" + t_sum_x[t] + 		
            		"\t" + t_sum_wip[t] +
            		"\t" + t_sum_r[t] +
            		"\t" + t_sum_p[t] +
	           		"\t" + t_sum_pl[t] +
            		"\t" + t_sum_l[t]            	
            	);            
            }
                 	  
            
            //if(OptimizationResult.WRITE_OPTIMIZATION_RESULTS_TO_XLXS)
			//OptimizationResult.WriteXlsxOptimizationResults(get_Main().optimizationResults, get_Main().simParams);            
            	//traceln("size +++++++++++ " + get_Main().optimizationResults.size());
            
		}else{
			traceln("NO Solution " + cplex.getStatus());
		}															
        	traceln("iqd size: " +iQd.size());        	
        	for (int p = 0; p < iQd.size(); p++) {        	        
               for (int t = 1; t < leadtimeHorizon; t++) {   
            				traceln("Status "  + cplex.solve());
            				traceln("Release it p " + p + " t " + t + " value " + cplex.getValue(R[p][t]));            
            				//traceln("da vor qty " + p + " " + t + " " + RI[p][t].getName());            				            				
					        					        				        
					        //if(RI[p][t].getName() != "noRelease"){
					        						        
					        //double qty = cplex.getValue(RI[p][t]);    			            			            		            
					        //traceln(qty);
					        //traceln("da for if");				               					        
							//if(qty > 0.9){
							if(false){
					        //traceln("da");				               					        
								
								//traceln("qty " + qty + " " + RI[p][t].getName());
								
								
								//if we have a running order, we have to reduce the release qty, as it was only required for the decision of release qty
			                    //but the qty itself is already considered for production.
			                    //traceln("X[" + p + "," + t + "] " + X[p][t] + " qty " + iQd.get(p).getQuantity() + " Running Orders Qty: " + iQd.get(p).getQuantityRunning());	        				        			        		
			                    
			                    String[] RiSplitted = RI[p][t].getName().split("_");
			                    traceln(RI[p][t].getName().split("_"));
			                    
			                    double qtyXt = Double.parseDouble(RiSplitted[3]);
			                    int itemIntTmp = Integer.parseInt(RiSplitted[1]);
			                    int plannedEnd = Integer.parseInt(RiSplitted[2]);
			                    			                    			                    			                    
			                    SpecialObject sp = iQd.stream().filter(e -> e.getItem() == itemIntTmp && e.getDueDate() == plannedEnd).findFirst().get();
			                    
			                    //traceln("X qty " + iQd.get(p).getQuantity() + " Running Orders Qty: " + iQd.get(p).getQuantityRunning() + " item " + iQd.get(p).getItem() + "DD " + iQd.get(p).getDueDate());	        				        			        					                    
			                    traceln("Xqtyn " + qtyXt + " Running Orders Qty: " + sp.getQuantityRunning() + " item " + sp.getItem() + " DD " + sp.getDueDate());
			                    
			                    //double qtyFinal = Math.ceil(iQd.get(p).getQuantity()-iQd.get(p).getQuantityRunning());
			                    double qtyFinal = Math.ceil(qtyXt - sp.getQuantityRunning());
			                    
			                    traceln("Final Qty: " + qtyFinal);
			                    //traceln("Final QtyN: " + qtyFinalN);
			                    if(qtyFinal > 0){
			                    			                    				                    				                    
				                    ProductionOrder order = new ProductionOrder();			                    			                    
				                    
				                    order.setQuantity(qtyFinal);			                    			                    
				                    
				                    traceln("Set Production Order Qty: " + order.getQuantity());
				                    order.setCreatedAt(time());
												                    				                    								
									//int itemIntTmp = iQd.get(p).getItem();
										
				                    //Item item = get_Main().items.stream().filter(e -> e.getItem() == itemIntTmp).findFirst().get();																		                     
				                    Item item = get_Main().items.stream().filter(e -> e.getItem() == itemIntTmp).findFirst().get();																		                     
				                    
				                    order.setOrderId(get_Main().prodOrderId++);
				                    order.setItem(item);
				                                                                                                                                  
									order.setPlannedCapacity(Routing.GetPlannedCapacityPerItem(get_Main().routings, order.getItem(), get_Main().simParams, order));
									
									//order.setPlannedCapacity(Routing.GetPlannedCapacityPerItem(routingList, order.getItem(), simParams, order));
									order.setPlannedSetupTime(Routing.GetPlannedSetupTimePerItem(get_Main().routings, order.getItem(), get_Main().simParams, order));								
				                    
				                    int minimumRoutingStep = Routing.GetMinimumStep(get_Main().routings, order.getItem() , get_Main().simParams);
									int maximumRoutingStep = Routing.GetMaximumStep(get_Main().routings, order.getItem() , get_Main().simParams);
							
									order.setMinimumRoutingStep(minimumRoutingStep);
									order.setMaximumRoutingStep(maximumRoutingStep);			
									order.setCurrentRoutingStep(minimumRoutingStep);                                        			                    			                    
				                                                            				                    
				                    order.setPlannedStart(max(Integer.parseInt(RiSplitted[5]) + time() - 1, time()));
				                    order.setPlannedEnd(Integer.parseInt(RiSplitted[2]) + time() - 1);
				                    
				                    traceln("Planned Start: " + order.getPlannedStart() +  " Planne End:" + order.getPlannedEnd() + " Time " + time());			                    			                            
				                    
				                    long exists = 0;				
				                                   			                    
				                    if(order.getPlannedStart() < time())
				                    	exists = 1;			                    											
					                    if(exists == 0){					                    	
						                    Routing routingObject = get_Main().routings.stream().filter(e -> e.getItem().getItem() == order.getItem().getItem()).findFirst().get();			
											order.setRouting(routingObject);
											order.setStatus(ProductionOrder.PRODUCTION_ORDER_STATUS_UNPROCESSED);
						                    
						                    get_Main().productionOrders.add(order);	                    						
															                    
					                    }//if
					                }    
		                    	}// if qty	
		                    	//}	                    
		                 }//for            
		            }//for
                        
        if(false) {
			traceln("Production Orders from Optmization Before Removing");
			traceln(ProductionOrder.GetCSVHeader());
			
	        for (ProductionOrder order: get_Main().productionOrders) {
	           traceln(ProductionOrder.GetCSVString(order));
	        }        
			
	        //get_Main().productionOrders.removeIf(e -> e.getPlannedStart() > time());
	
	        traceln("Production Orders from Optmization FOR SIMULATION");
	        traceln(ProductionOrder.GetCSVHeader());
	
	        for (ProductionOrder order: get_Main().productionOrders) {
	            traceln(ProductionOrder.GetCSVString(order));
	        }        
	        traceln("**************************");                							
        }
		
		//get_Main().Function_OrderRelease();
		
		cplex.deleteNames();        
		if(true) {
    	//if(Tools.Log_CF_Optimization_Values){                 
			cplex.exportModel("model/NV/NewModel" + time() + "_" + bomLevel + ".lp");
		}			
		cplex.end();
	}				
	catch (IloException exc) {
         System.err.println("Concert exception '" + exc.getMessage() + "' caught");
         System.exit(-1);
    }
    //catch (ProblemFoundException exc) {
      //   System.err.println("Expection'" + exc.getMessage() + "' caught");
         //System.exit(-1);
    //}
    
return 0;


]]></Body>
				</Function>
				<Function AccessType="default" StaticFunction="false">
					<ReturnModificator>RETURNS_VALUE</ReturnModificator>
					<ReturnType><![CDATA[int]]></ReturnType>
					<Id>1719933209291</Id>
					<Name><![CDATA[Function_ClearingFunction_ACF_wrong_Zt]]></Name>
					<X>490</X><Y>220</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Parameter>
						<Name><![CDATA[itemsToPlan]]></Name>
						<Type><![CDATA[List<MRP>]]></Type>
					</Parameter>
					<Parameter>
						<Name><![CDATA[bomLevel]]></Name>
						<Type><![CDATA[int]]></Type>
					</Parameter>
					<Parameter>
						<Name><![CDATA[inResource]]></Name>
						<Type><![CDATA[Resource]]></Type>
					</Parameter>
					<Parameter>
						<Name><![CDATA[fileSuffix]]></Name>
						<Type><![CDATA[String]]></Type>
					</Parameter>
					<Body><![CDATA[try{

Tools to = new Tools();
							
traceln("----------- Start CF OPTIMIZATION at DEFAULT Version incl. Exta Capacity " + time () + " ----------------");
							
StringBuilder output = new StringBuilder();

int maxCapacity = 1440;
//double wipCosts = 0;
//double inventoryHoldingCosts = 0;
traceln("Total found Segments: " + ClearingFunctionSegments.size());


/*
Iterator<MRP> iterator = itemsToPlan.iterator();
while (iterator.hasNext()) {
    MRP o = iterator.next();
    if (o.getItem().getItem() == 103 ||     
    o.getItem().getItem() == 111 ||
    o.getItem().getItem() == 115 ||
    o.getItem().getItem() == 119 ||
    o.getItem().getItem() == 123 ||
    o.getItem().getItem() == 127 ||
    o.getItem().getItem() == 131
    ) {
        iterator.remove(); // Safely remove the element from the list
    }
}
*/

	//via the bom level the cf is associated
	List<ClearingFunctionSegments> selectedSegments = new ArrayList();
	Item firstBomItem = itemsToPlan.get(0).getItem();
	//wipCosts = firstBomItem.getHoldingCostsWIP();
	//inventoryHoldingCosts = firstBomItem.getHoldingCosts();	
	
	//Routing firstRoutingItem = main.routings.stream().filter(e -> e.getItem().getItem() == firstBomItem.getItem()).findFirst().get();	
	//Resource firstResource= main.resources.stream().filter(e -> e.getName().equalsIgnoreCase(firstRoutingItem.getResource())).findFirst().get();
	
	//maxCapacity = inResource.getCapacity();
	//don't map it to the prodction stage 1-4, select the values based on the resource
	traceln("Total found segments: " + selectedSegments);
	
	if(firstBomItem.getLotsizePolicy().equalsIgnoreCase(Item.LOT_POLICY_FOP)) {
		int fop = firstBomItem.getFOPPeriod();	
		traceln("FOP Period:" + fop);	
					
		selectedSegments = ClearingFunctionSegments.stream().filter(e -> e.getLotParameter() == fop &&
							 e.getLotPolicy().equalsIgnoreCase(Item.LOT_POLICY_FOP) && e.getResource().equalsIgnoreCase(inResource.getName()) 
				 && e.getExperiment().equalsIgnoreCase(main.simParams.getExperiment())).collect(Collectors.toList());															 																								
	}
	else if(firstBomItem.getLotsizePolicy().equalsIgnoreCase(Item.LOT_POLICY_FOQ)) {
		int foq = (int)firstBomItem.getFOQQuantity();	
		traceln("FOQ Qty:" + foq);	
					
		selectedSegments = ClearingFunctionSegments.stream().filter(e -> e.getLotParameter() == foq &&
							 e.getLotPolicy().equalsIgnoreCase(Item.LOT_POLICY_FOQ) && e.getResource().equalsIgnoreCase(inResource.getName()) 
				 && e.getExperiment().equalsIgnoreCase(main.simParams.getExperiment())).collect(Collectors.toList());															 																								
	}
				
	traceln("Resource: " + inResource.getName());
	traceln("Resource Stage Number: " + inResource.getStageNumber());
	traceln("Production Stage: " + (bomLevel + 1));
	traceln("Max Capacity: " + maxCapacity);
	
	traceln("Items to Plan: ");
	itemsToPlan.forEach(e -> traceln(e.getItem().getItem() + " eProcessingTime " + e.getItem().getRouting().getEProcessingTime() + ";"));

	traceln("Selected Slopes: ");		
	selectedSegments.forEach(e -> traceln(e.getSlope() + ";"));
	traceln("Selected Intercepts: ");
	
	selectedSegments.forEach(e -> traceln(e.getyIntercept() + ";"));
	
	if(selectedSegments.size() == 0){
		traceln("STOP Simulation: No Segments found!");
		System.exit(0);
	}
	
	to.log("Segment Cnt: " + selectedSegments.size(), Tools.LogCFOptimization);
	
	double intercepts[] = new double[selectedSegments.size()];
	double slopes[] = new double[selectedSegments.size()];
	
	for(int i = 0; i < selectedSegments.size(); i++) {
		slopes[i] = selectedSegments.get(i).getSlope();
		intercepts[i] = selectedSegments.get(i).getyIntercept();
	}		
			
int numberSegments = selectedSegments.size();

double oCosts = 0;
double oFactor = 1000;//1000
double setupTime = 18; //standard = 18
int leadtimeHorizon = main.simParams.getLeadTimeHorizon();

traceln("Leadtime Horizon: " + leadtimeHorizon);

IloCplex cplex = new IloCplex();

     String[][] Inames = new String[itemsToPlan.size()][get_Main().simParams.getMRPPlanningHorizon()];
     String[][] Pnames = new String[itemsToPlan.size()][get_Main().simParams.getMRPPlanningHorizon()];
     String[] PLnames = new String[get_Main().simParams.getMRPPlanningHorizon()];
     String[] Lnames = new String[get_Main().simParams.getMRPPlanningHorizon()];
     String[][] Wnames = new String[itemsToPlan.size()][get_Main().simParams.getMRPPlanningHorizon()];
     String[][] Rnames = new String[itemsToPlan.size()][get_Main().simParams.getMRPPlanningHorizon()];     
     String[][] Bnames = new String[itemsToPlan.size()][get_Main().simParams.getMRPPlanningHorizon()];     
     String[][] Znames = new String[itemsToPlan.size()][get_Main().simParams.getMRPPlanningHorizon()];     
     
     for(int i = 0; i< get_Main().simParams.getMRPPlanningHorizon(); i++){
          for (int p = 0; p < itemsToPlan.size(); p++) {
        	 	Inames[p][i] = "I" + itemsToPlan.get(p).getItem().getItem() + "_" + i; 
        	 	Pnames[p][i] = "P" + itemsToPlan.get(p).getItem().getItem() + "_" + i; 
        	 	Wnames[p][i] = "W" + itemsToPlan.get(p).getItem().getItem() + "_" + i; 
        	 	Rnames[p][i] = "R" + itemsToPlan.get(p).getItem().getItem() + "_" + i; 
        	 	Bnames[p][i] = "B" + itemsToPlan.get(p).getItem().getItem() + "_" + i; 
        	 	PLnames[i] = "PL" + itemsToPlan.get(p).getItem().getItem() + "_" + i;
        	 	Znames[p][i] = "Z" + itemsToPlan.get(p).getItem().getItem() + "_" + i;  
        	 	Lnames[i] = "L" + itemsToPlan.get(p).getItem().getItem() + "_" + i; 
	     }
     }


     IloNumVar[] C = new IloNumVar[main.simParams.getMRPPlanningHorizon()]; 
     for (int t = 0; t < get_Main().simParams.getMRPPlanningHorizon(); t++) {
        C[t] = cplex.numVar(0, Double.MAX_VALUE, "C" + "_" + t); 
     }
     
     IloNumVar[][] I = new IloNumVar[itemsToPlan.size()][];
     for (int p = 0; p < itemsToPlan.size(); p++) {
        I[p] = cplex.numVarArray(get_Main().simParams.getMRPPlanningHorizon(), 0, Double.MAX_VALUE, Inames[p]);
        oCosts += itemsToPlan.get(p).getItem().getHoldingCosts();
     }
     
     oCosts = oFactor*oCosts;
     //oCosts = oFactor;
     
     IloNumVar[][] P = new IloNumVar[itemsToPlan.size()][];
     for (int p = 0; p < itemsToPlan.size(); p++) {     
        P[p] = cplex.numVarArray(get_Main().simParams.getMRPPlanningHorizon(), 0,  Double.MAX_VALUE, Pnames[p]);        
     }
     
     IloNumVar[] PL = new IloNumVar[leadtimeHorizon];     
     IloNumVar[] L = new IloNumVar[leadtimeHorizon];     
     
     for (int t = 0; t < leadtimeHorizon; t++) {               
     	PL[t] = cplex.numVar(0,  Double.MAX_VALUE, PLnames[t]);
     	L[t] = cplex.numVar(0,  Double.MAX_VALUE, Lnames[t]);
     }
     
                    
     IloNumVar[][] W = new IloNumVar[itemsToPlan.size()][];
     for (int p = 0; p < itemsToPlan.size(); p++) {
        W[p] = cplex.numVarArray(get_Main().simParams.getMRPPlanningHorizon(), 0, Double.MAX_VALUE, Wnames[p]);
     }
		
	 IloNumVar[][] R = new IloNumVar[itemsToPlan.size()][];
     for (int p = 0; p < itemsToPlan.size(); p++) {
        R[p] = cplex.numVarArray(get_Main().simParams.getMRPPlanningHorizon(), 0.0, Double.MAX_VALUE, Rnames[p]);
     }          
     
     IloNumVar[][] B = new IloNumVar[itemsToPlan.size()][];
     for (int p = 0; p < itemsToPlan.size(); p++) {
        B[p] = cplex.numVarArray(get_Main().simParams.getMRPPlanningHorizon(), 0.0, Double.MAX_VALUE, Bnames[p]);
     }
     
     //double epsilon = 1e-6;          	
     IloNumVar[][] Z = new IloNumVar[itemsToPlan.size()][];
     for (int p = 0; p < itemsToPlan.size(); p++) {
        Z[p] = cplex.numVarArray(get_Main().simParams.getMRPPlanningHorizon(), 0.0, Double.MAX_VALUE, Znames[p]);
     }          	
               	
	double[] inventory = new double[itemsToPlan.size()];
	double[] wip = new double[itemsToPlan.size()];
	double[] produce = new double[itemsToPlan.size()];
	double[] tl = new double[itemsToPlan.size()];
		
	int[][] X = new int[itemsToPlan.size()][get_Main().simParams.getMRPPlanningHorizon()];

	List<SpecialObject> iQd = new ArrayList<SpecialObject>();
	List<SpecialObject> runningOrders = new ArrayList<SpecialObject>();
	
     for (int p = 0; p < itemsToPlan.size(); p++) {      	     

     		   inventory[p] = 0;
     		   
     		   //wip[p] = (int)ProductionOrder.GetCurrentWip(get_Main().productionOrders, itemsToPlan.get(p).getItem(), get_Main().simParams);
     		   	wip[p]=0;
     		   
	        	int tmp_item = itemsToPlan.get(p).getItem().getItem();
				     		
     		   produce[p] = 0;
     		   
     		   //tl[p] = itemsToPlan.get(p).getItem().getTransportLotSize();
     	       for (int t = 0; t < get_Main().simParams.getMRPPlanningHorizon(); t++) {               	                          	               	
	               			               		               		               		               	
	               	//int tmp_item = itemsToPlan.get(p).getItem().getItem();
	               	int temp_t = t;
	               	int quantityRunningProductionOrders = 0;
	               	int lateOrders = 0;
	               	
	               	MRP mrpItem = null;
	               	
	               	if(t > 0){
		               	mrpItem = get_Main().mrpTable.stream().filter(e -> e.getItem().getItem() == tmp_item
		               	 && e.getTime() == time() && e.getPeriod() == temp_t-1).findFirst().orElseGet(() -> new MRP());
		               	 
		               	 //traceln("T for running Orders: " + t);
		               	 quantityRunningProductionOrders = remainingProductionOrderQty(tmp_item,t + time());
		               	 
		               	 //late Orders must only be computed in period 1 and not the remaining.
		               	 if(t == 1){
		               	 	lateOrders = lateProductionOrdersQty(tmp_item,t + time());						
		               	 }
		               	 
		               	 //traceln("t " + t + " PlannedOrderReceipts " + (int) mrpItem.getPlannedOrderReceipts()); 
		               	 
		               	 X[p][t] += (int) mrpItem.getPlannedOrderReceipts();
		               	 		               	 
		               	//mrpItem.setPlannedOrderReceipts(mrpItem.getPeriod() + 50);
		               	//traceln("MRP Item for Optimization");
		               	//traceln(MRP.GetCSVHeader());
		               	//traceln(MRP.GetCSVString(mrpItem));
	               	}
															
					if(quantityRunningProductionOrders > 0 || lateOrders > 0){
						traceln("RunningProduction Order Qty: " + quantityRunningProductionOrders + " time: " + time() + " t " + t + " item " + tmp_item);
						traceln("old Xpt: " + X[p][t]);
						
						if(t == 1){
							X[p][1] += (quantityRunningProductionOrders + lateOrders);							
						}else{
							X[p][t] += quantityRunningProductionOrders;
						}															
						
						traceln("new Xpt: " + X[p][t]);
						traceln("Now we have to consider the Remaining Qty for Capacity Consumption of: " + X[p][t]);
						
						SpecialObject runningOrder = new SpecialObject(
	        				mrpItem.getItem().getItem(),
	        				X[p][t], 
	        				t,
	        				quantityRunningProductionOrders + lateOrders);
	        				
	        			runningOrders.add(runningOrder);						
					}
															
					//if(t == 1){						
	        			//X[p][t] += (int) mrpItem.getPlannedOrderReceipts();	        				        			
	        		//}else if(t > 1){	        		
	        		
	        		
	        		//}

	        		if(X[p][t] > 0 && t > 0) {
	        			SpecialObject so = new SpecialObject(
	        				mrpItem.getItem().getItem(),
	        				X[p][t], 
	        				t,
	        				quantityRunningProductionOrders + lateOrders);
	        			iQd.add(so);
	        			traceln("X[" + p + "," + t + "] " + X[p][t] + " " + mrpItem.getItem().getItem());	        				        			        		
	        			
	        			//traceln("~~~~~~~~~~~~~" + so.getItem() + " qty: " + so.getQuantity() + " dd " + so.getDueDate());
	        			
	        		}        		  	        		        		
            }     	      	
     }                                        
     
     //if(iQd.size() == 0){     	
     	//throw new ProblemFoundException("No Planned order Receipts found.");
     //}
     	
               
     String[][] RiNames = new String[iQd.size()][leadtimeHorizon];
     int[][] releaseTmp = new int[iQd.size()][main.simParams.getMRPPlanningHorizon()];
     String[] releaseForX = new String[iQd.size()];

	 // this combinations are constructed .. every time the due date in this case 13, a 0 value is added RI_103_13_106.0_0R103_0
	 
	 //RI_103_13_106.0_0R103_0 + RI_103_13_106.0_0R103_0
       //+ RI_103_13_106.0_0R103_0 + RI_103_13_106.0_1R103_1
       //+ RI_103_13_106.0_2R103_2 + RI_103_13_106.0_3R103_3
       //+ RI_103_13_106.0_4R103_4 + RI_103_13_106.0_5R103_5
       //+ RI_103_13_106.0_6R103_6 + RI_103_13_106.0_7R103_7
       //+ RI_103_13_106.0_8R103_8 + RI_103_13_106.0_9R103_9
       //+ RI_103_13_106.0_10R103_10 + RI_103_13_106.0_11R103_11
       //+ RI_103_13_106.0_12R103_12 + RI_103_13_106.0_13R103_13 
	 
	 //for each Xt > 0 an entry to iQd is added and this represnts all Xts of all planned products!
     for (int p = 0; p < iQd.size(); p++) {
          for(int i = 1; i < leadtimeHorizon; i++){
          		int targetT = (int)(iQd.get(p).getDueDate() - leadtimeHorizon + i + 1);          		
          		
          		if(targetT < 0)
          			targetT = 0; // is 0 as this are values later thaen the due date e.g. 13
          		          		
          		releaseTmp[p][targetT] = i+1;
          		
          		if(targetT > 0){          		          		
        	 		RiNames[p][i] = "RI_" +  iQd.get(p).getItem() + "_" + (int)iQd.get(p).getDueDate() +         	 	
        	 		"_" + iQd.get(p).getQuantity() + "_" + targetT + "R" + iQd.get(p).getItem() + "_" + targetT; 
        	 	}else{
        	 		RiNames[p][i] = "noRelease";// + p + "" + i;
        	 	}        	 	        	 	
        	 	
        	 	//traceln(RiNames[p][i]);
	     }    
     }


	 //for each product we need the individual releases RI.....They are constructed with the above equation.            
	 //traceln("iQd.size " + iQd.size());
     IloNumVar[][] RI = new IloNumVar[iQd.size()][];
     for (int p = 0; p < iQd.size(); p++) {
          	     	
     	//e.g. if we have 8 releases while iqd.size = 8 and this all all the xts, we also need 8 RIs to get an individual decision for each Xt, which must be associated with an Release
     	// in each RiNames the item and due date (item and xt) is coded, consequently this works. 
        RI[p] = cplex.boolVarArray(leadtimeHorizon, RiNames[p]);                
        
     }                                      
            
     	//Objective Function     
		IloLinearNumExpr objFunction  = cplex.linearNumExpr();
	         
        for (int p = 0; p < itemsToPlan.size(); p++) {
           for (int t = 0; t < get_Main().simParams.getMRPPlanningHorizon(); t++) {
              objFunction.addTerm (itemsToPlan.get(p).getItem().getHoldingCosts(), I[p][t]);
            }
         }

        for (int p = 0; p < itemsToPlan.size(); p++) {
           for (int t = 0; t < get_Main().simParams.getMRPPlanningHorizon(); t++) {
             objFunction.addTerm (itemsToPlan.get(p).getItem().getHoldingCostsWIP(), W[p][t]);
            }                     	            
         } 
         
         for (int p = 0; p < itemsToPlan.size(); p++) {
           for (int t = 0; t < get_Main().simParams.getMRPPlanningHorizon(); t++) {
             objFunction.addTerm (itemsToPlan.get(p).getItem().getBacklogCosts(), B[p][t]);
            }                     	            
         } 
         
                  
         for (int t = 0; t < get_Main().simParams.getMRPPlanningHorizon(); t++) {
             objFunction.addTerm (oCosts, C[t]); 
         }                     	                              
                                      
         cplex.addMinimize(objFunction); //objective function
       
         for (int p = 0; p < itemsToPlan.size(); p++) {
           		
         	cplex.addEq(I[p][0],0); //Eq7
         	cplex.addEq(P[p][0],0); //Eq8  Pg,0 must be zero to avoid production in this period. this is not possible.                           
         	//cplex.addEq(W[p][0],0); //Eq7
         	cplex.addEq(R[p][0],0); //Eq9
         	cplex.addEq(W[p][0],0); //Eq10
         
            for (int t = 1; t < get_Main().simParams.getMRPPlanningHorizon(); t++) {
	           	cplex.addEq(cplex.sum(cplex.sum(I[p][t], X[p][t]),B[p][t-1]), 
                       cplex.sum(cplex.sum(I[p][t-1], P[p][t-1]),B[p][t]));
        	}
            
              
            cplex.addEq(W[p][0], R[p][0]);
            
            for (int t = 1; t < get_Main().simParams.getMRPPlanningHorizon(); t++) {
               cplex.addEq(cplex.sum(W[p][t], P[p][t-1]), 
                           cplex.sum(W[p][t-1], R[p][t]));   
                                                                                                                                    
            }			             											
         }
         
         //********************* Sum of RI_t == 1 *************************
         // RI_103_13_106.0_0R103_0 + RI_103_13_106.0_0R103_0 + RI_103_13_106.0_0R103_0 + RI_103_13_106.0_1R103_1  + RI_103_13_106.0_2R103_2 + RI_103_13_106.0_3R103_3  + RI_103_13_106.0_4R103_4 + RI_103_13_106.0_5R103_5 .... = 1       
         // CF Article EQ3 
          List<String> unique = new ArrayList();
          
          for (int p = 0; p < iQd.size(); p++) {
            IloLinearNumExpr num_expr_Sum_Binaries = cplex.linearNumExpr();  
            boolean weHaveRI = false;	           
	            for (int t = 1; t < leadtimeHorizon; t++) {	            	
	            	
	            	//int tmp_p = p;
	            	//int tmp_t = t;
	            	//traceln("test auf " + RI[tmp_p][tmp_t].getName());
	            	
	            	//boolean exists = unique.stream().filter(element -> element != null).anyMatch(element -> element.equals(RI[tmp_p][tmp_t].getName()));
	            	            	
	            	//if(!exists) {
	            		//unique.add(RI[tmp_p][tmp_t].getName());
	            		//traceln("p" + p + " t " + t );
	            		
	            		if(RI[p][t] != null){
	            		//traceln("ri not null");
	            		String variableName = RI[p][t].getName();
	            		//char isItRI = "RI";
	            		//traceln("Found variable " + variableName);
	            		
							           		
		            		if(variableName.contains("RI")){
		            			weHaveRI = true;
		            			num_expr_Sum_Binaries.addTerm(1,RI[p][t]);															
		            		}
		            		
	            		}
	            		
	            		
	            		//traceln("add" + RI[tmp_p][tmp_t].getName());
	            	//}else{
	            		//num_expr_Sum_Binaries.addTerm(0,RI[p][t]);															
	            	//}					
	            }
	            	            
	            if(weHaveRI)
	            	cplex.addEq(num_expr_Sum_Binaries,1);
            }
         
         
         //RI structure
         //Eq2 where Rg,t = RIg,t*Xg,t
         //RI_item_Xt_qty_start_lth_...end_lth_Ritem_start_lth...end_lth
         for (int pp = 0; pp < itemsToPlan.size(); pp++) {
         	IloLinearNumExpr cf = cplex.linearNumExpr();				         
	       for (int t = 1; t < main.simParams.getMRPPlanningHorizon()-1; t++) {	            	            
			       	String o = "";
			       	int sizeExpr = 0;
			        IloLinearNumExpr num_expr = cplex.linearNumExpr();
			                    
	                for (int p = 0; p < iQd.size(); p++) {
	                	if(iQd.get(p).getItem()== itemsToPlan.get(pp).getItem().getItem()){
	                	
		            		if(releaseTmp[p][t] > 0){
		            			
		            			o = o + iQd.get(p).getQuantity() + "*" + RI[p][releaseTmp[p][t]-1].getName() +  "+";	            			
		            			num_expr.addTerm(iQd.get(p).getQuantity(),RI[p][releaseTmp[p][t]-1]);
		            					            					            					            			
		            			sizeExpr++;		            					            					            			
		            		}			        
	            		}
					}
					
				if(o.length() > 1){
		            if(sizeExpr > 0){
		            	//Constraint Release Size 
			            cplex.addEq(R[pp][t],num_expr);    
			                  
			        }

				}else{
				         cplex.addEq(R[pp][t],0);          								
				}
																
				num_expr.clear();             														
			}         
         }
                         
		IloLinearNumExpr[] sumRIs = new IloLinearNumExpr[main.simParams.getMRPPlanningHorizon()];
		
		for (int t = 0; t < main.simParams.getMRPPlanningHorizon(); t++) {
		    IloLinearNumExpr sumRIsI = cplex.linearNumExpr();
		
		    for (int pp = 0; pp < itemsToPlan.size(); pp++) {
		        for (int p = 0; p < iQd.size(); p++) {
		            if (iQd.get(p).getItem() == itemsToPlan.get(pp).getItem().getItem()) {
		                if (releaseTmp[p][t] > 0) {
		                	//traceln("###### " + 1.0 + " :::: " +  RI[p][releaseTmp[p][t] - 1]);		                
		                    sumRIsI.addTerm(1.0, RI[p][releaseTmp[p][t] - 1]);		                    
		                }
		            }
		        }
		    }
		    
		    sumRIs[t] = sumRIsI;		    		    		    
		    //sumRIsI.clear();
		}				
		             
            
//Constraint avoiding that RI with later due date, releases order earlier that RI with earlier due date (orders should not overteak each other)
//The release of order 2 should not before order 1                                         
// ********************************* Guarantee Release ORDER  ****************************************
// ***************************************************************************************************            
//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
// Constraint avoiding that RI with later due date, releases order earlier that
// RI with earlier due date (orders should not overteak each other) The release
// of order 2 should not before order 1

traceln("iQd size " + iQd.size());

List<SpecialObject> iQdSorted = iQd;
if(main.simParams.getROFormulation() == 1){
	Collections.sort(iQdSorted, Comparator.comparing(SpecialObject::getDueDate).thenComparing(SpecialObject::getItem));
	//Collections.sort(iQdSorted, Comparator.comparing(SpecialObject::getItem).thenComparing(SpecialObject::getDueDate));
	
	traceln("IQd sorted:");
	for(SpecialObject o : iQdSorted){
		traceln(o.getDueDate()  + " " + o.getItem() + " " + o.getQuantity());						
	}
	
	for(int i = 0; i < iQdSorted.size() -1; i++){
	//now take the first succesor:
			SpecialObject currentiQd = iQdSorted.get(i);		
			SpecialObject succesoriQd = iQdSorted.get(i+1);
			
			if(currentiQd.getDueDate() <= succesoriQd.getDueDate() && currentiQd.getDueDate() > 1){
							
				int overlappingStart = max((int)succesoriQd.getDueDate() - leadtimeHorizon,0);
				//traceln("overlapping start" + (int)succesoriQd.getDueDate()  + " -" + leadtimeHorizon + "=" + overlappingStart);
				// for the overlapping time we have to generate the RI comparisions:			
				IloLinearNumExpr lhs = cplex.linearNumExpr();
		        IloLinearNumExpr rhs = cplex.linearNumExpr();
	
	             // traceln("Start Index " + RIstartIndex);
	            int overlappingPeriods = (int)currentiQd.getDueDate() - overlappingStart;
				
				int RIstartIndex =  max(0, (leadtimeHorizon - overlappingPeriods));                                            
	
	            StringBuilder lhsOut = new StringBuilder();
	            StringBuilder rhsOut = new StringBuilder();
	                          
	            int multiplier = 0;                   
	            //traceln("Overlapping Periods " + overlappingPeriods);
	            //traceln("Overlapping Start "  + overlappingStart);            
	            
	            for (int o = 0; o < overlappingPeriods; o++) {
					
					IloNumVar found = Function_FindeRIVarialbe(iQdSorted.size(), RI, currentiQd.getItem(), (int)currentiQd.getDueDate(), o+1, (int)currentiQd.getQuantity());
					
					IloNumVar foundSuccessor = Function_FindeRIVarialbe(iQdSorted.size(), RI, succesoriQd.getItem(), (int)succesoriQd.getDueDate(), o+1, (int)succesoriQd.getQuantity());
					
	                //if (RI[p][RIstartIndex + o].getName().contains("RI")) {
	                //traceln("found" + found.getName());
	                if (found.getName().contains("RI")) {
	                
	                	lhs.addTerm(multiplier + 1, found);
	                	lhsOut.append(multiplier + 1 + " " + found.getName()  + " + ");
	                	
	                	rhs.addTerm(multiplier + 1, foundSuccessor);
	                	rhsOut.append(multiplier + 1 + " " + foundSuccessor.getName() + " + ");
	                	                
	                	multiplier++;
	                }
	            }
	            
	            //for the remaining periods we have to extend the rhs:
	            
	            
	            for (int o = 0; o < succesoriQd.getDueDate() - overlappingPeriods; o++) {
													
					IloNumVar foundSuccessor = Function_FindeRIVarialbe(iQdSorted.size(), RI, succesoriQd.getItem(), (int)succesoriQd.getDueDate(), overlappingPeriods + o + 1, (int)succesoriQd.getQuantity());								
					
	                //if (RI[p][RIstartIndex + o].getName().contains("RI")) {
	                //traceln("found" + found.getName());
	                if (foundSuccessor.getName().contains("RI")) {                                
	                	
	                	rhs.addTerm(multiplier + 1, foundSuccessor);
	                	rhsOut.append(multiplier + 1 + " " + foundSuccessor.getName() + " + ");
	                	                
	                	multiplier++;
	                }
	            }
	            
	            
	            cplex.addLe(lhs, rhs);
	
	         traceln("Overlapping:");
	         traceln(lhsOut.toString() + "<=");
	         traceln(rhsOut.toString());             						
			
			}													
	}
}// END - if guaranteee release order         
//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~            
//--- Reha ALCF
         if(main.simParams.getALCFormulation() == 1){
			IloLinearNumExpr ziSum;
			for (int p = 0; p < itemsToPlan.size(); p++) {              
			    ziSum = cplex.linearNumExpr(); // Create a new expression for each item p            	   
			    for (int t = 1; t < get_Main().simParams.getMRPPlanningHorizon(); t++) {
			        ziSum.addTerm(1, Z[p][t]); // Correct the order of parameters, should be (coefficient, variable)
			    }
			    cplex.addEq(ziSum, 1); // Add the constraint Z_i_t = 1 for each p  
			    
			    			  //Klaus Input: uuuu
			    
			    // fr die zeitperiode ber alle produkte = 1
			    
			    //z1= z1,2 z1,3 ... z1,12 = 1 
			    //z2= z2,2,z23... zp,12      		            	
} 	      	         	         	         	         	         	         	         	
          }//if true
         //****************** CF SECTION ***************************************
         //*********************************************************************
     	IloLinearNumExpr cf = cplex.linearNumExpr();				             	    
     	IloLinearNumExpr cf1 = cplex.linearNumExpr();  //LHS			             	    
       	IloLinearNumExpr cf2 = cplex.linearNumExpr(); //RHS				             	    
	   	IloLinearNumExpr cf3 = cplex.linearNumExpr();				             	    
	   	IloLinearNumExpr cf4 = cplex.linearNumExpr();		
       	IloLinearNumExpr zgt = cplex.linearNumExpr();
       	
         for (int t = 0; t < main.simParams.getMRPPlanningHorizon(); t++) {	                 	        	    
    	    //Pgt smaller Wgt - Constraint for single item qty
    	    zgt = cplex.linearNumExpr();
        	 for (int pp = 0; pp < itemsToPlan.size(); pp++) {        	  			
					//merk dir, dass die weiter unten verwendet werden
					//double setupProption = 18.0/106.0;
					double setupProption = 0;
					
	         		cf.addTerm(itemsToPlan.get(pp).getItem().getRouting().getEProcessingTime()+setupProption,P[pp][t]);	         		
	         		
	         		if(get_Main().simParams.getCFSegments() > 0){	         		
	         			//cf1.addTerm(itemsToPlan.get(pp).getItem().getRouting().getEProcessingTime()+setupProption,P[pp][t]); 	         		        		         				
         				
         				 // Add the first term to cf2
            			//double processingTime = itemsToPlan.get(pp).getItem().getRouting().getEProcessingTime();
            			//cf2.addTerm(processingTime + setupProption, W[pp][t]);
            	         //		if(get_Main().simParams.getCFSegments() > 0){	         		
	         		
	         			cf1.addTerm(itemsToPlan.get(pp).getItem().getRouting().getEProcessingTime()+setupProption,P[pp][t]); 	         		        		
         				cf2.addTerm(itemsToPlan.get(pp).getItem().getRouting().getEProcessingTime()+setupProption,W[pp][t]);         			         		        			         			
         			
            			// Add the second term Z[pp][t] to cf2
            			
            			
            			zgt.addTerm(1.0, Z[pp][t]);
         				
						 //cf2.add(cplex.prod(1.0, Z[pp][t]));
						 //cf2.add(cplex.sum(cf2),Z[pp][t]);		        			         			
         			}
         			
         			cf3.addTerm(itemsToPlan.get(pp).getItem().getRouting().getEProcessingTime()+setupProption,P[pp][t]);         		
         			cf4.addTerm(itemsToPlan.get(pp).getItem().getRouting().getEProcessingTime()+setupProption,W[pp][t]);
         			
         			
         			//***************** Ppt, <= Wp,t ***********************        			         		         			
         			cplex.addLe(
         				//cplex.sum(P[pp][t],cplex.prod(0,sumRIs[t])),//LHS         			
         				cplex.sum(P[pp][t],0),//LHS         			
        				cplex.sum(W[pp][t],0));//RHS         			
        			//****************************************
        			  			        			         		         				
        				        				        				        			        			        				
        	  }//for (int pp = 0; pp < itemsToPlan.size(); pp++) {        	  			
        	  
        	          	  
			  //CF Constraints			           	  
			  //PL <= MC + Ct (Eq12)			  
			  //traceln("setup time " + setupTime + " sum ri " + sumRIs);
         	  //cplex.addLe(cplex.sum(cf,cplex.prod(setupTime,sumRIs)), //LHS         	  
         	  
         	  
         	  // **************** PL und Lt ausgeben *********************
         	  //keine constraints werden spter so auch nicht wiedervendet
         	  cplex.addEq(PL[t],cf);
         	  cplex.addEq(L[t],cf2);
         	  //********************************************************* 
         	  
         	  
         	  //cplex.addEq(PL[t],cplex.sum(cf,cplex.prod(setupTime,sumRIs)));
         	  //cplex.addEq(L[t],cplex.sum(cf2,cplex.prod(setupTime,sumRIs)));         	           	           	           	  
         	  
         	  /******** PLt <=MC+Ct (Eq14) ************/
         	  //This is also the reason why in the .lp file the maximum capacity is not available for t=0
         	  if(t==0){         	           	           	           	  
         	  		cplex.addLe(cf,         	  
         	  		cplex.sum(0,C[t]));	//RHS
         	  	}else{         	  	
         	  		cplex.addLe(cplex.sum(cf,cplex.prod(setupTime,sumRIs[t])),         	  
         	  		cplex.sum(maxCapacity,C[t]));	//RHS
         	  	}
         	           	           	           	  		         	           	           	  
         	           	           	  
         	  // ---- we have three segments         	           	           	  
			  //CF partition 2 from numerical example
			  //traceln("# segments " + numberSegments);
			  //represent CF as k*x + d -> 
			  
			  if(get_Main().simParams.getCFSegments() == 0){
			  	numberSegments = 0;			  	
			  }
			  
			  traceln("Number Segments: " + numberSegments);
			  
			  //pro produkt eine CF, die sind ber die Z Werte verknpft
			  //Klaus Input: uuuu
			  for(int i = 0; i < numberSegments; i++){
			  traceln("Setuptime: " + setupTime);
			  //slopes[i] = 1.0;
			  //intercepts[i] = 0.1;
			  
			  
	         	  cplex.addLe(
    	     	  	cplex.sum(cf1,cplex.prod(setupTime,sumRIs[t])), //LHS				
				
         	  		cplex.sum(cplex.sum(cplex.prod(max(slopes[i],0),         	  	         	  	
         	  		
         	  		cplex.sum(cf2,cplex.prod(setupTime,sumRIs[t]))),
         	  		
         	  		
         	  		cplex.prod(intercepts[i],zgt)),C[t]));//RHS         	  		         	  						
         	  	
         	  	
         	  		traceln("Slope (x): " + slopes[i] + " Y-intercept (d) " + intercepts[i]);
         	  		         	  		
         	  	//traceln("sumRIs " + sumRIs + " st " + setupTime);	
         	  }//for
         	           	           	           	  			           	  
         	  /******************************* PLt <= Lt + Ct (Eq18) *********************/
         	  //Constraint Pl musst be smaller as SL for all t         	           	  
         	  
         	  cplex.addLe(
         	  	cplex.sum(cf3,cplex.prod(setupTime,sumRIs[t])), //LHS         	  
	         	cplex.sum(cplex.sum(cf4,cplex.prod(setupTime,sumRIs[t])),C[t]));         	  	         		         		         		         	
	         	
	         	
	         	/*
	         	cplex.addLe(
         	  	cplex.sum(cf3,cplex.prod(setupTime,sumRIs[t])), //LHS         	  
	         	cplex.sum(cplex.sum(cf4,cplex.prod(setupTime,sumRIs[t])),0));         	  	         	
	         	*/
	         	
	          //***************************************************************************
         	  
			  cf.clear();
			  cf1.clear();
 			  cf2.clear();
 			  cf3.clear();
 			  cf4.clear();
         }



			// Create a two-dimensional array of IloNumVars
            int numRows = iQd.size(); // Assuming iQd is a list or array
                        
            // ... Initialize and populate the RI array with IloNumVars ...

            // Find the variable by name in the RI array
            traceln("iQd size: " + iQd.size());
            String targetVariableName = "noRelease";
            boolean isVariableFound = false;
            IloNumVar foundVariable = null;

            for (int i = 0; i < numRows; i++) {
                for (int j = 1; j < RI[i].length-1; j++) {
                    IloNumVar var = RI[i][j];
                    if (var.getName().equals(targetVariableName)) {
                        isVariableFound = true;
                        foundVariable = var;
                        break;
                    }
                }
                if (isVariableFound) {
                    break;
                }
            }
            
            if (isVariableFound) {
                // Add a constraint to enforce the found variable to be zero
                traceln("Yes found set no release to 0");                
                foundVariable.setName("noRelease");                                
                cplex.addEq(foundVariable, 0);
            }
            
            //All Entries represent Running Orders. So the associated
            //RI_...1 must be set to one
            
                                    
            int numberOpenOrders = runningOrders.size();
            for(SpecialObject o : runningOrders){
            	traceln(o.getItem() + " " + o.getQuantity() + " " + o.getQuantityRunning());
            }
            
            
            traceln("Count Running Orders: " + numberOpenOrders);
            traceln("RI length: " + RI.length);
            if(iQd.size() > 0){
            for (int i = 0; i < iQd.size(); i++) {
            	isVariableFound = false;            	
            	if(iQd.get(i).getQuantityRunning() > 0){
            		traceln("search " + iQd.get(i).getItem() + " " + iQd.get(i).getDueDate() + " " + iQd.get(i).getQuantity() + " " + iQd.get(i).getQuantityRunning());
	            	for(int a=0; a < iQd.size(); a++){
	            	for (int j = 1; j < RI[a].length; j++) {
	            	
	            		//"RI_103_13_106.0_0R103_0"
	            					                                		
	            	    String[] RiSplitted = RI[a][j].getName().split("_");
				        //traceln(RI[a][j].getName().split("_"));
	                    
	                    IloNumVar var = RI[a][j];
	                    
	                    if(!var.getName().equals("noRelease")){
	                    	
	                    	targetVariableName = "RI_" + iQd.get(i).getItem() + "_" + (int) iQd.get(i).getDueDate() + "_" + 
	                    	iQd.get(i).getQuantity() + "_1" + "R" +  iQd.get(i).getItem() + "_1";
	                    
	                    	//traceln("Running Order Target Name ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~: " + targetVariableName);
	                    
		                    if (var.getName().equals(targetVariableName)) {
		                        isVariableFound = true;
		                        foundVariable = var;
		                        break;
		                    }//if
		                 }//if
	                }//for
	                
	                if(isVariableFound){
	                	break;
	                }
	                
	               }//for                         
				}//if
				                
                if (isVariableFound) {	                	                	                
	                cplex.addEq(foundVariable, 1);
	                traceln("Release Variable found " + foundVariable.getName() + " set to 1");
	                isVariableFound = false;
            	}
            }//for
            }//if
                                                               
    
    //cplex.deleteNames();
    
    //if(time() == 0)
    if(Tools.Log_CF_Optimization_Values){                 
		cplex.exportModel("model/NewModel_" + time() + "_" + bomLevel + "_" + firstBomItem.getItem() +".lp");
	}	
	//cplex.writeSolution("model/NewModel_" + time() + "_" + bomLevel + ".sol");

	//cplex.setParam(IloCplex.BooleanParam.PreInd, true);
	//0.05 were to hard ... 0.1 before	
	
	//cplex.setParam(IloCplex.Param.MIP.Tolerances.MIPGap, 0.1);
	//cplex.setParam(IloCplex.IntParam.DataCheck, 2);	
	cplex.setParam(IloCplex.IntParam.WorkMem, 2000);
	cplex.setParam(IloCplex.Param.Threads, 4);
	

	if(cplex.solve() && Tools.Log_CF_Optimization_Values){
		    
		    System.out.println("Solution status: " + cplex.getStatus());
            System.out.println();
            System.out.println("Objective Value = " + cplex.getObjValue());
          
            System.out.println("Pieces: Wip, X, Release, P");
            System.out.println("Minutes: PL L, MC, CF1, CF2, CF3");
            System.out.println("\tp\tTime\tt\tWip\tX\tRelease\tP\tPL\tL\tMC\tCF1\tCF2\tCF3\tInv\tIBl\tWB\tObjPP\tCt\tBt\tPTime\tSTime\tPL\tLt\tICo\tWCo\tBco\tCo\tZt");
          	
            int[] t_sum_wip = new int[get_Main().simParams.getMRPPlanningHorizon()];
            int[] t_sum_pl = new int[get_Main().simParams.getMRPPlanningHorizon()];
            int[] t_sum_l = new int[get_Main().simParams.getMRPPlanningHorizon()];
            int[] t_sum_load = new int[get_Main().simParams.getMRPPlanningHorizon()];
            int[] t_sum_x = new int[get_Main().simParams.getMRPPlanningHorizon()];
            int[] t_sum_r = new int[get_Main().simParams.getMRPPlanningHorizon()];
            int[] t_sum_p = new int[get_Main().simParams.getMRPPlanningHorizon()];
            int[] t_sum_z = new int[get_Main().simParams.getMRPPlanningHorizon()];
          	
            for (int p = 0; p < itemsToPlan.size(); p++) {
                        	
               for (int t = 0; t < get_Main().simParams.getMRPPlanningHorizon(); t++) {
               
               double inventoryBalance = 0;
               double wipBalance = 0;

               if(t>0){
                  inventoryBalance = cplex.getValue(I[p][t-1])-X[p][t]+cplex.getValue(P[p][t-1]) - cplex.getValue(B[p][t-1]) + cplex.getValue(B[p][t]);
                  wipBalance = cplex.getValue(W[p][t-1])+cplex.getValue(R[p][t])-cplex.getValue(P[p][t-1]);               
               }
               		
               	  double lt = cplex.getValue(W[p][t])*itemsToPlan.get(p).getItem().getRouting().getEProcessingTime();
               	  double pl = cplex.getValue(P[p][t])*itemsToPlan.get(p).getItem().getRouting().getEProcessingTime();               	                 	  
               	  
               	  double objectivePerPeriod = cplex.getValue(W[p][t]) * itemsToPlan.get(p).getItem().getHoldingCostsWIP() + 
               	  							  cplex.getValue(I[p][t]) * itemsToPlan.get(p).getItem().getHoldingCosts() + 
               	  							  cplex.getValue(B[p][t]) * itemsToPlan.get(p).getItem().getBacklogCosts() +
               	  							  cplex.getValue(C[t]) * oCosts;  
               	  							  
               	  							  
               	 // traceln(cplex.getValue(W[p][t]) + "*" + itemsToPlan.get(p).getItem().getHoldingCostsWIP() + " = " + cplex.getValue(W[p][t]) * itemsToPlan.get(p).getItem().getHoldingCostsWIP());							               	  
               	 // traceln(cplex.getValue(I[p][t]) + "*" + itemsToPlan.get(p).getItem().getHoldingCosts() + " = "  + cplex.getValue(I[p][t]) * itemsToPlan.get(p).getItem().getHoldingCosts());							               	  
               	 // traceln(cplex.getValue(B[p][t]) + "*" + itemsToPlan.get(p).getItem().getBacklogCosts() + " = " + cplex.getValue(B[p][t]) * itemsToPlan.get(p).getItem().getBacklogCosts());							               	  
               	 // traceln(cplex.getValue(C[t]) + "*" + oCosts + " = " + cplex.getValue(C[t]) * oCosts);							               	  
               	  
               	  int slope2 = -99;
               	  int slope3 = -99;
               	  
               	  if(selectedSegments.size() == 2){
               	  	slope2 = (int)(slopes[1]*lt+intercepts[1]);
               	  }
               	  
              	  if(selectedSegments.size() == 3){
               	  	slope3 = (int)(slopes[2]*lt+intercepts[2]);
               	  }
               	                 	  
               	  int wipForPrintLn = (int)cplex.getValue(W[p][t]);  
               	  
               	  boolean zPt_Exists = true;// OptimizationResult.checkVariableExists(cplex, "Z["+p+"]["+t+"]"); 
         	                 	                 	  
               	  double zPTValue = OptimizationResult.getValueOrDefault(cplex, Z, p, t, 0.0);
               	  
                  System.out.println("\t" + itemsToPlan.get(p).getItem().getItem() +
                                     "\t" + (time() + t -1) +
                                     "\t" + t +                                     
                                     "\t" + (int)Math.round(wipForPrintLn) +
                                     "\t" + X[p][t] +
                                     "\t" + (int)Math.round(cplex.getValue(R[p][t])) +                                            
                                     "\t" + cplex.getValue(P[p][t]) +
                                     //"\t" + (int)Math.round(pl) +
                                     //"\t" + (int)Math.round(lt) +                                     
                                     "\t" + cplex.getValue(PL[t]) +      
                                     "\t" + cplex.getValue(L[t])  +
                                     "\t" + maxCapacity + 
                                     "\t" + (int)(slopes[0]*lt+intercepts[0]) + 
                                     "\t" + slope2 + 
                                     "\t" + slope3 +                                      
                                     "\t" + Math.round(cplex.getValue(I[p][t])) +
                                     "\t" + Math.round(inventoryBalance) +
                                     "\t" + (int)Math.round(wipBalance) +
                                     "\t" + (int)Math.round(objectivePerPeriod) +
                                     "\t" + Math.round(cplex.getValue(C[t])) +
                                     "\t" + (int)cplex.getValue(B[p][t]) + 
                                     "\t" + itemsToPlan.get(p).getItem().getRouting().getEProcessingTime() +
                                     "\t" + itemsToPlan.get(p).getItem().getRouting().getESetupTime()  +
                                     "\t" + cplex.getValue(PL[t]) +      
                                     "\t" + cplex.getValue(L[t])  +
                                     "\t" + (int)itemsToPlan.get(p).getItem().getHoldingCosts() +
                                     "\t" + (int)itemsToPlan.get(p).getItem().getHoldingCostsWIP() +
                                     "\t" + (int)itemsToPlan.get(p).getItem().getBacklogCosts() +
                                     "\t" + (int)oCosts +
                                     "\t" + zPTValue                                                                            
                                     );                                                                                                 
            
            		//t_sum_wip[t] += wipForPrintLn;
            		
            		t_sum_x[t] += X[p][t];            		
            		t_sum_wip[t] += (int)cplex.getValue(W[p][t]) ;
            		t_sum_r[t] += (int)Math.round(cplex.getValue(R[p][t]));            		
            		t_sum_p[t] += (int)cplex.getValue(P[p][t]);
            		t_sum_z[t] += zPTValue;
            		
            		//if(t==0){
            			t_sum_pl[t] = (int)cplex.getValue(PL[t]);
            			t_sum_l[t] = (int)cplex.getValue(L[t]);
            		//}
            			
            		t_sum_load[t] += lt;
	                                    
			if(OptimizationResult.WRITE_OPTIMIZATION_RESULTS_TO_XLXS){                    
                    OptimizationResult optResult = new OptimizationResult(                                        
                                        
	                   					itemsToPlan.get(p).getItem().getItem(),
	                                     (time() + t -1),
	                                     t,                                     
	                                     (int)Math.round(wipForPrintLn),
	                                     X[p][t],
	                                     Math.round(cplex.getValue(R[p][t])),                                            
	                                     cplex.getValue(P[p][t]),
	                                     cplex.getValue(PL[t]),      
	                                     cplex.getValue(L[t]),
	                                      maxCapacity,
	                                     (int)(slopes[0]*lt+intercepts[0]),
	                                      slope2,
	                                      slope3,                                      
	                                      (int)Math.round(cplex.getValue(I[p][t])),
	                                      (int)Math.round(inventoryBalance),
	                                      (int)Math.round(wipBalance),
	                                      (int)Math.round(objectivePerPeriod),
	                                      cplex.getValue(C[t]),
	                                      (int)cplex.getValue(B[p][t]), 
	                                     (double) itemsToPlan.get(p).getItem().getRouting().getEProcessingTime(),
	                                     (double) itemsToPlan.get(p).getItem().getRouting().getESetupTime(),
	                                     cplex.getValue(PL[t]),      
	                                     cplex.getValue(L[t]),
	                                     (int)itemsToPlan.get(p).getItem().getHoldingCosts(),
	                                     (int)itemsToPlan.get(p).getItem().getHoldingCostsWIP(),
	                                     (int)itemsToPlan.get(p).getItem().getBacklogCosts(),
	                                     (int)oCosts,
	                                     zPTValue                                                                                                                                                           
	                    );
                                                            
	                    get_Main().optimizationResults.add(optResult);                                                      
	                 }   
               }                              
            }
            
            System.out.println("\n");
            System.out.println("\tTime\tt\tX\tWip\tR\tP\tPL\tL\tZ");           
            for(int t = 0; t < get_Main().simParams.getMRPPlanningHorizon(); t++) {
            
            	System.out.println(
            		"\t" + (time() + t) +
       				"\t" + t +           
       				"\t" + t_sum_x[t] + 		
            		"\t" + t_sum_wip[t] +
            		"\t" + t_sum_r[t] +
            		"\t" + t_sum_p[t] +
	           		"\t" + t_sum_pl[t] +
            		"\t" + t_sum_l[t] +
            		"\t" + t_sum_z[t]            		           	
            	);            
            }
                 	  
            
            //if(OptimizationResult.WRITE_OPTIMIZATION_RESULTS_TO_XLXS)
			//OptimizationResult.WriteXlsxOptimizationResults(get_Main().optimizationResults, get_Main().simParams);            
            	//traceln("size +++++++++++ " + get_Main().optimizationResults.size());
            
		}else{
			traceln("NO Solution " + cplex.getStatus());
		}															
        	
        	for (int p = 0; p < iQd.size(); p++) {        	        
               for (int t = 1; t < leadtimeHorizon; t++) {   
            				            
            				//traceln("da vor qty " + p + " " + t + " " + RI[p][t].getName());            				            				
					        					        				        
					        if(RI[p][t].getName() != "noRelease"){
					        						        
					        double qty = cplex.getValue(RI[p][t]);    			            			            		            
					        //traceln(qty);
					        //traceln("da for if");				               					        
							if(qty > 0.9){
					        //traceln("da");				               					        
								
								//traceln("qty " + qty + " " + RI[p][t].getName());
								
								
								//if we have a running order, we have to reduce the release qty, as it was only required for the decision of release qty
			                    //but the qty itself is already considered for production.
			                    //traceln("X[" + p + "," + t + "] " + X[p][t] + " qty " + iQd.get(p).getQuantity() + " Running Orders Qty: " + iQd.get(p).getQuantityRunning());	        				        			        		
			                    
			                    String[] RiSplitted = RI[p][t].getName().split("_");
			                    traceln(RI[p][t].getName().split("_"));
			                    
			                    double qtyXt = Double.parseDouble(RiSplitted[3]);
			                    int itemIntTmp = Integer.parseInt(RiSplitted[1]);
			                    int plannedEnd = Integer.parseInt(RiSplitted[2]);
			                    			                    			                    			                    
			                    SpecialObject sp = iQd.stream().filter(e -> e.getItem() == itemIntTmp && e.getDueDate() == plannedEnd).findFirst().get();
			                    
			                    //traceln("X qty " + iQd.get(p).getQuantity() + " Running Orders Qty: " + iQd.get(p).getQuantityRunning() + " item " + iQd.get(p).getItem() + "DD " + iQd.get(p).getDueDate());	        				        			        					                    
			                    traceln("Xqtyn " + qtyXt + " Running Orders Qty: " + sp.getQuantityRunning() + " item " + sp.getItem() + " DD " + sp.getDueDate());
			                    
			                    //double qtyFinal = Math.ceil(iQd.get(p).getQuantity()-iQd.get(p).getQuantityRunning());
			                    double qtyFinal = Math.ceil(qtyXt - sp.getQuantityRunning());
			                    
			                    traceln("Final Qty: " + qtyFinal);
			                    //traceln("Final QtyN: " + qtyFinalN);
			                    if(qtyFinal > 0){
			                    
			                    	
			                    				                    
				                    ProductionOrder order = new ProductionOrder();			                    			                    
				                    
				                    order.setQuantity(qtyFinal);			                    			                    
				                    
				                    traceln("Set Production Order Qty: " + order.getQuantity());
				                    order.setCreatedAt(time());
												                    				                    								
									//int itemIntTmp = iQd.get(p).getItem();
										
				                    //Item item = get_Main().items.stream().filter(e -> e.getItem() == itemIntTmp).findFirst().get();																		                     
				                    Item item = get_Main().items.stream().filter(e -> e.getItem() == itemIntTmp).findFirst().get();																		                     
				                    
				                    order.setOrderId(get_Main().prodOrderId++);
				                    order.setItem(item);
				                                                                                                                                  
									order.setPlannedCapacity(Routing.GetPlannedCapacityPerItem(get_Main().routings, order.getItem(), get_Main().simParams, order));
									
									//order.setPlannedCapacity(Routing.GetPlannedCapacityPerItem(routingList, order.getItem(), simParams, order));
									order.setPlannedSetupTime(Routing.GetPlannedSetupTimePerItem(get_Main().routings, order.getItem(), get_Main().simParams, order));								
				                    
				                    int minimumRoutingStep = Routing.GetMinimumStep(get_Main().routings, order.getItem() , get_Main().simParams);
									int maximumRoutingStep = Routing.GetMaximumStep(get_Main().routings, order.getItem() , get_Main().simParams);
							
									order.setMinimumRoutingStep(minimumRoutingStep);
									order.setMaximumRoutingStep(maximumRoutingStep);			
									order.setCurrentRoutingStep(minimumRoutingStep);                                        			                    			                    
				                                                            
				                    //order.setQuantity(Math.round(iQd.get(p).getQuantity()));
				                    
				                    //traceln("################################## " + iQd.get(p).getQuantity());
				                    				                    				                    				                    
				                    //get the start and end dates from the RI decision variables			                    
				                    
				                    
				                    //order.setPlannedStart(max(Integer.parseInt(RiSplitted[5]) + time() - item.getSafetyLeadTime(), time()));
				                    //order.setPlannedStart(Integer.parseInt(RiSplitted[5] + time());
	
				                    //safety leadtime for stochastic scenario
				                    //order.setPlannedStart(max(Integer.parseInt(RiSplitted[5]) + time() - 1, time()));
				                    
				                   // order.setPlannedStart(max(Integer.parseInt(RiSplitted[5]) + time() - 1, time()));
				                    
				                    //Optimization Starts with 0, so we have to subract -1 from the result to meet the correct MRP Periods
				                    order.setPlannedStart(max(Integer.parseInt(RiSplitted[5]) + time() - 1, time()));
				                    order.setPlannedEnd(Integer.parseInt(RiSplitted[2]) + time() - 1);
				                    
				                    traceln("Planned Start: " + order.getPlannedStart() +  " Planne End:" + order.getPlannedEnd() + " Time " + time());			                    			                            
				                    
				                    long exists = 0;				
				                                   			                    
				                    if(order.getPlannedStart() < time())
				                    	exists = 1;			                    											
					                    if(exists == 0){
					                    	//traceln("Production Order Added");														                    
						                    Routing routingObject = get_Main().routings.stream().filter(e -> e.getItem().getItem() == order.getItem().getItem()).findFirst().get();			
											order.setRouting(routingObject);
											order.setStatus(ProductionOrder.PRODUCTION_ORDER_STATUS_UNPROCESSED);
						                    
						                    get_Main().productionOrders.add(order);	                    						
															                    
					                    }//if
					                }    
		                    	}// if qty	
		                    	}	                    
		                 }//for            
		            }//for
                        
        if(false) {
			traceln("Production Orders from Optmization Before Removing");
			traceln(ProductionOrder.GetCSVHeader());
			
	        for (ProductionOrder order: get_Main().productionOrders) {
	           traceln(ProductionOrder.GetCSVString(order));
	        }        
			
	        //get_Main().productionOrders.removeIf(e -> e.getPlannedStart() > time());
	
	        traceln("Production Orders from Optmization FOR SIMULATION");
	        traceln(ProductionOrder.GetCSVHeader());
	
	        for (ProductionOrder order: get_Main().productionOrders) {
	            traceln(ProductionOrder.GetCSVString(order));
	        }        
	        traceln("**************************");                							
        }
		
		//get_Main().Function_OrderRelease();
		
		cplex.deleteNames();        
    	if(Tools.Log_CF_Optimization_Values){                 
			cplex.exportModel("model/NV/NewModel" + time() + "_" + bomLevel + ".lp");
		}			
		cplex.end();
	}				
	catch (IloException exc) {
         System.err.println("Concert exception '" + exc.getMessage() + "' caught");
         System.exit(-1);
    }
    //catch (ProblemFoundException exc) {
      //   System.err.println("Expection'" + exc.getMessage() + "' caught");
         //System.exit(-1);
    //}
    
return 0;


]]></Body>
				</Function>
				<Function AccessType="default" StaticFunction="false">
					<ReturnModificator>RETURNS_VALUE</ReturnModificator>
					<ReturnType><![CDATA[int]]></ReturnType>
					<Id>1720000627511</Id>
					<Name><![CDATA[Function_ClearingFunction_ACF_incl_Ct]]></Name>
					<X>490</X><Y>300</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Parameter>
						<Name><![CDATA[itemsToPlan]]></Name>
						<Type><![CDATA[List<MRP>]]></Type>
					</Parameter>
					<Parameter>
						<Name><![CDATA[bomLevel]]></Name>
						<Type><![CDATA[int]]></Type>
					</Parameter>
					<Parameter>
						<Name><![CDATA[inResource]]></Name>
						<Type><![CDATA[Resource]]></Type>
					</Parameter>
					<Parameter>
						<Name><![CDATA[fileSuffix]]></Name>
						<Type><![CDATA[String]]></Type>
					</Parameter>
					<Body><![CDATA[try{

Tools to = new Tools();
							
traceln("----------- Start CF OPTIMIZATION at DEFAULT Version incl. Exta Capacity " + time () + " ----------------");
							
StringBuilder output = new StringBuilder();

int maxCapacity = 1440;
//double wipCosts = 0;
//double inventoryHoldingCosts = 0;
traceln("Total found Segments: " + ClearingFunctionSegments.size());


	//via the bom level the cf is associated
	List<ClearingFunctionSegments> selectedSegments = new ArrayList();
	Item firstBomItem = itemsToPlan.get(0).getItem();
	//wipCosts = firstBomItem.getHoldingCostsWIP();
	//inventoryHoldingCosts = firstBomItem.getHoldingCosts();	
	
	//Routing firstRoutingItem = main.routings.stream().filter(e -> e.getItem().getItem() == firstBomItem.getItem()).findFirst().get();	
	//Resource firstResource= main.resources.stream().filter(e -> e.getName().equalsIgnoreCase(firstRoutingItem.getResource())).findFirst().get();
	
	//maxCapacity = inResource.getCapacity();
	//don't map it to the prodction stage 1-4, select the values based on the resource
	traceln("Total found segments: " + selectedSegments);
	
	if(firstBomItem.getLotsizePolicy().equalsIgnoreCase(Item.LOT_POLICY_FOP)) {
		int fop = firstBomItem.getFOPPeriod();	
		traceln("FOP Period:" + fop);	
					
		selectedSegments = ClearingFunctionSegments.stream().filter(e -> e.getLotParameter() == fop &&
							 e.getLotPolicy().equalsIgnoreCase(Item.LOT_POLICY_FOP) && e.getResource().equalsIgnoreCase(inResource.getName()) 
				 && e.getExperiment().equalsIgnoreCase(main.simParams.getExperiment())).collect(Collectors.toList());															 																								
	}
	else if(firstBomItem.getLotsizePolicy().equalsIgnoreCase(Item.LOT_POLICY_FOQ)) {
		int foq = (int)firstBomItem.getFOQQuantity();	
		traceln("FOQ Qty:" + foq);	
					
		selectedSegments = ClearingFunctionSegments.stream().filter(e -> e.getLotParameter() == foq &&
							 e.getLotPolicy().equalsIgnoreCase(Item.LOT_POLICY_FOQ) && e.getResource().equalsIgnoreCase(inResource.getName()) 
				 && e.getExperiment().equalsIgnoreCase(main.simParams.getExperiment())).collect(Collectors.toList());															 																								
	}
				
	traceln("Resource: " + inResource.getName());
	traceln("Resource Stage Number: " + inResource.getStageNumber());
	traceln("Production Stage: " + (bomLevel + 1));
	traceln("Max Capacity: " + maxCapacity);
	
	traceln("Items to Plan: ");
	itemsToPlan.forEach(e -> traceln(e.getItem().getItem() + " eProcessingTime " + e.getItem().getRouting().getEProcessingTime() + ";"));

	traceln("Selected Slopes: ");		
	selectedSegments.forEach(e -> traceln(e.getSlope() + ";"));
	traceln("Selected Intercepts: ");
	
	selectedSegments.forEach(e -> traceln(e.getyIntercept() + ";"));
	
	if(selectedSegments.size() == 0){
		traceln("STOP Simulation: No Segments found!");
		System.exit(0);
	}
	
	to.log("Segment Cnt: " + selectedSegments.size(), Tools.LogCFOptimization);
	
	double intercepts[] = new double[selectedSegments.size()];
	double slopes[] = new double[selectedSegments.size()];
	
	for(int i = 0; i < selectedSegments.size(); i++) {
		slopes[i] = selectedSegments.get(i).getSlope();
		intercepts[i] = selectedSegments.get(i).getyIntercept();
	}		
			
int numberSegments = selectedSegments.size();

double oCosts = 0;
double oFactor = 1000;//1000
double setupTime = 18; //standard = 18
int leadtimeHorizon = main.simParams.getLeadTimeHorizon();

traceln("Leadtime Horizon: " + leadtimeHorizon);

IloCplex cplex = new IloCplex();

     String[][] Inames = new String[itemsToPlan.size()][get_Main().simParams.getMRPPlanningHorizon()];
     String[][] Pnames = new String[itemsToPlan.size()][get_Main().simParams.getMRPPlanningHorizon()];
     String[] PLnames = new String[get_Main().simParams.getMRPPlanningHorizon()];
     String[] Lnames = new String[get_Main().simParams.getMRPPlanningHorizon()];
     String[][] Wnames = new String[itemsToPlan.size()][get_Main().simParams.getMRPPlanningHorizon()];
     String[][] Rnames = new String[itemsToPlan.size()][get_Main().simParams.getMRPPlanningHorizon()];     
     String[][] Bnames = new String[itemsToPlan.size()][get_Main().simParams.getMRPPlanningHorizon()];     
     String[][] Znames = new String[itemsToPlan.size()][get_Main().simParams.getMRPPlanningHorizon()];     
     
     for(int i = 0; i< get_Main().simParams.getMRPPlanningHorizon(); i++){
          for (int p = 0; p < itemsToPlan.size(); p++) {
        	 	Inames[p][i] = "I" + itemsToPlan.get(p).getItem().getItem() + "_" + i; 
        	 	Pnames[p][i] = "P" + itemsToPlan.get(p).getItem().getItem() + "_" + i; 
        	 	Wnames[p][i] = "W" + itemsToPlan.get(p).getItem().getItem() + "_" + i; 
        	 	Rnames[p][i] = "R" + itemsToPlan.get(p).getItem().getItem() + "_" + i; 
        	 	Bnames[p][i] = "B" + itemsToPlan.get(p).getItem().getItem() + "_" + i; 
        	 	PLnames[i] = "PL" + itemsToPlan.get(p).getItem().getItem() + "_" + i;
        	 	Znames[p][i] = "Z" + itemsToPlan.get(p).getItem().getItem() + "_" + i;  
        	 	Lnames[i] = "L" + itemsToPlan.get(p).getItem().getItem() + "_" + i; 
	     }
     }


     IloNumVar[] C = new IloNumVar[main.simParams.getMRPPlanningHorizon()]; 
     for (int t = 0; t < get_Main().simParams.getMRPPlanningHorizon(); t++) {
        C[t] = cplex.numVar(0, Double.MAX_VALUE, "C" + "_" + t); 
     }
     
     IloNumVar[][] I = new IloNumVar[itemsToPlan.size()][];
     for (int p = 0; p < itemsToPlan.size(); p++) {
        I[p] = cplex.numVarArray(get_Main().simParams.getMRPPlanningHorizon(), 0, Double.MAX_VALUE, Inames[p]);
        oCosts += itemsToPlan.get(p).getItem().getHoldingCosts();
     }
     
     oCosts = oFactor*oCosts;
     //oCosts = oFactor;
     
     IloNumVar[][] P = new IloNumVar[itemsToPlan.size()][];
     for (int p = 0; p < itemsToPlan.size(); p++) {     
        P[p] = cplex.numVarArray(get_Main().simParams.getMRPPlanningHorizon(), 0,  Double.MAX_VALUE, Pnames[p]);        
     }
     
     IloNumVar[] PL = new IloNumVar[leadtimeHorizon];     
     IloNumVar[] L = new IloNumVar[leadtimeHorizon];     
     
     for (int t = 0; t < leadtimeHorizon; t++) {               
     	PL[t] = cplex.numVar(0,  Double.MAX_VALUE, PLnames[t]);
     	L[t] = cplex.numVar(0,  Double.MAX_VALUE, Lnames[t]);
     }
     
                    
     IloNumVar[][] W = new IloNumVar[itemsToPlan.size()][];
     for (int p = 0; p < itemsToPlan.size(); p++) {
        W[p] = cplex.numVarArray(get_Main().simParams.getMRPPlanningHorizon(), 0, Double.MAX_VALUE, Wnames[p]);
     }
		
	 IloNumVar[][] R = new IloNumVar[itemsToPlan.size()][];
     for (int p = 0; p < itemsToPlan.size(); p++) {
        R[p] = cplex.numVarArray(get_Main().simParams.getMRPPlanningHorizon(), 0.0, Double.MAX_VALUE, Rnames[p]);
     }          
     
     IloNumVar[][] B = new IloNumVar[itemsToPlan.size()][];
     for (int p = 0; p < itemsToPlan.size(); p++) {
        B[p] = cplex.numVarArray(get_Main().simParams.getMRPPlanningHorizon(), 0.0, Double.MAX_VALUE, Bnames[p]);
     }
     
     //double epsilon = 1e-6;          	
     IloNumVar[][] Z = new IloNumVar[itemsToPlan.size()][];
     for (int p = 0; p < itemsToPlan.size(); p++) {
        Z[p] = cplex.numVarArray(get_Main().simParams.getMRPPlanningHorizon(), 0.0, Double.MAX_VALUE, Znames[p]);
     }          	
               	
	double[] inventory = new double[itemsToPlan.size()];
	double[] wip = new double[itemsToPlan.size()];
	double[] produce = new double[itemsToPlan.size()];
	double[] tl = new double[itemsToPlan.size()];
		
	int[][] X = new int[itemsToPlan.size()][get_Main().simParams.getMRPPlanningHorizon()];

	List<SpecialObject> iQd = new ArrayList<SpecialObject>();
	List<SpecialObject> runningOrders = new ArrayList<SpecialObject>();
	
     for (int p = 0; p < itemsToPlan.size(); p++) {      	     

     		   inventory[p] = 0;
     		   
     		   //wip[p] = (int)ProductionOrder.GetCurrentWip(get_Main().productionOrders, itemsToPlan.get(p).getItem(), get_Main().simParams);
     		   	wip[p]=0;
     		   
	        	int tmp_item = itemsToPlan.get(p).getItem().getItem();
				     		
     		   produce[p] = 0;
     		   
     		   //tl[p] = itemsToPlan.get(p).getItem().getTransportLotSize();
     	       for (int t = 0; t < get_Main().simParams.getMRPPlanningHorizon(); t++) {               	                          	               	
	               			               		               		               		               	
	               	//int tmp_item = itemsToPlan.get(p).getItem().getItem();
	               	int temp_t = t;
	               	int quantityRunningProductionOrders = 0;
	               	int lateOrders = 0;
	               	
	               	MRP mrpItem = null;
	               	
	               	if(t > 0){
		               	mrpItem = get_Main().mrpTable.stream().filter(e -> e.getItem().getItem() == tmp_item
		               	 && e.getTime() == time() && e.getPeriod() == temp_t-1).findFirst().orElseGet(() -> new MRP());
		               	 
		               	 //traceln("T for running Orders: " + t);
		               	 quantityRunningProductionOrders = remainingProductionOrderQty(tmp_item,t + time());
		               	 
		               	 //late Orders must only be computed in period 1 and not the remaining.
		               	 if(t == 1){
		               	 	lateOrders = lateProductionOrdersQty(tmp_item,t + time());						
		               	 }
		               	 
		               	 //traceln("t " + t + " PlannedOrderReceipts " + (int) mrpItem.getPlannedOrderReceipts()); 
		               	 
		               	 X[p][t] += (int) mrpItem.getPlannedOrderReceipts();
		               	 		               	 
		               	//mrpItem.setPlannedOrderReceipts(mrpItem.getPeriod() + 50);
		               	//traceln("MRP Item for Optimization");
		               	//traceln(MRP.GetCSVHeader());
		               	//traceln(MRP.GetCSVString(mrpItem));
	               	}
															
					if(quantityRunningProductionOrders > 0 || lateOrders > 0){
						traceln("RunningProduction Order Qty: " + quantityRunningProductionOrders + " time: " + time() + " t " + t + " item " + tmp_item);
						traceln("old Xpt: " + X[p][t]);
						
						if(t == 1){
							X[p][1] += (quantityRunningProductionOrders + lateOrders);							
						}else{
							X[p][t] += quantityRunningProductionOrders;
						}															
						
						traceln("new Xpt: " + X[p][t]);
						traceln("Now we have to consider the Remaining Qty for Capacity Consumption of: " + X[p][t]);
						
						SpecialObject runningOrder = new SpecialObject(
	        				mrpItem.getItem().getItem(),
	        				X[p][t], 
	        				t,
	        				quantityRunningProductionOrders + lateOrders);
	        				
	        			runningOrders.add(runningOrder);						
					}
															
					//if(t == 1){						
	        			//X[p][t] += (int) mrpItem.getPlannedOrderReceipts();	        				        			
	        		//}else if(t > 1){	        		
	        		
	        		
	        		//}

	        		if(X[p][t] > 0 && t > 0) {
	        			SpecialObject so = new SpecialObject(
	        				mrpItem.getItem().getItem(),
	        				X[p][t], 
	        				t,
	        				quantityRunningProductionOrders + lateOrders);
	        			iQd.add(so);
	        			traceln("X[" + p + "," + t + "] " + X[p][t] + " " + mrpItem.getItem().getItem());	        				        			        		
	        			
	        			//traceln("~~~~~~~~~~~~~" + so.getItem() + " qty: " + so.getQuantity() + " dd " + so.getDueDate());
	        			
	        		}        		  	        		        		
            }     	      	
     }                                        
     
     //if(iQd.size() == 0){     	
     	//throw new ProblemFoundException("No Planned order Receipts found.");
     //}
     	
               
     String[][] RiNames = new String[iQd.size()][leadtimeHorizon];
     int[][] releaseTmp = new int[iQd.size()][main.simParams.getMRPPlanningHorizon()];
     String[] releaseForX = new String[iQd.size()];

	 // this combinations are constructed .. every time the due date in this case 13, a 0 value is added RI_103_13_106.0_0R103_0
	 
	 //RI_103_13_106.0_0R103_0 + RI_103_13_106.0_0R103_0
       //+ RI_103_13_106.0_0R103_0 + RI_103_13_106.0_1R103_1
       //+ RI_103_13_106.0_2R103_2 + RI_103_13_106.0_3R103_3
       //+ RI_103_13_106.0_4R103_4 + RI_103_13_106.0_5R103_5
       //+ RI_103_13_106.0_6R103_6 + RI_103_13_106.0_7R103_7
       //+ RI_103_13_106.0_8R103_8 + RI_103_13_106.0_9R103_9
       //+ RI_103_13_106.0_10R103_10 + RI_103_13_106.0_11R103_11
       //+ RI_103_13_106.0_12R103_12 + RI_103_13_106.0_13R103_13 
	 
	 //for each Xt > 0 an entry to iQd is added and this represnts all Xts of all planned products!
     for (int p = 0; p < iQd.size(); p++) {
          for(int i = 1; i < leadtimeHorizon; i++){
          		int targetT = (int)(iQd.get(p).getDueDate() - leadtimeHorizon + i + 1);          		
          		
          		if(targetT < 0)
          			targetT = 0; // is 0 as this are values later thaen the due date e.g. 13
          		          		
          		releaseTmp[p][targetT] = i+1;
          		
          		if(targetT > 0){          		          		
        	 		RiNames[p][i] = "RI_" +  iQd.get(p).getItem() + "_" + (int)iQd.get(p).getDueDate() +         	 	
        	 		"_" + iQd.get(p).getQuantity() + "_" + targetT + "R" + iQd.get(p).getItem() + "_" + targetT; 
        	 	}else{
        	 		RiNames[p][i] = "noRelease";// + p + "" + i;
        	 	}        	 	        	 	
        	 	
        	 	//traceln(RiNames[p][i]);
	     }    
     }


	 //for each product we need the individual releases RI.....They are constructed with the above equation.            
	 //traceln("iQd.size " + iQd.size());
     IloNumVar[][] RI = new IloNumVar[iQd.size()][];
     for (int p = 0; p < iQd.size(); p++) {
          	     	
     	//e.g. if we have 8 releases while iqd.size = 8 and this all all the xts, we also need 8 RIs to get an individual decision for each Xt, which must be associated with an Release
     	// in each RiNames the item and due date (item and xt) is coded, consequently this works. 
        RI[p] = cplex.boolVarArray(leadtimeHorizon, RiNames[p]);                
        
     }                                      
            
     	//Objective Function     
		IloLinearNumExpr objFunction  = cplex.linearNumExpr();
	         
        for (int p = 0; p < itemsToPlan.size(); p++) {
           for (int t = 0; t < get_Main().simParams.getMRPPlanningHorizon(); t++) {
              objFunction.addTerm (itemsToPlan.get(p).getItem().getHoldingCosts(), I[p][t]);
            }
         }

        for (int p = 0; p < itemsToPlan.size(); p++) {
           for (int t = 0; t < get_Main().simParams.getMRPPlanningHorizon(); t++) {
             objFunction.addTerm (itemsToPlan.get(p).getItem().getHoldingCostsWIP(), W[p][t]);
            }                     	            
         } 
         
         for (int p = 0; p < itemsToPlan.size(); p++) {
           for (int t = 0; t < get_Main().simParams.getMRPPlanningHorizon(); t++) {
             objFunction.addTerm (itemsToPlan.get(p).getItem().getBacklogCosts(), B[p][t]);
            }                     	            
         } 
         
                  
         for (int t = 0; t < get_Main().simParams.getMRPPlanningHorizon(); t++) {
             objFunction.addTerm (oCosts, C[t]); 
         }                     	                              
                                      
         cplex.addMinimize(objFunction); //objective function
       
         for (int p = 0; p < itemsToPlan.size(); p++) {
           		
         	cplex.addEq(I[p][0],0); //Eq7
         	cplex.addEq(P[p][0],0); //Eq8  Pg,0 must be zero to avoid production in this period. this is not possible.                           
         	//cplex.addEq(W[p][0],0); //Eq7
         	cplex.addEq(R[p][0],0); //Eq9
         	cplex.addEq(W[p][0],0); //Eq10
         
            for (int t = 1; t < get_Main().simParams.getMRPPlanningHorizon(); t++) {
	           	cplex.addEq(cplex.sum(cplex.sum(I[p][t], X[p][t]),B[p][t-1]), 
                       cplex.sum(cplex.sum(I[p][t-1], P[p][t-1]),B[p][t]));
        	}
            
              
            cplex.addEq(W[p][0], R[p][0]);
            
            for (int t = 1; t < get_Main().simParams.getMRPPlanningHorizon(); t++) {
               cplex.addEq(cplex.sum(W[p][t], P[p][t-1]), 
                           cplex.sum(W[p][t-1], R[p][t]));   
                                                                                                                                    
            }			             											
         }
         
         //********************* Sum of RI_t == 1 *************************
         // RI_103_13_106.0_0R103_0 + RI_103_13_106.0_0R103_0 + RI_103_13_106.0_0R103_0 + RI_103_13_106.0_1R103_1  + RI_103_13_106.0_2R103_2 + RI_103_13_106.0_3R103_3  + RI_103_13_106.0_4R103_4 + RI_103_13_106.0_5R103_5 .... = 1       
         // CF Article EQ3 
          List<String> unique = new ArrayList();
          
          for (int p = 0; p < iQd.size(); p++) {
            IloLinearNumExpr num_expr_Sum_Binaries = cplex.linearNumExpr();  
            boolean weHaveRI = false;	           
	            for (int t = 1; t < leadtimeHorizon; t++) {	            	
	            
	            		
	            		if(RI[p][t] != null){
	            		String variableName = RI[p][t].getName();
							           		
		            		if(variableName.contains("RI")){
		            			weHaveRI = true;
		            			num_expr_Sum_Binaries.addTerm(1,RI[p][t]);															
		            		}
		            		
	            		}
	            }
	            	            
	            if(weHaveRI)
	            	cplex.addEq(num_expr_Sum_Binaries,1);
            }
         
         
         //RI structure
         //Eq2 where Rg,t = RIg,t*Xg,t
         //RI_item_Xt_qty_start_lth_...end_lth_Ritem_start_lth...end_lth
         for (int pp = 0; pp < itemsToPlan.size(); pp++) {
         	IloLinearNumExpr cf = cplex.linearNumExpr();				         
	       for (int t = 1; t < main.simParams.getMRPPlanningHorizon()-1; t++) {	            	            
			       	String o = "";
			       	int sizeExpr = 0;
			        IloLinearNumExpr num_expr = cplex.linearNumExpr();
			                    
	                for (int p = 0; p < iQd.size(); p++) {
	                	if(iQd.get(p).getItem()== itemsToPlan.get(pp).getItem().getItem()){
	                	
		            		if(releaseTmp[p][t] > 0){
		            			
		            			o = o + iQd.get(p).getQuantity() + "*" + RI[p][releaseTmp[p][t]-1].getName() +  "+";	            			
		            			num_expr.addTerm(iQd.get(p).getQuantity(),RI[p][releaseTmp[p][t]-1]);
		            					            					            					            			
		            			sizeExpr++;		            					            					            			
		            		}			        
	            		}
					}
					
				if(o.length() > 1){
		            if(sizeExpr > 0){
		            	//Constraint Release Size 
			            cplex.addEq(R[pp][t],num_expr);    
			                  
			        }

				}else{
				         cplex.addEq(R[pp][t],0);          								
				}
																
				num_expr.clear();             														
			}         
         }
                         
		IloLinearNumExpr[] sumRIs = new IloLinearNumExpr[main.simParams.getMRPPlanningHorizon()];
		
		for (int t = 0; t < main.simParams.getMRPPlanningHorizon(); t++) {
		    IloLinearNumExpr sumRIsI = cplex.linearNumExpr();
		
		    for (int pp = 0; pp < itemsToPlan.size(); pp++) {
		        for (int p = 0; p < iQd.size(); p++) {
		            if (iQd.get(p).getItem() == itemsToPlan.get(pp).getItem().getItem()) {
		                if (releaseTmp[p][t] > 0) {
		                	//traceln("###### " + 1.0 + " :::: " +  RI[p][releaseTmp[p][t] - 1]);		                
		                    sumRIsI.addTerm(1.0, RI[p][releaseTmp[p][t] - 1]);		                    
		                }
		            }
		        }
		    }
		    
		    sumRIs[t] = sumRIsI;		    		    		    
		    //sumRIsI.clear();
		}				
		             
            
//Constraint avoiding that RI with later due date, releases order earlier that RI with earlier due date (orders should not overteak each other)
//The release of order 2 should not before order 1                                         
// ********************************* Guarantee Release ORDER  ****************************************
// ***************************************************************************************************            
//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
// Constraint avoiding that RI with later due date, releases order earlier that
// RI with earlier due date (orders should not overteak each other) The release
// of order 2 should not before order 1

traceln("iQd size " + iQd.size());

List<SpecialObject> iQdSorted = iQd;
if(main.simParams.getROFormulation() == 1){
	Collections.sort(iQdSorted, Comparator.comparing(SpecialObject::getDueDate).thenComparing(SpecialObject::getItem));
	//Collections.sort(iQdSorted, Comparator.comparing(SpecialObject::getItem).thenComparing(SpecialObject::getDueDate));
	
	traceln("IQd sorted:");
	for(SpecialObject o : iQdSorted){
		traceln(o.getDueDate()  + " " + o.getItem() + " " + o.getQuantity());						
	}
	
	for(int i = 0; i < iQdSorted.size() -1; i++){
	//now take the first succesor:
			SpecialObject currentiQd = iQdSorted.get(i);		
			SpecialObject succesoriQd = iQdSorted.get(i+1);
			
			if(currentiQd.getDueDate() <= succesoriQd.getDueDate() && currentiQd.getDueDate() > 1){
							
				int overlappingStart = max((int)succesoriQd.getDueDate() - leadtimeHorizon,0);
				//traceln("overlapping start" + (int)succesoriQd.getDueDate()  + " -" + leadtimeHorizon + "=" + overlappingStart);
				// for the overlapping time we have to generate the RI comparisions:			
				IloLinearNumExpr lhs = cplex.linearNumExpr();
		        IloLinearNumExpr rhs = cplex.linearNumExpr();
	
	             // traceln("Start Index " + RIstartIndex);
	            int overlappingPeriods = (int)currentiQd.getDueDate() - overlappingStart;
				
				int RIstartIndex =  max(0, (leadtimeHorizon - overlappingPeriods));                                            
	
	            StringBuilder lhsOut = new StringBuilder();
	            StringBuilder rhsOut = new StringBuilder();
	                          
	            int multiplier = 0;                             
	            
	            for (int o = 0; o < overlappingPeriods; o++) {
					
					IloNumVar found = Function_FindeRIVarialbe(iQdSorted.size(), RI, currentiQd.getItem(), (int)currentiQd.getDueDate(), o+1, (int)currentiQd.getQuantity());
					
					IloNumVar foundSuccessor = Function_FindeRIVarialbe(iQdSorted.size(), RI, succesoriQd.getItem(), (int)succesoriQd.getDueDate(), o+1, (int)succesoriQd.getQuantity());
					
	                if (found.getName().contains("RI")) {
	                
	                	lhs.addTerm(multiplier + 1, found);
	                	lhsOut.append(multiplier + 1 + " " + found.getName()  + " + ");
	                	
	                	rhs.addTerm(multiplier + 1, foundSuccessor);
	                	rhsOut.append(multiplier + 1 + " " + foundSuccessor.getName() + " + ");
	                	                
	                	multiplier++;
	                }
	            }
	            
	            
	            for (int o = 0; o < succesoriQd.getDueDate() - overlappingPeriods; o++) {
													
					IloNumVar foundSuccessor = Function_FindeRIVarialbe(iQdSorted.size(), RI, succesoriQd.getItem(), (int)succesoriQd.getDueDate(), overlappingPeriods + o + 1, (int)succesoriQd.getQuantity());								
					
	                if (foundSuccessor.getName().contains("RI")) {                                
	                	
	                	rhs.addTerm(multiplier + 1, foundSuccessor);
	                	rhsOut.append(multiplier + 1 + " " + foundSuccessor.getName() + " + ");
	                	                
	                	multiplier++;
	                }
	            }
	            
	            
	            cplex.addLe(lhs, rhs);
	
	         traceln("Overlapping:");
	         traceln(lhsOut.toString() + "<=");
	         traceln(rhsOut.toString());             						
			
			}													
	}
}// END - if guaranteee release order         
//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~            
//--- Reha ALCF
         if(main.simParams.getALCFormulation() == 1){
			IloLinearNumExpr ziSum;
			  for (int t = 1; t < get_Main().simParams.getMRPPlanningHorizon(); t++) {          
			    ziSum = cplex.linearNumExpr(); // Create a new expression for each item p            	   
				for (int p = 0; p < itemsToPlan.size(); p++) {  
			        ziSum.addTerm(1, Z[p][t]); // Correct the order of parameters, should be (coefficient, variable)
			    }
			    cplex.addEq(ziSum, 1); // Add the constraint Z_i_t = 1 for each p  
			    
			    //Klaus Input: uuuu
			    
			    // fr die zeitperiode ber alle produkte = 1
			    
			    //z1= z1,2 z1,3 ... z1,12 = 1 
			    //z2= z2,2,z23... zp,12      		            	
			} 	      	         	         	         	         	         	         	         	
          }//if true
         //****************** CF SECTION ***************************************
         //*********************************************************************
     	IloLinearNumExpr cf = cplex.linearNumExpr();				             	    
     	IloLinearNumExpr cf1 = cplex.linearNumExpr();  //LHS			             	    
       	IloLinearNumExpr cf2 = cplex.linearNumExpr(); //RHS				             	    
	   	IloLinearNumExpr cf3 = cplex.linearNumExpr();				             	    
	   	IloLinearNumExpr cf4 = cplex.linearNumExpr();		
       	//IloLinearNumExpr zgt = cplex.linearNumExpr();
       	
         for (int t = 0; t < main.simParams.getMRPPlanningHorizon(); t++) {	                 	        	    
    	    //Pgt smaller Wgt - Constraint for single item qty
    	    //zgt = cplex.linearNumExpr();
        	 for (int pp = 0; pp < itemsToPlan.size(); pp++) {        	  			
					//merk dir, dass die weiter unten verwendet werden
					//double setupProption = 18.0/106.0;
					double setupProption = 0;
					
	         		cf.addTerm(itemsToPlan.get(pp).getItem().getRouting().getEProcessingTime()+setupProption,P[pp][t]);	         		
	         		
	         		if(get_Main().simParams.getCFSegments() > 0){	         		

	         			cf1.addTerm(itemsToPlan.get(pp).getItem().getRouting().getEProcessingTime()+setupProption,P[pp][t]); 	         		        		
         				cf2.addTerm(itemsToPlan.get(pp).getItem().getRouting().getEProcessingTime()+setupProption,W[pp][t]);         			         		        			         			
            			
            			//zgt.addTerm(1.0, Z[pp][t]);
	        			         			
         			}
         			
         			cf3.addTerm(itemsToPlan.get(pp).getItem().getRouting().getEProcessingTime()+setupProption,P[pp][t]);         		
         			cf4.addTerm(itemsToPlan.get(pp).getItem().getRouting().getEProcessingTime()+setupProption,W[pp][t]);
         			
         			
         			//***************** Ppt, <= Wp,t ***********************        			         		         			
         			cplex.addLe(
         				cplex.sum(P[pp][t],0),//LHS         			
        				cplex.sum(W[pp][t],0));//RHS         			
        			//****************************************
        			
        			
        			//****************************************
					for (int i = 0; i < numberSegments; i++) {
					    traceln("Setuptime: " + setupTime);
					    slopes[i] = 1;
					    intercepts[i] = 0.1;
					    // cplex.addLe defines a constraint with a left-hand side (LHS) and right-hand side (RHS)
					    cplex.addLe(
					        cplex.sum(cf1, cplex.prod(setupTime, sumRIs[t])), // LHS
					        cplex.sum(
					            cplex.sum(
					                cplex.prod(Math.max(slopes[i], 0), cplex.sum(cf2, cplex.prod(setupTime, sumRIs[t]))),
					                cplex.prod(intercepts[i], Z[pp][t])
					            ),
					            C[t]
					        ) // RHS
					    );
					    
					    traceln("Slope (x): " + slopes[i] + " Y-intercept (d): " + intercepts[i]);
					}
        			//*****************************************
		        			         		         				
        				        				        				        			        			        				
        	  }//for (int pp = 0; pp < itemsToPlan.size(); pp++) {        	  			
        	            	         	  
         	  
         	  // **************** PL und Lt ausgeben *********************
         	  //keine constraints werden spter so auch nicht wiedervendet
         	  cplex.addEq(PL[t],cf);
         	  cplex.addEq(L[t],cf2);
         	  //*********************************************************       	           	           	           	  
         	  
         	  /******** PLt <=MC+Ct (Eq14) ************/
         	  //This is also the reason why in the .lp file the maximum capacity is not available for t=0
         	  if(t==0){         	           	           	           	  
         	  		cplex.addLe(cf,         	  
         	  		cplex.sum(0,C[t]));	//RHS
         	  	}else{         	  	
         	  		cplex.addLe(cplex.sum(cf,cplex.prod(setupTime,sumRIs[t])),         	  
         	  		cplex.sum(maxCapacity,C[t]));	//RHS
         	  	}
         	           	           	           	  		         	           	           	  
         	           	           	  
			  //represent CF as k*x + d -> 
			  if(get_Main().simParams.getCFSegments() == 0){
			  	numberSegments = 0;			  	
			  }
			  
	           	           	  			           	  
         	  /******************************* PLt <= Lt + Ct (Eq18) *********************/
         	  //Constraint Pl musst be smaller as SL for all t         	           	  
         	  
         	  cplex.addLe(
         	  	cplex.sum(cf3,cplex.prod(setupTime,sumRIs[t])), //LHS         	  
	         	cplex.sum(cplex.sum(cf4,cplex.prod(setupTime,sumRIs[t])),C[t]));         	  	         		         		         		         	         		         	
	          //***************************************************************************
         	  
			  cf.clear();
			  cf1.clear();
 			  cf2.clear();
 			  cf3.clear();
 			  cf4.clear();
         }


			// Create a two-dimensional array of IloNumVars
            int numRows = iQd.size(); // Assuming iQd is a list or array
                        
            // ... Initialize and populate the RI array with IloNumVars ...

            // Find the variable by name in the RI array
            traceln("iQd size: " + iQd.size());
            String targetVariableName = "noRelease";
            boolean isVariableFound = false;
            IloNumVar foundVariable = null;

            for (int i = 0; i < numRows; i++) {
                for (int j = 1; j < RI[i].length-1; j++) {
                    IloNumVar var = RI[i][j];
                    if (var.getName().equals(targetVariableName)) {
                        isVariableFound = true;
                        foundVariable = var;
                        break;
                    }
                }
                if (isVariableFound) {
                    break;
                }
            }
            
            if (isVariableFound) {
                // Add a constraint to enforce the found variable to be zero
                traceln("Yes found set no release to 0");                
                foundVariable.setName("noRelease");                                
                cplex.addEq(foundVariable, 0);
            }
            
            //All Entries represent Running Orders. So the associated
            //RI_...1 must be set to one
            
                                    
            int numberOpenOrders = runningOrders.size();
            for(SpecialObject o : runningOrders){
            	traceln(o.getItem() + " " + o.getQuantity() + " " + o.getQuantityRunning());
            }
            
            
            traceln("Count Running Orders: " + numberOpenOrders);
            traceln("RI length: " + RI.length);
            if(iQd.size() > 0){
            for (int i = 0; i < iQd.size(); i++) {
            	isVariableFound = false;            	
            	if(iQd.get(i).getQuantityRunning() > 0){
            		traceln("search " + iQd.get(i).getItem() + " " + iQd.get(i).getDueDate() + " " + iQd.get(i).getQuantity() + " " + iQd.get(i).getQuantityRunning());
	            	for(int a=0; a < iQd.size(); a++){
	            	for (int j = 1; j < RI[a].length; j++) {
	            	
	            		//"RI_103_13_106.0_0R103_0"
	            					                                		
	            	    String[] RiSplitted = RI[a][j].getName().split("_");
				        //traceln(RI[a][j].getName().split("_"));
	                    
	                    IloNumVar var = RI[a][j];
	                    
	                    if(!var.getName().equals("noRelease")){
	                    	
	                    	targetVariableName = "RI_" + iQd.get(i).getItem() + "_" + (int) iQd.get(i).getDueDate() + "_" + 
	                    	iQd.get(i).getQuantity() + "_1" + "R" +  iQd.get(i).getItem() + "_1";
	                    
	                    	//traceln("Running Order Target Name ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~: " + targetVariableName);
	                    
		                    if (var.getName().equals(targetVariableName)) {
		                        isVariableFound = true;
		                        foundVariable = var;
		                        break;
		                    }//if
		                 }//if
	                }//for
	                
	                if(isVariableFound){
	                	break;
	                }
	                
	               }//for                         
				}//if
				                
                if (isVariableFound) {	                	                	                
	                cplex.addEq(foundVariable, 1);
	                traceln("Release Variable found " + foundVariable.getName() + " set to 1");
	                isVariableFound = false;
            	}
            }//for
            }//if
                                                               
    
    //cplex.deleteNames();
    
    //if(time() == 0)
    if(Tools.Log_CF_Optimization_Values){                 
		cplex.exportModel("model/NewModel_" + time() + "_" + bomLevel + "_" + firstBomItem.getItem() +".lp");
	}	
	//cplex.writeSolution("model/NewModel_" + time() + "_" + bomLevel + ".sol");

	//cplex.setParam(IloCplex.BooleanParam.PreInd, true);
	//0.05 were to hard ... 0.1 before	
	
	//cplex.setParam(IloCplex.Param.MIP.Tolerances.MIPGap, 0.1);
	//cplex.setParam(IloCplex.IntParam.DataCheck, 2);	
	cplex.setParam(IloCplex.IntParam.WorkMem, 2000);
	cplex.setParam(IloCplex.Param.Threads, 4);
	

	if(cplex.solve() && Tools.Log_CF_Optimization_Values){
		    
		    System.out.println("Solution status: " + cplex.getStatus());
            System.out.println();
            System.out.println("Objective Value = " + cplex.getObjValue());
          
            System.out.println("Pieces: Wip, X, Release, P");
            System.out.println("Minutes: PL L, MC, CF1, CF2, CF3");
            System.out.println("\tp\tTime\tt\tWip\tX\tRelease\tP\tPL\tL\tMC\tCF1\tCF2\tCF3\tInv\tIBl\tWB\tObjPP\tCt\tBt\tPTime\tSTime\tPL\tLt\tICo\tWCo\tBco\tCo\tZt");
          	
            int[] t_sum_wip = new int[get_Main().simParams.getMRPPlanningHorizon()];
            int[] t_sum_pl = new int[get_Main().simParams.getMRPPlanningHorizon()];
            int[] t_sum_l = new int[get_Main().simParams.getMRPPlanningHorizon()];
            int[] t_sum_load = new int[get_Main().simParams.getMRPPlanningHorizon()];
            int[] t_sum_x = new int[get_Main().simParams.getMRPPlanningHorizon()];
            int[] t_sum_r = new int[get_Main().simParams.getMRPPlanningHorizon()];
            int[] t_sum_p = new int[get_Main().simParams.getMRPPlanningHorizon()];
            int[] t_sum_z = new int[get_Main().simParams.getMRPPlanningHorizon()];
          	
            for (int p = 0; p < itemsToPlan.size(); p++) {
                        	
               for (int t = 0; t < get_Main().simParams.getMRPPlanningHorizon(); t++) {
               
               double inventoryBalance = 0;
               double wipBalance = 0;

               if(t>0){
                  inventoryBalance = cplex.getValue(I[p][t-1])-X[p][t]+cplex.getValue(P[p][t-1]) - cplex.getValue(B[p][t-1]) + cplex.getValue(B[p][t]);
                  wipBalance = cplex.getValue(W[p][t-1])+cplex.getValue(R[p][t])-cplex.getValue(P[p][t-1]);               
               }
               		
               	  double lt = cplex.getValue(W[p][t])*itemsToPlan.get(p).getItem().getRouting().getEProcessingTime();
               	  double pl = cplex.getValue(P[p][t])*itemsToPlan.get(p).getItem().getRouting().getEProcessingTime();               	                 	  
               	  
               	  double objectivePerPeriod = cplex.getValue(W[p][t]) * itemsToPlan.get(p).getItem().getHoldingCostsWIP() + 
               	  							  cplex.getValue(I[p][t]) * itemsToPlan.get(p).getItem().getHoldingCosts() + 
               	  							  cplex.getValue(B[p][t]) * itemsToPlan.get(p).getItem().getBacklogCosts() +
               	  							  cplex.getValue(C[t]) * oCosts;  
               	  							  
               	  							  
               	 // traceln(cplex.getValue(W[p][t]) + "*" + itemsToPlan.get(p).getItem().getHoldingCostsWIP() + " = " + cplex.getValue(W[p][t]) * itemsToPlan.get(p).getItem().getHoldingCostsWIP());							               	  
               	 // traceln(cplex.getValue(I[p][t]) + "*" + itemsToPlan.get(p).getItem().getHoldingCosts() + " = "  + cplex.getValue(I[p][t]) * itemsToPlan.get(p).getItem().getHoldingCosts());							               	  
               	 // traceln(cplex.getValue(B[p][t]) + "*" + itemsToPlan.get(p).getItem().getBacklogCosts() + " = " + cplex.getValue(B[p][t]) * itemsToPlan.get(p).getItem().getBacklogCosts());							               	  
               	 // traceln(cplex.getValue(C[t]) + "*" + oCosts + " = " + cplex.getValue(C[t]) * oCosts);							               	  
               	  
               	  int slope2 = -99;
               	  int slope3 = -99;
               	  
               	  if(selectedSegments.size() == 2){
               	  	slope2 = (int)(slopes[1]*lt+intercepts[1]);
               	  }
               	  
              	  if(selectedSegments.size() == 3){
               	  	slope3 = (int)(slopes[2]*lt+intercepts[2]);
               	  }
               	                 	  
               	  int wipForPrintLn = (int)cplex.getValue(W[p][t]);  
               	  
               	  boolean zPt_Exists = true;// OptimizationResult.checkVariableExists(cplex, "Z["+p+"]["+t+"]"); 
         	                 	                 	  
               	  double zPTValue = OptimizationResult.getValueOrDefault(cplex, Z, p, t, 0.0);
               	  
                  System.out.println("\t" + itemsToPlan.get(p).getItem().getItem() +
                                     "\t" + (time() + t -1) +
                                     "\t" + t +                                     
                                     "\t" + (int)Math.round(wipForPrintLn) +
                                     "\t" + X[p][t] +
                                     "\t" + (int)Math.round(cplex.getValue(R[p][t])) +                                            
                                     "\t" + cplex.getValue(P[p][t]) +
                                     //"\t" + (int)Math.round(pl) +
                                     //"\t" + (int)Math.round(lt) +                                     
                                     "\t" + cplex.getValue(PL[t]) +      
                                     "\t" + cplex.getValue(L[t])  +
                                     "\t" + maxCapacity + 
                                     "\t" + (int)(slopes[0]*lt+intercepts[0]) + 
                                     "\t" + slope2 + 
                                     "\t" + slope3 +                                      
                                     "\t" + Math.round(cplex.getValue(I[p][t])) +
                                     "\t" + Math.round(inventoryBalance) +
                                     "\t" + (int)Math.round(wipBalance) +
                                     "\t" + (int)Math.round(objectivePerPeriod) +
                                     "\t" + Math.round(cplex.getValue(C[t])) +
                                     "\t" + (int)cplex.getValue(B[p][t]) + 
                                     "\t" + itemsToPlan.get(p).getItem().getRouting().getEProcessingTime() +
                                     "\t" + itemsToPlan.get(p).getItem().getRouting().getESetupTime()  +
                                     "\t" + cplex.getValue(PL[t]) +      
                                     "\t" + cplex.getValue(L[t])  +
                                     "\t" + (int)itemsToPlan.get(p).getItem().getHoldingCosts() +
                                     "\t" + (int)itemsToPlan.get(p).getItem().getHoldingCostsWIP() +
                                     "\t" + (int)itemsToPlan.get(p).getItem().getBacklogCosts() +
                                     "\t" + (int)oCosts +
                                     "\t" + zPTValue                                                                            
                                     );                                                                                                 
            
            		//t_sum_wip[t] += wipForPrintLn;
            		
            		t_sum_x[t] += X[p][t];            		
            		t_sum_wip[t] += (int)cplex.getValue(W[p][t]) ;
            		t_sum_r[t] += (int)Math.round(cplex.getValue(R[p][t]));            		
            		t_sum_p[t] += (int)cplex.getValue(P[p][t]);
            		t_sum_z[t] += zPTValue;
            		
            		//if(t==0){
            			t_sum_pl[t] = (int)cplex.getValue(PL[t]);
            			t_sum_l[t] = (int)cplex.getValue(L[t]);
            		//}
            			
            		t_sum_load[t] += lt;
	                                    
			if(OptimizationResult.WRITE_OPTIMIZATION_RESULTS_TO_XLXS){                    
                    OptimizationResult optResult = new OptimizationResult(                                        
                                        
	                   					itemsToPlan.get(p).getItem().getItem(),
	                                     (time() + t -1),
	                                     t,                                     
	                                     (int)Math.round(wipForPrintLn),
	                                     X[p][t],
	                                     Math.round(cplex.getValue(R[p][t])),                                            
	                                     cplex.getValue(P[p][t]),
	                                     cplex.getValue(PL[t]),      
	                                     cplex.getValue(L[t]),
	                                      maxCapacity,
	                                     (int)(slopes[0]*lt+intercepts[0]),
	                                      slope2,
	                                      slope3,                                      
	                                      (int)Math.round(cplex.getValue(I[p][t])),
	                                      (int)Math.round(inventoryBalance),
	                                      (int)Math.round(wipBalance),
	                                      (int)Math.round(objectivePerPeriod),
	                                      cplex.getValue(C[t]),
	                                      (int)cplex.getValue(B[p][t]), 
	                                     (double) itemsToPlan.get(p).getItem().getRouting().getEProcessingTime(),
	                                     (double) itemsToPlan.get(p).getItem().getRouting().getESetupTime(),
	                                     cplex.getValue(PL[t]),      
	                                     cplex.getValue(L[t]),
	                                     (int)itemsToPlan.get(p).getItem().getHoldingCosts(),
	                                     (int)itemsToPlan.get(p).getItem().getHoldingCostsWIP(),
	                                     (int)itemsToPlan.get(p).getItem().getBacklogCosts(),
	                                     (int)oCosts,
	                                     zPTValue                                                                                                                                                           
	                    );
                                                            
	                    get_Main().optimizationResults.add(optResult);                                                      
	                 }   
               }                              
            }
            
            System.out.println("\n");
            System.out.println("\tTime\tt\tX\tWip\tR\tP\tPL\tL\tZ");           
            for(int t = 0; t < get_Main().simParams.getMRPPlanningHorizon(); t++) {
            
            	System.out.println(
            		"\t" + (time() + t) +
       				"\t" + t +           
       				"\t" + t_sum_x[t] + 		
            		"\t" + t_sum_wip[t] +
            		"\t" + t_sum_r[t] +
            		"\t" + t_sum_p[t] +
	           		"\t" + t_sum_pl[t] +
            		"\t" + t_sum_l[t] +
            		"\t" + t_sum_z[t]            		           	
            	);            
            }
                 	  
            
            //if(OptimizationResult.WRITE_OPTIMIZATION_RESULTS_TO_XLXS)
			//OptimizationResult.WriteXlsxOptimizationResults(get_Main().optimizationResults, get_Main().simParams);            
            	//traceln("size +++++++++++ " + get_Main().optimizationResults.size());
            
		}else{
			traceln("NO Solution " + cplex.getStatus());
		}															
        	
        	for (int p = 0; p < iQd.size(); p++) {        	        
               for (int t = 1; t < leadtimeHorizon; t++) {   
            				            
            				//traceln("da vor qty " + p + " " + t + " " + RI[p][t].getName());            				            				
					        					        				        
					        if(RI[p][t].getName() != "noRelease"){
					        						        
					        double qty = cplex.getValue(RI[p][t]);    			            			            		            
					        //traceln(qty);
					        //traceln("da for if");				               					        
							if(qty > 0.9){
					        //traceln("da");				               					        
								
								//traceln("qty " + qty + " " + RI[p][t].getName());
								
								
								//if we have a running order, we have to reduce the release qty, as it was only required for the decision of release qty
			                    //but the qty itself is already considered for production.
			                    //traceln("X[" + p + "," + t + "] " + X[p][t] + " qty " + iQd.get(p).getQuantity() + " Running Orders Qty: " + iQd.get(p).getQuantityRunning());	        				        			        		
			                    
			                    String[] RiSplitted = RI[p][t].getName().split("_");
			                    traceln(RI[p][t].getName().split("_"));
			                    
			                    double qtyXt = Double.parseDouble(RiSplitted[3]);
			                    int itemIntTmp = Integer.parseInt(RiSplitted[1]);
			                    int plannedEnd = Integer.parseInt(RiSplitted[2]);
			                    			                    			                    			                    
			                    SpecialObject sp = iQd.stream().filter(e -> e.getItem() == itemIntTmp && e.getDueDate() == plannedEnd).findFirst().get();
			                    
			                    //traceln("X qty " + iQd.get(p).getQuantity() + " Running Orders Qty: " + iQd.get(p).getQuantityRunning() + " item " + iQd.get(p).getItem() + "DD " + iQd.get(p).getDueDate());	        				        			        					                    
			                    traceln("Xqtyn " + qtyXt + " Running Orders Qty: " + sp.getQuantityRunning() + " item " + sp.getItem() + " DD " + sp.getDueDate());
			                    
			                    //double qtyFinal = Math.ceil(iQd.get(p).getQuantity()-iQd.get(p).getQuantityRunning());
			                    double qtyFinal = Math.ceil(qtyXt - sp.getQuantityRunning());
			                    
			                    traceln("Final Qty: " + qtyFinal);
			                    //traceln("Final QtyN: " + qtyFinalN);
			                    if(qtyFinal > 0){
			                    
			                    	
			                    				                    
				                    ProductionOrder order = new ProductionOrder();			                    			                    
				                    
				                    order.setQuantity(qtyFinal);			                    			                    
				                    
				                    traceln("Set Production Order Qty: " + order.getQuantity());
				                    order.setCreatedAt(time());
												                    				                    								
									//int itemIntTmp = iQd.get(p).getItem();
										
				                    //Item item = get_Main().items.stream().filter(e -> e.getItem() == itemIntTmp).findFirst().get();																		                     
				                    Item item = get_Main().items.stream().filter(e -> e.getItem() == itemIntTmp).findFirst().get();																		                     
				                    
				                    order.setOrderId(get_Main().prodOrderId++);
				                    order.setItem(item);
				                                                                                                                                  
									order.setPlannedCapacity(Routing.GetPlannedCapacityPerItem(get_Main().routings, order.getItem(), get_Main().simParams, order));
									
									//order.setPlannedCapacity(Routing.GetPlannedCapacityPerItem(routingList, order.getItem(), simParams, order));
									order.setPlannedSetupTime(Routing.GetPlannedSetupTimePerItem(get_Main().routings, order.getItem(), get_Main().simParams, order));								
				                    
				                    int minimumRoutingStep = Routing.GetMinimumStep(get_Main().routings, order.getItem() , get_Main().simParams);
									int maximumRoutingStep = Routing.GetMaximumStep(get_Main().routings, order.getItem() , get_Main().simParams);
							
									order.setMinimumRoutingStep(minimumRoutingStep);
									order.setMaximumRoutingStep(maximumRoutingStep);			
									order.setCurrentRoutingStep(minimumRoutingStep);                                        			                    			                    
				                                                            
				                    //order.setQuantity(Math.round(iQd.get(p).getQuantity()));
				                    
				                    //traceln("################################## " + iQd.get(p).getQuantity());
				                    				                    				                    				                    
				                    //get the start and end dates from the RI decision variables			                    
				                    
				                    
				                    //order.setPlannedStart(max(Integer.parseInt(RiSplitted[5]) + time() - item.getSafetyLeadTime(), time()));
				                    //order.setPlannedStart(Integer.parseInt(RiSplitted[5] + time());
	
				                    //safety leadtime for stochastic scenario
				                    //order.setPlannedStart(max(Integer.parseInt(RiSplitted[5]) + time() - 1, time()));
				                    
				                   // order.setPlannedStart(max(Integer.parseInt(RiSplitted[5]) + time() - 1, time()));
				                    
				                    //Optimization Starts with 0, so we have to subract -1 from the result to meet the correct MRP Periods
				                    order.setPlannedStart(max(Integer.parseInt(RiSplitted[5]) + time() - 1, time()));
				                    order.setPlannedEnd(Integer.parseInt(RiSplitted[2]) + time() - 1);
				                    
				                    traceln("Planned Start: " + order.getPlannedStart() +  " Planne End:" + order.getPlannedEnd() + " Time " + time());			                    			                            
				                    
				                    long exists = 0;				
				                                   			                    
				                    if(order.getPlannedStart() < time())
				                    	exists = 1;			                    											
					                    if(exists == 0){
					                    	//traceln("Production Order Added");														                    
						                    Routing routingObject = get_Main().routings.stream().filter(e -> e.getItem().getItem() == order.getItem().getItem()).findFirst().get();			
											order.setRouting(routingObject);
											order.setStatus(ProductionOrder.PRODUCTION_ORDER_STATUS_UNPROCESSED);
						                    
						                    get_Main().productionOrders.add(order);	                    						
															                    
					                    }//if
					                }    
		                    	}// if qty	
		                    	}	                    
		                 }//for            
		            }//for
                        
        if(false) {
			traceln("Production Orders from Optmization Before Removing");
			traceln(ProductionOrder.GetCSVHeader());
			
	        for (ProductionOrder order: get_Main().productionOrders) {
	           traceln(ProductionOrder.GetCSVString(order));
	        }        
			
	        //get_Main().productionOrders.removeIf(e -> e.getPlannedStart() > time());
	
	        traceln("Production Orders from Optmization FOR SIMULATION");
	        traceln(ProductionOrder.GetCSVHeader());
	
	        for (ProductionOrder order: get_Main().productionOrders) {
	            traceln(ProductionOrder.GetCSVString(order));
	        }        
	        traceln("**************************");                							
        }
		
		//get_Main().Function_OrderRelease();
		
		cplex.deleteNames();        
    	if(Tools.Log_CF_Optimization_Values){                 
			cplex.exportModel("model/NV/NewModel" + time() + "_" + bomLevel + ".lp");
		}			
		cplex.end();
	}				
	catch (IloException exc) {
         System.err.println("Concert exception '" + exc.getMessage() + "' caught");
         System.exit(-1);
    }
    //catch (ProblemFoundException exc) {
      //   System.err.println("Expection'" + exc.getMessage() + "' caught");
         //System.exit(-1);
    //}
    
return 0;


]]></Body>
				</Function>
			</Functions>
			<AgentLinks>
				<AgentLink>
					<Id>1652788218455</Id>
					<Name><![CDATA[connections]]></Name>
					<X>50</X><Y>-50</Y>
					<Label><X>15</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<HandleReceiveInConnections>false</HandleReceiveInConnections>
					<AgentLinkType>COLLECTION_OF_LINKS</AgentLinkType>
					<AgentLinkBidirectional>true</AgentLinkBidirectional>
					<MessageType><![CDATA[Object]]></MessageType>
					<LineStyle>SOLID</LineStyle>
					<LineWidth>1</LineWidth>
					<LineColor>-16777216</LineColor>
					<LineZOrder>UNDER_AGENTS</LineZOrder>
					<LineArrow>NONE</LineArrow>
					<LineArrowPosition>END</LineArrowPosition>
				</AgentLink>
			</AgentLinks>

			<ContainerLinks>
				<ContainerLink>
					<Id>1655207886949</Id>
					<Name><![CDATA[main]]></Name>
					<X>50</X><Y>-100</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<ActiveObjectClass>
						<PackageName><![CDATA[simopt]]></PackageName>
						<ClassName><![CDATA[Main]]></ClassName>
					</ActiveObjectClass>
				</ContainerLink>
			</ContainerLinks>

			<Presentation>
				<Level>
					<Id>1652788218459</Id>
					<Name><![CDATA[level]]></Name>
					<X>0</X><Y>0</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>true</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>false</ShowLabel>
					<DrawMode>SHAPE_DRAW_2D3D</DrawMode>
					<Z>0</Z>
					<LevelVisibility>DIM_NON_CURRENT</LevelVisibility>


				</Level>
			</Presentation>

		</ActiveObjectClass>
		<!--   =========   Active Object Class   ========  -->
		<ActiveObjectClass>
			<Id>1653365883864</Id>
			<Name><![CDATA[ClearingFunctionAgent]]></Name>
			<Generic>false</Generic>
			<GenericParameter>
				<Id>1653365883862</Id>
				<Name><![CDATA[1653365883862]]></Name>
				<GenericParameterValue Class="CodeValue">
					<Code><![CDATA[T extends Agent]]></Code>
				</GenericParameterValue>
				<GenericParameterLabel><![CDATA[Generic parameter:]]></GenericParameterLabel>
			</GenericParameter>
			<FlowChartsUsage>ENTITY</FlowChartsUsage>
			<SamplesToKeep>100</SamplesToKeep>
			<LimitNumberOfArrayElements>false</LimitNumberOfArrayElements>
			<ElementsLimitValue>100</ElementsLimitValue>
			<MakeDefaultViewArea>true</MakeDefaultViewArea>
			<SceneGridColor/>
			<SceneBackgroundColor/>
			<SceneSkybox>null</SceneSkybox>
			<AgentProperties>
				<EnvironmentDefinesInitialLocation>true</EnvironmentDefinesInitialLocation>
				<RotateAnimationTowardsMovement>true</RotateAnimationTowardsMovement>
				<RotateAnimationVertically>false</RotateAnimationVertically>
				<VelocityCode Class="CodeUnitValue">
					<Code><![CDATA[10]]></Code>
					<Unit Class="SpeedUnits"><![CDATA[MPS]]></Unit>
				</VelocityCode>
				<PhysicalLength Class="CodeUnitValue">
					<Code><![CDATA[1]]></Code>
					<Unit Class="LengthUnits"><![CDATA[METER]]></Unit>
				</PhysicalLength>
				<PhysicalWidth Class="CodeUnitValue">
					<Code><![CDATA[1]]></Code>
					<Unit Class="LengthUnits"><![CDATA[METER]]></Unit>
				</PhysicalWidth>
				<PhysicalHeight Class="CodeUnitValue">
					<Code><![CDATA[1]]></Code>
					<Unit Class="LengthUnits"><![CDATA[METER]]></Unit>
				</PhysicalHeight>
			</AgentProperties>
			<EnvironmentProperties>
					<EnableSteps>false</EnableSteps>
					<StepDurationCode Class="CodeUnitValue">
						<Code><![CDATA[1.0]]></Code>
						<Unit Class="TimeUnits"><![CDATA[SECOND]]></Unit>
					</StepDurationCode>
					<SpaceType>CONTINUOUS</SpaceType>
					<WidthCode><![CDATA[500]]></WidthCode>
					<HeightCode><![CDATA[500]]></HeightCode>
					<ZHeightCode><![CDATA[0]]></ZHeightCode>
					<ColumnsCountCode><![CDATA[100]]></ColumnsCountCode>
					<RowsCountCode><![CDATA[100]]></RowsCountCode>
					<NeigborhoodType>MOORE</NeigborhoodType>
					<LayoutType>USER_DEF</LayoutType>
					<NetworkType>USER_DEF</NetworkType>
					<ConnectionsPerAgentCode><![CDATA[2]]></ConnectionsPerAgentCode>
					<ConnectionsRangeCode><![CDATA[50]]></ConnectionsRangeCode>
					<NeighborLinkFractionCode><![CDATA[0.95]]></NeighborLinkFractionCode>
					<MCode><![CDATA[10]]></MCode>
			</EnvironmentProperties>
			<DatasetsCreationProperties>
				<AutoCreate>true</AutoCreate>
					<OccurrenceAtTime>true</OccurrenceAtTime>
					<OccurrenceDate>1653379200000</OccurrenceDate>
					<OccurrenceTime Class="CodeUnitValue">
						<Code><![CDATA[0]]></Code>
						<Unit Class="TimeUnits"><![CDATA[DAY]]></Unit>
					</OccurrenceTime>
					<RecurrenceCode Class="CodeUnitValue">
						<Code><![CDATA[1]]></Code>
						<Unit Class="TimeUnits"><![CDATA[DAY]]></Unit>
					</RecurrenceCode>
			</DatasetsCreationProperties>
			<ScaleRuler>
				<Id>1653365883860</Id>
				<Name><![CDATA[scale]]></Name>
				<X>0</X><Y>-150</Y>
				<PublicFlag>false</PublicFlag>
				<PresentationFlag>false</PresentationFlag>
				<ShowLabel>false</ShowLabel>
				<DrawMode>SHAPE_DRAW_2D3D</DrawMode>
				<Length>100</Length>
				<Rotation>0</Rotation>
				<ScaleType>BASED_ON_LENGTH</ScaleType>
				<ModelLength>10</ModelLength>
				<LengthUnits>METER</LengthUnits>
				<Scale>10</Scale>
				<InheritedFromParentAgentType>true</InheritedFromParentAgentType>
			</ScaleRuler>
			<CurrentLevel>1653365883863</CurrentLevel>
			<ConnectionsId>1653365883859</ConnectionsId>
			<Variables>
				<Variable Class="PlainVariable">
					<Id>1671995861350</Id>
					<Name><![CDATA[varStage1]]></Name>
					<X>70</X><Y>30</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Properties SaveInSnapshot="true" Constant="false" AccessType="public" StaticVariable="false">
						<Type><![CDATA[double]]></Type>        
					</Properties>
				</Variable>
				<Variable Class="PlainVariable">
					<Id>1671995872243</Id>
					<Name><![CDATA[varStage2]]></Name>
					<X>80</X><Y>430</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Properties SaveInSnapshot="true" Constant="false" AccessType="public" StaticVariable="false">
						<Type><![CDATA[double]]></Type>        
					</Properties>
				</Variable>
				<Variable Class="PlainVariable">
					<Id>1671996274956</Id>
					<Name><![CDATA[varStage3]]></Name>
					<X>80</X><Y>850</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Properties SaveInSnapshot="true" Constant="false" AccessType="public" StaticVariable="false">
						<Type><![CDATA[double]]></Type>        
					</Properties>
				</Variable>
				<Variable Class="PlainVariable">
					<Id>1671996306706</Id>
					<Name><![CDATA[varStage4]]></Name>
					<X>80</X><Y>1250</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Properties SaveInSnapshot="true" Constant="false" AccessType="public" StaticVariable="false">
						<Type><![CDATA[double]]></Type>        
					</Properties>
				</Variable>
				<Variable Class="PlainVariable">
					<Id>1680098703409</Id>
					<Name><![CDATA[varPLStage1]]></Name>
					<X>640</X><Y>30</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Properties SaveInSnapshot="true" Constant="false" AccessType="public" StaticVariable="false">
						<Type><![CDATA[double]]></Type>        
					</Properties>
				</Variable>
				<Variable Class="PlainVariable">
					<Id>1680099379385</Id>
					<Name><![CDATA[varPLStage2]]></Name>
					<X>650</X><Y>430</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Properties SaveInSnapshot="true" Constant="false" AccessType="public" StaticVariable="false">
						<Type><![CDATA[double]]></Type>        
					</Properties>
				</Variable>
				<Variable Class="PlainVariable">
					<Id>1680099426892</Id>
					<Name><![CDATA[varPLStage3]]></Name>
					<X>650</X><Y>850</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Properties SaveInSnapshot="true" Constant="false" AccessType="public" StaticVariable="false">
						<Type><![CDATA[double]]></Type>        
					</Properties>
				</Variable>
				<Variable Class="PlainVariable">
					<Id>1680099481991</Id>
					<Name><![CDATA[varPLStage4]]></Name>
					<X>650</X><Y>1250</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Properties SaveInSnapshot="true" Constant="false" AccessType="public" StaticVariable="false">
						<Type><![CDATA[double]]></Type>        
					</Properties>
				</Variable>
			</Variables>
			<AnalysisData>
    			<DataSet>
					<Id>1653365995403</Id>
					<Name><![CDATA[dataSetStage1]]></Name>
					<X>70</X><Y>100</Y>
					<Label><X>15</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<AutoUpdate>false</AutoUpdate>
					<OccurrenceAtTime>true</OccurrenceAtTime>
					<OccurrenceDate>1653379200000</OccurrenceDate>
					<OccurrenceTime Class="CodeUnitValue">
						<Code><![CDATA[0]]></Code>
						<Unit Class="TimeUnits"><![CDATA[DAY]]></Unit>
					</OccurrenceTime>
					<RecurrenceCode Class="CodeUnitValue">
						<Code><![CDATA[1]]></Code>
						<Unit Class="TimeUnits"><![CDATA[DAY]]></Unit>
					</RecurrenceCode>
					<FreezeXAxis>false</FreezeXAxis>
					<SamplesToKeep>100</SamplesToKeep>
				</DataSet>
    			<DataSet>
					<Id>1671970441922</Id>
					<Name><![CDATA[dataSetStage2]]></Name>
					<X>80</X><Y>500</Y>
					<Label><X>15</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<AutoUpdate>false</AutoUpdate>
					<OccurrenceAtTime>true</OccurrenceAtTime>
					<OccurrenceDate>1653379200000</OccurrenceDate>
					<OccurrenceTime Class="CodeUnitValue">
						<Code><![CDATA[0]]></Code>
						<Unit Class="TimeUnits"><![CDATA[DAY]]></Unit>
					</OccurrenceTime>
					<RecurrenceCode Class="CodeUnitValue">
						<Code><![CDATA[1]]></Code>
						<Unit Class="TimeUnits"><![CDATA[DAY]]></Unit>
					</RecurrenceCode>
					<FreezeXAxis>false</FreezeXAxis>
					<SamplesToKeep>100</SamplesToKeep>
				</DataSet>
    			<Statistics>
					<Id>1671995710982</Id>
					<Name><![CDATA[statisticStage1]]></Name>
					<X>70</X><Y>60</Y>
					<Label><X>15</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<AutoUpdate>true</AutoUpdate>
					<OccurrenceAtTime>true</OccurrenceAtTime>
					<OccurrenceDate>1672041600000</OccurrenceDate>
					<OccurrenceTime Class="CodeUnitValue">
						<Code><![CDATA[0]]></Code>
						<Unit Class="TimeUnits"><![CDATA[DAY]]></Unit>
					</OccurrenceTime>
					<RecurrenceCode Class="CodeUnitValue">
						<Code><![CDATA[1]]></Code>
						<Unit Class="TimeUnits"><![CDATA[DAY]]></Unit>
					</RecurrenceCode>
					<Discrete>false</Discrete>
				</Statistics>
    			<Statistics>
					<Id>1671995742250</Id>
					<Name><![CDATA[statisticStage2]]></Name>
					<X>80</X><Y>460</Y>
					<Label><X>15</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<AutoUpdate>true</AutoUpdate>
					<OccurrenceAtTime>true</OccurrenceAtTime>
					<OccurrenceDate>1672041600000</OccurrenceDate>
					<OccurrenceTime Class="CodeUnitValue">
						<Code><![CDATA[0]]></Code>
						<Unit Class="TimeUnits"><![CDATA[DAY]]></Unit>
					</OccurrenceTime>
					<RecurrenceCode Class="CodeUnitValue">
						<Code><![CDATA[1]]></Code>
						<Unit Class="TimeUnits"><![CDATA[DAY]]></Unit>
					</RecurrenceCode>
					<Discrete>false</Discrete>
				</Statistics>
    			<DataSet>
					<Id>1671996274959</Id>
					<Name><![CDATA[dataSetStage3]]></Name>
					<X>80</X><Y>920</Y>
					<Label><X>15</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<AutoUpdate>false</AutoUpdate>
					<OccurrenceAtTime>true</OccurrenceAtTime>
					<OccurrenceDate>1653379200000</OccurrenceDate>
					<OccurrenceTime Class="CodeUnitValue">
						<Code><![CDATA[0]]></Code>
						<Unit Class="TimeUnits"><![CDATA[DAY]]></Unit>
					</OccurrenceTime>
					<RecurrenceCode Class="CodeUnitValue">
						<Code><![CDATA[1]]></Code>
						<Unit Class="TimeUnits"><![CDATA[DAY]]></Unit>
					</RecurrenceCode>
					<FreezeXAxis>false</FreezeXAxis>
					<SamplesToKeep>100</SamplesToKeep>
				</DataSet>
    			<Statistics>
					<Id>1671996274962</Id>
					<Name><![CDATA[statisticStage3]]></Name>
					<X>80</X><Y>880</Y>
					<Label><X>15</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<AutoUpdate>true</AutoUpdate>
					<OccurrenceAtTime>true</OccurrenceAtTime>
					<OccurrenceDate>1672041600000</OccurrenceDate>
					<OccurrenceTime Class="CodeUnitValue">
						<Code><![CDATA[0]]></Code>
						<Unit Class="TimeUnits"><![CDATA[DAY]]></Unit>
					</OccurrenceTime>
					<RecurrenceCode Class="CodeUnitValue">
						<Code><![CDATA[1]]></Code>
						<Unit Class="TimeUnits"><![CDATA[DAY]]></Unit>
					</RecurrenceCode>
					<Discrete>false</Discrete>
				</Statistics>
    			<DataSet>
					<Id>1671996306709</Id>
					<Name><![CDATA[dataSetStage4]]></Name>
					<X>80</X><Y>1320</Y>
					<Label><X>15</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<AutoUpdate>false</AutoUpdate>
					<OccurrenceAtTime>true</OccurrenceAtTime>
					<OccurrenceDate>1653379200000</OccurrenceDate>
					<OccurrenceTime Class="CodeUnitValue">
						<Code><![CDATA[0]]></Code>
						<Unit Class="TimeUnits"><![CDATA[DAY]]></Unit>
					</OccurrenceTime>
					<RecurrenceCode Class="CodeUnitValue">
						<Code><![CDATA[1]]></Code>
						<Unit Class="TimeUnits"><![CDATA[DAY]]></Unit>
					</RecurrenceCode>
					<FreezeXAxis>false</FreezeXAxis>
					<SamplesToKeep>100</SamplesToKeep>
				</DataSet>
    			<Statistics>
					<Id>1671996306712</Id>
					<Name><![CDATA[statisticStage4]]></Name>
					<X>80</X><Y>1280</Y>
					<Label><X>15</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<AutoUpdate>true</AutoUpdate>
					<OccurrenceAtTime>true</OccurrenceAtTime>
					<OccurrenceDate>1672041600000</OccurrenceDate>
					<OccurrenceTime Class="CodeUnitValue">
						<Code><![CDATA[0]]></Code>
						<Unit Class="TimeUnits"><![CDATA[DAY]]></Unit>
					</OccurrenceTime>
					<RecurrenceCode Class="CodeUnitValue">
						<Code><![CDATA[1]]></Code>
						<Unit Class="TimeUnits"><![CDATA[DAY]]></Unit>
					</RecurrenceCode>
					<Discrete>false</Discrete>
				</Statistics>
    			<Statistics>
					<Id>1680097971699</Id>
					<Name><![CDATA[statisticPLStage1]]></Name>
					<X>640</X><Y>60</Y>
					<Label><X>15</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<AutoUpdate>true</AutoUpdate>
					<OccurrenceAtTime>true</OccurrenceAtTime>
					<OccurrenceDate>1672041600000</OccurrenceDate>
					<OccurrenceTime Class="CodeUnitValue">
						<Code><![CDATA[0]]></Code>
						<Unit Class="TimeUnits"><![CDATA[DAY]]></Unit>
					</OccurrenceTime>
					<RecurrenceCode Class="CodeUnitValue">
						<Code><![CDATA[1]]></Code>
						<Unit Class="TimeUnits"><![CDATA[DAY]]></Unit>
					</RecurrenceCode>
					<Discrete>true</Discrete>
				</Statistics>
    			<DataSet>
					<Id>1680098179823</Id>
					<Name><![CDATA[dataSetPLStage1]]></Name>
					<X>640</X><Y>100</Y>
					<Label><X>15</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<AutoUpdate>false</AutoUpdate>
					<OccurrenceAtTime>true</OccurrenceAtTime>
					<OccurrenceDate>1653379200000</OccurrenceDate>
					<OccurrenceTime Class="CodeUnitValue">
						<Code><![CDATA[0]]></Code>
						<Unit Class="TimeUnits"><![CDATA[DAY]]></Unit>
					</OccurrenceTime>
					<RecurrenceCode Class="CodeUnitValue">
						<Code><![CDATA[1]]></Code>
						<Unit Class="TimeUnits"><![CDATA[DAY]]></Unit>
					</RecurrenceCode>
					<FreezeXAxis>false</FreezeXAxis>
					<SamplesToKeep>100</SamplesToKeep>
				</DataSet>
    			<Statistics>
					<Id>1680099379388</Id>
					<Name><![CDATA[statisticPLStage2]]></Name>
					<X>650</X><Y>460</Y>
					<Label><X>15</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<AutoUpdate>true</AutoUpdate>
					<OccurrenceAtTime>true</OccurrenceAtTime>
					<OccurrenceDate>1672041600000</OccurrenceDate>
					<OccurrenceTime Class="CodeUnitValue">
						<Code><![CDATA[0]]></Code>
						<Unit Class="TimeUnits"><![CDATA[DAY]]></Unit>
					</OccurrenceTime>
					<RecurrenceCode Class="CodeUnitValue">
						<Code><![CDATA[1]]></Code>
						<Unit Class="TimeUnits"><![CDATA[DAY]]></Unit>
					</RecurrenceCode>
					<Discrete>true</Discrete>
				</Statistics>
    			<DataSet>
					<Id>1680099379392</Id>
					<Name><![CDATA[dataSetPLStage2]]></Name>
					<X>650</X><Y>500</Y>
					<Label><X>15</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<AutoUpdate>false</AutoUpdate>
					<OccurrenceAtTime>true</OccurrenceAtTime>
					<OccurrenceDate>1653379200000</OccurrenceDate>
					<OccurrenceTime Class="CodeUnitValue">
						<Code><![CDATA[0]]></Code>
						<Unit Class="TimeUnits"><![CDATA[DAY]]></Unit>
					</OccurrenceTime>
					<RecurrenceCode Class="CodeUnitValue">
						<Code><![CDATA[1]]></Code>
						<Unit Class="TimeUnits"><![CDATA[DAY]]></Unit>
					</RecurrenceCode>
					<FreezeXAxis>false</FreezeXAxis>
					<SamplesToKeep>100</SamplesToKeep>
				</DataSet>
    			<Statistics>
					<Id>1680099426895</Id>
					<Name><![CDATA[statisticPLStage3]]></Name>
					<X>650</X><Y>880</Y>
					<Label><X>15</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<AutoUpdate>true</AutoUpdate>
					<OccurrenceAtTime>true</OccurrenceAtTime>
					<OccurrenceDate>1672041600000</OccurrenceDate>
					<OccurrenceTime Class="CodeUnitValue">
						<Code><![CDATA[0]]></Code>
						<Unit Class="TimeUnits"><![CDATA[DAY]]></Unit>
					</OccurrenceTime>
					<RecurrenceCode Class="CodeUnitValue">
						<Code><![CDATA[1]]></Code>
						<Unit Class="TimeUnits"><![CDATA[DAY]]></Unit>
					</RecurrenceCode>
					<Discrete>true</Discrete>
				</Statistics>
    			<DataSet>
					<Id>1680099426898</Id>
					<Name><![CDATA[dataSetPLStage3]]></Name>
					<X>650</X><Y>920</Y>
					<Label><X>15</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<AutoUpdate>false</AutoUpdate>
					<OccurrenceAtTime>true</OccurrenceAtTime>
					<OccurrenceDate>1653379200000</OccurrenceDate>
					<OccurrenceTime Class="CodeUnitValue">
						<Code><![CDATA[0]]></Code>
						<Unit Class="TimeUnits"><![CDATA[DAY]]></Unit>
					</OccurrenceTime>
					<RecurrenceCode Class="CodeUnitValue">
						<Code><![CDATA[1]]></Code>
						<Unit Class="TimeUnits"><![CDATA[DAY]]></Unit>
					</RecurrenceCode>
					<FreezeXAxis>false</FreezeXAxis>
					<SamplesToKeep>100</SamplesToKeep>
				</DataSet>
    			<Statistics>
					<Id>1680099481994</Id>
					<Name><![CDATA[statisticPLStage4]]></Name>
					<X>650</X><Y>1280</Y>
					<Label><X>15</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<AutoUpdate>true</AutoUpdate>
					<OccurrenceAtTime>true</OccurrenceAtTime>
					<OccurrenceDate>1672041600000</OccurrenceDate>
					<OccurrenceTime Class="CodeUnitValue">
						<Code><![CDATA[0]]></Code>
						<Unit Class="TimeUnits"><![CDATA[DAY]]></Unit>
					</OccurrenceTime>
					<RecurrenceCode Class="CodeUnitValue">
						<Code><![CDATA[1]]></Code>
						<Unit Class="TimeUnits"><![CDATA[DAY]]></Unit>
					</RecurrenceCode>
					<Discrete>true</Discrete>
				</Statistics>
    			<DataSet>
					<Id>1680099481997</Id>
					<Name><![CDATA[dataSetPLStage4]]></Name>
					<X>650</X><Y>1320</Y>
					<Label><X>15</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<AutoUpdate>false</AutoUpdate>
					<OccurrenceAtTime>true</OccurrenceAtTime>
					<OccurrenceDate>1653379200000</OccurrenceDate>
					<OccurrenceTime Class="CodeUnitValue">
						<Code><![CDATA[0]]></Code>
						<Unit Class="TimeUnits"><![CDATA[DAY]]></Unit>
					</OccurrenceTime>
					<RecurrenceCode Class="CodeUnitValue">
						<Code><![CDATA[1]]></Code>
						<Unit Class="TimeUnits"><![CDATA[DAY]]></Unit>
					</RecurrenceCode>
					<FreezeXAxis>false</FreezeXAxis>
					<SamplesToKeep>100</SamplesToKeep>
				</DataSet>
    			<DataSet>
					<Id>1680104794941</Id>
					<Name><![CDATA[testDs]]></Name>
					<X>1200</X><Y>80</Y>
					<Label><X>15</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<AutoUpdate>false</AutoUpdate>
					<OccurrenceAtTime>true</OccurrenceAtTime>
					<OccurrenceDate>1680163200000</OccurrenceDate>
					<OccurrenceTime Class="CodeUnitValue">
						<Code><![CDATA[0]]></Code>
						<Unit Class="TimeUnits"><![CDATA[DAY]]></Unit>
					</OccurrenceTime>
					<RecurrenceCode Class="CodeUnitValue">
						<Code><![CDATA[1]]></Code>
						<Unit Class="TimeUnits"><![CDATA[DAY]]></Unit>
					</RecurrenceCode>
					<FreezeXAxis>true</FreezeXAxis>
					<SamplesToKeep>1000</SamplesToKeep>
				</DataSet>
    			<DataSet>
					<Id>1680286785762</Id>
					<Name><![CDATA[testDs2]]></Name>
					<X>1250</X><Y>450</Y>
					<Label><X>15</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<AutoUpdate>false</AutoUpdate>
					<OccurrenceAtTime>true</OccurrenceAtTime>
					<OccurrenceDate>1680163200000</OccurrenceDate>
					<OccurrenceTime Class="CodeUnitValue">
						<Code><![CDATA[0]]></Code>
						<Unit Class="TimeUnits"><![CDATA[DAY]]></Unit>
					</OccurrenceTime>
					<RecurrenceCode Class="CodeUnitValue">
						<Code><![CDATA[1]]></Code>
						<Unit Class="TimeUnits"><![CDATA[DAY]]></Unit>
					</RecurrenceCode>
					<FreezeXAxis>true</FreezeXAxis>
					<SamplesToKeep>1000</SamplesToKeep>
				</DataSet>
    			<DataSet>
					<Id>1680286834670</Id>
					<Name><![CDATA[testDs3]]></Name>
					<X>1290</X><Y>870</Y>
					<Label><X>15</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<AutoUpdate>false</AutoUpdate>
					<OccurrenceAtTime>true</OccurrenceAtTime>
					<OccurrenceDate>1680163200000</OccurrenceDate>
					<OccurrenceTime Class="CodeUnitValue">
						<Code><![CDATA[0]]></Code>
						<Unit Class="TimeUnits"><![CDATA[DAY]]></Unit>
					</OccurrenceTime>
					<RecurrenceCode Class="CodeUnitValue">
						<Code><![CDATA[1]]></Code>
						<Unit Class="TimeUnits"><![CDATA[DAY]]></Unit>
					</RecurrenceCode>
					<FreezeXAxis>true</FreezeXAxis>
					<SamplesToKeep>1000</SamplesToKeep>
				</DataSet>
    			<DataSet>
					<Id>1680286877090</Id>
					<Name><![CDATA[testDs4]]></Name>
					<X>1290</X><Y>1270</Y>
					<Label><X>15</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<AutoUpdate>false</AutoUpdate>
					<OccurrenceAtTime>true</OccurrenceAtTime>
					<OccurrenceDate>1680163200000</OccurrenceDate>
					<OccurrenceTime Class="CodeUnitValue">
						<Code><![CDATA[0]]></Code>
						<Unit Class="TimeUnits"><![CDATA[DAY]]></Unit>
					</OccurrenceTime>
					<RecurrenceCode Class="CodeUnitValue">
						<Code><![CDATA[1]]></Code>
						<Unit Class="TimeUnits"><![CDATA[DAY]]></Unit>
					</RecurrenceCode>
					<FreezeXAxis>true</FreezeXAxis>
					<SamplesToKeep>1000</SamplesToKeep>
				</DataSet>
			</AnalysisData>
			<AgentLinks>
				<AgentLink>
					<Id>1653365883859</Id>
					<Name><![CDATA[connections]]></Name>
					<X>50</X><Y>-50</Y>
					<Label><X>15</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<HandleReceiveInConnections>false</HandleReceiveInConnections>
					<AgentLinkType>COLLECTION_OF_LINKS</AgentLinkType>
					<AgentLinkBidirectional>true</AgentLinkBidirectional>
					<MessageType><![CDATA[Object]]></MessageType>
					<LineStyle>SOLID</LineStyle>
					<LineWidth>1</LineWidth>
					<LineColor>-16777216</LineColor>
					<LineZOrder>UNDER_AGENTS</LineZOrder>
					<LineArrow>NONE</LineArrow>
					<LineArrowPosition>END</LineArrowPosition>
				</AgentLink>
			</AgentLinks>

			<ContainerLinks>
				<ContainerLink>
					<Id>1671861033418</Id>
					<Name><![CDATA[main]]></Name>
					<X>50</X><Y>-100</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<ActiveObjectClass>
						<PackageName><![CDATA[simopt]]></PackageName>
						<ClassName><![CDATA[Main]]></ClassName>
					</ActiveObjectClass>
				</ContainerLink>
			</ContainerLinks>

			<Presentation>
				<Level>
					<Id>1653365883863</Id>
					<Name><![CDATA[level]]></Name>
					<X>0</X><Y>0</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>true</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>false</ShowLabel>
					<DrawMode>SHAPE_DRAW_2D3D</DrawMode>
					<Z>0</Z>
					<LevelVisibility>DIM_NON_CURRENT</LevelVisibility>

			<Presentation>
				<Group>
					<Id>1653365883877</Id>
					<Name><![CDATA[factory]]></Name>
					<X>0</X><Y>0</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>false</ShowLabel>
					<DrawMode>SHAPE_DRAW_2D</DrawMode>
					<EmbeddedIcon>false</EmbeddedIcon>
					<Z>0</Z>
					<Rotation>0.0</Rotation>

			<Presentation>
				<Polyline>
					<Id>1653365883879</Id>
					<Name><![CDATA[_ps287]]></Name>
					<X>0</X><Y>15</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>true</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>false</ShowLabel>
					<DrawMode>SHAPE_DRAW_2D3D</DrawMode>
					<EmbeddedIcon>false</EmbeddedIcon>
					<Z>0</Z>
					<ZHeight>10</ZHeight>
					<LineWidth>1</LineWidth>
					<LineColor/>
					<LineMaterial>null</LineMaterial>
					<LineStyle>SOLID</LineStyle>
					<BeginArrowSize>1</BeginArrowSize>
					<BeginArrowStyle>0</BeginArrowStyle>
					<EndArrowSize>1</EndArrowSize>
					<EndArrowStyle>0</EndArrowStyle>
					<FillColor>1342177280</FillColor>
					<FillMaterial>null</FillMaterial>
					<Points>
					   <Point><X>0</X><Y>0</Y><Z>0</Z></Point>
					   <Point><X>6</X><Y>-1</Y><Z>0</Z></Point>
					   <Point><X>4</X><Y>-2</Y><Z>0</Z></Point>
					   <Point><X>10</X><Y>-3</Y><Z>0</Z></Point>
					   <Point><X>8</X><Y>-4</Y><Z>0</Z></Point>
					   <Point><X>14</X><Y>-5</Y><Z>0</Z></Point>
					   <Point><X>12</X><Y>-6</Y><Z>0</Z></Point>
					   <Point><X>14</X><Y>-6</Y><Z>0</Z></Point>
					   <Point><X>16</X><Y>-5</Y><Z>0</Z></Point>
					   <Point><X>18</X><Y>-6</Y><Z>0</Z></Point>
					   <Point><X>16</X><Y>-7</Y><Z>0</Z></Point>
					   <Point><X>16</X><Y>-8</Y><Z>0</Z></Point>
					   <Point><X>12</X><Y>-10</Y><Z>0</Z></Point>
					   <Point><X>-4</X><Y>-2</Y><Z>0</Z></Point>
					</Points>
					<Closed>true</Closed>
				</Polyline>
				<Polyline>
					<Id>1653365883881</Id>
					<Name><![CDATA[_ps288]]></Name>
					<X>-16</X><Y>7</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>true</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>false</ShowLabel>
					<DrawMode>SHAPE_DRAW_2D3D</DrawMode>
					<EmbeddedIcon>false</EmbeddedIcon>
					<Z>0</Z>
					<ZHeight>10</ZHeight>
					<LineWidth>1</LineWidth>
					<LineColor/>
					<LineMaterial>null</LineMaterial>
					<LineStyle>SOLID</LineStyle>
					<BeginArrowSize>1</BeginArrowSize>
					<BeginArrowStyle>0</BeginArrowStyle>
					<EndArrowSize>1</EndArrowSize>
					<EndArrowStyle>0</EndArrowStyle>
					<FillColor>-3065088</FillColor>
					<FillMaterial>null</FillMaterial>
					<Points>
					   <Point><X>0</X><Y>0</Y><Z>0</Z></Point>
					   <Point><X>0</X><Y>-6</Y><Z>0</Z></Point>
					   <Point><X>12</X><Y>0</Y><Z>0</Z></Point>
					   <Point><X>12</X><Y>6</Y><Z>0</Z></Point>
					</Points>
					<Closed>true</Closed>
				</Polyline>
				<Polyline>
					<Id>1653365883883</Id>
					<Name><![CDATA[_ps289]]></Name>
					<X>12</X><Y>-1</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>true</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>false</ShowLabel>
					<DrawMode>SHAPE_DRAW_2D3D</DrawMode>
					<EmbeddedIcon>false</EmbeddedIcon>
					<Z>0</Z>
					<ZHeight>10</ZHeight>
					<LineWidth>1</LineWidth>
					<LineColor/>
					<LineMaterial>null</LineMaterial>
					<LineStyle>SOLID</LineStyle>
					<BeginArrowSize>1</BeginArrowSize>
					<BeginArrowStyle>0</BeginArrowStyle>
					<EndArrowSize>1</EndArrowSize>
					<EndArrowStyle>0</EndArrowStyle>
					<FillColor>-507904</FillColor>
					<FillMaterial>null</FillMaterial>
					<Points>
					   <Point><X>0</X><Y>0</Y><Z>0</Z></Point>
					   <Point><X>-4</X><Y>-2</Y><Z>0</Z></Point>
					   <Point><X>-4</X><Y>2</Y><Z>0</Z></Point>
					</Points>
					<Closed>true</Closed>
				</Polyline>
				<Curve ControlPoints="true">
					<Id>1653365883885</Id>
					<Name><![CDATA[_ps290]]></Name>
					<X>2</X><Y>-4</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>true</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>false</ShowLabel>
					<DrawMode>SHAPE_DRAW_2D</DrawMode>
					<EmbeddedIcon>false</EmbeddedIcon>
					<Z>0</Z>
					<ZHeight>10</ZHeight>
					<LineWidth>1</LineWidth>
					<LineColor/>
					<LineMaterial>null</LineMaterial>
					<LineStyle>SOLID</LineStyle>
					<BeginArrowSize>1</BeginArrowSize>
					<BeginArrowStyle>0</BeginArrowStyle>
					<EndArrowSize>1</EndArrowSize>
					<EndArrowStyle>0</EndArrowStyle>
					<FillColor>-4447488</FillColor>
					<FillMaterial>null</FillMaterial>
					<Points>
					   <Point><X>0</X><Y>0</Y><Z>0</Z></Point>
					   <Point><X>0</X><Y>2</Y><Z>0</Z></Point>
					   <Point><X>-4</X><Y>2</Y><Z>0</Z></Point>
					   <Point><X>-4</X><Y>0</Y><Z>0</Z></Point>
					   <Point><X>-4</X><Y>0</Y><Z>0</Z></Point>
					   <Point><X>-4</X><Y>-10</Y><Z>0</Z></Point>
					   <Point><X>-4</X><Y>-11</Y><Z>0</Z></Point>
					   <Point><X>-4</X><Y>-12</Y><Z>0</Z></Point>
					   <Point><X>0</X><Y>-12</Y><Z>0</Z></Point>
					   <Point><X>0</X><Y>-11</Y><Z>0</Z></Point>
					   <Point><X>0</X><Y>-11</Y><Z>0</Z></Point>
					   <Point><X>0</X><Y>0</Y><Z>0</Z></Point>
					</Points>
					<Closed>true</Closed>
				</Curve>
				<Curve ControlPoints="true">
					<Id>1653365883887</Id>
					<Name><![CDATA[_ps291]]></Name>
					<X>8</X><Y>-1</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>true</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>false</ShowLabel>
					<DrawMode>SHAPE_DRAW_2D</DrawMode>
					<EmbeddedIcon>false</EmbeddedIcon>
					<Z>0</Z>
					<ZHeight>10</ZHeight>
					<LineWidth>1</LineWidth>
					<LineColor/>
					<LineMaterial>null</LineMaterial>
					<LineStyle>SOLID</LineStyle>
					<BeginArrowSize>1</BeginArrowSize>
					<BeginArrowStyle>0</BeginArrowStyle>
					<EndArrowSize>1</EndArrowSize>
					<EndArrowStyle>0</EndArrowStyle>
					<FillColor>-4447488</FillColor>
					<FillMaterial>null</FillMaterial>
					<Points>
					   <Point><X>0</X><Y>0</Y><Z>0</Z></Point>
					   <Point><X>0</X><Y>2</Y><Z>0</Z></Point>
					   <Point><X>-4</X><Y>2</Y><Z>0</Z></Point>
					   <Point><X>-4</X><Y>0</Y><Z>0</Z></Point>
					   <Point><X>-4</X><Y>0</Y><Z>0</Z></Point>
					   <Point><X>-4</X><Y>-10</Y><Z>0</Z></Point>
					   <Point><X>-4</X><Y>-11</Y><Z>0</Z></Point>
					   <Point><X>-4</X><Y>-12</Y><Z>0</Z></Point>
					   <Point><X>0</X><Y>-12</Y><Z>0</Z></Point>
					   <Point><X>0</X><Y>-11</Y><Z>0</Z></Point>
					   <Point><X>0</X><Y>-11</Y><Z>0</Z></Point>
					   <Point><X>0</X><Y>0</Y><Z>0</Z></Point>
					</Points>
					<Closed>true</Closed>
				</Curve>
				<Polyline>
					<Id>1653365883889</Id>
					<Name><![CDATA[_ps292]]></Name>
					<X>-4</X><Y>7</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>true</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>false</ShowLabel>
					<DrawMode>SHAPE_DRAW_2D3D</DrawMode>
					<EmbeddedIcon>false</EmbeddedIcon>
					<Z>0</Z>
					<ZHeight>10</ZHeight>
					<LineWidth>1</LineWidth>
					<LineColor/>
					<LineMaterial>null</LineMaterial>
					<LineStyle>SOLID</LineStyle>
					<BeginArrowSize>1</BeginArrowSize>
					<BeginArrowStyle>0</BeginArrowStyle>
					<EndArrowSize>1</EndArrowSize>
					<EndArrowStyle>0</EndArrowStyle>
					<FillColor>-507904</FillColor>
					<FillMaterial>null</FillMaterial>
					<Points>
					   <Point><X>0</X><Y>0</Y><Z>0</Z></Point>
					   <Point><X>-12</X><Y>-6</Y><Z>0</Z></Point>
					   <Point><X>-8</X><Y>-12</Y><Z>0</Z></Point>
					   <Point><X>-6</X><Y>-11</Y><Z>0</Z></Point>
					   <Point><X>-4</X><Y>-14</Y><Z>0</Z></Point>
					   <Point><X>-2</X><Y>-13</Y><Z>0</Z></Point>
					   <Point><X>0</X><Y>-16</Y><Z>0</Z></Point>
					   <Point><X>12</X><Y>-10</Y><Z>0</Z></Point>
					   <Point><X>12</X><Y>-6</Y><Z>0</Z></Point>
					</Points>
					<Closed>true</Closed>
				</Polyline>
				<Polyline>
					<Id>1653365883891</Id>
					<Name><![CDATA[_ps293]]></Name>
					<X>-4</X><Y>13</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>true</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>false</ShowLabel>
					<DrawMode>SHAPE_DRAW_2D3D</DrawMode>
					<EmbeddedIcon>false</EmbeddedIcon>
					<Z>0</Z>
					<ZHeight>10</ZHeight>
					<LineWidth>1</LineWidth>
					<LineColor/>
					<LineMaterial>null</LineMaterial>
					<LineStyle>SOLID</LineStyle>
					<BeginArrowSize>1</BeginArrowSize>
					<BeginArrowStyle>0</BeginArrowStyle>
					<EndArrowSize>1</EndArrowSize>
					<EndArrowStyle>0</EndArrowStyle>
					<FillColor>-4447488</FillColor>
					<FillMaterial>null</FillMaterial>
					<Points>
					   <Point><X>0</X><Y>0</Y><Z>0</Z></Point>
					   <Point><X>16</X><Y>-8</Y><Z>0</Z></Point>
					   <Point><X>16</X><Y>-14</Y><Z>0</Z></Point>
					   <Point><X>12</X><Y>-12</Y><Z>0</Z></Point>
					   <Point><X>12</X><Y>-16</Y><Z>0</Z></Point>
					   <Point><X>8</X><Y>-10</Y><Z>0</Z></Point>
					   <Point><X>8</X><Y>-14</Y><Z>0</Z></Point>
					   <Point><X>4</X><Y>-8</Y><Z>0</Z></Point>
					   <Point><X>4</X><Y>-12</Y><Z>0</Z></Point>
					   <Point><X>0</X><Y>-6</Y><Z>0</Z></Point>
					</Points>
					<Closed>true</Closed>
				</Polyline>
				<Polyline>
					<Id>1653365883893</Id>
					<Name><![CDATA[_ps294]]></Name>
					<X>0</X><Y>11</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>true</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>false</ShowLabel>
					<DrawMode>SHAPE_DRAW_2D3D</DrawMode>
					<EmbeddedIcon>false</EmbeddedIcon>
					<Z>0</Z>
					<ZHeight>10</ZHeight>
					<LineWidth>1</LineWidth>
					<LineColor/>
					<LineMaterial>null</LineMaterial>
					<LineStyle>SOLID</LineStyle>
					<BeginArrowSize>1</BeginArrowSize>
					<BeginArrowStyle>0</BeginArrowStyle>
					<EndArrowSize>1</EndArrowSize>
					<EndArrowStyle>0</EndArrowStyle>
					<FillColor>-9039360</FillColor>
					<FillMaterial>null</FillMaterial>
					<Points>
					   <Point><X>0</X><Y>0</Y><Z>0</Z></Point>
					   <Point><X>2</X><Y>-1</Y><Z>0</Z></Point>
					   <Point><X>2</X><Y>-4</Y><Z>0</Z></Point>
					   <Point><X>0</X><Y>-3</Y><Z>0</Z></Point>
					</Points>
					<Closed>true</Closed>
				</Polyline>
				<Polyline>
					<Id>1653365883895</Id>
					<Name><![CDATA[_ps295]]></Name>
					<X>4</X><Y>9</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>true</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>false</ShowLabel>
					<DrawMode>SHAPE_DRAW_2D3D</DrawMode>
					<EmbeddedIcon>false</EmbeddedIcon>
					<Z>0</Z>
					<ZHeight>10</ZHeight>
					<LineWidth>1</LineWidth>
					<LineColor/>
					<LineMaterial>null</LineMaterial>
					<LineStyle>SOLID</LineStyle>
					<BeginArrowSize>1</BeginArrowSize>
					<BeginArrowStyle>0</BeginArrowStyle>
					<EndArrowSize>1</EndArrowSize>
					<EndArrowStyle>0</EndArrowStyle>
					<FillColor>-9039360</FillColor>
					<FillMaterial>null</FillMaterial>
					<Points>
					   <Point><X>0</X><Y>0</Y><Z>0</Z></Point>
					   <Point><X>2</X><Y>-1</Y><Z>0</Z></Point>
					   <Point><X>2</X><Y>-4</Y><Z>0</Z></Point>
					   <Point><X>0</X><Y>-3</Y><Z>0</Z></Point>
					</Points>
					<Closed>true</Closed>
				</Polyline>
				<Polyline>
					<Id>1653365883897</Id>
					<Name><![CDATA[_ps296]]></Name>
					<X>8</X><Y>7</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>true</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>false</ShowLabel>
					<DrawMode>SHAPE_DRAW_2D3D</DrawMode>
					<EmbeddedIcon>false</EmbeddedIcon>
					<Z>0</Z>
					<ZHeight>10</ZHeight>
					<LineWidth>1</LineWidth>
					<LineColor/>
					<LineMaterial>null</LineMaterial>
					<LineStyle>SOLID</LineStyle>
					<BeginArrowSize>1</BeginArrowSize>
					<BeginArrowStyle>0</BeginArrowStyle>
					<EndArrowSize>1</EndArrowSize>
					<EndArrowStyle>0</EndArrowStyle>
					<FillColor>-9039360</FillColor>
					<FillMaterial>null</FillMaterial>
					<Points>
					   <Point><X>0</X><Y>0</Y><Z>0</Z></Point>
					   <Point><X>2</X><Y>-1</Y><Z>0</Z></Point>
					   <Point><X>2</X><Y>-4</Y><Z>0</Z></Point>
					   <Point><X>0</X><Y>-3</Y><Z>0</Z></Point>
					</Points>
					<Closed>true</Closed>
				</Polyline>
				<Curve ControlPoints="true">
					<Id>1653365883899</Id>
					<Name><![CDATA[_ps297]]></Name>
					<X>12</X><Y>-1</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>true</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>false</ShowLabel>
					<DrawMode>SHAPE_DRAW_2D</DrawMode>
					<EmbeddedIcon>false</EmbeddedIcon>
					<Z>0</Z>
					<ZHeight>10</ZHeight>
					<LineWidth>1</LineWidth>
					<LineColor>-12187648</LineColor>
					<LineMaterial>null</LineMaterial>
					<LineStyle>SOLID</LineStyle>
					<BeginArrowSize>1</BeginArrowSize>
					<BeginArrowStyle>0</BeginArrowStyle>
					<EndArrowSize>1</EndArrowSize>
					<EndArrowStyle>0</EndArrowStyle>
					<FillColor/>
					<FillMaterial>null</FillMaterial>
					<Points>
					   <Point><X>0</X><Y>0</Y><Z>0</Z></Point>
					   <Point><X>0</X><Y>0</Y><Z>0</Z></Point>
					   <Point><X>0</X><Y>6</Y><Z>0</Z></Point>
					   <Point><X>0</X><Y>6</Y><Z>0</Z></Point>
					   <Point><X>0</X><Y>6</Y><Z>0</Z></Point>
					   <Point><X>-16</X><Y>14</Y><Z>0</Z></Point>
					   <Point><X>-16</X><Y>14</Y><Z>0</Z></Point>
					   <Point><X>-16</X><Y>14</Y><Z>0</Z></Point>
					   <Point><X>-28</X><Y>8</Y><Z>0</Z></Point>
					   <Point><X>-28</X><Y>8</Y><Z>0</Z></Point>
					   <Point><X>-28</X><Y>8</Y><Z>0</Z></Point>
					   <Point><X>-28</X><Y>2</Y><Z>0</Z></Point>
					   <Point><X>-28</X><Y>2</Y><Z>0</Z></Point>
					   <Point><X>-28</X><Y>2</Y><Z>0</Z></Point>
					   <Point><X>-24</X><Y>-4</Y><Z>0</Z></Point>
					   <Point><X>-24</X><Y>-4</Y><Z>0</Z></Point>
					   <Point><X>-24</X><Y>-4</Y><Z>0</Z></Point>
					   <Point><X>-22</X><Y>-3</Y><Z>0</Z></Point>
					   <Point><X>-22</X><Y>-3</Y><Z>0</Z></Point>
					   <Point><X>-22</X><Y>-3</Y><Z>0</Z></Point>
					   <Point><X>-20</X><Y>-6</Y><Z>0</Z></Point>
					   <Point><X>-20</X><Y>-6</Y><Z>0</Z></Point>
					   <Point><X>-20</X><Y>-6</Y><Z>0</Z></Point>
					   <Point><X>-18</X><Y>-5</Y><Z>0</Z></Point>
					   <Point><X>-18</X><Y>-5</Y><Z>0</Z></Point>
					   <Point><X>-18</X><Y>-5</Y><Z>0</Z></Point>
					   <Point><X>-16</X><Y>-8</Y><Z>0</Z></Point>
					   <Point><X>-16</X><Y>-8</Y><Z>0</Z></Point>
					   <Point><X>-16</X><Y>-8</Y><Z>0</Z></Point>
					   <Point><X>-14</X><Y>-7</Y><Z>0</Z></Point>
					   <Point><X>-14</X><Y>-7</Y><Z>0</Z></Point>
					   <Point><X>-14</X><Y>-7</Y><Z>0</Z></Point>
					   <Point><X>-14</X><Y>-13</Y><Z>0</Z></Point>
					   <Point><X>-14</X><Y>-14</Y><Z>0</Z></Point>
					   <Point><X>-14</X><Y>-15</Y><Z>0</Z></Point>
					   <Point><X>-10</X><Y>-15</Y><Z>0</Z></Point>
					   <Point><X>-10</X><Y>-14</Y><Z>0</Z></Point>
					   <Point><X>-10</X><Y>-13</Y><Z>0</Z></Point>
					   <Point><X>-10</X><Y>-5</Y><Z>0</Z></Point>
					   <Point><X>-10</X><Y>-5</Y><Z>0</Z></Point>
					   <Point><X>-10</X><Y>-5</Y><Z>0</Z></Point>
					   <Point><X>-8</X><Y>-4</Y><Z>0</Z></Point>
					   <Point><X>-8</X><Y>-4</Y><Z>0</Z></Point>
					   <Point><X>-8</X><Y>-4</Y><Z>0</Z></Point>
					   <Point><X>-8</X><Y>-10</Y><Z>0</Z></Point>
					   <Point><X>-8</X><Y>-11</Y><Z>0</Z></Point>
					   <Point><X>-8</X><Y>-12</Y><Z>0</Z></Point>
					   <Point><X>-4</X><Y>-12</Y><Z>0</Z></Point>
					   <Point><X>-4</X><Y>-11</Y><Z>0</Z></Point>
					   <Point><X>-4</X><Y>-10</Y><Z>0</Z></Point>
					   <Point><X>-4</X><Y>-2</Y><Z>0</Z></Point>
					   <Point><X>-4</X><Y>-2</Y><Z>0</Z></Point>
					   <Point><X>-4</X><Y>-2</Y><Z>0</Z></Point>
					   <Point><X>0</X><Y>0</Y><Z>0</Z></Point>
					</Points>
					<Closed>true</Closed>
				</Curve>
			</Presentation>

				</Group>
    			<Plot>
					<Id>1653396431898</Id>
					<Name><![CDATA[plot]]></Name>
					<X>40</X><Y>100</Y>
					<Label><X>0</X><Y>-10</Y></Label>
					<PublicFlag>true</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>false</ShowLabel>
					<DrawMode>SHAPE_DRAW_2D3D</DrawMode>
					<AutoUpdate>false</AutoUpdate>
					<OccurrenceAtTime>true</OccurrenceAtTime>
					<OccurrenceDate>1653465600000</OccurrenceDate>
					<OccurrenceTime Class="CodeUnitValue">
						<Code><![CDATA[0]]></Code>
						<Unit Class="TimeUnits"><![CDATA[DAY]]></Unit>
					</OccurrenceTime>
					<RecurrenceCode Class="CodeUnitValue">
						<Code><![CDATA[1]]></Code>
						<Unit Class="TimeUnits"><![CDATA[DAY]]></Unit>
					</RecurrenceCode>
					<EmbeddedIcon>false</EmbeddedIcon>
					<Width>550</Width>
					<Height>300</Height>
					<BackgroundColor/>
					<BorderColor/>
					<ChartArea>
						<XOffset>50</XOffset>
						<YOffset>30</YOffset>
						<Width>470</Width>
						<Height>210</Height>
						<BackgroundColor>-1</BackgroundColor>
						<BorderColor>-16777216</BorderColor>
						<GridColor>-12566464</GridColor>
					</ChartArea>
					<Legend>
						<Place>SOUTH</Place>
						<TextColor>-16777216</TextColor>
						<Size>30</Size>
					</Legend>
					<Labels>
						<HorLabelsPosition>DEFAULT</HorLabelsPosition>
						<VerLabelsPosition>DEFAULT</VerLabelsPosition>
						<TextColor>-12566464</TextColor>
					</Labels>
					<ShowLegend>true</ShowLegend>
					<VerScaleFromExpression><![CDATA[0]]></VerScaleFromExpression>
					<VerScaleToExpression><![CDATA[1]]></VerScaleToExpression>
					<VerScaleType>AUTO</VerScaleType>
					<DrawLine>true</DrawLine>
					<Interpolation>LINEAR</Interpolation>
					<DatasetExpression>  
						<Title><![CDATA[Stage1]]></Title>
					<Id>0</Id>
					<Expression><![CDATA[dataSetStage1]]></Expression>
					<Color>-12004916</Color>
					<Expression2><![CDATA[dataset.getY(i)]]></Expression2>
					<Expression2Flag>false</Expression2Flag>
						<PointStyle>CIRCLE</PointStyle>
						<LineWidth>2.0</LineWidth>
						<HorizontalAxisExpression><![CDATA[dataset.getX(i)]]></HorizontalAxisExpression>
					</DatasetExpression>
					<SamplesToKeep>100</SamplesToKeep>
					<HorScaleFromExpression><![CDATA[0]]></HorScaleFromExpression>
					<HorScaleToExpression><![CDATA[1]]></HorScaleToExpression>
					<HorScaleType>AUTO</HorScaleType>
    			</Plot>
				<Text>
					<Id>1671994872578</Id>
					<Name><![CDATA[text]]></Name>
					<X>250</X><Y>370</Y>
					<Label><X>0</X><Y>-10</Y></Label>
					<PublicFlag>true</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>false</ShowLabel>
					<DrawMode>SHAPE_DRAW_2D</DrawMode>
					<EmbeddedIcon>false</EmbeddedIcon>
					<Z>0</Z>
					<Rotation>0.0</Rotation>
					<Color>-16777216</Color>
					<Text><![CDATA[Time]]></Text>
					<Font>
						<Name>SansSerif</Name>
						<Size>14</Size>
						<Style>0</Style>
					</Font>
					<Alignment>LEFT</Alignment>
				</Text>
				<Text>
					<Id>1671994884477</Id>
					<Name><![CDATA[text1]]></Name>
					<X>30</X><Y>250</Y>
					<Label><X>0</X><Y>-10</Y></Label>
					<PublicFlag>true</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>false</ShowLabel>
					<DrawMode>SHAPE_DRAW_2D</DrawMode>
					<EmbeddedIcon>false</EmbeddedIcon>
					<Z>0</Z>
					<Rotation>270.0</Rotation>
					<Color>-16777216</Color>
					<Text><![CDATA[System Load]]></Text>
					<Font>
						<Name>SansSerif</Name>
						<Size>14</Size>
						<Style>0</Style>
					</Font>
					<Alignment>LEFT</Alignment>
				</Text>
    			<Plot>
					<Id>1671995325344</Id>
					<Name><![CDATA[plot1]]></Name>
					<X>40</X><Y>500</Y>
					<Label><X>0</X><Y>-10</Y></Label>
					<PublicFlag>true</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>false</ShowLabel>
					<DrawMode>SHAPE_DRAW_2D3D</DrawMode>
					<AutoUpdate>false</AutoUpdate>
					<OccurrenceAtTime>true</OccurrenceAtTime>
					<OccurrenceDate>1653465600000</OccurrenceDate>
					<OccurrenceTime Class="CodeUnitValue">
						<Code><![CDATA[0]]></Code>
						<Unit Class="TimeUnits"><![CDATA[DAY]]></Unit>
					</OccurrenceTime>
					<RecurrenceCode Class="CodeUnitValue">
						<Code><![CDATA[1]]></Code>
						<Unit Class="TimeUnits"><![CDATA[DAY]]></Unit>
					</RecurrenceCode>
					<EmbeddedIcon>false</EmbeddedIcon>
					<Width>550</Width>
					<Height>300</Height>
					<BackgroundColor/>
					<BorderColor/>
					<ChartArea>
						<XOffset>50</XOffset>
						<YOffset>30</YOffset>
						<Width>470</Width>
						<Height>210</Height>
						<BackgroundColor>-1</BackgroundColor>
						<BorderColor>-16777216</BorderColor>
						<GridColor>-12566464</GridColor>
					</ChartArea>
					<Legend>
						<Place>SOUTH</Place>
						<TextColor>-16777216</TextColor>
						<Size>30</Size>
					</Legend>
					<Labels>
						<HorLabelsPosition>DEFAULT</HorLabelsPosition>
						<VerLabelsPosition>DEFAULT</VerLabelsPosition>
						<TextColor>-12566464</TextColor>
					</Labels>
					<ShowLegend>true</ShowLegend>
					<VerScaleFromExpression><![CDATA[0]]></VerScaleFromExpression>
					<VerScaleToExpression><![CDATA[1]]></VerScaleToExpression>
					<VerScaleType>AUTO</VerScaleType>
					<DrawLine>true</DrawLine>
					<Interpolation>LINEAR</Interpolation>
					<DatasetExpression>  
						<Title><![CDATA[Stage2]]></Title>
					<Id>1671995325341</Id>
					<Expression><![CDATA[dataSetStage2]]></Expression>
					<Color>-65536</Color>
					<Expression2><![CDATA[dataset.getY(i)]]></Expression2>
					<Expression2Flag>false</Expression2Flag>
						<PointStyle>CIRCLE</PointStyle>
						<LineWidth>2.0</LineWidth>
						<HorizontalAxisExpression><![CDATA[dataset.getX(i)]]></HorizontalAxisExpression>
					</DatasetExpression>
					<SamplesToKeep>100</SamplesToKeep>
					<HorScaleFromExpression><![CDATA[0]]></HorScaleFromExpression>
					<HorScaleToExpression><![CDATA[1]]></HorScaleToExpression>
					<HorScaleType>AUTO</HorScaleType>
    			</Plot>
				<Text>
					<Id>1671995325348</Id>
					<Name><![CDATA[text2]]></Name>
					<X>250</X><Y>770</Y>
					<Label><X>0</X><Y>-10</Y></Label>
					<PublicFlag>true</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>false</ShowLabel>
					<DrawMode>SHAPE_DRAW_2D</DrawMode>
					<EmbeddedIcon>false</EmbeddedIcon>
					<Z>0</Z>
					<Rotation>0.0</Rotation>
					<Color>-16777216</Color>
					<Text><![CDATA[Time]]></Text>
					<Font>
						<Name>SansSerif</Name>
						<Size>14</Size>
						<Style>0</Style>
					</Font>
					<Alignment>LEFT</Alignment>
				</Text>
				<Text>
					<Id>1671995325350</Id>
					<Name><![CDATA[text3]]></Name>
					<X>30</X><Y>650</Y>
					<Label><X>0</X><Y>-10</Y></Label>
					<PublicFlag>true</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>false</ShowLabel>
					<DrawMode>SHAPE_DRAW_2D</DrawMode>
					<EmbeddedIcon>false</EmbeddedIcon>
					<Z>0</Z>
					<Rotation>270.0</Rotation>
					<Color>-16777216</Color>
					<Text><![CDATA[System Load]]></Text>
					<Font>
						<Name>SansSerif</Name>
						<Size>14</Size>
						<Style>0</Style>
					</Font>
					<Alignment>LEFT</Alignment>
				</Text>
    			<Plot>
					<Id>1671996274948</Id>
					<Name><![CDATA[plot2]]></Name>
					<X>40</X><Y>920</Y>
					<Label><X>0</X><Y>-10</Y></Label>
					<PublicFlag>true</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>false</ShowLabel>
					<DrawMode>SHAPE_DRAW_2D3D</DrawMode>
					<AutoUpdate>false</AutoUpdate>
					<OccurrenceAtTime>true</OccurrenceAtTime>
					<OccurrenceDate>1653465600000</OccurrenceDate>
					<OccurrenceTime Class="CodeUnitValue">
						<Code><![CDATA[0]]></Code>
						<Unit Class="TimeUnits"><![CDATA[DAY]]></Unit>
					</OccurrenceTime>
					<RecurrenceCode Class="CodeUnitValue">
						<Code><![CDATA[1]]></Code>
						<Unit Class="TimeUnits"><![CDATA[DAY]]></Unit>
					</RecurrenceCode>
					<EmbeddedIcon>false</EmbeddedIcon>
					<Width>550</Width>
					<Height>300</Height>
					<BackgroundColor/>
					<BorderColor/>
					<ChartArea>
						<XOffset>50</XOffset>
						<YOffset>30</YOffset>
						<Width>470</Width>
						<Height>210</Height>
						<BackgroundColor>-1</BackgroundColor>
						<BorderColor>-16777216</BorderColor>
						<GridColor>-12566464</GridColor>
					</ChartArea>
					<Legend>
						<Place>SOUTH</Place>
						<TextColor>-16777216</TextColor>
						<Size>30</Size>
					</Legend>
					<Labels>
						<HorLabelsPosition>DEFAULT</HorLabelsPosition>
						<VerLabelsPosition>DEFAULT</VerLabelsPosition>
						<TextColor>-12566464</TextColor>
					</Labels>
					<ShowLegend>true</ShowLegend>
					<VerScaleFromExpression><![CDATA[0]]></VerScaleFromExpression>
					<VerScaleToExpression><![CDATA[1]]></VerScaleToExpression>
					<VerScaleType>AUTO</VerScaleType>
					<DrawLine>true</DrawLine>
					<Interpolation>LINEAR</Interpolation>
					<DatasetExpression>  
						<Title><![CDATA[Stage3]]></Title>
					<Id>1671996274945</Id>
					<Expression><![CDATA[dataSetStage3]]></Expression>
					<Color>-16777216</Color>
					<Expression2><![CDATA[dataset.getY(i)]]></Expression2>
					<Expression2Flag>false</Expression2Flag>
						<PointStyle>CIRCLE</PointStyle>
						<LineWidth>2.0</LineWidth>
						<HorizontalAxisExpression><![CDATA[dataset.getX(i)]]></HorizontalAxisExpression>
					</DatasetExpression>
					<SamplesToKeep>100</SamplesToKeep>
					<HorScaleFromExpression><![CDATA[0]]></HorScaleFromExpression>
					<HorScaleToExpression><![CDATA[1]]></HorScaleToExpression>
					<HorScaleType>AUTO</HorScaleType>
    			</Plot>
				<Text>
					<Id>1671996274952</Id>
					<Name><![CDATA[text4]]></Name>
					<X>250</X><Y>1190</Y>
					<Label><X>0</X><Y>-10</Y></Label>
					<PublicFlag>true</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>false</ShowLabel>
					<DrawMode>SHAPE_DRAW_2D</DrawMode>
					<EmbeddedIcon>false</EmbeddedIcon>
					<Z>0</Z>
					<Rotation>0.0</Rotation>
					<Color>-16777216</Color>
					<Text><![CDATA[Time]]></Text>
					<Font>
						<Name>SansSerif</Name>
						<Size>14</Size>
						<Style>0</Style>
					</Font>
					<Alignment>LEFT</Alignment>
				</Text>
				<Text>
					<Id>1671996274954</Id>
					<Name><![CDATA[text5]]></Name>
					<X>30</X><Y>1070</Y>
					<Label><X>0</X><Y>-10</Y></Label>
					<PublicFlag>true</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>false</ShowLabel>
					<DrawMode>SHAPE_DRAW_2D</DrawMode>
					<EmbeddedIcon>false</EmbeddedIcon>
					<Z>0</Z>
					<Rotation>270.0</Rotation>
					<Color>-16777216</Color>
					<Text><![CDATA[System Load]]></Text>
					<Font>
						<Name>SansSerif</Name>
						<Size>14</Size>
						<Style>0</Style>
					</Font>
					<Alignment>LEFT</Alignment>
				</Text>
    			<Plot>
					<Id>1671996306700</Id>
					<Name><![CDATA[plot3]]></Name>
					<X>40</X><Y>1320</Y>
					<Label><X>0</X><Y>-10</Y></Label>
					<PublicFlag>true</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>false</ShowLabel>
					<DrawMode>SHAPE_DRAW_2D3D</DrawMode>
					<AutoUpdate>false</AutoUpdate>
					<OccurrenceAtTime>true</OccurrenceAtTime>
					<OccurrenceDate>1653465600000</OccurrenceDate>
					<OccurrenceTime Class="CodeUnitValue">
						<Code><![CDATA[0]]></Code>
						<Unit Class="TimeUnits"><![CDATA[DAY]]></Unit>
					</OccurrenceTime>
					<RecurrenceCode Class="CodeUnitValue">
						<Code><![CDATA[1]]></Code>
						<Unit Class="TimeUnits"><![CDATA[DAY]]></Unit>
					</RecurrenceCode>
					<EmbeddedIcon>false</EmbeddedIcon>
					<Width>550</Width>
					<Height>300</Height>
					<BackgroundColor/>
					<BorderColor/>
					<ChartArea>
						<XOffset>50</XOffset>
						<YOffset>30</YOffset>
						<Width>470</Width>
						<Height>210</Height>
						<BackgroundColor>-1</BackgroundColor>
						<BorderColor>-16777216</BorderColor>
						<GridColor>-12566464</GridColor>
					</ChartArea>
					<Legend>
						<Place>SOUTH</Place>
						<TextColor>-16777216</TextColor>
						<Size>30</Size>
					</Legend>
					<Labels>
						<HorLabelsPosition>DEFAULT</HorLabelsPosition>
						<VerLabelsPosition>DEFAULT</VerLabelsPosition>
						<TextColor>-12566464</TextColor>
					</Labels>
					<ShowLegend>true</ShowLegend>
					<VerScaleFromExpression><![CDATA[0]]></VerScaleFromExpression>
					<VerScaleToExpression><![CDATA[1]]></VerScaleToExpression>
					<VerScaleType>AUTO</VerScaleType>
					<DrawLine>true</DrawLine>
					<Interpolation>LINEAR</Interpolation>
					<DatasetExpression>  
						<Title><![CDATA[Stage4]]></Title>
					<Id>1671996306697</Id>
					<Expression><![CDATA[dataSetStage4]]></Expression>
					<Color>-65281</Color>
					<Expression2><![CDATA[dataset.getY(i)]]></Expression2>
					<Expression2Flag>false</Expression2Flag>
						<PointStyle>CIRCLE</PointStyle>
						<LineWidth>2.0</LineWidth>
						<HorizontalAxisExpression><![CDATA[dataset.getX(i)]]></HorizontalAxisExpression>
					</DatasetExpression>
					<SamplesToKeep>100</SamplesToKeep>
					<HorScaleFromExpression><![CDATA[0]]></HorScaleFromExpression>
					<HorScaleToExpression><![CDATA[1]]></HorScaleToExpression>
					<HorScaleType>AUTO</HorScaleType>
    			</Plot>
				<Text>
					<Id>1671996306702</Id>
					<Name><![CDATA[text6]]></Name>
					<X>250</X><Y>1590</Y>
					<Label><X>0</X><Y>-10</Y></Label>
					<PublicFlag>true</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>false</ShowLabel>
					<DrawMode>SHAPE_DRAW_2D</DrawMode>
					<EmbeddedIcon>false</EmbeddedIcon>
					<Z>0</Z>
					<Rotation>0.0</Rotation>
					<Color>-16777216</Color>
					<Text><![CDATA[Time]]></Text>
					<Font>
						<Name>SansSerif</Name>
						<Size>14</Size>
						<Style>0</Style>
					</Font>
					<Alignment>LEFT</Alignment>
				</Text>
				<Text>
					<Id>1671996306704</Id>
					<Name><![CDATA[text7]]></Name>
					<X>30</X><Y>1470</Y>
					<Label><X>0</X><Y>-10</Y></Label>
					<PublicFlag>true</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>false</ShowLabel>
					<DrawMode>SHAPE_DRAW_2D</DrawMode>
					<EmbeddedIcon>false</EmbeddedIcon>
					<Z>0</Z>
					<Rotation>270.0</Rotation>
					<Color>-16777216</Color>
					<Text><![CDATA[System Load]]></Text>
					<Font>
						<Name>SansSerif</Name>
						<Size>14</Size>
						<Style>0</Style>
					</Font>
					<Alignment>LEFT</Alignment>
				</Text>
    			<Plot>
					<Id>1680098113457</Id>
					<Name><![CDATA[plotPL1]]></Name>
					<X>580</X><Y>100</Y>
					<Label><X>0</X><Y>-10</Y></Label>
					<PublicFlag>true</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>false</ShowLabel>
					<DrawMode>SHAPE_DRAW_2D3D</DrawMode>
					<AutoUpdate>false</AutoUpdate>
					<OccurrenceAtTime>true</OccurrenceAtTime>
					<OccurrenceDate>1653465600000</OccurrenceDate>
					<OccurrenceTime Class="CodeUnitValue">
						<Code><![CDATA[0]]></Code>
						<Unit Class="TimeUnits"><![CDATA[DAY]]></Unit>
					</OccurrenceTime>
					<RecurrenceCode Class="CodeUnitValue">
						<Code><![CDATA[1]]></Code>
						<Unit Class="TimeUnits"><![CDATA[DAY]]></Unit>
					</RecurrenceCode>
					<EmbeddedIcon>false</EmbeddedIcon>
					<Width>550</Width>
					<Height>300</Height>
					<BackgroundColor/>
					<BorderColor/>
					<ChartArea>
						<XOffset>50</XOffset>
						<YOffset>30</YOffset>
						<Width>470</Width>
						<Height>210</Height>
						<BackgroundColor>-1</BackgroundColor>
						<BorderColor>-16777216</BorderColor>
						<GridColor>-12566464</GridColor>
					</ChartArea>
					<Legend>
						<Place>SOUTH</Place>
						<TextColor>-16777216</TextColor>
						<Size>30</Size>
					</Legend>
					<Labels>
						<HorLabelsPosition>DEFAULT</HorLabelsPosition>
						<VerLabelsPosition>DEFAULT</VerLabelsPosition>
						<TextColor>-12566464</TextColor>
					</Labels>
					<ShowLegend>true</ShowLegend>
					<VerScaleFromExpression><![CDATA[0]]></VerScaleFromExpression>
					<VerScaleToExpression><![CDATA[1]]></VerScaleToExpression>
					<VerScaleType>AUTO</VerScaleType>
					<DrawLine>true</DrawLine>
					<Interpolation>LINEAR</Interpolation>
					<DatasetExpression>  
						<Title><![CDATA[Stage1]]></Title>
					<Id>1680098113454</Id>
					<Expression><![CDATA[dataSetPLStage1]]></Expression>
					<Color>-12004916</Color>
					<Expression2><![CDATA[dataset.getY(i)]]></Expression2>
					<Expression2Flag>false</Expression2Flag>
						<PointStyle>CIRCLE</PointStyle>
						<LineWidth>2.0</LineWidth>
						<HorizontalAxisExpression><![CDATA[dataset.getX(i)]]></HorizontalAxisExpression>
					</DatasetExpression>
					<SamplesToKeep>100</SamplesToKeep>
					<HorScaleFromExpression><![CDATA[0]]></HorScaleFromExpression>
					<HorScaleToExpression><![CDATA[1]]></HorScaleToExpression>
					<HorScaleType>AUTO</HorScaleType>
    			</Plot>
				<Text>
					<Id>1680098239172</Id>
					<Name><![CDATA[text8]]></Name>
					<X>820</X><Y>369</Y>
					<Label><X>0</X><Y>-10</Y></Label>
					<PublicFlag>true</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>false</ShowLabel>
					<DrawMode>SHAPE_DRAW_2D</DrawMode>
					<EmbeddedIcon>false</EmbeddedIcon>
					<Z>0</Z>
					<Rotation>0.0</Rotation>
					<Color>-16777216</Color>
					<Text><![CDATA[Time]]></Text>
					<Font>
						<Name>SansSerif</Name>
						<Size>14</Size>
						<Style>0</Style>
					</Font>
					<Alignment>LEFT</Alignment>
				</Text>
				<Text>
					<Id>1680098259966</Id>
					<Name><![CDATA[text9]]></Name>
					<X>562</X><Y>252</Y>
					<Label><X>0</X><Y>-10</Y></Label>
					<PublicFlag>true</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>false</ShowLabel>
					<DrawMode>SHAPE_DRAW_2D</DrawMode>
					<EmbeddedIcon>false</EmbeddedIcon>
					<Z>0</Z>
					<Rotation>270.0</Rotation>
					<Color>-16777216</Color>
					<Text><![CDATA[Processed Load]]></Text>
					<Font>
						<Name>SansSerif</Name>
						<Size>14</Size>
						<Style>0</Style>
					</Font>
					<Alignment>LEFT</Alignment>
				</Text>
    			<Plot>
					<Id>1680099379379</Id>
					<Name><![CDATA[plotPL2]]></Name>
					<X>590</X><Y>500</Y>
					<Label><X>0</X><Y>-10</Y></Label>
					<PublicFlag>true</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>false</ShowLabel>
					<DrawMode>SHAPE_DRAW_2D3D</DrawMode>
					<AutoUpdate>false</AutoUpdate>
					<OccurrenceAtTime>true</OccurrenceAtTime>
					<OccurrenceDate>1653465600000</OccurrenceDate>
					<OccurrenceTime Class="CodeUnitValue">
						<Code><![CDATA[0]]></Code>
						<Unit Class="TimeUnits"><![CDATA[DAY]]></Unit>
					</OccurrenceTime>
					<RecurrenceCode Class="CodeUnitValue">
						<Code><![CDATA[1]]></Code>
						<Unit Class="TimeUnits"><![CDATA[DAY]]></Unit>
					</RecurrenceCode>
					<EmbeddedIcon>false</EmbeddedIcon>
					<Width>550</Width>
					<Height>300</Height>
					<BackgroundColor/>
					<BorderColor/>
					<ChartArea>
						<XOffset>50</XOffset>
						<YOffset>30</YOffset>
						<Width>470</Width>
						<Height>210</Height>
						<BackgroundColor>-1</BackgroundColor>
						<BorderColor>-16777216</BorderColor>
						<GridColor>-12566464</GridColor>
					</ChartArea>
					<Legend>
						<Place>SOUTH</Place>
						<TextColor>-16777216</TextColor>
						<Size>30</Size>
					</Legend>
					<Labels>
						<HorLabelsPosition>DEFAULT</HorLabelsPosition>
						<VerLabelsPosition>DEFAULT</VerLabelsPosition>
						<TextColor>-12566464</TextColor>
					</Labels>
					<ShowLegend>true</ShowLegend>
					<VerScaleFromExpression><![CDATA[0]]></VerScaleFromExpression>
					<VerScaleToExpression><![CDATA[1]]></VerScaleToExpression>
					<VerScaleType>AUTO</VerScaleType>
					<DrawLine>true</DrawLine>
					<Interpolation>LINEAR</Interpolation>
					<DatasetExpression>  
						<Title><![CDATA[Stage2]]></Title>
					<Id>1680099379376</Id>
					<Expression><![CDATA[dataSetPLStage2]]></Expression>
					<Color>-65536</Color>
					<Expression2><![CDATA[dataset.getY(i)]]></Expression2>
					<Expression2Flag>false</Expression2Flag>
						<PointStyle>CIRCLE</PointStyle>
						<LineWidth>2.0</LineWidth>
						<HorizontalAxisExpression><![CDATA[dataset.getX(i)]]></HorizontalAxisExpression>
					</DatasetExpression>
					<SamplesToKeep>100</SamplesToKeep>
					<HorScaleFromExpression><![CDATA[0]]></HorScaleFromExpression>
					<HorScaleToExpression><![CDATA[1]]></HorScaleToExpression>
					<HorScaleType>AUTO</HorScaleType>
    			</Plot>
				<Text>
					<Id>1680099379381</Id>
					<Name><![CDATA[text10]]></Name>
					<X>572</X><Y>652</Y>
					<Label><X>0</X><Y>-10</Y></Label>
					<PublicFlag>true</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>false</ShowLabel>
					<DrawMode>SHAPE_DRAW_2D</DrawMode>
					<EmbeddedIcon>false</EmbeddedIcon>
					<Z>0</Z>
					<Rotation>270.0</Rotation>
					<Color>-16777216</Color>
					<Text><![CDATA[Processed Load]]></Text>
					<Font>
						<Name>SansSerif</Name>
						<Size>14</Size>
						<Style>0</Style>
					</Font>
					<Alignment>LEFT</Alignment>
				</Text>
				<Text>
					<Id>1680099379383</Id>
					<Name><![CDATA[text11]]></Name>
					<X>830</X><Y>769</Y>
					<Label><X>0</X><Y>-10</Y></Label>
					<PublicFlag>true</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>false</ShowLabel>
					<DrawMode>SHAPE_DRAW_2D</DrawMode>
					<EmbeddedIcon>false</EmbeddedIcon>
					<Z>0</Z>
					<Rotation>0.0</Rotation>
					<Color>-16777216</Color>
					<Text><![CDATA[Time]]></Text>
					<Font>
						<Name>SansSerif</Name>
						<Size>14</Size>
						<Style>0</Style>
					</Font>
					<Alignment>LEFT</Alignment>
				</Text>
				<Text>
					<Id>1680099426881</Id>
					<Name><![CDATA[text12]]></Name>
					<X>572</X><Y>1072</Y>
					<Label><X>0</X><Y>-10</Y></Label>
					<PublicFlag>true</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>false</ShowLabel>
					<DrawMode>SHAPE_DRAW_2D</DrawMode>
					<EmbeddedIcon>false</EmbeddedIcon>
					<Z>0</Z>
					<Rotation>270.0</Rotation>
					<Color>-16777216</Color>
					<Text><![CDATA[Processed Load]]></Text>
					<Font>
						<Name>SansSerif</Name>
						<Size>14</Size>
						<Style>0</Style>
					</Font>
					<Alignment>LEFT</Alignment>
				</Text>
    			<Plot>
					<Id>1680099426888</Id>
					<Name><![CDATA[plotPL3]]></Name>
					<X>590</X><Y>920</Y>
					<Label><X>0</X><Y>-10</Y></Label>
					<PublicFlag>true</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>false</ShowLabel>
					<DrawMode>SHAPE_DRAW_2D3D</DrawMode>
					<AutoUpdate>false</AutoUpdate>
					<OccurrenceAtTime>true</OccurrenceAtTime>
					<OccurrenceDate>1653465600000</OccurrenceDate>
					<OccurrenceTime Class="CodeUnitValue">
						<Code><![CDATA[0]]></Code>
						<Unit Class="TimeUnits"><![CDATA[DAY]]></Unit>
					</OccurrenceTime>
					<RecurrenceCode Class="CodeUnitValue">
						<Code><![CDATA[1]]></Code>
						<Unit Class="TimeUnits"><![CDATA[DAY]]></Unit>
					</RecurrenceCode>
					<EmbeddedIcon>false</EmbeddedIcon>
					<Width>550</Width>
					<Height>300</Height>
					<BackgroundColor/>
					<BorderColor/>
					<ChartArea>
						<XOffset>50</XOffset>
						<YOffset>30</YOffset>
						<Width>470</Width>
						<Height>210</Height>
						<BackgroundColor>-1</BackgroundColor>
						<BorderColor>-16777216</BorderColor>
						<GridColor>-12566464</GridColor>
					</ChartArea>
					<Legend>
						<Place>SOUTH</Place>
						<TextColor>-16777216</TextColor>
						<Size>30</Size>
					</Legend>
					<Labels>
						<HorLabelsPosition>DEFAULT</HorLabelsPosition>
						<VerLabelsPosition>DEFAULT</VerLabelsPosition>
						<TextColor>-12566464</TextColor>
					</Labels>
					<ShowLegend>true</ShowLegend>
					<VerScaleFromExpression><![CDATA[0]]></VerScaleFromExpression>
					<VerScaleToExpression><![CDATA[1]]></VerScaleToExpression>
					<VerScaleType>AUTO</VerScaleType>
					<DrawLine>true</DrawLine>
					<Interpolation>LINEAR</Interpolation>
					<DatasetExpression>  
						<Title><![CDATA[Stage3]]></Title>
					<Id>1680099426885</Id>
					<Expression><![CDATA[dataSetPLStage3]]></Expression>
					<Color>-16777216</Color>
					<Expression2><![CDATA[dataset.getY(i)]]></Expression2>
					<Expression2Flag>false</Expression2Flag>
						<PointStyle>CIRCLE</PointStyle>
						<LineWidth>2.0</LineWidth>
						<HorizontalAxisExpression><![CDATA[dataset.getX(i)]]></HorizontalAxisExpression>
					</DatasetExpression>
					<SamplesToKeep>100</SamplesToKeep>
					<HorScaleFromExpression><![CDATA[0]]></HorScaleFromExpression>
					<HorScaleToExpression><![CDATA[1]]></HorScaleToExpression>
					<HorScaleType>AUTO</HorScaleType>
    			</Plot>
				<Text>
					<Id>1680099426890</Id>
					<Name><![CDATA[text13]]></Name>
					<X>830</X><Y>1189</Y>
					<Label><X>0</X><Y>-10</Y></Label>
					<PublicFlag>true</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>false</ShowLabel>
					<DrawMode>SHAPE_DRAW_2D</DrawMode>
					<EmbeddedIcon>false</EmbeddedIcon>
					<Z>0</Z>
					<Rotation>0.0</Rotation>
					<Color>-16777216</Color>
					<Text><![CDATA[Time]]></Text>
					<Font>
						<Name>SansSerif</Name>
						<Size>14</Size>
						<Style>0</Style>
					</Font>
					<Alignment>LEFT</Alignment>
				</Text>
				<Text>
					<Id>1680099481978</Id>
					<Name><![CDATA[text14]]></Name>
					<X>830</X><Y>1589</Y>
					<Label><X>0</X><Y>-10</Y></Label>
					<PublicFlag>true</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>false</ShowLabel>
					<DrawMode>SHAPE_DRAW_2D</DrawMode>
					<EmbeddedIcon>false</EmbeddedIcon>
					<Z>0</Z>
					<Rotation>0.0</Rotation>
					<Color>-16777216</Color>
					<Text><![CDATA[Time]]></Text>
					<Font>
						<Name>SansSerif</Name>
						<Size>14</Size>
						<Style>0</Style>
					</Font>
					<Alignment>LEFT</Alignment>
				</Text>
    			<Plot>
					<Id>1680099481987</Id>
					<Name><![CDATA[plotPL4]]></Name>
					<X>590</X><Y>1320</Y>
					<Label><X>0</X><Y>-10</Y></Label>
					<PublicFlag>true</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>false</ShowLabel>
					<DrawMode>SHAPE_DRAW_2D3D</DrawMode>
					<AutoUpdate>false</AutoUpdate>
					<OccurrenceAtTime>true</OccurrenceAtTime>
					<OccurrenceDate>1653465600000</OccurrenceDate>
					<OccurrenceTime Class="CodeUnitValue">
						<Code><![CDATA[0]]></Code>
						<Unit Class="TimeUnits"><![CDATA[DAY]]></Unit>
					</OccurrenceTime>
					<RecurrenceCode Class="CodeUnitValue">
						<Code><![CDATA[1]]></Code>
						<Unit Class="TimeUnits"><![CDATA[DAY]]></Unit>
					</RecurrenceCode>
					<EmbeddedIcon>false</EmbeddedIcon>
					<Width>550</Width>
					<Height>300</Height>
					<BackgroundColor/>
					<BorderColor/>
					<ChartArea>
						<XOffset>50</XOffset>
						<YOffset>30</YOffset>
						<Width>470</Width>
						<Height>210</Height>
						<BackgroundColor>-1</BackgroundColor>
						<BorderColor>-16777216</BorderColor>
						<GridColor>-12566464</GridColor>
					</ChartArea>
					<Legend>
						<Place>SOUTH</Place>
						<TextColor>-16777216</TextColor>
						<Size>30</Size>
					</Legend>
					<Labels>
						<HorLabelsPosition>DEFAULT</HorLabelsPosition>
						<VerLabelsPosition>DEFAULT</VerLabelsPosition>
						<TextColor>-12566464</TextColor>
					</Labels>
					<ShowLegend>true</ShowLegend>
					<VerScaleFromExpression><![CDATA[0]]></VerScaleFromExpression>
					<VerScaleToExpression><![CDATA[1]]></VerScaleToExpression>
					<VerScaleType>AUTO</VerScaleType>
					<DrawLine>true</DrawLine>
					<Interpolation>LINEAR</Interpolation>
					<DatasetExpression>  
						<Title><![CDATA[Stage4]]></Title>
					<Id>1680099481984</Id>
					<Expression><![CDATA[dataSetPLStage4]]></Expression>
					<Color>-65281</Color>
					<Expression2><![CDATA[dataset.getY(i)]]></Expression2>
					<Expression2Flag>false</Expression2Flag>
						<PointStyle>CIRCLE</PointStyle>
						<LineWidth>2.0</LineWidth>
						<HorizontalAxisExpression><![CDATA[dataset.getX(i)]]></HorizontalAxisExpression>
					</DatasetExpression>
					<SamplesToKeep>100</SamplesToKeep>
					<HorScaleFromExpression><![CDATA[0]]></HorScaleFromExpression>
					<HorScaleToExpression><![CDATA[1]]></HorScaleToExpression>
					<HorScaleType>AUTO</HorScaleType>
    			</Plot>
				<Text>
					<Id>1680099481989</Id>
					<Name><![CDATA[text15]]></Name>
					<X>572</X><Y>1472</Y>
					<Label><X>0</X><Y>-10</Y></Label>
					<PublicFlag>true</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>false</ShowLabel>
					<DrawMode>SHAPE_DRAW_2D</DrawMode>
					<EmbeddedIcon>false</EmbeddedIcon>
					<Z>0</Z>
					<Rotation>270.0</Rotation>
					<Color>-16777216</Color>
					<Text><![CDATA[Processed Load]]></Text>
					<Font>
						<Name>SansSerif</Name>
						<Size>14</Size>
						<Style>0</Style>
					</Font>
					<Alignment>LEFT</Alignment>
				</Text>
    			<Plot>
					<Id>1680104724817</Id>
					<Name><![CDATA[plotPL5]]></Name>
					<X>1160</X><Y>100</Y>
					<Label><X>0</X><Y>-10</Y></Label>
					<PublicFlag>true</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>false</ShowLabel>
					<DrawMode>SHAPE_DRAW_2D3D</DrawMode>
					<AutoUpdate>false</AutoUpdate>
					<OccurrenceAtTime>true</OccurrenceAtTime>
					<OccurrenceDate>1653465600000</OccurrenceDate>
					<OccurrenceTime Class="CodeUnitValue">
						<Code><![CDATA[0]]></Code>
						<Unit Class="TimeUnits"><![CDATA[DAY]]></Unit>
					</OccurrenceTime>
					<RecurrenceCode Class="CodeUnitValue">
						<Code><![CDATA[1]]></Code>
						<Unit Class="TimeUnits"><![CDATA[DAY]]></Unit>
					</RecurrenceCode>
					<EmbeddedIcon>false</EmbeddedIcon>
					<Width>550</Width>
					<Height>300</Height>
					<BackgroundColor/>
					<BorderColor/>
					<ChartArea>
						<XOffset>50</XOffset>
						<YOffset>30</YOffset>
						<Width>470</Width>
						<Height>210</Height>
						<BackgroundColor>-1</BackgroundColor>
						<BorderColor>-16777216</BorderColor>
						<GridColor>-12566464</GridColor>
					</ChartArea>
					<Legend>
						<Place>SOUTH</Place>
						<TextColor>-16777216</TextColor>
						<Size>30</Size>
					</Legend>
					<Labels>
						<HorLabelsPosition>DEFAULT</HorLabelsPosition>
						<VerLabelsPosition>DEFAULT</VerLabelsPosition>
						<TextColor>-12566464</TextColor>
					</Labels>
					<ShowLegend>true</ShowLegend>
					<VerScaleFromExpression><![CDATA[0]]></VerScaleFromExpression>
					<VerScaleToExpression><![CDATA[1]]></VerScaleToExpression>
					<VerScaleType>AUTO</VerScaleType>
					<DrawLine>true</DrawLine>
					<Interpolation>LINEAR</Interpolation>
					<DatasetExpression>  
						<Title><![CDATA[Stage1]]></Title>
					<Id>1680104724814</Id>
					<Expression><![CDATA[testDs]]></Expression>
					<Color>-16777216</Color>
					<Expression2><![CDATA[testDs.getY(i)]]></Expression2>
					<Expression2Flag>false</Expression2Flag>
						<PointStyle>CIRCLE</PointStyle>
						<LineWidth>0.0</LineWidth>
						<HorizontalAxisExpression><![CDATA[testDs.getX(i)]]></HorizontalAxisExpression>
					</DatasetExpression>
					<SamplesToKeep>1000</SamplesToKeep>
					<HorScaleFromExpression><![CDATA[0]]></HorScaleFromExpression>
					<HorScaleToExpression><![CDATA[1]]></HorScaleToExpression>
					<HorScaleType>AUTO</HorScaleType>
    			</Plot>
				<Text>
					<Id>1680149925168</Id>
					<Name><![CDATA[text16]]></Name>
					<X>1140</X><Y>280</Y>
					<Label><X>0</X><Y>-10</Y></Label>
					<PublicFlag>true</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>false</ShowLabel>
					<DrawMode>SHAPE_DRAW_2D</DrawMode>
					<EmbeddedIcon>false</EmbeddedIcon>
					<Z>0</Z>
					<Rotation>270.0</Rotation>
					<Color>-16777216</Color>
					<Text><![CDATA[Processed Load]]></Text>
					<Font>
						<Name>SansSerif</Name>
						<Size>14</Size>
						<Style>0</Style>
					</Font>
					<Alignment>LEFT</Alignment>
				</Text>
				<Text>
					<Id>1680149934098</Id>
					<Name><![CDATA[text17]]></Name>
					<X>1410</X><Y>370</Y>
					<Label><X>0</X><Y>-10</Y></Label>
					<PublicFlag>true</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>false</ShowLabel>
					<DrawMode>SHAPE_DRAW_2D</DrawMode>
					<EmbeddedIcon>false</EmbeddedIcon>
					<Z>0</Z>
					<Rotation>0.0</Rotation>
					<Color>-16777216</Color>
					<Text><![CDATA[System Load]]></Text>
					<Font>
						<Name>SansSerif</Name>
						<Size>14</Size>
						<Style>0</Style>
					</Font>
					<Alignment>LEFT</Alignment>
				</Text>
				<Text>
					<Id>1680286785745</Id>
					<Name><![CDATA[text18]]></Name>
					<X>1190</X><Y>650</Y>
					<Label><X>0</X><Y>-10</Y></Label>
					<PublicFlag>true</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>false</ShowLabel>
					<DrawMode>SHAPE_DRAW_2D</DrawMode>
					<EmbeddedIcon>false</EmbeddedIcon>
					<Z>0</Z>
					<Rotation>270.0</Rotation>
					<Color>-16777216</Color>
					<Text><![CDATA[Processed Load]]></Text>
					<Font>
						<Name>SansSerif</Name>
						<Size>14</Size>
						<Style>0</Style>
					</Font>
					<Alignment>LEFT</Alignment>
				</Text>
				<Text>
					<Id>1680286785751</Id>
					<Name><![CDATA[text19]]></Name>
					<X>1460</X><Y>740</Y>
					<Label><X>0</X><Y>-10</Y></Label>
					<PublicFlag>true</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>false</ShowLabel>
					<DrawMode>SHAPE_DRAW_2D</DrawMode>
					<EmbeddedIcon>false</EmbeddedIcon>
					<Z>0</Z>
					<Rotation>0.0</Rotation>
					<Color>-16777216</Color>
					<Text><![CDATA[System Load]]></Text>
					<Font>
						<Name>SansSerif</Name>
						<Size>14</Size>
						<Style>0</Style>
					</Font>
					<Alignment>LEFT</Alignment>
				</Text>
    			<Plot>
					<Id>1680286785756</Id>
					<Name><![CDATA[plotPL6]]></Name>
					<X>1210</X><Y>470</Y>
					<Label><X>0</X><Y>-10</Y></Label>
					<PublicFlag>true</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>false</ShowLabel>
					<DrawMode>SHAPE_DRAW_2D3D</DrawMode>
					<AutoUpdate>false</AutoUpdate>
					<OccurrenceAtTime>true</OccurrenceAtTime>
					<OccurrenceDate>1653465600000</OccurrenceDate>
					<OccurrenceTime Class="CodeUnitValue">
						<Code><![CDATA[0]]></Code>
						<Unit Class="TimeUnits"><![CDATA[DAY]]></Unit>
					</OccurrenceTime>
					<RecurrenceCode Class="CodeUnitValue">
						<Code><![CDATA[1]]></Code>
						<Unit Class="TimeUnits"><![CDATA[DAY]]></Unit>
					</RecurrenceCode>
					<EmbeddedIcon>false</EmbeddedIcon>
					<Width>550</Width>
					<Height>300</Height>
					<BackgroundColor/>
					<BorderColor/>
					<ChartArea>
						<XOffset>50</XOffset>
						<YOffset>30</YOffset>
						<Width>470</Width>
						<Height>210</Height>
						<BackgroundColor>-1</BackgroundColor>
						<BorderColor>-16777216</BorderColor>
						<GridColor>-12566464</GridColor>
					</ChartArea>
					<Legend>
						<Place>SOUTH</Place>
						<TextColor>-16777216</TextColor>
						<Size>30</Size>
					</Legend>
					<Labels>
						<HorLabelsPosition>DEFAULT</HorLabelsPosition>
						<VerLabelsPosition>DEFAULT</VerLabelsPosition>
						<TextColor>-12566464</TextColor>
					</Labels>
					<ShowLegend>true</ShowLegend>
					<VerScaleFromExpression><![CDATA[0]]></VerScaleFromExpression>
					<VerScaleToExpression><![CDATA[1]]></VerScaleToExpression>
					<VerScaleType>AUTO</VerScaleType>
					<DrawLine>true</DrawLine>
					<Interpolation>LINEAR</Interpolation>
					<DatasetExpression>  
						<Title><![CDATA[Stage2]]></Title>
					<Id>1680286785753</Id>
					<Expression><![CDATA[testDs2]]></Expression>
					<Color>-16777216</Color>
					<Expression2><![CDATA[testDs.getY(i)]]></Expression2>
					<Expression2Flag>false</Expression2Flag>
						<PointStyle>CIRCLE</PointStyle>
						<LineWidth>0.0</LineWidth>
						<HorizontalAxisExpression><![CDATA[testDs.getX(i)]]></HorizontalAxisExpression>
					</DatasetExpression>
					<SamplesToKeep>1000</SamplesToKeep>
					<HorScaleFromExpression><![CDATA[0]]></HorScaleFromExpression>
					<HorScaleToExpression><![CDATA[1]]></HorScaleToExpression>
					<HorScaleType>AUTO</HorScaleType>
    			</Plot>
				<Text>
					<Id>1680286834660</Id>
					<Name><![CDATA[text20]]></Name>
					<X>1230</X><Y>1070</Y>
					<Label><X>0</X><Y>-10</Y></Label>
					<PublicFlag>true</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>false</ShowLabel>
					<DrawMode>SHAPE_DRAW_2D</DrawMode>
					<EmbeddedIcon>false</EmbeddedIcon>
					<Z>0</Z>
					<Rotation>270.0</Rotation>
					<Color>-16777216</Color>
					<Text><![CDATA[Processed Load]]></Text>
					<Font>
						<Name>SansSerif</Name>
						<Size>14</Size>
						<Style>0</Style>
					</Font>
					<Alignment>LEFT</Alignment>
				</Text>
    			<Plot>
					<Id>1680286834665</Id>
					<Name><![CDATA[plotPL7]]></Name>
					<X>1250</X><Y>890</Y>
					<Label><X>0</X><Y>-10</Y></Label>
					<PublicFlag>true</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>false</ShowLabel>
					<DrawMode>SHAPE_DRAW_2D3D</DrawMode>
					<AutoUpdate>false</AutoUpdate>
					<OccurrenceAtTime>true</OccurrenceAtTime>
					<OccurrenceDate>1653465600000</OccurrenceDate>
					<OccurrenceTime Class="CodeUnitValue">
						<Code><![CDATA[0]]></Code>
						<Unit Class="TimeUnits"><![CDATA[DAY]]></Unit>
					</OccurrenceTime>
					<RecurrenceCode Class="CodeUnitValue">
						<Code><![CDATA[1]]></Code>
						<Unit Class="TimeUnits"><![CDATA[DAY]]></Unit>
					</RecurrenceCode>
					<EmbeddedIcon>false</EmbeddedIcon>
					<Width>550</Width>
					<Height>300</Height>
					<BackgroundColor/>
					<BorderColor/>
					<ChartArea>
						<XOffset>50</XOffset>
						<YOffset>30</YOffset>
						<Width>470</Width>
						<Height>210</Height>
						<BackgroundColor>-1</BackgroundColor>
						<BorderColor>-16777216</BorderColor>
						<GridColor>-12566464</GridColor>
					</ChartArea>
					<Legend>
						<Place>SOUTH</Place>
						<TextColor>-16777216</TextColor>
						<Size>30</Size>
					</Legend>
					<Labels>
						<HorLabelsPosition>DEFAULT</HorLabelsPosition>
						<VerLabelsPosition>DEFAULT</VerLabelsPosition>
						<TextColor>-12566464</TextColor>
					</Labels>
					<ShowLegend>true</ShowLegend>
					<VerScaleFromExpression><![CDATA[0]]></VerScaleFromExpression>
					<VerScaleToExpression><![CDATA[1]]></VerScaleToExpression>
					<VerScaleType>AUTO</VerScaleType>
					<DrawLine>true</DrawLine>
					<Interpolation>LINEAR</Interpolation>
					<DatasetExpression>  
						<Title><![CDATA[Stage3]]></Title>
					<Id>1680286834662</Id>
					<Expression><![CDATA[testDs3]]></Expression>
					<Color>-16777216</Color>
					<Expression2><![CDATA[testDs.getY(i)]]></Expression2>
					<Expression2Flag>false</Expression2Flag>
						<PointStyle>CIRCLE</PointStyle>
						<LineWidth>0.0</LineWidth>
						<HorizontalAxisExpression><![CDATA[testDs.getX(i)]]></HorizontalAxisExpression>
					</DatasetExpression>
					<SamplesToKeep>1000</SamplesToKeep>
					<HorScaleFromExpression><![CDATA[0]]></HorScaleFromExpression>
					<HorScaleToExpression><![CDATA[1]]></HorScaleToExpression>
					<HorScaleType>AUTO</HorScaleType>
    			</Plot>
				<Text>
					<Id>1680286834667</Id>
					<Name><![CDATA[text21]]></Name>
					<X>1500</X><Y>1160</Y>
					<Label><X>0</X><Y>-10</Y></Label>
					<PublicFlag>true</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>false</ShowLabel>
					<DrawMode>SHAPE_DRAW_2D</DrawMode>
					<EmbeddedIcon>false</EmbeddedIcon>
					<Z>0</Z>
					<Rotation>0.0</Rotation>
					<Color>-16777216</Color>
					<Text><![CDATA[System Load]]></Text>
					<Font>
						<Name>SansSerif</Name>
						<Size>14</Size>
						<Style>0</Style>
					</Font>
					<Alignment>LEFT</Alignment>
				</Text>
				<Text>
					<Id>1680286877081</Id>
					<Name><![CDATA[text22]]></Name>
					<X>1230</X><Y>1470</Y>
					<Label><X>0</X><Y>-10</Y></Label>
					<PublicFlag>true</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>false</ShowLabel>
					<DrawMode>SHAPE_DRAW_2D</DrawMode>
					<EmbeddedIcon>false</EmbeddedIcon>
					<Z>0</Z>
					<Rotation>270.0</Rotation>
					<Color>-16777216</Color>
					<Text><![CDATA[Processed Load]]></Text>
					<Font>
						<Name>SansSerif</Name>
						<Size>14</Size>
						<Style>0</Style>
					</Font>
					<Alignment>LEFT</Alignment>
				</Text>
    			<Plot>
					<Id>1680286877085</Id>
					<Name><![CDATA[plotPL8]]></Name>
					<X>1250</X><Y>1290</Y>
					<Label><X>0</X><Y>-10</Y></Label>
					<PublicFlag>true</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>false</ShowLabel>
					<DrawMode>SHAPE_DRAW_2D3D</DrawMode>
					<AutoUpdate>false</AutoUpdate>
					<OccurrenceAtTime>true</OccurrenceAtTime>
					<OccurrenceDate>1653465600000</OccurrenceDate>
					<OccurrenceTime Class="CodeUnitValue">
						<Code><![CDATA[0]]></Code>
						<Unit Class="TimeUnits"><![CDATA[DAY]]></Unit>
					</OccurrenceTime>
					<RecurrenceCode Class="CodeUnitValue">
						<Code><![CDATA[1]]></Code>
						<Unit Class="TimeUnits"><![CDATA[DAY]]></Unit>
					</RecurrenceCode>
					<EmbeddedIcon>false</EmbeddedIcon>
					<Width>550</Width>
					<Height>300</Height>
					<BackgroundColor/>
					<BorderColor/>
					<ChartArea>
						<XOffset>50</XOffset>
						<YOffset>30</YOffset>
						<Width>470</Width>
						<Height>210</Height>
						<BackgroundColor>-1</BackgroundColor>
						<BorderColor>-16777216</BorderColor>
						<GridColor>-12566464</GridColor>
					</ChartArea>
					<Legend>
						<Place>SOUTH</Place>
						<TextColor>-16777216</TextColor>
						<Size>30</Size>
					</Legend>
					<Labels>
						<HorLabelsPosition>DEFAULT</HorLabelsPosition>
						<VerLabelsPosition>DEFAULT</VerLabelsPosition>
						<TextColor>-12566464</TextColor>
					</Labels>
					<ShowLegend>true</ShowLegend>
					<VerScaleFromExpression><![CDATA[0]]></VerScaleFromExpression>
					<VerScaleToExpression><![CDATA[1]]></VerScaleToExpression>
					<VerScaleType>AUTO</VerScaleType>
					<DrawLine>true</DrawLine>
					<Interpolation>LINEAR</Interpolation>
					<DatasetExpression>  
						<Title><![CDATA[Stage4]]></Title>
					<Id>1680286877082</Id>
					<Expression><![CDATA[testDs4]]></Expression>
					<Color>-16777216</Color>
					<Expression2><![CDATA[testDs.getY(i)]]></Expression2>
					<Expression2Flag>false</Expression2Flag>
						<PointStyle>CIRCLE</PointStyle>
						<LineWidth>0.0</LineWidth>
						<HorizontalAxisExpression><![CDATA[testDs.getX(i)]]></HorizontalAxisExpression>
					</DatasetExpression>
					<SamplesToKeep>1000</SamplesToKeep>
					<HorScaleFromExpression><![CDATA[0]]></HorScaleFromExpression>
					<HorScaleToExpression><![CDATA[1]]></HorScaleToExpression>
					<HorScaleType>AUTO</HorScaleType>
    			</Plot>
				<Text>
					<Id>1680286877087</Id>
					<Name><![CDATA[text23]]></Name>
					<X>1500</X><Y>1560</Y>
					<Label><X>0</X><Y>-10</Y></Label>
					<PublicFlag>true</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>false</ShowLabel>
					<DrawMode>SHAPE_DRAW_2D</DrawMode>
					<EmbeddedIcon>false</EmbeddedIcon>
					<Z>0</Z>
					<Rotation>0.0</Rotation>
					<Color>-16777216</Color>
					<Text><![CDATA[System Load]]></Text>
					<Font>
						<Name>SansSerif</Name>
						<Size>14</Size>
						<Style>0</Style>
					</Font>
					<Alignment>LEFT</Alignment>
				</Text>
			</Presentation>

				</Level>
			</Presentation>

		</ActiveObjectClass>
		<!--   =========   Active Object Class   ========  -->
		<ActiveObjectClass>
			<Id>1654071868018</Id>
			<Name><![CDATA[KPIAgent]]></Name>
			<Import><![CDATA[import java.text.DecimalFormat; 
import java.text.NumberFormat; ]]></Import>
			<Generic>false</Generic>
			<GenericParameter>
				<Id>1654071868016</Id>
				<Name><![CDATA[1654071868016]]></Name>
				<GenericParameterValue Class="CodeValue">
					<Code><![CDATA[T extends Agent]]></Code>
				</GenericParameterValue>
				<GenericParameterLabel><![CDATA[Generic parameter:]]></GenericParameterLabel>
			</GenericParameter>
			<FlowChartsUsage>ENTITY</FlowChartsUsage>
			<SamplesToKeep>100</SamplesToKeep>
			<LimitNumberOfArrayElements>false</LimitNumberOfArrayElements>
			<ElementsLimitValue>100</ElementsLimitValue>
			<MakeDefaultViewArea>true</MakeDefaultViewArea>
			<SceneGridColor/>
			<SceneBackgroundColor/>
			<SceneSkybox>null</SceneSkybox>
			<AgentProperties>
				<EnvironmentDefinesInitialLocation>true</EnvironmentDefinesInitialLocation>
				<RotateAnimationTowardsMovement>true</RotateAnimationTowardsMovement>
				<RotateAnimationVertically>false</RotateAnimationVertically>
				<VelocityCode Class="CodeUnitValue">
					<Code><![CDATA[10]]></Code>
					<Unit Class="SpeedUnits"><![CDATA[MPS]]></Unit>
				</VelocityCode>
				<PhysicalLength Class="CodeUnitValue">
					<Code><![CDATA[1]]></Code>
					<Unit Class="LengthUnits"><![CDATA[METER]]></Unit>
				</PhysicalLength>
				<PhysicalWidth Class="CodeUnitValue">
					<Code><![CDATA[1]]></Code>
					<Unit Class="LengthUnits"><![CDATA[METER]]></Unit>
				</PhysicalWidth>
				<PhysicalHeight Class="CodeUnitValue">
					<Code><![CDATA[1]]></Code>
					<Unit Class="LengthUnits"><![CDATA[METER]]></Unit>
				</PhysicalHeight>
			</AgentProperties>
			<EnvironmentProperties>
					<EnableSteps>false</EnableSteps>
					<StepDurationCode Class="CodeUnitValue">
						<Code><![CDATA[1.0]]></Code>
						<Unit Class="TimeUnits"><![CDATA[SECOND]]></Unit>
					</StepDurationCode>
					<SpaceType>CONTINUOUS</SpaceType>
					<WidthCode><![CDATA[500]]></WidthCode>
					<HeightCode><![CDATA[500]]></HeightCode>
					<ZHeightCode><![CDATA[0]]></ZHeightCode>
					<ColumnsCountCode><![CDATA[100]]></ColumnsCountCode>
					<RowsCountCode><![CDATA[100]]></RowsCountCode>
					<NeigborhoodType>MOORE</NeigborhoodType>
					<LayoutType>USER_DEF</LayoutType>
					<NetworkType>USER_DEF</NetworkType>
					<ConnectionsPerAgentCode><![CDATA[2]]></ConnectionsPerAgentCode>
					<ConnectionsRangeCode><![CDATA[50]]></ConnectionsRangeCode>
					<NeighborLinkFractionCode><![CDATA[0.95]]></NeighborLinkFractionCode>
					<MCode><![CDATA[10]]></MCode>
			</EnvironmentProperties>
			<DatasetsCreationProperties>
				<AutoCreate>true</AutoCreate>
					<OccurrenceAtTime>true</OccurrenceAtTime>
					<OccurrenceDate>1654156800000</OccurrenceDate>
					<OccurrenceTime Class="CodeUnitValue">
						<Code><![CDATA[0]]></Code>
						<Unit Class="TimeUnits"><![CDATA[DAY]]></Unit>
					</OccurrenceTime>
					<RecurrenceCode Class="CodeUnitValue">
						<Code><![CDATA[1]]></Code>
						<Unit Class="TimeUnits"><![CDATA[DAY]]></Unit>
					</RecurrenceCode>
			</DatasetsCreationProperties>
			<ScaleRuler>
				<Id>1654071868014</Id>
				<Name><![CDATA[scale]]></Name>
				<X>0</X><Y>-150</Y>
				<PublicFlag>false</PublicFlag>
				<PresentationFlag>false</PresentationFlag>
				<ShowLabel>false</ShowLabel>
				<DrawMode>SHAPE_DRAW_2D3D</DrawMode>
				<Length>100</Length>
				<Rotation>0</Rotation>
				<ScaleType>BASED_ON_LENGTH</ScaleType>
				<ModelLength>10</ModelLength>
				<LengthUnits>METER</LengthUnits>
				<Scale>10</Scale>
				<InheritedFromParentAgentType>true</InheritedFromParentAgentType>
			</ScaleRuler>
			<CurrentLevel>1654071868017</CurrentLevel>
			<ConnectionsId>1654071868013</ConnectionsId>
			<Variables>
				<Variable Class="PlainVariable">
					<Id>1654696067241</Id>
					<Name><![CDATA[avgUtilization]]></Name>
					<X>-210</X><Y>490</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Properties SaveInSnapshot="true" Constant="false" AccessType="public" StaticVariable="false">
						<Type><![CDATA[double]]></Type>        
						<InitialValue Class="CodeValue">
							<Code><![CDATA[0]]></Code>
						</InitialValue>
					</Properties>
				</Variable>
				<Variable Class="PlainVariable">
					<Id>1654786853036</Id>
					<Name><![CDATA[systemJSI]]></Name>
					<X>-180</X><Y>890</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Properties SaveInSnapshot="true" Constant="false" AccessType="public" StaticVariable="false">
						<Type><![CDATA[double]]></Type>        
					</Properties>
				</Variable>
				<Variable Class="PlainVariable">
					<Id>1654842153035</Id>
					<Name><![CDATA[systemSGI]]></Name>
					<X>-180</X><Y>910</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Properties SaveInSnapshot="true" Constant="false" AccessType="public" StaticVariable="false">
						<Type><![CDATA[double]]></Type>        
					</Properties>
				</Variable>
			</Variables>
			<Events>
				<Event>
					<Id>1654072161205</Id>
					<Name><![CDATA[eventUpdateStatistics]]></Name>
					<ExcludeFromBuild>true</ExcludeFromBuild>
					<X>-220</X><Y>160</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Properties TriggerType="timeout" Mode="cyclic">
						<Timeout Class="CodeUnitValue">
							<Code><![CDATA[1]]></Code>
							<Unit Class="TimeUnits"><![CDATA[DAY]]></Unit>
						</Timeout>
						<Rate Class="CodeUnitValue">
							<Code><![CDATA[1]]></Code>
							<Unit Class="RateUnits"><![CDATA[PER_DAY]]></Unit>
						</Rate>
						<OccurrenceAtTime>true</OccurrenceAtTime>
						<OccurrenceDate>1653638400000</OccurrenceDate>
						<OccurrenceTime Class="CodeUnitValue">
							<Code><![CDATA[get_Main().simParams.getWarumUpTime()]]></Code>
							<Unit Class="TimeUnits"><![CDATA[DAY]]></Unit>
						</OccurrenceTime>
						<RecurrenceCode Class="CodeUnitValue">
							<Code><![CDATA[1]]></Code>
							<Unit Class="TimeUnits"><![CDATA[DAY]]></Unit>
						</RecurrenceCode>
						<Condition><![CDATA[false]]></Condition>
					</Properties>
					<Action><![CDATA[
//Compute average utilization over all machine agents
double avg = 0;

for(int i = 0; i < get_Main().machineAgents.size(); i++){
	avg += get_Main().machineAgents.get(i).delayProcessingTime.statsUtilization.mean();				
}

avg = avg / get_Main().machineAgents.size();

double percentage = avg * 100;
]]></Action>
				</Event>
				<Event>
					<Id>1654370940539</Id>
					<Name><![CDATA[eventComputeKPIs]]></Name>
					<X>-210</X><Y>430</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Properties TriggerType="timeout" Mode="cyclic">
						<Timeout Class="CodeUnitValue">
							<Code><![CDATA[1]]></Code>
							<Unit Class="TimeUnits"><![CDATA[DAY]]></Unit>
						</Timeout>
						<Rate Class="CodeUnitValue">
							<Code><![CDATA[1]]></Code>
							<Unit Class="RateUnits"><![CDATA[PER_DAY]]></Unit>
						</Rate>
						<OccurrenceAtTime>true</OccurrenceAtTime>
						<OccurrenceDate>1654416000000</OccurrenceDate>
						<OccurrenceTime Class="CodeUnitValue">
							<Code><![CDATA[0]]></Code>
							<Unit Class="TimeUnits"><![CDATA[DAY]]></Unit>
						</OccurrenceTime>
						<RecurrenceCode Class="CodeUnitValue">
							<Code><![CDATA[1]]></Code>
							<Unit Class="TimeUnits"><![CDATA[DAY]]></Unit>
						</RecurrenceCode>
						<Condition><![CDATA[false]]></Condition>
					</Properties>
					<Action><![CDATA[
if(time() > get_Main().simParams.getWarumUpTime()){
	function_computeSystemUtilization(true);
	function_computeSGIandJSI();
	function_computeMeanDemandPerItem();
}
]]></Action>
				</Event>
				<Event>
					<Id>1654689288943</Id>
					<Name><![CDATA[eventResetStatistics]]></Name>
					<X>-210</X><Y>390</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Properties TriggerType="timeout" Mode="occuresOnce">
						<Timeout Class="CodeUnitValue">
							<Code><![CDATA[1]]></Code>
							<Unit Class="TimeUnits"><![CDATA[DAY]]></Unit>
						</Timeout>
						<Rate Class="CodeUnitValue">
							<Code><![CDATA[1]]></Code>
							<Unit Class="RateUnits"><![CDATA[PER_DAY]]></Unit>
						</Rate>
						<OccurrenceAtTime>true</OccurrenceAtTime>
						<OccurrenceDate>1654416000000</OccurrenceDate>
						<OccurrenceTime Class="CodeUnitValue">
							<Code><![CDATA[0]]></Code>
							<Unit Class="TimeUnits"><![CDATA[DAY]]></Unit>
						</OccurrenceTime>
						<RecurrenceCode Class="CodeUnitValue">
							<Code><![CDATA[0]]></Code>
							<Unit Class="TimeUnits"><![CDATA[DAY]]></Unit>
						</RecurrenceCode>
						<Condition><![CDATA[false]]></Condition>
					</Properties>
					<Action><![CDATA[
traceln("Statistic Reset at " + time());

for(int i = 0; i < get_Main().machineAgents.size();i++){
	get_Main().machineAgents.get(i).delayProcessingTime.statsUtilization.reset();
	get_Main().machineAgents.get(i).statJSIperMachine.reset();
	//get_Main().machineAgents.get(i).varJSI = 0;
}

get_Main().statSystemWIP.reset();
get_Main().statSystemWIPComponents.reset();
get_Main().datasetSystemUtilization.reset();
main.StatisticServiceLevel.reset();
main.sumEnergyCosts = 0;	
main.countCapacityFactorBlock = 0;
main.countEnergyPriceBlock = 0;]]></Action>
				</Event>
			</Events>
			<Functions>
				<Function AccessType="default" StaticFunction="false">
					<ReturnModificator>RETURNS_VALUE</ReturnModificator>
					<ReturnType><![CDATA[KPI]]></ReturnType>
					<Id>1654588645976</Id>
					<Name><![CDATA[function_computeSystemUtilization]]></Name>
					<X>-210</X><Y>460</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Parameter>
						<Name><![CDATA[writeKPI]]></Name>
						<Type><![CDATA[boolean]]></Type>
					</Parameter>
					<Body><![CDATA[double val = 0;
double val1 = 0;
double avg = 0;
StringBuilder utilizations = new StringBuilder();

for(int i = 0; i < get_Main().machineAgents.size();i++){
	val = get_Main().machineAgents.get(i).delayProcessingTime.statsUtilization.mean();	
	val1 = get_Main().machineAgents.get(i).statJSIperMachine.integral()/time();
		
	if(writeKPI){
		utilizations.append(get_Main().machineAgents.get(i).Resource.getName() + "=" +  val + ";");
		//if(val > 0 && get_Main().machineAgents.get(i).Resource.getName().equals("M41") )
			//traceln(time() + " " + get_Main().machineAgents.get(i).Resource.getName() + " " + val);	
	}
	
	if(!Double.isNaN(val)) {
		get_Main().kPIAgent.plotUtilizations.get(i).add(time(),val*100);	
	}
	
	if(!Double.isNaN(val1)) {
		get_Main().kPIAgent.plotJSIPerMachine.get(i).add(time(),val1);	
	}
	
	avg += val;		
}

avg = avg / get_Main().machineAgents.size();

if(!Double.isNaN(avg)) {
	get_Main().datasetSystemUtilization.add(avg * 100);
}else {
	avg = 0;
}

NumberFormat formatter = new DecimalFormat("#0.00"); 
textSystemUtilization.setText("System Utilization:" + formatter.format(avg * 100) + " %");

avgUtilization = avg * 100;

plotSystemUtilization.updateData();
plotJSIPerMachine.updateData();

KPI kpi = new KPI(avgUtilization,utilizations.toString());

return kpi;
]]></Body>
				</Function>
				<Function AccessType="default" StaticFunction="false">
					<ReturnModificator>RETURNS_VALUE</ReturnModificator>
					<ReturnType><![CDATA[KPI]]></ReturnType>
					<Id>1654765074740</Id>
					<Name><![CDATA[function_computeSGIandJSI]]></Name>
					<X>-180</X><Y>860</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Body><![CDATA[plotSystemUtilization.updateData();

systemJSI = get_Main().statSystemWIP.integral()/time();
systemSGI = get_Main().statSystemWIPComponents.integral()/time();

NumberFormat formatter = new DecimalFormat("#.00");
textSystemWIP.setText("JSI:" + formatter.format(systemJSI) 
+ " SGI: " + formatter.format(systemSGI));

KPI k = new KPI(systemJSI,Double.toString(systemSGI));
return k;
]]></Body>
				</Function>
				<Function AccessType="default" StaticFunction="false">
					<ReturnModificator>RETURNS_VALUE</ReturnModificator>
					<ReturnType><![CDATA[KPI]]></ReturnType>
					<Id>1654864128064</Id>
					<Name><![CDATA[function_computeMeanDemandPerItem]]></Name>
					<X>-150</X><Y>1420</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Body><![CDATA[double val = 0;

StringBuilder demands = new StringBuilder();

for(Item item : get_Main().items){
	if(item.getDataItemIndex() >= 0 && item.getType().equals(Item.ITEM_TYPE_SALES)){			
		val = plotDemandPerItem.get(item.getDataItemIndex()).getYMean();						
			demands.append(item.getItem() + "=" +  val + ";");		
	}
}

NumberFormat formatter = new DecimalFormat("#0.00"); 
textDemandPerItem.setText("Demand per Item Average(" + demands + ")");

KPI kpi = new KPI(0,demands.toString());

return kpi;
]]></Body>
				</Function>
			</Functions>
			<AgentLinks>
				<AgentLink>
					<Id>1654071868013</Id>
					<Name><![CDATA[connections]]></Name>
					<X>50</X><Y>-50</Y>
					<Label><X>15</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<HandleReceiveInConnections>false</HandleReceiveInConnections>
					<AgentLinkType>COLLECTION_OF_LINKS</AgentLinkType>
					<AgentLinkBidirectional>true</AgentLinkBidirectional>
					<MessageType><![CDATA[Object]]></MessageType>
					<LineStyle>SOLID</LineStyle>
					<LineWidth>1</LineWidth>
					<LineColor>-16777216</LineColor>
					<LineZOrder>UNDER_AGENTS</LineZOrder>
					<LineArrow>NONE</LineArrow>
					<LineArrowPosition>END</LineArrowPosition>
				</AgentLink>
			</AgentLinks>

			<ContainerLinks>
				<ContainerLink>
					<Id>1654489517756</Id>
					<Name><![CDATA[main]]></Name>
					<X>50</X><Y>-100</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<ActiveObjectClass>
						<PackageName><![CDATA[simopt]]></PackageName>
						<ClassName><![CDATA[Main]]></ClassName>
					</ActiveObjectClass>
				</ContainerLink>
			</ContainerLinks>

			<Presentation>
				<Level>
					<Id>1654071868017</Id>
					<Name><![CDATA[level]]></Name>
					<X>0</X><Y>0</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>true</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>false</ShowLabel>
					<DrawMode>SHAPE_DRAW_2D3D</DrawMode>
					<Z>0</Z>
					<LevelVisibility>DIM_NON_CURRENT</LevelVisibility>

			<Presentation>
				<Figure3D>
					<Id>1654071868024</Id>
					<Name><![CDATA[person]]></Name>
					<X>0</X><Y>0</Y>
					<Label><X>0</X><Y>-10</Y></Label>
					<PublicFlag>true</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>false</ShowLabel>
					<DrawMode>SHAPE_DRAW_2D3D</DrawMode>
					<X>0</X><Y>0</Y><Z>0</Z>
					<Label><X>0</X><Y>-10</Y></Label>
					<ResourceReference>
						<PackageName><![CDATA[simopt]]></PackageName>
						<ClassName><![CDATA[3d/person.dae]]></ClassName>
					</ResourceReference>
					<ColorTable>
						<ColorMapping>
							<Name><![CDATA[Material__3__Surf]]></Name>
							<OriginalColor>-3355444</OriginalColor>
						</ColorMapping>
						<ColorMapping>
							<Name><![CDATA[Material__5__Surf]]></Name>
							<OriginalColor>-3355444</OriginalColor>
						</ColorMapping>
						<ColorMapping>
							<Name><![CDATA[Material__6__Surf]]></Name>
							<OriginalColor>-4083577</OriginalColor>
						</ColorMapping>
						<ColorMapping>
							<Name><![CDATA[Material__2__Surf]]></Name>
							<OriginalColor>-13355980</OriginalColor>
						</ColorMapping>
						<ColorMapping>
							<Name><![CDATA[Material__4__Surf]]></Name>
							<OriginalColor>-13355980</OriginalColor>
						</ColorMapping>
						<ColorMapping>
							<Name><![CDATA[Material__1__Surf]]></Name>
							<OriginalColor>-5279952</OriginalColor>
						</ColorMapping>
					</ColorTable>
					<AutoScale>true</AutoScale>
					<Scale>1.0</Scale>
					<Rotation>0.0</Rotation>
					<AxisOrder>YZX_AXIS_ORDER</AxisOrder>
					<ApplyShading>true</ApplyShading>
					<InternalLighting>OFF</InternalLighting>
					<IgnoreSceneLights>false</IgnoreSceneLights>
				</Figure3D>
				<Group>
					<Id>1654696384161</Id>
					<Name><![CDATA[group]]></Name>
					<X>340</X><Y>140</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>true</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>false</ShowLabel>
					<DrawMode>SHAPE_DRAW_2D3D</DrawMode>
					<EmbeddedIcon>false</EmbeddedIcon>
					<Z>0</Z>
					<Rotation>0.0</Rotation>

			<Presentation>
    			<TimePlot>
					<Id>1654322711504</Id>
					<Name><![CDATA[plotUtilizations]]></Name>
					<X>-290</X><Y>-130</Y>
					<Label><X>0</X><Y>-10</Y></Label>
					<PublicFlag>true</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>false</ShowLabel>
					<DrawMode>SHAPE_DRAW_2D3D</DrawMode>
					<AutoUpdate>false</AutoUpdate>
					<OccurrenceAtTime>true</OccurrenceAtTime>
					<OccurrenceDate>1639555200000</OccurrenceDate>
					<OccurrenceTime Class="CodeUnitValue">
						<Code><![CDATA[get_Main().simParams.getWarumUpTime()
]]></Code>
						<Unit Class="TimeUnits"><![CDATA[DAY]]></Unit>
					</OccurrenceTime>
					<RecurrenceCode Class="CodeUnitValue">
						<Code><![CDATA[1]]></Code>
						<Unit Class="TimeUnits"><![CDATA[DAY]]></Unit>
					</RecurrenceCode>
					<EmbeddedIcon>false</EmbeddedIcon>
					<Width>590</Width>
					<Height>270</Height>
					<BackgroundColor/>
					<BorderColor/>
					<ChartArea>
						<XOffset>50</XOffset>
						<YOffset>30</YOffset>
						<Width>530</Width>
						<Height>180</Height>
						<BackgroundColor>-1</BackgroundColor>
						<BorderColor>-16777216</BorderColor>
						<GridColor>-12566464</GridColor>
					</ChartArea>
					<Legend>
						<Place>SOUTH</Place>
						<TextColor>-16777216</TextColor>
						<Size>30</Size>
					</Legend>
					<Labels>
						<HorLabelsPosition>DEFAULT</HorLabelsPosition>
						<VerLabelsPosition>DEFAULT</VerLabelsPosition>
						<TextColor>-12566464</TextColor>
					</Labels>
					<ShowLegend>true</ShowLegend>
					<TimeWindowsMovementType>MOVEMENT_WITH_TIME</TimeWindowsMovementType>		
					<TimeWindowUnits>MODEL_TIME_UNIT</TimeWindowUnits>
					<VerScaleFromExpression><![CDATA[0]]></VerScaleFromExpression>
					<VerScaleToExpression><![CDATA[100]]></VerScaleToExpression>
					<VerScaleType>FIXED</VerScaleType>
					<DrawLine>true</DrawLine>
					<Interpolation>LINEAR</Interpolation>
					<SamplesToKeep>100</SamplesToKeep>
					<TimeWindowExpression><![CDATA[100]]></TimeWindowExpression>
					<FillAreaUnderLine>false</FillAreaUnderLine>
					<LabelFormat>MODEL_TIME_UNITS</LabelFormat>
    			</TimePlot>
				<Text>
					<Id>1654696207511</Id>
					<Name><![CDATA[text9]]></Name>
					<X>-300</X><Y>40</Y>
					<Label><X>0</X><Y>-10</Y></Label>
					<PublicFlag>true</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>false</ShowLabel>
					<DrawMode>SHAPE_DRAW_2D</DrawMode>
					<EmbeddedIcon>false</EmbeddedIcon>
					<Z>0</Z>
					<Rotation>270.0</Rotation>
					<Color>-16777216</Color>
					<Text><![CDATA[Percentage
]]></Text>
					<Font>
						<Name>SansSerif</Name>
						<Size>20</Size>
						<Style>0</Style>
					</Font>
					<Alignment>LEFT</Alignment>
				</Text>
			</Presentation>

				</Group>
    			<TimePlot>
					<Id>1654764779086</Id>
					<Name><![CDATA[plotSystemWIP]]></Name>
					<X>70</X><Y>720</Y>
					<Label><X>0</X><Y>-10</Y></Label>
					<PublicFlag>true</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>false</ShowLabel>
					<DrawMode>SHAPE_DRAW_2D3D</DrawMode>
					<AutoUpdate>true</AutoUpdate>
					<OccurrenceAtTime>true</OccurrenceAtTime>
					<OccurrenceDate>1654848000000</OccurrenceDate>
					<OccurrenceTime Class="CodeUnitValue">
						<Code><![CDATA[0]]></Code>
						<Unit Class="TimeUnits"><![CDATA[DAY]]></Unit>
					</OccurrenceTime>
					<RecurrenceCode Class="CodeUnitValue">
						<Code><![CDATA[1]]></Code>
						<Unit Class="TimeUnits"><![CDATA[DAY]]></Unit>
					</RecurrenceCode>
					<EmbeddedIcon>false</EmbeddedIcon>
					<Width>600</Width>
					<Height>280</Height>
					<BackgroundColor/>
					<BorderColor/>
					<ChartArea>
						<XOffset>50</XOffset>
						<YOffset>30</YOffset>
						<Width>520</Width>
						<Height>190</Height>
						<BackgroundColor>-1</BackgroundColor>
						<BorderColor>-16777216</BorderColor>
						<GridColor>-12566464</GridColor>
					</ChartArea>
					<Legend>
						<Place>SOUTH</Place>
						<TextColor>-16777216</TextColor>
						<Size>30</Size>
					</Legend>
					<Labels>
						<HorLabelsPosition>DEFAULT</HorLabelsPosition>
						<VerLabelsPosition>DEFAULT</VerLabelsPosition>
						<TextColor>-12566464</TextColor>
					</Labels>
					<ShowLegend>true</ShowLegend>
					<TimeWindowsMovementType>MOVEMENT_WITH_TIME</TimeWindowsMovementType>		
					<TimeWindowUnits>MODEL_TIME_UNIT</TimeWindowUnits>
					<VerScaleFromExpression><![CDATA[0]]></VerScaleFromExpression>
					<VerScaleToExpression><![CDATA[1]]></VerScaleToExpression>
					<VerScaleType>AUTO</VerScaleType>
					<DrawLine>true</DrawLine>
					<Interpolation>LINEAR</Interpolation>
					<DatasetExpression>  
						<Title><![CDATA[System WIP (pieces per time)]]></Title>
					<Id>0</Id>
					<Expression><![CDATA[my_dataset]]></Expression>
					<Color>-7667573</Color>
					<Expression2><![CDATA[systemJSI]]></Expression2>
					<Expression2Flag>true</Expression2Flag>
						<PointStyle>NONE</PointStyle>
						<LineWidth>2.0</LineWidth>
					</DatasetExpression>
					<DatasetExpression>  
						<Title><![CDATA[System WIP Components (pieces per time)]]></Title>
					<Id>0</Id>
					<Expression><![CDATA[my_dataset1]]></Expression>
					<Color>-23296</Color>
					<Expression2><![CDATA[systemSGI]]></Expression2>
					<Expression2Flag>true</Expression2Flag>
						<PointStyle>NONE</PointStyle>
						<LineWidth>2.0</LineWidth>
					</DatasetExpression>
					<SamplesToKeep>100</SamplesToKeep>
					<TimeWindowExpression><![CDATA[100]]></TimeWindowExpression>
					<FillAreaUnderLine>false</FillAreaUnderLine>
					<LabelFormat>MODEL_TIME_UNITS</LabelFormat>
    			</TimePlot>
				<Text>
					<Id>1654773652795</Id>
					<Name><![CDATA[text8]]></Name>
					<X>120</X><Y>710</Y>
					<Label><X>0</X><Y>-10</Y></Label>
					<PublicFlag>true</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>false</ShowLabel>
					<DrawMode>SHAPE_DRAW_2D</DrawMode>
					<EmbeddedIcon>false</EmbeddedIcon>
					<Z>0</Z>
					<Rotation>0.0</Rotation>
					<Color>-16777216</Color>
					<Text><![CDATA[System WIP]]></Text>
					<Font>
						<Name>SansSerif</Name>
						<Size>20</Size>
						<Style>0</Style>
					</Font>
					<Alignment>LEFT</Alignment>
				</Text>
				<Text>
					<Id>1654773652807</Id>
					<Name><![CDATA[textSystemWIP]]></Name>
					<X>250</X><Y>710</Y>
					<Label><X>0</X><Y>-10</Y></Label>
					<PublicFlag>true</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>false</ShowLabel>
					<DrawMode>SHAPE_DRAW_2D</DrawMode>
					<EmbeddedIcon>false</EmbeddedIcon>
					<Z>0</Z>
					<Rotation>0.0</Rotation>
					<Color>-16777216</Color>
					<Text><![CDATA[Current System WIP]]></Text>
					<Font>
						<Name>SansSerif</Name>
						<Size>20</Size>
						<Style>0</Style>
					</Font>
					<Alignment>LEFT</Alignment>
				</Text>
    			<TimePlot>
					<Id>1654783534079</Id>
					<Name><![CDATA[plotSystemWIP1]]></Name>
					<X>80</X><Y>1000</Y>
					<Label><X>0</X><Y>-10</Y></Label>
					<PublicFlag>true</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>false</ShowLabel>
					<DrawMode>SHAPE_DRAW_2D3D</DrawMode>
					<AutoUpdate>true</AutoUpdate>
					<OccurrenceAtTime>true</OccurrenceAtTime>
					<OccurrenceDate>1654848000000</OccurrenceDate>
					<OccurrenceTime Class="CodeUnitValue">
						<Code><![CDATA[0]]></Code>
						<Unit Class="TimeUnits"><![CDATA[DAY]]></Unit>
					</OccurrenceTime>
					<RecurrenceCode Class="CodeUnitValue">
						<Code><![CDATA[1]]></Code>
						<Unit Class="TimeUnits"><![CDATA[DAY]]></Unit>
					</RecurrenceCode>
					<EmbeddedIcon>false</EmbeddedIcon>
					<Width>580</Width>
					<Height>280</Height>
					<BackgroundColor/>
					<BorderColor/>
					<ChartArea>
						<XOffset>50</XOffset>
						<YOffset>30</YOffset>
						<Width>500</Width>
						<Height>190</Height>
						<BackgroundColor>-1</BackgroundColor>
						<BorderColor>-16777216</BorderColor>
						<GridColor>-12566464</GridColor>
					</ChartArea>
					<Legend>
						<Place>SOUTH</Place>
						<TextColor>-16777216</TextColor>
						<Size>30</Size>
					</Legend>
					<Labels>
						<HorLabelsPosition>DEFAULT</HorLabelsPosition>
						<VerLabelsPosition>DEFAULT</VerLabelsPosition>
						<TextColor>-12566464</TextColor>
					</Labels>
					<ShowLegend>true</ShowLegend>
					<TimeWindowsMovementType>MOVEMENT_WITH_TIME</TimeWindowsMovementType>		
					<TimeWindowUnits>MODEL_TIME_UNIT</TimeWindowUnits>
					<VerScaleFromExpression><![CDATA[0]]></VerScaleFromExpression>
					<VerScaleToExpression><![CDATA[1]]></VerScaleToExpression>
					<VerScaleType>AUTO</VerScaleType>
					<DrawLine>true</DrawLine>
					<Interpolation>LINEAR</Interpolation>
					<DatasetExpression>  
						<Title><![CDATA[JFI]]></Title>
					<Id>1654783534076</Id>
					<Expression><![CDATA[my_dataset]]></Expression>
					<Color>-7667573</Color>
					<Expression2><![CDATA[get_Main().varSystemWIP]]></Expression2>
					<Expression2Flag>true</Expression2Flag>
						<PointStyle>NONE</PointStyle>
						<LineWidth>2.0</LineWidth>
					</DatasetExpression>
					<DatasetExpression>  
						<Title><![CDATA[SGI]]></Title>
					<Id>0</Id>
					<Expression><![CDATA[my_dataset1]]></Expression>
					<Color>-23296</Color>
					<Expression2><![CDATA[get_Main().varSystemWIPComponents]]></Expression2>
					<Expression2Flag>true</Expression2Flag>
						<PointStyle>NONE</PointStyle>
						<LineWidth>2.0</LineWidth>
					</DatasetExpression>
					<SamplesToKeep>100</SamplesToKeep>
					<TimeWindowExpression><![CDATA[100]]></TimeWindowExpression>
					<FillAreaUnderLine>false</FillAreaUnderLine>
					<LabelFormat>MODEL_TIME_UNITS</LabelFormat>
    			</TimePlot>
				<Text>
					<Id>1654786482892</Id>
					<Name><![CDATA[textSystemWIPComponents]]></Name>
					<X>130</X><Y>1000</Y>
					<Label><X>0</X><Y>-10</Y></Label>
					<PublicFlag>true</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>false</ShowLabel>
					<DrawMode>SHAPE_DRAW_2D</DrawMode>
					<EmbeddedIcon>false</EmbeddedIcon>
					<Z>0</Z>
					<Rotation>0.0</Rotation>
					<Color>-16777216</Color>
					<Text><![CDATA[WIP]]></Text>
					<Font>
						<Name>SansSerif</Name>
						<Size>20</Size>
						<Style>0</Style>
					</Font>
					<Alignment>LEFT</Alignment>
				</Text>
				<Text>
					<Id>1654786524020</Id>
					<Name><![CDATA[text11]]></Name>
					<X>70</X><Y>1170</Y>
					<Label><X>0</X><Y>-10</Y></Label>
					<PublicFlag>true</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>false</ShowLabel>
					<DrawMode>SHAPE_DRAW_2D</DrawMode>
					<EmbeddedIcon>false</EmbeddedIcon>
					<Z>0</Z>
					<Rotation>270.0</Rotation>
					<Color>-16777216</Color>
					<Text><![CDATA[Quantity]]></Text>
					<Font>
						<Name>SansSerif</Name>
						<Size>20</Size>
						<Style>0</Style>
					</Font>
					<Alignment>LEFT</Alignment>
				</Text>
				<Group>
					<Id>1654862745531</Id>
					<Name><![CDATA[group2]]></Name>
					<X>390</X><Y>1440</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>true</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>false</ShowLabel>
					<DrawMode>SHAPE_DRAW_2D3D</DrawMode>
					<EmbeddedIcon>false</EmbeddedIcon>
					<Z>0</Z>
					<Rotation>0.0</Rotation>

			<Presentation>
    			<TimePlot>
					<Id>1654862745534</Id>
					<Name><![CDATA[plotDemandPerItem]]></Name>
					<X>-290</X><Y>-130</Y>
					<Label><X>0</X><Y>-10</Y></Label>
					<PublicFlag>true</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>false</ShowLabel>
					<DrawMode>SHAPE_DRAW_2D3D</DrawMode>
					<AutoUpdate>false</AutoUpdate>
					<OccurrenceAtTime>true</OccurrenceAtTime>
					<OccurrenceDate>1639555200000</OccurrenceDate>
					<OccurrenceTime Class="CodeUnitValue">
						<Code><![CDATA[get_Main().simParams.getWarumUpTime()
]]></Code>
						<Unit Class="TimeUnits"><![CDATA[DAY]]></Unit>
					</OccurrenceTime>
					<RecurrenceCode Class="CodeUnitValue">
						<Code><![CDATA[1]]></Code>
						<Unit Class="TimeUnits"><![CDATA[DAY]]></Unit>
					</RecurrenceCode>
					<EmbeddedIcon>false</EmbeddedIcon>
					<Width>590</Width>
					<Height>270</Height>
					<BackgroundColor/>
					<BorderColor/>
					<ChartArea>
						<XOffset>50</XOffset>
						<YOffset>30</YOffset>
						<Width>530</Width>
						<Height>180</Height>
						<BackgroundColor>-1</BackgroundColor>
						<BorderColor>-16777216</BorderColor>
						<GridColor>-12566464</GridColor>
					</ChartArea>
					<Legend>
						<Place>SOUTH</Place>
						<TextColor>-16777216</TextColor>
						<Size>30</Size>
					</Legend>
					<Labels>
						<HorLabelsPosition>DEFAULT</HorLabelsPosition>
						<VerLabelsPosition>DEFAULT</VerLabelsPosition>
						<TextColor>-12566464</TextColor>
					</Labels>
					<ShowLegend>true</ShowLegend>
					<TimeWindowsMovementType>MOVEMENT_WITH_TIME</TimeWindowsMovementType>		
					<TimeWindowUnits>MODEL_TIME_UNIT</TimeWindowUnits>
					<VerScaleFromExpression><![CDATA[0]]></VerScaleFromExpression>
					<VerScaleToExpression><![CDATA[100]]></VerScaleToExpression>
					<VerScaleType>AUTO</VerScaleType>
					<DrawLine>true</DrawLine>
					<Interpolation>LINEAR</Interpolation>
					<SamplesToKeep>100</SamplesToKeep>
					<TimeWindowExpression><![CDATA[100]]></TimeWindowExpression>
					<FillAreaUnderLine>false</FillAreaUnderLine>
					<LabelFormat>MODEL_TIME_UNITS</LabelFormat>
    			</TimePlot>
				<Text>
					<Id>1654862745536</Id>
					<Name><![CDATA[text12]]></Name>
					<X>-300</X><Y>40</Y>
					<Label><X>0</X><Y>-10</Y></Label>
					<PublicFlag>true</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>false</ShowLabel>
					<DrawMode>SHAPE_DRAW_2D</DrawMode>
					<EmbeddedIcon>false</EmbeddedIcon>
					<Z>0</Z>
					<Rotation>270.0</Rotation>
					<Color>-16777216</Color>
					<Text><![CDATA[Quantity]]></Text>
					<Font>
						<Name>SansSerif</Name>
						<Size>20</Size>
						<Style>0</Style>
					</Font>
					<Alignment>LEFT</Alignment>
				</Text>
			</Presentation>

				</Group>
				<Text>
					<Id>1654864034743</Id>
					<Name><![CDATA[textDemandPerItem]]></Name>
					<X>140</X><Y>1290</Y>
					<Label><X>0</X><Y>-10</Y></Label>
					<PublicFlag>true</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>false</ShowLabel>
					<DrawMode>SHAPE_DRAW_2D</DrawMode>
					<EmbeddedIcon>false</EmbeddedIcon>
					<Z>0</Z>
					<Rotation>0.0</Rotation>
					<Color>-16777216</Color>
					<Text><![CDATA[Demand per Item]]></Text>
					<Font>
						<Name>SansSerif</Name>
						<Size>20</Size>
						<Style>0</Style>
					</Font>
					<Alignment>LEFT</Alignment>
				</Text>
				<Text>
					<Id>1655125457698</Id>
					<Name><![CDATA[text13]]></Name>
					<X>100</X><Y>0</Y>
					<Label><X>0</X><Y>-10</Y></Label>
					<PublicFlag>true</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>false</ShowLabel>
					<DrawMode>SHAPE_DRAW_2D</DrawMode>
					<EmbeddedIcon>false</EmbeddedIcon>
					<Z>0</Z>
					<Rotation>0.0</Rotation>
					<Color>-16777216</Color>
					<Text><![CDATA[Utilization per Machine]]></Text>
					<Font>
						<Name>SansSerif</Name>
						<Size>20</Size>
						<Style>0</Style>
					</Font>
					<Alignment>LEFT</Alignment>
				</Text>
				<Group>
					<Id>1655127207848</Id>
					<Name><![CDATA[group3]]></Name>
					<X>370</X><Y>360</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>true</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>false</ShowLabel>
					<DrawMode>SHAPE_DRAW_2D3D</DrawMode>
					<EmbeddedIcon>false</EmbeddedIcon>
					<Z>0</Z>
					<Rotation>0.0</Rotation>

			<Presentation>
				<Text>
					<Id>1654072012776</Id>
					<Name><![CDATA[text7]]></Name>
					<X>-270</X><Y>-90</Y>
					<Label><X>0</X><Y>-10</Y></Label>
					<PublicFlag>true</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>false</ShowLabel>
					<DrawMode>SHAPE_DRAW_2D</DrawMode>
					<EmbeddedIcon>false</EmbeddedIcon>
					<Z>0</Z>
					<Rotation>0.0</Rotation>
					<Color>-16777216</Color>
					<Text><![CDATA[Utilization (Precessing and Setup)]]></Text>
					<Font>
						<Name>SansSerif</Name>
						<Size>20</Size>
						<Style>0</Style>
					</Font>
					<Alignment>LEFT</Alignment>
				</Text>
				<Text>
					<Id>1654491519661</Id>
					<Name><![CDATA[textSystemUtilization]]></Name>
					<X>30</X><Y>-90</Y>
					<Label><X>0</X><Y>-10</Y></Label>
					<PublicFlag>true</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>false</ShowLabel>
					<DrawMode>SHAPE_DRAW_2D</DrawMode>
					<EmbeddedIcon>false</EmbeddedIcon>
					<Z>0</Z>
					<Rotation>0.0</Rotation>
					<Color>-16777216</Color>
					<Text><![CDATA[Current System Utilization]]></Text>
					<Font>
						<Name>SansSerif</Name>
						<Size>20</Size>
						<Style>0</Style>
					</Font>
					<Alignment>LEFT</Alignment>
				</Text>
				<Group>
					<Id>1654696393140</Id>
					<Name><![CDATA[group1]]></Name>
					<X>-30</X><Y>80</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>true</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>false</ShowLabel>
					<DrawMode>SHAPE_DRAW_2D3D</DrawMode>
					<EmbeddedIcon>false</EmbeddedIcon>
					<Z>0</Z>
					<Rotation>0.0</Rotation>

			<Presentation>
    			<TimePlot>
					<Id>1654583614078</Id>
					<Name><![CDATA[plotSystemUtilization]]></Name>
					<X>-280</X><Y>-160</Y>
					<Label><X>0</X><Y>-10</Y></Label>
					<PublicFlag>true</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>false</ShowLabel>
					<DrawMode>SHAPE_DRAW_2D3D</DrawMode>
					<AutoUpdate>false</AutoUpdate>
					<OccurrenceAtTime>true</OccurrenceAtTime>
					<OccurrenceDate>1654588800000</OccurrenceDate>
					<OccurrenceTime Class="CodeUnitValue">
						<Code><![CDATA[0]]></Code>
						<Unit Class="TimeUnits"><![CDATA[DAY]]></Unit>
					</OccurrenceTime>
					<RecurrenceCode Class="CodeUnitValue">
						<Code><![CDATA[1]]></Code>
						<Unit Class="TimeUnits"><![CDATA[DAY]]></Unit>
					</RecurrenceCode>
					<EmbeddedIcon>false</EmbeddedIcon>
					<Width>600</Width>
					<Height>330</Height>
					<BackgroundColor/>
					<BorderColor/>
					<ChartArea>
						<XOffset>50</XOffset>
						<YOffset>30</YOffset>
						<Width>520</Width>
						<Height>240</Height>
						<BackgroundColor>-1</BackgroundColor>
						<BorderColor>-16777216</BorderColor>
						<GridColor>-12566464</GridColor>
					</ChartArea>
					<Legend>
						<Place>SOUTH</Place>
						<TextColor>-16777216</TextColor>
						<Size>30</Size>
					</Legend>
					<Labels>
						<HorLabelsPosition>DEFAULT</HorLabelsPosition>
						<VerLabelsPosition>DEFAULT</VerLabelsPosition>
						<TextColor>-12566464</TextColor>
					</Labels>
					<ShowLegend>true</ShowLegend>
					<TimeWindowsMovementType>MOVEMENT_WITH_DATA</TimeWindowsMovementType>		
					<TimeWindowUnits>MODEL_TIME_UNIT</TimeWindowUnits>
					<VerScaleFromExpression><![CDATA[0]]></VerScaleFromExpression>
					<VerScaleToExpression><![CDATA[100]]></VerScaleToExpression>
					<VerScaleType>FIXED</VerScaleType>
					<DrawLine>true</DrawLine>
					<Interpolation>LINEAR</Interpolation>
					<DatasetExpression>  
						<Title><![CDATA[Mean System Utilization]]></Title>
					<Id>0</Id>
					<Expression><![CDATA[get_Main().datasetSystemUtilization.getYMean()]]></Expression>
					<Color>-3308225</Color>
					<Expression2><![CDATA[avgUtilization]]></Expression2>
					<Expression2Flag>true</Expression2Flag>
						<PointStyle>NONE</PointStyle>
						<LineWidth>2.0</LineWidth>
					</DatasetExpression>
					<SamplesToKeep>100</SamplesToKeep>
					<TimeWindowExpression><![CDATA[100]]></TimeWindowExpression>
					<FillAreaUnderLine>false</FillAreaUnderLine>
					<LabelFormat>MODEL_TIME_UNITS</LabelFormat>
    			</TimePlot>
				<Text>
					<Id>1654696215015</Id>
					<Name><![CDATA[text10]]></Name>
					<X>-300</X><Y>10</Y>
					<Label><X>0</X><Y>-10</Y></Label>
					<PublicFlag>true</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>false</ShowLabel>
					<DrawMode>SHAPE_DRAW_2D</DrawMode>
					<EmbeddedIcon>false</EmbeddedIcon>
					<Z>0</Z>
					<Rotation>270.0</Rotation>
					<Color>-16777216</Color>
					<Text><![CDATA[Percentage
]]></Text>
					<Font>
						<Name>SansSerif</Name>
						<Size>20</Size>
						<Style>0</Style>
					</Font>
					<Alignment>LEFT</Alignment>
				</Text>
			</Presentation>

				</Group>
			</Presentation>

				</Group>
				<Group>
					<Id>1655193572303</Id>
					<Name><![CDATA[group4]]></Name>
					<X>960</X><Y>880</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>true</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>false</ShowLabel>
					<DrawMode>SHAPE_DRAW_2D3D</DrawMode>
					<EmbeddedIcon>false</EmbeddedIcon>
					<Z>0</Z>
					<Rotation>0.0</Rotation>

			<Presentation>
    			<TimePlot>
					<Id>1655193572306</Id>
					<Name><![CDATA[plotJSIPerMachine]]></Name>
					<X>-290</X><Y>-130</Y>
					<Label><X>0</X><Y>-10</Y></Label>
					<PublicFlag>true</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>false</ShowLabel>
					<DrawMode>SHAPE_DRAW_2D3D</DrawMode>
					<AutoUpdate>false</AutoUpdate>
					<OccurrenceAtTime>true</OccurrenceAtTime>
					<OccurrenceDate>1639555200000</OccurrenceDate>
					<OccurrenceTime Class="CodeUnitValue">
						<Code><![CDATA[get_Main().simParams.getWarumUpTime()
]]></Code>
						<Unit Class="TimeUnits"><![CDATA[DAY]]></Unit>
					</OccurrenceTime>
					<RecurrenceCode Class="CodeUnitValue">
						<Code><![CDATA[1]]></Code>
						<Unit Class="TimeUnits"><![CDATA[DAY]]></Unit>
					</RecurrenceCode>
					<EmbeddedIcon>false</EmbeddedIcon>
					<Width>590</Width>
					<Height>270</Height>
					<BackgroundColor/>
					<BorderColor/>
					<ChartArea>
						<XOffset>50</XOffset>
						<YOffset>30</YOffset>
						<Width>530</Width>
						<Height>180</Height>
						<BackgroundColor>-1</BackgroundColor>
						<BorderColor>-16777216</BorderColor>
						<GridColor>-12566464</GridColor>
					</ChartArea>
					<Legend>
						<Place>SOUTH</Place>
						<TextColor>-16777216</TextColor>
						<Size>30</Size>
					</Legend>
					<Labels>
						<HorLabelsPosition>DEFAULT</HorLabelsPosition>
						<VerLabelsPosition>DEFAULT</VerLabelsPosition>
						<TextColor>-12566464</TextColor>
					</Labels>
					<ShowLegend>true</ShowLegend>
					<TimeWindowsMovementType>MOVEMENT_WITH_TIME</TimeWindowsMovementType>		
					<TimeWindowUnits>MODEL_TIME_UNIT</TimeWindowUnits>
					<VerScaleFromExpression><![CDATA[0]]></VerScaleFromExpression>
					<VerScaleToExpression><![CDATA[100]]></VerScaleToExpression>
					<VerScaleType>AUTO</VerScaleType>
					<DrawLine>true</DrawLine>
					<Interpolation>LINEAR</Interpolation>
					<SamplesToKeep>100</SamplesToKeep>
					<TimeWindowExpression><![CDATA[100]]></TimeWindowExpression>
					<FillAreaUnderLine>false</FillAreaUnderLine>
					<LabelFormat>MODEL_TIME_UNITS</LabelFormat>
    			</TimePlot>
				<Text>
					<Id>1655193572308</Id>
					<Name><![CDATA[text14]]></Name>
					<X>-300</X><Y>40</Y>
					<Label><X>0</X><Y>-10</Y></Label>
					<PublicFlag>true</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>false</ShowLabel>
					<DrawMode>SHAPE_DRAW_2D</DrawMode>
					<EmbeddedIcon>false</EmbeddedIcon>
					<Z>0</Z>
					<Rotation>270.0</Rotation>
					<Color>-16777216</Color>
					<Text><![CDATA[Percentage
]]></Text>
					<Font>
						<Name>SansSerif</Name>
						<Size>20</Size>
						<Style>0</Style>
					</Font>
					<Alignment>LEFT</Alignment>
				</Text>
			</Presentation>

				</Group>
			</Presentation>

				</Level>
			</Presentation>

		</ActiveObjectClass>
	</ActiveObjectClasses>
	<DifferentialEquationsMethod>EULER</DifferentialEquationsMethod>
	<MixedEquationsMethod>RK45_NEWTON</MixedEquationsMethod>
	<AlgebraicEquationsMethod>MODIFIED_NEWTON</AlgebraicEquationsMethod>
	<AbsoluteAccuracy>1.0E-5</AbsoluteAccuracy>
	<FixedTimeStep>0.001</FixedTimeStep>
	<RelativeAccuracy>1.0E-5</RelativeAccuracy>
	<TimeAccuracy>1.0E-5</TimeAccuracy>
	<Frame>
		<Width>810</Width>
		<Height>600</Height>
	</Frame>
	<Database>
		<Logging>false</Logging>
		<AutoExport>false</AutoExport>
		<ShutdownCompact>false</ShutdownCompact>
		<ImportSettings>
		</ImportSettings>
		<ExportSettings>
		</ExportSettings>
	</Database>

	<RunConfiguration ActiveObjectClassId="1634127996028">
		<Id>1634127996032</Id>
		<Name><![CDATA[RunConfiguration]]></Name>
		<MaximumMemory>512</MaximumMemory>
		<ModelTimeProperties>
			<StopOption><![CDATA[Stop at specified time]]></StopOption>
			<InitialDate><![CDATA[1634083200000]]></InitialDate>	
			<InitialTime><![CDATA[0.0]]></InitialTime>	
			<FinalDate><![CDATA[1636761600000]]></FinalDate>	
			<FinalTime><![CDATA[100.0]]></FinalTime>	
		</ModelTimeProperties>
		<AnimationProperties>
			<StopNever>true</StopNever>
			<ExecutionMode>realTimeScaled</ExecutionMode>
			<RealTimeScale>1.0</RealTimeScale>
			<EnableZoomAndPanning>true</EnableZoomAndPanning>
			<EnableDeveloperPanel>false</EnableDeveloperPanel>
			<ShowDeveloperPanelOnStart>false</ShowDeveloperPanelOnStart>
		</AnimationProperties>
		<Inputs>		
		</Inputs>
		<Outputs>
		</Outputs>
	</RunConfiguration>
	<Experiments>	
		<!--   =========   Simulation Experiment   ========  -->
		<SimulationExperiment ActiveObjectClassId="1634127996028">
			<Id>1634127996030</Id>
			<Name><![CDATA[Simulation]]></Name>
			<Import><![CDATA[import java.util.stream.*;
import java.time.LocalDateTime;]]></Import>
			<CommandLineArguments><![CDATA[]]></CommandLineArguments>
			<InitialSetupCode><![CDATA[
ForecastHistory.DeleteFile(ForecastHistory.FC_HISTORY_FILENAME);
ForecastHistory.DeleteFile(MRP.FILENAME_MRP_TABLE);
ForecastHistory.DeleteFile(MRP.FILENAME_MRP_TABLE_HORIZONTAL);
ForecastHistory.DeleteFile(Result.OUTPUT_EXCEL_FILENAME);
ForecastHistory.DeleteFile(MRPExtensions.FILENAME_CAPACITY_NEEDED);
ForecastHistory.DeleteFile(MRPExtensions.FILENAME_MRP_ITEMS_RELAXED);
]]></InitialSetupCode>
			<MaximumMemory>4096</MaximumMemory>
			<RandomNumberGenerationType>fixedSeed</RandomNumberGenerationType>
			<CustomGeneratorCode>new Random()</CustomGeneratorCode>
			<BeforeSimulationRunCode><![CDATA[root.checkSingleOptimizationParameter = this.editBoxSingleOptimizationParameter.getIntValue();
DBQueries db = new DBQueries(); 

root.list_ForecastInputParameter = ForecastInputParameter.ReadForecastExcelIntputParameters(db.GetSimulationParameters().getInputFileLocation());
root.varNormalSimulationRun = true;

if(ForecastInputParameter.WriteOutputToFile)
	ForecastInputParameter.WriteToFile(root.list_ForecastInputParameter);]]></BeforeSimulationRunCode>
			<AfterSimulationRunCode><![CDATA[for (Item item: root.items) {
    StockBooking bookEnd = new StockBooking(
        item,
        0,
        getEngine().getStopTime(),
        "Initialization End",
        0,
        0,
        0);

    root.stockBookings.add(bookEnd);
}

if(SimulationParameter.WRITE_RESULTS_TO_CONSOLE) {
	traceln(" -----------  FINAL Customer Order List -------------");
	traceln(CustomerOrder.GetCSVHeader(";"));
	
	for(CustomerOrder order : root.customerOrders) {
		traceln(CustomerOrder.GetCSVString(order));
	}
	traceln(" -----------  FINAL Production Order List -------------");
	
	traceln(ProductionOrder.GetCSVHeader());
	
	for(ProductionOrder order : root.productionOrders) {
		traceln(ProductionOrder.GetCSVString(order));
	}
	
	traceln(" -----------  FINAL Stock Booking List -------------");
	
	traceln(StockBooking.GetCSVHeader());
	
	for(StockBooking order : root.stockBookings) {
		traceln(StockBooking.GetCSVString(order));
	}
	
	traceln(" -----------  FINAL Routing Times List -------------");

	traceln(RoutingTimes.GetCSVHeader());

	for(RoutingTimes order : root.RoutingTimesList) {
		traceln(RoutingTimes.GetCSVString(order));
	}
}

if(root.simParams.getWriteResultsToXLSX())
	Result.WriteXlxsResults(root.customerOrders, root.productionOrders,
	 root.stockBookings, root.RoutingTimesList, root.simParams, Result.OUTPUT_EXCEL_FILENAME,root.optimizationParameters);

if(root.simParams.getApplyClearingFunctions() && OptimizationResult.WRITE_OPTIMIZATION_RESULTS_TO_XLXS)
	OptimizationResult.WriteXlsxOptimizationResults(root.optimizationResults, root.simParams);

double sumToltalProcessingTime = root.productionOrders.stream().mapToDouble(ProductionOrder::getTotalProcessingTime).sum();

sumToltalProcessingTime = sumToltalProcessingTime/60/24;

double systemUtilization = sumToltalProcessingTime/time();

root.FunctionCalculateKPIs();

//write simulation results to db
Result res = Result.CreateResult(root, getEngine().getRunCount(), 0,LocalDateTime.now());
root.simulationResults.add(res);
DBQueries db  = new DBQueries();
db.WriteResultToDb(root.simulationResults, root.simParams, false, root.pcName, root.optimizationParameters);

traceln("Final System Utilization: " + root.kPIAgent.function_computeSystemUtilization(true).getValue());
traceln("Simulation Experiment finished!");
stop();

]]></AfterSimulationRunCode>
			<SeedValue>3</SeedValue>
			<SelectionModeForSimultaneousEvents>LIFO</SelectionModeForSimultaneousEvents>
			<VmArgs><![CDATA[-Djava.library.path="C:\Program Files\IBM\ILOG\CPLEX_Studio128\cplex\bin\x64_win64"]]></VmArgs>
			<LoadRootFromSnapshot>false</LoadRootFromSnapshot>
			<Variables>
				<Variable Class="PlainVariable">
					<Id>1636553035658</Id>
					<Name><![CDATA[simParams1]]></Name>
					<X>40</X><Y>630</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Properties SaveInSnapshot="true" Constant="false" AccessType="public" StaticVariable="false">
						<Type><![CDATA[SimulationParameters]]></Type>        
						<InitialValue Class="CodeValue">
							<Code><![CDATA[//simParams1 = SimulationParameters.SimulationParameters();]]></Code>
						</InitialValue>
					</Properties>
				</Variable>
			</Variables>

			<Presentation>
				<Text>
					<Id>1634127996031</Id>
					<Name><![CDATA[text]]></Name>
					<X>50</X><Y>30</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>true</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>false</ShowLabel>
					<DrawMode>SHAPE_DRAW_2D3D</DrawMode>
					<EmbeddedIcon>false</EmbeddedIcon>
					<Z>0</Z>
					<Rotation>0.0</Rotation>
					<Color>-12490271</Color>
					<Text><![CDATA[SimOpt]]></Text>
					<Font>
						<Name>SansSerif</Name>
						<Size>24</Size>
						<Style>0</Style>
					</Font>
					<Alignment>LEFT</Alignment>
				</Text>
				<Control Type="Button">
				 	<EmbeddedIcon>false</EmbeddedIcon>				
					<Id>1718555293049</Id>
					<Name><![CDATA[button]]></Name>
					<X>510</X><Y>520</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>true</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>false</ShowLabel>
					<DrawMode>SHAPE_DRAW_2D3D</DrawMode>
					<BasicProperties Width="180" Height="60">
                        <EmbeddedIcon>false</EmbeddedIcon>	
						<TextColor/>
						<Enabled>true</Enabled>
						<EnableExpression><![CDATA[getState() == IDLE]]></EnableExpression>
						<ActionCode><![CDATA[run();
]]></ActionCode>
					</BasicProperties>
					<ExtendedProperties>
						<Font Name="Dialog" Size="16" Style="1"/>
						<LabelText><![CDATA[Run Simulation]]></LabelText>
					</ExtendedProperties>
				</Control>
				<Control Type="EditBox">
				 	<EmbeddedIcon>false</EmbeddedIcon>				
					<Id>1718556083963</Id>
					<Name><![CDATA[editBoxSingleOptimizationParameter]]></Name>
					<X>310</X><Y>100</Y>
					<Label><X>0</X><Y>-10</Y></Label>
					<PublicFlag>true</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>false</ShowLabel>
					<DrawMode>SHAPE_DRAW_2D3D</DrawMode>
					<BasicProperties Width="100" Height="30">
                        <EmbeddedIcon>false</EmbeddedIcon>	
						<FillColor/>
						<TextColor/>
						<Enabled>true</Enabled>
					</BasicProperties>
					<ExtendedProperties>
						<Font Name="Dialog" Size="18" Style="0"/>
						<DefaultValueCode><![CDATA["35725"]]></DefaultValueCode>
						<LinkTo>false</LinkTo>
					</ExtendedProperties>
				</Control>
				<Text>
					<Id>1718556149958</Id>
					<Name><![CDATA[text1]]></Name>
					<X>50</X><Y>110</Y>
					<Label><X>0</X><Y>-10</Y></Label>
					<PublicFlag>true</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>false</ShowLabel>
					<DrawMode>SHAPE_DRAW_2D</DrawMode>
					<OnClickCode><![CDATA[editBoxSingleOptimizationParameter.setText("0");]]></OnClickCode>
					<EmbeddedIcon>false</EmbeddedIcon>
					<Z>0</Z>
					<Rotation>0.0</Rotation>
					<Color>-16777216</Color>
					<Text><![CDATA[Single-Optimization-Parameter:]]></Text>
					<Font>
						<Name>SansSerif</Name>
						<Size>18</Size>
						<Style>0</Style>
					</Font>
					<Alignment>LEFT</Alignment>
				</Text>
			</Presentation>

			<Parameters>			
				<Parameter>
					<ParameterName><![CDATA[list_ForecastInputParameter]]></ParameterName>
				</Parameter>
				<Parameter>
					<ParameterName><![CDATA[optimizationParameters]]></ParameterName>
				</Parameter>
				<Parameter>
					<ParameterName><![CDATA[simParams]]></ParameterName>
				</Parameter>
				<Parameter>
					<ParameterName><![CDATA[stockBookings]]></ParameterName>
				</Parameter>
				<Parameter>
					<ParameterName><![CDATA[MachineList]]></ParameterName>
				</Parameter>
				<Parameter>
					<ParameterName><![CDATA[RoutingTimesList]]></ParameterName>
				</Parameter>
				<Parameter>
					<ParameterName><![CDATA[simulationResults]]></ParameterName>
				</Parameter>
				<Parameter>
					<ParameterName><![CDATA[forecastHistoryList]]></ParameterName>
				</Parameter>
				<Parameter>
					<ParameterName><![CDATA[currentReplicationCount]]></ParameterName>
				</Parameter>
				<Parameter>
					<ParameterName><![CDATA[varNormalSimulationRun]]></ParameterName>
				</Parameter>
				<Parameter>
					<ParameterName><![CDATA[pcName]]></ParameterName>
				</Parameter>
				<Parameter>
					<ParameterName><![CDATA[numberScenarios]]></ParameterName>
				</Parameter>
				<Parameter>
					<ParameterName><![CDATA[WriteResultsPerReplicationToDb]]></ParameterName>
				</Parameter>
				<Parameter>
					<ParameterName><![CDATA[UseIdealCFLine]]></ParameterName>
				</Parameter>
				<Parameter>
					<ParameterName><![CDATA[MachineFailure]]></ParameterName>
				</Parameter>
				<Parameter>
					<ParameterName><![CDATA[replicationStart]]></ParameterName>
				</Parameter>
				<Parameter>
					<ParameterName><![CDATA[checkSingleOptimizationParameter]]></ParameterName>
				</Parameter>
			</Parameters>			
			<PresentationProperties>
				<EnableZoomAndPanning>true</EnableZoomAndPanning>
				<ExecutionMode><![CDATA[virtualTime]]></ExecutionMode>
				<Title><![CDATA[Model : Simulation]]></Title>	
				<EnableDeveloperPanel>true</EnableDeveloperPanel>
				<ShowDeveloperPanelOnStart>false</ShowDeveloperPanelOnStart>
				<RealTimeScale>5.0</RealTimeScale>
			</PresentationProperties>
			<ModelTimeProperties>
				<StopOption><![CDATA[Stop at specified time]]></StopOption>
				<InitialDate><![CDATA[1634083200000]]></InitialDate>	
				<InitialTime><![CDATA[0.0]]></InitialTime>	
				<FinalDate><![CDATA[1638403200000]]></FinalDate>	
				<FinalTime><![CDATA[50.0]]></FinalTime>	
			</ModelTimeProperties>
			<BypassInitialScreen>false</BypassInitialScreen>
		</SimulationExperiment>
		<!--   =========  Parameter Variation Experiment   ========  -->
		<ParamVariationExperiment ActiveObjectClassId="1634127996028">
			<Id>1643103174326</Id>
			<Name><![CDATA[ParametersVariation]]></Name>
			<Import><![CDATA[import org.apache.commons.math3.stat.descriptive.rank.*;
import org.apache.commons.math3.stat.StatUtils.*;
import java.time.LocalDateTime;
import java.time.ZonedDateTime;
import java.time.format.DateTimeFormatter;
import java.util.stream.*;]]></Import>
			<CommandLineArguments><![CDATA[]]></CommandLineArguments>
			<InitialSetupCode><![CDATA[run();]]></InitialSetupCode>
			<MaximumMemory>8192</MaximumMemory>
			<RandomNumberGenerationType>fixedSeed</RandomNumberGenerationType>
			<CustomGeneratorCode>new Random()</CustomGeneratorCode>
			<BeforeEachExperimentRunCode><![CDATA[traceln("da 5");
if(suffi == null){
	Random randSuffix = new Random();
	suffi = "_" + ForecastInputParameter.GetCurrentDateTimeFormatted() + "_" + randSuffix.nextInt(1000);
}

DBQueries db = new DBQueries(); 
simParams = db.GetSimulationParameters();
traceln("Experiment: " + simParams.getExperiment());
simParams.setSimulationPCName(suffi,null);

simParamsParameterVariation = new SimulationParameter();

simParamsParameterVariation = simParams;

try{
	PropertyValues properties = new PropertyValues(SimulationParameter.PROPERTIES_FILENAME);	
	traceln("Random Optimizationparameter: " + properties.RandomOptimizationParameter);
	simParams.setRandomOptimizationParameter(Integer.parseInt(properties.RandomOptimizationParameter));	
}catch(Exception ex) {
	traceln(ex.getMessage());    		
}

traceln("Check for redo of Optimizationparameter Id: " + redoOptimizationParameterId);

if(redoOptimizationParameterId == 0){
	optimizationParameters = db.GetOptimizationParameterbyStatus(simParams,
	OptimizationParameter.UNPROCESSED_OPTIMIZATION_PARAMETER, true, true,suffi);
}else{ 
	optimizationParameters = db.GetOptimizationParameterbyId(simParams, redoOptimizationParameterId);
	traceln("Before each experiment run Start Redo of Optimizationparameter Id: " + redoOptimizationParameterId); 
}
  
if(optimizationParameters.getId() == 0) {
	traceln("STOP Parameter Variation -> Found Optimization Parameter ID = " + optimizationParameters.getId());	
	traceln("We are completely done!");
	close();
}
 
 
db.SetOptimizationParameterStatusActive(optimizationParameters, simParams, true);
]]></BeforeEachExperimentRunCode>
			<BeforeSimulationRunCode><![CDATA[traceln("At Beginning Before Simulation run:");
simParams.setSimulationPCName(suffi,null);
traceln("Simulation PC " + simParams.getSimulationPCName());
//traceln("--> Start Iteration " + n);

root.pcName = simParams.getSimulationPCName();
simPCName = root.pcName;

DBQueries db = new DBQueries(); 
root.varNormalSimulationRun = false;
root.currentReplicationCount = getCurrentReplication();

root.list_ForecastInputParameter = ForecastInputParameter.ReadForecastExcelIntputParameters(db.GetSimulationParameters().getInputFileLocation());

if(ForecastInputParameter.WriteOutputToFile){
	ForecastInputParameter.WriteToFile(list_ForecastInputParameter);
}

parametervariationItems = root.items;
]]></BeforeSimulationRunCode>
			<AfterSimulationRunCode><![CDATA[	traceln("At Beginning After simulation run:");
	traceln(" +++++++++++++++++> " + "Iteration: " + n + "/" +  root.optimizationParameters.getMaxIterations()); 	
	traceln(" +++++++++++++++++>  Finished Replication " + getCurrentReplication() + "/" 
	+ root.optimizationParameters.getFixedNumberReplications());
	traceln(" OptParam Id: " +  root.optimizationParameters.getId());;
	
	//compute KPIs and add them to the results
	root.FunctionCalculateKPIs();
	traceln("Finished calculating KPIs");
	Result res = Result.CreateResult(root, n, getCurrentReplication(),LocalDateTime.now());
	
	traceln("add Replication Result for Replication: " + getCurrentReplication());
	traceln(res.toString());
		
	replicationResults.add(res);
	
	double[] dataArray = new double[getCurrentReplication()];
	double sumOverallCosts = 0;
	int replicationMultiplier = 1;
	
	//SBM Settings printout		
	traceln("SBM Value from Optimizationparameter: " + root.optimizationParameters.getSBM());
	traceln("SBM Initphase from Optimizationparamter: " +  root.optimizationParameters.getSBMInitPhase());
	traceln("Current n: " + n);
	setFixedReplicationsNumber(max(root.optimizationParameters.getFixedNumberReplications(),1));
	traceln("SBM Percentil UB: " + root.optimizationParameters.getSBMPercentilUB());
	traceln("SBM Percentil LB: " + root.optimizationParameters.getSBMPercentilLB());		
	root.currentReplicationCount = getCurrentReplication();
	traceln("replicationMultiplier: " + replicationMultiplier);				
	traceln("Current Replication: " + getCurrentReplication());
	traceln("Size Replication Results for SBM: " + replicationResults.size());
	
	for(Result replResult : replicationResults){
		traceln("SBM Replresults: " + replResult.getOverallCosts_inkl_not_Delivered());
	}
	
	//Only after a initialization phase the simulation budget management replication skip is performed
	if(root.optimizationParameters.getSBM() >= 1 && n > root.optimizationParameters.getSBMInitPhase()){
		totalReplicationCount++; //total replication count starts after initialization phase.		
	}			
	        boolean skipReplicationInsertToDB = false;
				
	if(root.optimizationParameters.getSBM() >= 1 && n > root.optimizationParameters.getSBMInitPhase()
	 && getCurrentReplication() > root.optimizationParameters.getSBMLowerBoundReplications()){
	
		double[] iterationAvgArray = new double[n - root.optimizationParameters.getSBMInitPhase()];
	
		if(n > 0){	
			iterationAvgArray = SimulationBudgetManagement.GetAVGCostPreviousIterations(n,
			root.optimizationParameters,avgIterationResults);
		}
		
		
        // Filter out values greater than 0 otherwise the percentile value is wrong
        iterationAvgArray = Arrays.stream(iterationAvgArray)
                                  .filter(value -> value > 0)
                                  .toArray();
									
		Arrays.sort(iterationAvgArray);
																							                      
	    setFixedReplicationsNumber((int)root.optimizationParameters.getFixedNumberReplications());
		Percentile percentile = new Percentile();
	                  
	    percentile.setData(iterationAvgArray);                                  
	    
	    double percentil = 0;
		         
		double percentilStep = (root.optimizationParameters.getSBMPercentilUB() - root.optimizationParameters.getSBMPercentilLB())/(root.optimizationParameters.getFixedNumberReplications()-1);
	    traceln("SBM Percentil UB: " + root.optimizationParameters.getSBMPercentilUB());
	   	traceln("SBM Percentil LB: " + root.optimizationParameters.getSBMPercentilLB());
	    
	    traceln("percentile Step: " + percentilStep);          
	    
	    if(getCurrentReplication() == 1){
	    	percentil = root.optimizationParameters.getSBMPercentilUB();
	    }else{	  	
	    	percentil = root.optimizationParameters.getSBMPercentilUB() - (percentilStep * (getCurrentReplication()-1));
	    }
	    
	    int tt = n-root.optimizationParameters.getSBMInitPhase()-1;
	   	
	   	traceln("iterationAvgArray: " + iterationAvgArray.length);
	   	traceln("Percentile: " + percentil);
	   	int numberElements = max(1,n-root.optimizationParameters.getSBMInitPhase()-1);
	   	
	   	traceln("upper bound percentile: " + numberElements);	
	   	traceln("n: " + n);
	   	traceln("sbmInitPhase: " + root.optimizationParameters.getSBMInitPhase());
	   		   	
	   	if(numberElements <= 0)
	   		numberElements = 1;
	   	
		//double percentilValue = percentile.evaluate(iterationAvgArray,
		//0,numberElements,percentil);
		traceln("Current Replication: " + getCurrentReplication());
		
		traceln("Applied Values for Percentile Value Computation:");
		
		 // Print all values in iterationAvgArray
        for (double value : iterationAvgArray) {
            traceln(value);
        }
		
		double percentilValue = percentile.evaluate(iterationAvgArray, percentil);
		traceln("percentileValue based on prevous AvgIterationsCots: " + percentilValue);			
		
		double avgOverallCosts = replicationResults.stream().filter(e -> e.getReplicationStatus() == Integer.parseInt(SimHeuristic.REPLICATION_STATUS_TO_INCLUDE))
                                           .mapToDouble(Result::getOverallCosts_inkl_not_Delivered)  
                                           .average()                    
                                           .orElse(0);   
                                           
        traceln("avgOverallCosts previous Replications - Entries see above: " +  avgOverallCosts);                                   
					
			traceln("Iteration " + n + " INITIALIZATION PHASE passed USING " + replicationResults.size() + " Replications to compute " + avgOverallCosts + " avgOverallCosts " + 
			" PercentilValue " + percentilValue + " Percentil " + percentil + 
			" PercentialRange Start/Max/Step (" + root.optimizationParameters.getSBMPercentilLB() + "/" + root.optimizationParameters.getSBMPercentilUB() + "/" + percentilStep +")");
			
			if(avgOverallCosts > percentilValue || root.currentOverallCosts > root.simParams.getOverallCostsLimit()){	
				traceln("------> STOPP after REPLICATION " + getCurrentReplication()  + " total Replication count " + (totalReplicationCount-1));				
				traceln("------> STOPP Replication with Current Overallcosts are: " + root.currentOverallCosts + " and OverallCostsLimit is :" + root.simParams.getOverallCostsLimit());
				
				if(SimulationBudgetManagement.SBM_STOP_AFTER_MAX_REPLICATIONS) {
					setFixedReplicationsNumber(getCurrentReplication());
					//skipReplicationInsertToDB = true;
				}else {
					replicationMultiplier = -1;
				}
			}
			else if(avgOverallCosts <= percentilValue){	
				traceln("------> START next REPLICATION " + getCurrentReplication()+1 + " total Replication count " + (totalReplicationCount-1));
			}				
			
			/* --- simulation budget management --- */			
			int maxIterations = root.optimizationParameters.getMaxIterations();	
			int maxSimulationBudget = maxIterations;// * root.optimizationParameters.getFixedNumberReplications();
			traceln("totalReplicationCount: " + (totalReplicationCount-1));
			traceln("maxSimulationBudget: " + maxSimulationBudget);		
			traceln("max Replications per Iteration: " + root.optimizationParameters.getFixedNumberReplications());
			if(totalReplicationCount > root.optimizationParameters.getFixedNumberReplications() &&  root.optimizationParameters.getSBM() == SimulationBudgetManagement.SBM_ACTIVE){
				if(SimulationBudgetManagement.SBM_STOP_AFTER_MAX_REPLICATIONS) {
					traceln("Stop after max replications");
					setFixedReplicationsNumber(root.optimizationParameters.getFixedNumberReplications());
				}else {					
					replicationMultiplier = -1;
				}
			}
			/* --- simulation budget management --- */
			
			//evalute that only after 20 replications the range is reduced for Extension 1
			traceln("Test for ReduceRange: " + (totalReplicationCount-1) + " " + root.optimizationParameters.getFixedNumberReplications());						
			traceln("Fixed Number Replications: " + root.optimizationParameters.getFixedNumberReplications());
			traceln("Total Replicaction Count: " + (totalReplicationCount-1));
			//traceln("Mod result: " + (totalReplicationCount-1 % root.optimizationParameters.getFixedNumberReplications()));
			//if((totalReplicationCount-1 % root.optimizationParameters.getFixedNumberReplications())==0){
			if(((totalReplicationCount-1) % root.optimizationParameters.getFixedNumberReplications())==0){
				traceln("We reduce the Range");
				reduceRangeSBM = true;
				traceln("reduceRangeSBM must now be true: " + true);
			}
							
		}else{
			traceln("Simulation Budget Management is not applied for this Simulation Experiment.");
		}							

		for(Item item : root.items){		
			StockBooking bookEnd = new StockBooking(
			item,
			0,
			getEngine().getStopTime(),
			"Initialization End",
			0,
			0,
			0);
			root.stockBookings.add(bookEnd);	
		}


DBQueries db = new DBQueries();	
traceln("Write Results per Repliation to DB After Simulation Run: " + root.WriteResultsPerReplicationToDb);
traceln("Replication Multiplier: " + replicationMultiplier);
if(root.WriteResultsPerReplicationToDb==1){
	
	if(root.optimizationParameters.getSBM() >= 2) {
		
		if((SimulationBudgetManagement.SBM_STOP_AFTER_MAX_REPLICATIONS && !skipReplicationInsertToDB) ||
			!SimulationBudgetManagement.SBM_STOP_AFTER_MAX_REPLICATIONS) {
			
			int tmpReplicationMultiplier = replicationMultiplier;
			 replicationResults.stream()
	            .filter(e -> Math.abs(e.getReplication()) == getCurrentReplication())  // Filter elements
	            .forEach(e -> e.setReplication(e.getReplication()*tmpReplicationMultiplier)); 
			
			
			//avoid saving the same replication result for each replication again.
			db.WriteResultToDb(replicationResults.stream().filter(e ->  Math.abs(e.getReplication()) == getCurrentReplication()).collect(Collectors.toList())
			,db.GetSimulationParameters(), true, simPCName, root.optimizationParameters);
		}
	
	}else {
		db.WriteResultToDb(replicationResults, db.GetSimulationParameters(), 
		true, simPCName, root.optimizationParameters);
	}
	
	if(root.optimizationParameters.getSBM() < 1) {
		replicationResults.clear();
	}
}

if(getCurrentReplication() == 1 && root.optimizationParameters.getSBM() < 1){
	if(db.GetSimulationParameters().getWriteResultsToXLSX()){
		Result.WriteXlxsResults(root.customerOrders, root.productionOrders, root.stockBookings,
		 root.RoutingTimesList, root.simParams, Result.OUTPUT_EXCEL_FILENAME_PARAMETERVARIATION, root.optimizationParameters);	
		 traceln("Finished writing Results to File");				
	}
}	 
]]></AfterSimulationRunCode>
			<SeedValue>3</SeedValue>
			<SelectionModeForSimultaneousEvents>LIFO</SelectionModeForSimultaneousEvents>
			<VmArgs><![CDATA[-Djava.library.path="C:\Program Files\IBM\ILOG\CPLEX_Studio128\cplex\bin\x64_win64"]]></VmArgs>
			<LoadRootFromSnapshot>false</LoadRootFromSnapshot>
			<Variables>
				<Variable Class="PlainVariable">
					<Id>1643182281694</Id>
					<Name><![CDATA[simPCName]]></Name>
					<X>60</X><Y>310</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Properties SaveInSnapshot="true" Constant="false" AccessType="public" StaticVariable="false">
						<Type><![CDATA[String]]></Type>        
					</Properties>
				</Variable>
				<Variable Class="PlainVariable">
					<Id>1645593660302</Id>
					<Name><![CDATA[reduceRangeSBM]]></Name>
					<X>60</X><Y>350</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Properties SaveInSnapshot="true" Constant="false" AccessType="public" StaticVariable="false">
						<Type><![CDATA[boolean]]></Type>        
						<InitialValue Class="CodeValue">
							<Code><![CDATA[false]]></Code>
						</InitialValue>
					</Properties>
				</Variable>
				<Variable Class="PlainVariable">
					<Id>1645593865831</Id>
					<Name><![CDATA[totalReplicationCount]]></Name>
					<X>60</X><Y>390</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Properties SaveInSnapshot="true" Constant="false" AccessType="public" StaticVariable="false">
						<Type><![CDATA[int]]></Type>        
						<InitialValue Class="CodeValue">
							<Code><![CDATA[1]]></Code>
						</InitialValue>
					</Properties>
				</Variable>
				<Variable Class="PlainVariable">
					<Id>1645696423940</Id>
					<Name><![CDATA[n]]></Name>
					<X>60</X><Y>430</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Properties SaveInSnapshot="true" Constant="false" AccessType="public" StaticVariable="false">
						<Type><![CDATA[int]]></Type>        
						<InitialValue Class="CodeValue">
							<Code><![CDATA[0]]></Code>
						</InitialValue>
					</Properties>
				</Variable>
				<Variable Class="PlainVariable">
					<Id>1645851295545</Id>
					<Name><![CDATA[replicationResults]]></Name>
					<X>60</X><Y>470</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Properties SaveInSnapshot="true" Constant="false" AccessType="public" StaticVariable="false">
						<Type><![CDATA[List<Result>]]></Type>        
						<InitialValue Class="CodeValue">
							<Code><![CDATA[new ArrayList<Result>()]]></Code>
						</InitialValue>
					</Properties>
				</Variable>
				<Variable Class="PlainVariable">
					<Id>1647065197960</Id>
					<Name><![CDATA[avgIterationResults]]></Name>
					<X>60</X><Y>500</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Properties SaveInSnapshot="true" Constant="false" AccessType="public" StaticVariable="false">
						<Type><![CDATA[List<Result>]]></Type>        
						<InitialValue Class="CodeValue">
							<Code><![CDATA[new ArrayList()]]></Code>
						</InitialValue>
					</Properties>
				</Variable>
				<Variable Class="PlainVariable">
					<Id>1671774274427</Id>
					<Name><![CDATA[suffi]]></Name>
					<X>60</X><Y>540</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Properties SaveInSnapshot="true" Constant="false" AccessType="public" StaticVariable="false">
						<Type><![CDATA[String]]></Type>        
					</Properties>
				</Variable>
				<Variable Class="PlainVariable">
					<Id>1706901365523</Id>
					<Name><![CDATA[simParamsParameterVariation]]></Name>
					<X>60</X><Y>570</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Properties SaveInSnapshot="true" Constant="false" AccessType="public" StaticVariable="false">
						<Type><![CDATA[SimulationParameter]]></Type>        
					</Properties>
				</Variable>
				<Variable Class="PlainVariable">
					<Id>1724744235093</Id>
					<Name><![CDATA[list_simresults]]></Name>
					<X>310</X><Y>310</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Properties SaveInSnapshot="true" Constant="false" AccessType="public" StaticVariable="false">
						<Type><![CDATA[ArrayList<Entry_simresults>]]></Type>        
						<InitialValue Class="CodeValue">
							<Code><![CDATA[new ArrayList<Entry_simresults>()]]></Code>
						</InitialValue>
					</Properties>
				</Variable>
				<Variable Class="PlainVariable">
					<Id>1724749719527</Id>
					<Name><![CDATA[iteration_nr]]></Name>
					<X>310</X><Y>340</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Properties SaveInSnapshot="true" Constant="false" AccessType="public" StaticVariable="false">
						<Type><![CDATA[int]]></Type>        
						<InitialValue Class="CodeValue">
							<Code><![CDATA[1]]></Code>
						</InitialValue>
					</Properties>
				</Variable>
				<Variable Class="PlainVariable">
					<Id>1724753766609</Id>
					<Name><![CDATA[randParam]]></Name>
					<X>310</X><Y>400</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Properties SaveInSnapshot="true" Constant="false" AccessType="public" StaticVariable="false">
						<Type><![CDATA[Random]]></Type>        
						<InitialValue Class="CodeValue">
							<Code><![CDATA[new Random(getCurrentReplication() + 20000)]]></Code>
						</InitialValue>
					</Properties>
				</Variable>
				<Variable Class="PlainVariable">
					<Id>1724754690827</Id>
					<Name><![CDATA[bestSolution]]></Name>
					<X>310</X><Y>430</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Properties SaveInSnapshot="true" Constant="false" AccessType="public" StaticVariable="false">
						<Type><![CDATA[List<ResultObject>]]></Type>        
						<InitialValue Class="CodeValue">
							<Code><![CDATA[new ArrayList<ResultObject>();]]></Code>
						</InitialValue>
					</Properties>
				</Variable>
				<Variable Class="PlainVariable">
					<Id>1724754739068</Id>
					<Name><![CDATA[bestSolutionValue]]></Name>
					<X>310</X><Y>460</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Properties SaveInSnapshot="true" Constant="false" AccessType="public" StaticVariable="false">
						<Type><![CDATA[double]]></Type>        
						<InitialValue Class="CodeValue">
							<Code><![CDATA[0]]></Code>
						</InitialValue>
					</Properties>
				</Variable>
				<Variable Class="PlainVariable">
					<Id>1724754758322</Id>
					<Name><![CDATA[baseSolutionValue]]></Name>
					<X>310</X><Y>490</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Properties SaveInSnapshot="true" Constant="false" AccessType="public" StaticVariable="false">
						<Type><![CDATA[double]]></Type>        
						<InitialValue Class="CodeValue">
							<Code><![CDATA[0]]></Code>
						</InitialValue>
					</Properties>
				</Variable>
				<Variable Class="PlainVariable">
					<Id>1724754867347</Id>
					<Name><![CDATA[delta]]></Name>
					<X>310</X><Y>520</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Properties SaveInSnapshot="true" Constant="false" AccessType="public" StaticVariable="false">
						<Type><![CDATA[double]]></Type>        
						<InitialValue Class="CodeValue">
							<Code><![CDATA[0]]></Code>
						</InitialValue>
					</Properties>
				</Variable>
				<Variable Class="PlainVariable">
					<Id>1724754903205</Id>
					<Name><![CDATA[credit]]></Name>
					<X>310</X><Y>550</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Properties SaveInSnapshot="true" Constant="false" AccessType="public" StaticVariable="false">
						<Type><![CDATA[double]]></Type>        
						<InitialValue Class="CodeValue">
							<Code><![CDATA[0]]></Code>
						</InitialValue>
					</Properties>
				</Variable>
				<Variable Class="PlainVariable">
					<Id>1724755076653</Id>
					<Name><![CDATA[bestSolutionIteration]]></Name>
					<X>310</X><Y>580</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Properties SaveInSnapshot="true" Constant="false" AccessType="public" StaticVariable="false">
						<Type><![CDATA[int]]></Type>        
						<InitialValue Class="CodeValue">
							<Code><![CDATA[0]]></Code>
						</InitialValue>
					</Properties>
				</Variable>
				<Variable Class="PlainVariable">
					<Id>1724755190197</Id>
					<Name><![CDATA[baseSolutionIteration]]></Name>
					<X>510</X><Y>310</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Properties SaveInSnapshot="true" Constant="false" AccessType="public" StaticVariable="false">
						<Type><![CDATA[int]]></Type>        
						<InitialValue Class="CodeValue">
							<Code><![CDATA[0]]></Code>
						</InitialValue>
					</Properties>
				</Variable>
				<Variable Class="PlainVariable">
					<Id>1724755238140</Id>
					<Name><![CDATA[defaultCreditRange]]></Name>
					<X>510</X><Y>340</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Properties SaveInSnapshot="true" Constant="false" AccessType="public" StaticVariable="false">
						<Type><![CDATA[double]]></Type>        
					</Properties>
				</Variable>
				<Variable Class="PlainVariable">
					<Id>1724755256469</Id>
					<Name><![CDATA[baseSolution]]></Name>
					<X>510</X><Y>370</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Properties SaveInSnapshot="true" Constant="false" AccessType="public" StaticVariable="false">
						<Type><![CDATA[List<ResultObject>]]></Type>        
						<InitialValue Class="CodeValue">
							<Code><![CDATA[new ArrayList<ResultObject>();]]></Code>
						</InitialValue>
					</Properties>
				</Variable>
				<Variable Class="PlainVariable">
					<Id>1724755278285</Id>
					<Name><![CDATA[adaptedSAReset]]></Name>
					<X>510</X><Y>400</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Properties SaveInSnapshot="true" Constant="false" AccessType="public" StaticVariable="false">
						<Type><![CDATA[int]]></Type>        
					</Properties>
				</Variable>
				<Variable Class="PlainVariable">
					<Id>1724755302278</Id>
					<Name><![CDATA[adaptedCreditRange]]></Name>
					<X>510</X><Y>430</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Properties SaveInSnapshot="true" Constant="false" AccessType="public" StaticVariable="false">
						<Type><![CDATA[double]]></Type>        
						<InitialValue Class="CodeValue">
							<Code><![CDATA[0]]></Code>
						</InitialValue>
					</Properties>
				</Variable>
				<Variable Class="PlainVariable">
					<Id>1725371410166</Id>
					<Name><![CDATA[redoOptimizationParameterId]]></Name>
					<X>510</X><Y>460</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Properties SaveInSnapshot="true" Constant="false" AccessType="public" StaticVariable="false">
						<Type><![CDATA[int]]></Type>        
						<InitialValue Class="CodeValue">
							<Code><![CDATA[0]]></Code>
						</InitialValue>
					</Properties>
				</Variable>
				<Variable Class="PlainVariable">
					<Id>1727122854368</Id>
					<Name><![CDATA[parametervariationItems]]></Name>
					<X>510</X><Y>490</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Properties SaveInSnapshot="true" Constant="false" AccessType="public" StaticVariable="false">
						<Type><![CDATA[List<Item>]]></Type>        
					</Properties>
				</Variable>
			</Variables>

			<Presentation>
				<Text>
					<Id>1643103543363</Id>
					<Name><![CDATA[text]]></Name>
					<X>40</X><Y>30</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>true</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>false</ShowLabel>
					<DrawMode>SHAPE_DRAW_2D3D</DrawMode>
					<EmbeddedIcon>false</EmbeddedIcon>
					<Z>0</Z>
					<Rotation>0.0</Rotation>
					<Color>-12490271</Color>
					<Text><![CDATA[SimOpt : ParametersVariation]]></Text>
					<Font>
						<Name>SansSerif</Name>
						<Size>24</Size>
						<Style>0</Style>
					</Font>
					<Alignment>LEFT</Alignment>
				</Text>
				<Text>
					<Id>1643103543364</Id>
					<Name><![CDATA[text1]]></Name>
					<X>50</X><Y>80</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>true</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>false</ShowLabel>
					<DrawMode>SHAPE_DRAW_2D3D</DrawMode>
					<EmbeddedIcon>false</EmbeddedIcon>
					<Z>0</Z>
					<Rotation>0.0</Rotation>
					<Color>-12171190</Color>
					<Text><![CDATA[Iterations completed:]]></Text>
					<Font>
						<Name>SansSerif</Name>
						<Size>12</Size>
						<Style>0</Style>
					</Font>
					<Alignment>LEFT</Alignment>
				</Text>
				<Text>
					<Id>1643103543365</Id>
					<Name><![CDATA[text2]]></Name>
					<X>240</X><Y>80</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>true</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>false</ShowLabel>
					<DrawMode>SHAPE_DRAW_2D3D</DrawMode>
					<VisibleCode><![CDATA[getCurrentIteration() > 0]]></VisibleCode>
					<EmbeddedIcon>false</EmbeddedIcon>
					<Z>0</Z>
					<Rotation>0.0</Rotation>
					<Color>-12042869</Color>
					<Text><![CDATA[?]]></Text>
					<TextCode><![CDATA[format(getNumberOfCompletedIterations())]]></TextCode>
					<Font>
						<Name>SansSerif</Name>
						<Size>12</Size>
						<Style>0</Style>
					</Font>
					<Alignment>RIGHT</Alignment>
				</Text>
				<Rectangle>
					<Id>1643103543366</Id>
					<Name><![CDATA[rectangle]]></Name>
					<X>40</X><Y>100</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>true</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>false</ShowLabel>
					<DrawMode>SHAPE_DRAW_2D3D</DrawMode>
					<EmbeddedIcon>false</EmbeddedIcon>
					<Z>0</Z>
					<ZHeight>10</ZHeight>
					<LineWidth>1</LineWidth>
					<LineColor/>
					<LineMaterial>null</LineMaterial>
					<LineStyle>SOLID</LineStyle>
					<Width>210</Width>
					<Height>30</Height>
					<Rotation>0.0</Rotation>
					<FillColor>-657931</FillColor>
					<FillMaterial>null</FillMaterial>
				</Rectangle>
				<Text>
					<Id>1643103543367</Id>
					<Name><![CDATA[text3]]></Name>
					<X>50</X><Y>110</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>true</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>false</ShowLabel>
					<DrawMode>SHAPE_DRAW_2D3D</DrawMode>
					<EmbeddedIcon>false</EmbeddedIcon>
					<Z>0</Z>
					<Rotation>0.0</Rotation>
					<Color>-12171190</Color>
					<Text><![CDATA[Replication:]]></Text>
					<Font>
						<Name>SansSerif</Name>
						<Size>12</Size>
						<Style>0</Style>
					</Font>
					<Alignment>LEFT</Alignment>
				</Text>
				<Text>
					<Id>1643103543368</Id>
					<Name><![CDATA[text4]]></Name>
					<X>240</X><Y>110</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>true</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>false</ShowLabel>
					<DrawMode>SHAPE_DRAW_2D3D</DrawMode>
					<VisibleCode><![CDATA[getCurrentIteration() > 0]]></VisibleCode>
					<EmbeddedIcon>false</EmbeddedIcon>
					<Z>0</Z>
					<Rotation>0.0</Rotation>
					<Color>-12042869</Color>
					<Text><![CDATA[?]]></Text>
					<TextCode><![CDATA[format(getCurrentReplication())]]></TextCode>
					<Font>
						<Name>SansSerif</Name>
						<Size>12</Size>
						<Style>0</Style>
					</Font>
					<Alignment>RIGHT</Alignment>
				</Text>
				<Text>
					<Id>1643103543369</Id>
					<Name><![CDATA[text5]]></Name>
					<X>50</X><Y>140</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>true</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>false</ShowLabel>
					<DrawMode>SHAPE_DRAW_2D3D</DrawMode>
					<EmbeddedIcon>false</EmbeddedIcon>
					<Z>0</Z>
					<Rotation>0.0</Rotation>
					<Color>-12566464</Color>
					<Text><![CDATA[Parameters]]></Text>
					<Font>
						<Name>SansSerif</Name>
						<Size>12</Size>
						<Style>1</Style>
					</Font>
					<Alignment>LEFT</Alignment>
				</Text>
				<Line>
					<Id>1643103543370</Id>
					<Name><![CDATA[line]]></Name>
					<X>40</X><Y>160</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>true</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>false</ShowLabel>
					<DrawMode>SHAPE_DRAW_2D3D</DrawMode>
					<EmbeddedIcon>false</EmbeddedIcon>
					<Z>0</Z>
					<ZHeight>10</ZHeight>
					<LineWidth>2</LineWidth>
					<LineColor>-12566464</LineColor>
					<LineMaterial>null</LineMaterial>
					<LineStyle>SOLID</LineStyle>
					<BeginArrowSize>1</BeginArrowSize>
					<BeginArrowStyle>0</BeginArrowStyle>
					<EndArrowSize>1</EndArrowSize>
					<EndArrowStyle>0</EndArrowStyle>
					<Dx>210</Dx>
					<Dy>0</Dy>
					<Dz>0</Dz>
				</Line>
				<Text>
					<Id>1643103543371</Id>
					<Name><![CDATA[text6]]></Name>
					<X>50</X><Y>180</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>true</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>false</ShowLabel>
					<DrawMode>SHAPE_DRAW_2D3D</DrawMode>
					<EmbeddedIcon>false</EmbeddedIcon>
					<Z>0</Z>
					<Rotation>0.0</Rotation>
					<Color>-12171190</Color>
					<Text><![CDATA[list_ForecastInputParameter]]></Text>
					<Font>
						<Name>SansSerif</Name>
						<Size>12</Size>
						<Style>0</Style>
					</Font>
					<Alignment>LEFT</Alignment>
				</Text>
				<Text>
					<Id>1643103543372</Id>
					<Name><![CDATA[text7]]></Name>
					<X>240</X><Y>180</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>true</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>false</ShowLabel>
					<DrawMode>SHAPE_DRAW_2D3D</DrawMode>
					<VisibleCode><![CDATA[getCurrentIteration() > 0]]></VisibleCode>
					<EmbeddedIcon>false</EmbeddedIcon>
					<Z>0</Z>
					<Rotation>0.0</Rotation>
					<Color>-12042869</Color>
					<Text><![CDATA[?]]></Text>
					<TextCode><![CDATA[String.valueOf( list_ForecastInputParameter )]]></TextCode>
					<Font>
						<Name>SansSerif</Name>
						<Size>12</Size>
						<Style>0</Style>
					</Font>
					<Alignment>RIGHT</Alignment>
				</Text>
				<Control Type="Button">
				 	<EmbeddedIcon>false</EmbeddedIcon>				
					<Id>1643103889671</Id>
					<Name><![CDATA[button]]></Name>
					<X>50</X><Y>240</Y>
					<Label><X>0</X><Y>-10</Y></Label>
					<PublicFlag>true</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>false</ShowLabel>
					<DrawMode>SHAPE_DRAW_2D3D</DrawMode>
					<BasicProperties Width="100" Height="30">
                        <EmbeddedIcon>false</EmbeddedIcon>	
						<TextColor/>
						<Enabled>true</Enabled>
						<ActionCode><![CDATA[run();]]></ActionCode>
					</BasicProperties>
					<ExtendedProperties>
						<Font Name="Dialog" Size="11" Style="0"/>
						<LabelText><![CDATA[Start]]></LabelText>
					</ExtendedProperties>
				</Control>
			</Presentation>

			<AfterIterationCode><![CDATA[//compute avg iteration results
//orElseThrow(IllegalStateException::new)
traceln("At AfterIteration Top");
traceln("ReduceRangeSBM In: " + reduceRangeSBM);

DBQueries db = new DBQueries();
optimizationParameters = db.GetOptimizationParameterbyStatus(simParamsParameterVariation,
    OptimizationParameter.ACTIVE_OPTIMIZATION_PARAMETER, false, true, simPCName);

String simHeuristic = optimizationParameters.getSimHeuristic();
int defaultSAReset = 0;

Main mainAgent = (Main) getEngine().getRoot();
parametervariationItems = db.GetItems(simParamsParameterVariation);

traceln("items" + parametervariationItems.size());

for(Item i : parametervariationItems){
	traceln(Item.GetCSVString(i));
}

/*************************** BEGIN SIMHEURISTIC *******************************************/
traceln("SimHeuristic: " + optimizationParameters.getSimHeuristic());
if (optimizationParameters.getSimHeuristic() != null && 
optimizationParameters.getSimHeuristic().length() > 0) {

    int outlierCorrectionType = optimizationParameters.getOutlierCorrectionType();

    list_simresults = SimHeuristic.RemoveSimulationResultsPercentile(list_simresults, outlierCorrectionType);

    iteration_nr++;

    int simBudgetManagement = optimizationParameters.getSBM();
    traceln("simBudgetManagement: " + simBudgetManagement);

    int simAnnealing = optimizationParameters.getSimAnnealing();
    traceln("simAnnealing: " + simAnnealing);

    double percentileStart = optimizationParameters.getPercentilStart();
    traceln("percentileStart: " + percentileStart);

    defaultCreditRange = optimizationParameters.getDefaultCreditRange();
    traceln("defaultCreditRange: " + defaultCreditRange);

    int initializationPhase = optimizationParameters.getInitializationPhase();
    traceln("initializationPhase: " + initializationPhase);

    double lowerBoundSBMReplications = optimizationParameters.getSBMLowerBoundReplications();
    traceln("lowerBoundSBMReplications: " + lowerBoundSBMReplications);

    double maxPercentil = optimizationParameters.getMaxPercentil();
    traceln("maxPercentil: " + maxPercentil);

    int fixedNumberReplications = optimizationParameters.getFixedNumberReplications();
    traceln("fixedNumberReplications: " + fixedNumberReplications);

    String currentSimulationExperiment = optimizationParameters.getSimulationExperiment();
    traceln("currentSimulationExperiment: " + currentSimulationExperiment);

    double warmUpTime = optimizationParameters.getWarmupPhase();
    traceln("warmUpPhase: " + warmUpTime);

    int historyValues = optimizationParameters.getHistoryValues();
    traceln("historyValues: " + historyValues);

    double alpha = optimizationParameters.getAlpha();
    traceln("alpha: " + alpha);

    int maxIterations = optimizationParameters.getMaxIterations();
    traceln("maxIterations: " + maxIterations);

    // alte variante war mit fixed number replications multipliziert wurde fr wsc24 extension gendert.
    // bei der WSC24 Extension werden immer ALLE Replikationen konsumiert.
    // somit wird eine iterationsbergreifender replicationscounter bentigt.
    int maxSimulationBudget = maxIterations; // * (int)fixedNumberReplications;
    traceln("maxSimulationBudget: " + maxSimulationBudget);

    String distributionType = optimizationParameters.getDistributionType();
    traceln("distributionType: " + distributionType);

    double cbrrlb = optimizationParameters.getMinCBRRItems();
    traceln("cbrrlb: " + cbrrlb);

    int minCBRRItems = optimizationParameters.getMinCBRRItems();
    traceln("minCBRRItems: " + minCBRRItems);

    defaultSAReset = optimizationParameters.getDefaultSAReset();
    traceln("defaultSAReset: " + defaultSAReset);

    StringBuilder sqlInsertString = new StringBuilder();

    int minParameterEntryId = optimizationParameters.getId();

    traceln("Actual Parmeterentry ID " + minParameterEntryId);
    sqlInsertString.setLength(0);

    double consumedReplications = SimHeuristic.GetTotalReplicationCount(optimizationParameters.getSimulationExperiment(), simParamsParameterVariation, true, optimizationParameters);

    traceln("Simulation Budget Management active " + simBudgetManagement + " max simulation budget " + maxSimulationBudget
     + " sumOfConsumedReplications " + consumedReplications);
    //if the maximum number of allowed replications is reached simulation experiment ist stopped

    boolean simbudgetExhausted = false;
    
    
    if (consumedReplications >= maxSimulationBudget && simBudgetManagement == 2) {// alte version war mit totalReplicationCount
        traceln("We are done after Iteration Count = " + n + " and " + totalReplicationCount + " Replications ");
        simbudgetExhausted = true;
    } else if (n > maxIterations - 2 && simBudgetManagement != 2) {
        traceln("We are done after Iteration Count = " + n + " and " + totalReplicationCount + " Replications ");
        simbudgetExhausted = true;
    }

    traceln(" Done Experiment " + currentSimulationExperiment + "  #####################################");
    traceln(" ----------------------------------------------------------- Iteration " + (n) + " of Max ReplicationsBudget " + maxIterations + " sumOfConsumedReplications " + consumedReplications + " FINISHED ------------------------------------");

    if (!simbudgetExhausted) {

        List <InputParameter> inputParameterList = new ArrayList < InputParameter > ();

        inputParameterList.addAll(InputParameter.processParameters(optimizationParameters));

        traceln("Note Mod=0 is OK in the following list, these are the values from the input parameters, mod is set later on.");
        for (InputParameter item: inputParameterList) {
            traceln(item.toString());
        }

        //afte the initial run meaning first iteration with x 
        //replications we are here and have automatically the inital soluation
        //which is also our best soluation	
        traceln("Current n: " + n);
        //if (n == 0 || n == 1) {
        if (n == 0) {
            bestSolution = SimHeuristic.GetIterationBasedSolution(currentSimulationExperiment, 0,
             simParamsParameterVariation, true, optimizationParameters, 0);

            bestSolutionValue = SimHeuristic.GetBestSolutionValue(SimHeuristic.RESULT_TYPE_VALUE,
                currentSimulationExperiment, simParamsParameterVariation, true, optimizationParameters);

            baseSolution = bestSolution;
            baseSolutionValue = bestSolutionValue;

            baseSolutionIteration = 0;
            bestSolutionIteration = 0;
            adaptedCreditRange = defaultCreditRange;
            adaptedSAReset = 0;
        }

        //newSolution
        double currentSolutionValue = SimHeuristic.GetCurrentSolutionValue(n, currentSimulationExperiment, 
        simParamsParameterVariation, true, optimizationParameters);
        
		double currentSolutionValueIterationCount = SimHeuristic.GetCurrentSolutionValueIterationCount(n, 
        currentSimulationExperiment, 
        simParamsParameterVariation, true, optimizationParameters);

        traceln("Current Solution " + currentSolutionValue + " Iteration " + n);
        traceln("Base Solution Value " + baseSolutionValue + " Iteration " + baseSolutionIteration);
        traceln("Best Solution Value " + bestSolutionValue + " Iteration " + bestSolutionIteration);

        StringBuilder outputSA = new StringBuilder();

        outputSA.append("Current Solution " + currentSolutionValue + " Iteration " + n + "\n");
        outputSA.append("Base Solution Value " + baseSolutionValue + " Iteration " + baseSolutionIteration + "\n");
        outputSA.append("Best Solution Value " + bestSolutionValue + " Iteration " + bestSolutionIteration + "\n");

        delta = baseSolutionValue - currentSolutionValue;
        traceln("n=" + n + " delta " + delta + "(" + baseSolutionValue + "-" + currentSolutionValue + ") credit " + credit);

        outputSA.append("n=" + n + " delta " + delta + "(" + baseSolutionValue + "-" + currentSolutionValue + ") credit " + credit + "\n");
		
		traceln("Solution Config applied FOR applying SA calling GetBestSolution with: " + n);
        List <ResultObject> currentSolution =
            SimHeuristic.GetIterationBasedSolution(currentSimulationExperiment, n, simParamsParameterVariation, true, 
            optimizationParameters, bestSolutionIteration);

        //base solution ist fr x iterationen nicht besser geworden dann set to best soltuion

        if (simAnnealing == 1) {

            if (baseSolutionValue >= bestSolutionValue) {
                adaptedSAReset--;
                outputSA.append("Iteration " + n + " Replication " + getCurrentReplication() + " adaptedSAReset " + adaptedSAReset + " currentSolutionValue " + currentSolutionValue + " baseSolutionValue " + baseSolutionValue + "\n");
            }

            if (adaptedSAReset == 0) {

                outputSA.append("RESET BaseSolution TO BestSolution --- at Iteration " + n + " Replication " + getCurrentReplication() + " SAReset Limit " + defaultSAReset + " ResetDiff " + (baseSolutionIteration - bestSolutionIteration) +
                    " currentSolutionValue " + currentSolutionValue + " currentSolutionIteration " + n + " baseSolutionValue " + baseSolutionValue + "basesolution itearation " + baseSolutionIteration +
                    " best solution " + bestSolutionValue + " bestsolution iteration " + bestSolutionIteration + " old adaptedRest " + adaptedSAReset + " new adapted reset " + n + "\n");                

                baseSolution = bestSolution;
                baseSolutionValue = bestSolutionValue;
                baseSolutionIteration = bestSolutionIteration;
                adaptedSAReset = defaultSAReset;
            }

            //delta evaluation
            if (delta > 0) {

                outputSA.append("New Candiate -> Delta > 0 n=" + n + " delta " + delta + "(" + baseSolutionValue + "-" + currentSolutionValue + ") credit " + credit + "\n");

                credit = delta;
                baseSolution = currentSolution;
                baseSolutionIteration = n;
                baseSolutionValue = currentSolutionValue;
	        
                if (currentSolutionValue < bestSolutionValue && 
                	currentSolutionValueIterationCount == optimizationParameters.getFixedNumberReplications()) {
                    bestSolution = currentSolution;
                    bestSolutionValue = currentSolutionValue;
                    bestSolutionIteration = n;
                    adaptedSAReset = defaultSAReset;
                    outputSA.append("RESET BEST SOLUTION ---> at Iteration " + n + " Replication " + getCurrentReplication() + " adaptedSAReset " + adaptedSAReset + " currentSolutionValue " + currentSolutionValue + " baseSolutionValue " + baseSolutionValue + "\n");

                    traceln("********************** WE HAVE A NEW BEST SOLUTION ********************************");
                    traceln("New BestSolution: " + bestSolutionValue);
                    traceln("BestSolution Config: " + bestSolution.toString());
                }

            } else if (delta * (-1) <= credit) {
                baseSolution = currentSolution;
                baseSolutionValue = currentSolutionValue;
                baseSolutionIteration = n;
                credit = 0;
                outputSA.append("UNDER CREDIT LIMIT Iteration " + n + " delta = " + (delta * (-1)) + " credit " + (credit * 2) + "\n");
            } else if (currentSolutionValue < baseSolutionValue) {
                baseSolution = currentSolution;
                baseSolutionValue = currentSolutionValue;
                baseSolutionIteration = n;
                outputSA.append("CurrentSolutionValue  Iteration " + n + " " + currentSolutionValue + " < BaseSolutionValue " + baseSolutionValue + "\n");
            }
        } else { // default style
        
            if (currentSolutionValue < bestSolutionValue && 
            currentSolutionValueIterationCount == optimizationParameters.getFixedNumberReplications()) {

                bestSolution = currentSolution;
                bestSolutionValue = currentSolutionValue;
                bestSolutionIteration = n;

                adaptedSAReset = defaultSAReset;

                baseSolution = currentSolution;
                baseSolutionValue = currentSolutionValue;
                baseSolutionIteration = n;

                traceln("********************** WE HAVE A NEW BEST SOLUTION ********************************");
                traceln("New BestSoluation Value " + bestSolutionValue);
            }
        }

        if (n == 1) {
            baseSolutionIteration = 0;
        }
		
		traceln("After Iteration Parameters applied ... will now be changed:");
		traceln("Base solution Iteration applied for selecting Solution Configuration: " + baseSolutionIteration);
		traceln("Best Solution Iteration applied for selecting Solution Configuration: " + bestSolutionIteration);
		
        List <ResultObject> bestConfiguration =
            SimHeuristic.GetIterationBasedSolution(currentSimulationExperiment, baseSolutionIteration, simParamsParameterVariation,
             true, optimizationParameters, bestSolutionIteration);

        traceln("Used Configuration based on " + currentSimulationExperiment + " Iteration " + baseSolutionIteration);
		traceln("This Configuration WAS applied during the Replications and Represented the basic for change them using triangular distribution");
        
        if (bestConfiguration.size() > 0)
            traceln("Our USED configuration is " + bestConfiguration.toString());

        //Only for heuristic 1 and 2 we update the mode in the following iteration. For Heuristic 3 this is done in the SimHeuristic Class
        if (simHeuristic.equalsIgnoreCase(InputParameter.HeuristicType.Extension2.toString()) && n < warmUpTime ||
            simHeuristic.equalsIgnoreCase(InputParameter.HeuristicType.Extension1.toString()) ||
            simHeuristic.equalsIgnoreCase(InputParameter.HeuristicType.Basic.toString()) ||
            simHeuristic.equalsIgnoreCase(InputParameter.HeuristicType.Random.toString())
        ) {

            traceln("before adapt mode");
            for (InputParameter p: inputParameterList) {
                traceln(p.toString());
            }

            inputParameterList = InputParameter.processAndSetModValues(inputParameterList, bestConfiguration);

        }

        List <InputParameter> adaptedList = inputParameterList;

        traceln("after adapt mode");
        for (InputParameter p: inputParameterList) {
            traceln(p.toString());
        }

        //Heuristic 2 (Extension 1) applied for WSC24 Extension
        //Update Lower and UpperBound, we simply iterate over all lower and upper bounds of the input parameters and update the lower and upper bound		
        if (simHeuristic.equalsIgnoreCase(InputParameter.HeuristicType.Extension1.toString()) && n > warmUpTime) {
			traceln("I am in Extension 1 Iteration " + n + " warmupphase: " + warmUpTime);
			traceln("ReduceRangeSBM: " + reduceRangeSBM);
			traceln("simBudgetManagement: " + simBudgetManagement);
            //when simulation budget managment is actived only after the fixed replication count the Range is reduced.


            if (simBudgetManagement > 1 && reduceRangeSBM) {
                traceln("Reduce Range due to SBM!");
                traceln("Before Range Reduction");
                for (InputParameter p: inputParameterList) {
                    traceln(p.toString());
                }
                for (InputParameter item: inputParameterList) {
                    double[] range = SimHeuristic.getRange(item.getLowerBound(), item.getMod(), 
                    item.getUpperBound(), alpha, n, currentSimulationExperiment,
                     item.parameterType, Integer.parseInt(item.getMaterial()),parametervariationItems);
                    
                    //we have found and updated the item
                    if(range != null){
                    	item.setLowerBound(range[0]);
                    	item.setUpperBound(range[1]);
                    }else{
                    	traceln("Item " + item.getMaterial() +  " not updated");
                    }
                }
            } else {
            
                for (InputParameter item: inputParameterList) {
                    traceln("Reduce Range - Basic not via SBM");
                    double[] range = SimHeuristic.getRange(item.getLowerBound(), item.getMod(),
                    item.getUpperBound(), alpha, n, currentSimulationExperiment,
                    item.parameterType, Integer.parseInt(item.getMaterial()),parametervariationItems);
                    
                   //we have found and updated the item
                    if(range != null){                    
                    	item.setLowerBound(range[0]);
                    	item.setUpperBound(range[1]);
                    }else{
                    	traceln("Item " + item.getMaterial() +  " not updated");
                    }
                }
            }

            traceln("After Range Reduction");
            for (InputParameter p: inputParameterList) {
                traceln(p.toString());
            }
        }

        //Heuristic 3
        //For the third SimHeuristic we upate mod, lower and uper bounds after X iteration, and alwways take the X best solutions.

        if (simHeuristic.equalsIgnoreCase(InputParameter.HeuristicType.Extension2.toString()) &&
            n >= warmUpTime) {
            traceln("I am in Extension 2");

            //ony reduction after fixed replications 20  
            if (cbrrlb > 0) {

                double j = 1 / (cbrrlb - 1);
                alpha = (cbrrlb / defaultCreditRange);
                alpha = 1 - Math.pow(alpha, j);
            }

            if (simBudgetManagement > 1 && reduceRangeSBM) {
                double oldRange = adaptedCreditRange;

                adaptedCreditRange = oldRange * (1 - alpha);

                SimHeuristic.WriteToFileAppend(SimHeuristic.FILE_RANGE_REDUCTION, "SBM based reduction old credit Range " + oldRange + "*(1-" + alpha + ") new Range " +
                    adaptedCreditRange + " UB " + defaultCreditRange + " LB " + cbrrlb + " MinItems " + minCBRRItems, SimHeuristic.FILE_CREDIT_RANGE_REDUCTION_WRITE);

            } else if (simBudgetManagement == 0) {
                double oldRange = adaptedCreditRange;

                adaptedCreditRange = oldRange * (1 - alpha); //without SBM reduce after default set of max iterations
                SimHeuristic.WriteToFileAppend(SimHeuristic.FILE_RANGE_REDUCTION, "Default based reduction old credit Range " + oldRange + "*(1-" + alpha + ") new Range " +
                    adaptedCreditRange + " UB " + defaultCreditRange + " LB " + cbrrlb + " MinItems " + minCBRRItems, SimHeuristic.FILE_CREDIT_RANGE_REDUCTION_WRITE);

            }

            inputParameterList = SimHeuristic.SetBestSolutionForPopulation(currentSimulationExperiment, historyValues,
                inputParameterList, simAnnealing,
                baseSolution, adaptedCreditRange, bestSolutionValue, n, totalReplicationCount, 
                minCBRRItems, simParamsParameterVariation, true, optimizationParameters);
        }

        //reset to false for the next x-fixed number of replications
        reduceRangeSBM = false;

        //Triangular Distribution is always used for alle three Heuristics

        //old Call where we use the currentIteration instead of n
        //adaptedList = SimHeuristic.DistributionValues(inputParameterList, n, distributionType);

        //Random rand = new Random(n); 								
		randParam.setSeed(n + 60006);
		//Random rand = new Random(totalReplicationCount + 2000);
        adaptedList = SimHeuristic.DistributionValues(inputParameterList, n, distributionType, randParam);
		
		//here n+1 as the following code already done for iteration n+1, but n++ is done at the end of ths function which is correct 		
        traceln("##################################### START Replication " + n +1 + " of " + maxIterations + " max Simulationbudget " +
            " using SimHeuristic " + simHeuristic + " Experiment " + currentSimulationExperiment + "  #####################################");
		traceln("In this part the adpated values are combined to sql statement to update optimizationparameters for next iteration");
        if (n >= 1) {
            //now update the values;
            ZonedDateTime now = ZonedDateTime.now();
            String formattedNow = now.format(DateTimeFormatter.ofPattern("yyyy-MM-dd'T'HH:mm:ss"));
            sqlInsertString.append("UPDATE optimizationparameter SET lastmodified= '" + formattedNow + "',");

            if (!SimHeuristic.USE_FIXED_PARAMETERSET) {

                Map <String, Integer> parameterTypeToSuffix = new HashMap <> ();
                parameterTypeToSuffix.put(InputParameter.ParameterType.FOQLOTSIZE.toString(), 0);
                parameterTypeToSuffix.put(InputParameter.ParameterType.LEADTIME.toString(), 1);
                parameterTypeToSuffix.put(InputParameter.ParameterType.SAFETYSTOCK.toString(), 2);
                parameterTypeToSuffix.put(InputParameter.ParameterType.WIPCAP.toString(), 3);
				parameterTypeToSuffix.put(InputParameter.ParameterType.WAWBUFFER.toString(), 4);
                

                for (InputParameter item: adaptedList) {
                    int materialIndex = SimHeuristic.materials.indexOf(item.getMaterial());
                    if (materialIndex != -1) { // Ensure the material is in the list
                        Integer suffixOffset = parameterTypeToSuffix.get(item.getParameterType());
                        if (suffixOffset != null) {
                            // Calculate the actual suffix for the column
                            int columnSuffix = materialIndex * 5 + suffixOffset;
                            // Construct the column name and append to the SQL string
                            sqlInsertString.append("V" + String.format("%03d", columnSuffix) + " = " + item.getValue() + ",");
                        }
                    }
                }

            } else {

                String[] fixedParameters = SimHeuristic.FIXED_PARAMETERSET.split(";");

                // Mapping of parameter types to column suffixes
                Map < String, Integer > parameterTypeToSuffix = new HashMap < > ();
                parameterTypeToSuffix.put(InputParameter.ParameterType.FOQLOTSIZE.toString(), 0);
                parameterTypeToSuffix.put(InputParameter.ParameterType.LEADTIME.toString(), 1);
                parameterTypeToSuffix.put(InputParameter.ParameterType.SAFETYSTOCK.toString(), 2);
                parameterTypeToSuffix.put(InputParameter.ParameterType.WIPCAP.toString(), 3);
                parameterTypeToSuffix.put(InputParameter.ParameterType.WAWBUFFER.toString(), 4);


                for (InputParameter item: adaptedList) {
                    int materialIndex = SimHeuristic.materials.indexOf(item.getMaterial());
                    if (materialIndex != -1) { // Ensure the material is in the list
                        Integer suffixOffset = parameterTypeToSuffix.get(item.getParameterType());
                        if (suffixOffset != null) {
                            // Calculate the index for the fixed parameter
                            int fixedParamIndex = materialIndex * 5 + suffixOffset;
                            // Calculate the actual suffix for the column
                            int columnSuffix = fixedParamIndex;
                            // Construct the column name and append to the SQL string
                            sqlInsertString.append("V" + String.format("%03d", columnSuffix) + " = " + fixedParameters[fixedParamIndex] + ",");
                        }
                    }
                }

            } //else fixed parmeters

            traceln("Adapted input values for update sql statement to update Optimizationparameters for next Iteration");
            for (InputParameter p: inputParameterList) {
                traceln(p.toString());
            }

            for (int i = 0; i < SimHeuristic.materials.size(); i++) {
                String currentMaterial = SimHeuristic.materials.get(i);
                // Generate the SP format string like SP000, SP001, etc.
                String sectionName = String.format("SP%03d", i);

                // Start constructing the SQL insert string for the current material
                sqlInsertString.append(sectionName).append("='");

                // Initialize lists to capture bounds and halfsteps for this material
                List < String > bounds = new ArrayList < > ();
                List < Integer > halfSteps = new ArrayList < > ();
                String materialValue = "";

                // Loop through the adaptedList to process the lower and upper bounds and halfsteps
                for (InputParameter k: adaptedList) {
                    if (k.getMaterial().equals(currentMaterial)) {
                        // Collect lower and upper bounds if not already collected (limit to 3 pairs)
                        if (bounds.size() < 10) {
                            bounds.add(k.getLowerBound() + ";" + k.getUpperBound());
                        }

                        // Collect halfsteps (limit to 3)
                        if (halfSteps.size() < 5) {
                            halfSteps.add(k.getHalfSteps());
                        }

                        // Store the material value (assuming it's consistent for the same material)
                        materialValue = String.valueOf(k.getMaterial());
                        traceln("material value " + materialValue + " LB:" + k.getLowerBound() + " UB:" + k.getUpperBound());
                    }
                }

                // Append the three lower and upper bounds to the SQL string
                for (String bound: bounds) {
                    sqlInsertString.append(bound).append(";");
                }

                // Append the three halfsteps to the SQL string
                for (int step: halfSteps) {
                    sqlInsertString.append(step).append(";");
                }

                // Append the material number (or value)
                sqlInsertString.append(materialValue).append(";");

                // Replace the last semicolon with a single quote and append a comma
                sqlInsertString.setCharAt(sqlInsertString.length() - 1, '\'');
                sqlInsertString.append(",");
            }

            //insert adapted parameters into database

            sqlInsertString.append("maxiterations = " + maxIterations + ",fixednumberreplications = " + fixedNumberReplications);

            sqlInsertString.append(" WHERE ID = " + minParameterEntryId + " and status = " +
                optimizationParameters.getStatus() + ";");

            traceln("Update Query String " + sqlInsertString.toString());
			traceln("Updated Optimization Parameters for Next Iteration");
            db.AdaptOptimizationParameter(simParamsParameterVariation, sqlInsertString.toString());
        }

        if (simAnnealing > 0) {
            SimHeuristic.WriteToFileAppend(SimHeuristic.FILE_CREDIT_SA, outputSA.toString(), SimHeuristic.FILE_SA_REDUCTION_WRITE);
        }

        redoOptimizationParameterId = optimizationParameters.getId();
        traceln("Start Redo of Optimizationparameter Id: " + redoOptimizationParameterId);

        n++;
    } else {
        redoOptimizationParameterId = 0;
        n = 0;
        totalReplicationCount = 1;
        //reset creditRange after Experiment
        adaptedCreditRange = defaultCreditRange;
        adaptedSAReset = defaultSAReset;
    }
} else { //no Simheristic
    traceln("Iteration " + n + " finsihed");
    n++;
    redoOptimizationParameterId = 0;
}
/******************************* END SIMHEURISTIC ***********************************/

//Attention here the average costs are build!
double getOverallCosts_inkl_not_Delivered = replicationResults.stream().filter(e -> e.getReplication() > 0 
&& e.getOverallCosts_inkl_not_Delivered() > 0)
.mapToDouble(Result::getOverallCosts_inkl_not_Delivered).average().orElse(0);

Result iterationResult = new Result();

iterationResult.setOverallCosts_inkl_not_Delivered(getOverallCosts_inkl_not_Delivered);

iterationResult.setIteration(n);
iterationResult.setReplication(replicationResults.size());
avgIterationResults.add(iterationResult);

traceln("Write Results per Replication to DB ... Check After Iteration Value: " + WriteResultsPerReplicationToDb);

int writeResultsPerReplicationToDb = 0;
try{
	PropertyValues properties = new PropertyValues(SimulationParameter.PROPERTIES_FILENAME);	
	traceln("Write Results per Replication After Iteation Set: " + properties.WriteResultsPerReplicationToDb);
	writeResultsPerReplicationToDb = Integer.parseInt(properties.WriteResultsPerReplicationToDb);	
}catch(Exception ex) {
	traceln(ex.getMessage());    		
}

if (writeResultsPerReplicationToDb == 0) {
    db.WriteResultToDb(replicationResults, db.GetSimulationParameters(),
        true, simPCName, optimizationParameters);
    replicationResults.clear();
}

traceln("After Iteration: SBM Value: " + optimizationParameters.getSBM());
if(optimizationParameters.getSBM() >= 1) {
	replicationResults.clear();
}
traceln("Size replicationResults after Clearing: " + replicationResults.size());
//optimizationParameters = db.GetOptimizationParameterbyStatus(simParamsParameterVariation, 
//OptimizationParameter.ACTIVE_OPTIMIZATION_PARAMETER, false, true,simPCName);

traceln("After iteration set processed param id " + optimizationParameters.getId() + " redo? " + redoOptimizationParameterId);

if (redoOptimizationParameterId == 0) {
    db.SetOptimizationParameterStatusProcessed(simParamsParameterVariation, optimizationParameters, true, simPCName);
	avgIterationResults.clear();
}
traceln("da 1");]]></AfterIterationCode>
			<AfterExperimentCode><![CDATA[traceln("da 2");
DBQueries db = new DBQueries();

int notProcessedOptimizationParameters = OptimizationParameter.GetNumberNotProcessedParameters(simParamsParameterVariation,true,false);

int allOptimizationParameters = OptimizationParameter.GetNumberNotProcessedParameters(simParamsParameterVariation,true,true);

traceln("Finished optimizizaton parameters: " + notProcessedOptimizationParameters + " of " + allOptimizationParameters);
traceln("Used Simulation PC: " + simParams.getSimulationPCName());
if(notProcessedOptimizationParameters > 0){	
	traceln("------------------------------------ Start new Experiment ------------------------------------");
	stop();	
	run();
	totalReplicationCount = 1;
} else {
	traceln("We are completely done!!!!");
	stop();
}]]></AfterExperimentCode>
			<AllowParallelEvaluations>true</AllowParallelEvaluations>
			<UseFreeformParameters>false</UseFreeformParameters>
			<NumberOfRuns>10</NumberOfRuns>
			<FreeformParamValue>	
				<Id>1639651241059</Id>
			</FreeformParamValue>
			<FreeformParamValue>	
				<Id>1643118215806</Id>
			</FreeformParamValue>
			<FreeformParamValue>	
				<Id>1643118692841</Id>
			</FreeformParamValue>
			<FreeformParamValue>	
				<Id>1643199330836</Id>
			</FreeformParamValue>
			<FreeformParamValue>	
				<Id>1643405334788</Id>
			</FreeformParamValue>
			<FreeformParamValue>	
				<Id>1643640921074</Id>
			</FreeformParamValue>
			<FreeformParamValue>	
				<Id>1645764624224</Id>
			</FreeformParamValue>
			<FreeformParamValue>	
				<Id>1646143437023</Id>
			</FreeformParamValue>
			<FreeformParamValue>	
				<Id>1646819915337</Id>
			</FreeformParamValue>
			<FreeformParamValue>	
				<Id>1647439124689</Id>
			</FreeformParamValue>
			<FreeformParamValue>	
				<Id>1671771926561</Id>
			</FreeformParamValue>
			<FreeformParamValue>	
				<Id>1679494083638</Id>
			</FreeformParamValue>
			<FreeformParamValue>	
				<Id>1684474491035</Id>
			</FreeformParamValue>
			<FreeformParamValue>	
				<Id>1693988659951</Id>
			</FreeformParamValue>
			<FreeformParamValue>	
				<Id>1694008060246</Id>
			</FreeformParamValue>
			<FreeformParamValue>	
				<Id>1715850640098</Id>
			</FreeformParamValue>
			<FreeformParamValue>	
				<Id>1718555911406</Id>
			</FreeformParamValue>
			<RangeVariationParamValue>	
				<Id>1639651241059</Id>
				<Type>FIXED</Type>
			</RangeVariationParamValue>
			<RangeVariationParamValue>	
				<Id>1643118215806</Id>
				<Type>FIXED</Type>
			</RangeVariationParamValue>
			<RangeVariationParamValue>	
				<Id>1643118692841</Id>
				<Type>FIXED</Type>
			</RangeVariationParamValue>
			<RangeVariationParamValue>	
				<Id>1643199330836</Id>
				<Type>FIXED</Type>
			</RangeVariationParamValue>
			<RangeVariationParamValue>	
				<Id>1643405334788</Id>
				<Type>FIXED</Type>
			</RangeVariationParamValue>
			<RangeVariationParamValue>	
				<Id>1643640921074</Id>
				<Type>FIXED</Type>
			</RangeVariationParamValue>
			<RangeVariationParamValue>	
				<Id>1645764624224</Id>
				<Type>FIXED</Type>
			</RangeVariationParamValue>
			<RangeVariationParamValue>	
				<Id>1646143437023</Id>
				<Type>FIXED</Type>
			</RangeVariationParamValue>
			<RangeVariationParamValue>	
				<Id>1646819915337</Id>
				<Type>FIXED</Type>
			</RangeVariationParamValue>
			<RangeVariationParamValue>	
				<Id>1647439124689</Id>
				<Type>FIXED</Type>
			</RangeVariationParamValue>
			<RangeVariationParamValue>	
				<Id>1671771926561</Id>
				<Type>FIXED</Type>
			</RangeVariationParamValue>
			<RangeVariationParamValue>	
				<Id>1679494083638</Id>
				<Type>FIXED</Type>
			</RangeVariationParamValue>
			<RangeVariationParamValue>	
				<Id>1684474491035</Id>
				<Type>FIXED</Type>
			</RangeVariationParamValue>
			<RangeVariationParamValue>	
				<Id>1693988659951</Id>
				<Type>FIXED</Type>
			</RangeVariationParamValue>
			<RangeVariationParamValue>	
				<Id>1694008060246</Id>
				<Type>FIXED</Type>
			</RangeVariationParamValue>
			<RangeVariationParamValue>	
				<Id>1715850640098</Id>
				<Type>FIXED</Type>
			</RangeVariationParamValue>
			<RangeVariationParamValue>	
				<Id>1718555911406</Id>
				<Type>FIXED</Type>
			</RangeVariationParamValue>
			<ModelTimeProperties>
				<StopOption><![CDATA[Stop at specified time]]></StopOption>
				<InitialDate><![CDATA[1634083200000]]></InitialDate>	
				<InitialTime><![CDATA[0.0]]></InitialTime>	
				<FinalDate><![CDATA[1677283200000]]></FinalDate>	
				<FinalTime><![CDATA[500.0]]></FinalTime>	
			</ModelTimeProperties>
			<PresentationProperties>
				<EnableZoomAndPanning>true</EnableZoomAndPanning>
				<Title><![CDATA[SimOpt : ParametersVariation]]></Title>
				<EnableDeveloperPanel>true</EnableDeveloperPanel>
				<ShowDeveloperPanelOnStart>false</ShowDeveloperPanelOnStart>
			</PresentationProperties>
			<ReplicationsProperties>
				<UseReplication>true</UseReplication>
				<FixedReplicationsNumber>true</FixedReplicationsNumber>
				<ReplicationPerIteration>5</ReplicationPerIteration>
				<MinimumReplication>2</MinimumReplication>
				<MaximumReplication>10</MaximumReplication>
				<ConfidenceLevel>LEVEL_80</ConfidenceLevel>
				<ErrorPercent>0.5</ErrorPercent>
				<ExpressionForConfidenceComputation><![CDATA[0]]></ExpressionForConfidenceComputation>
			</ReplicationsProperties>
		</ParamVariationExperiment>	
	</Experiments>
	<JavaClasses>
		<!--   =========   Java Class   ========  -->
		<JavaClass>
			<Id>1636617911247</Id>
			<Name><![CDATA[Item]]></Name>
			<Text><![CDATA[import java.io.Serializable;
import com.google.gson.annotations.Expose;

/**
 * Item
 */	
public class Item implements Serializable {

    public static final String ITEM_TYPE_SALES = "S";
    public static final String ITEM_TYPE_COMPONENT = "C";
    public static final String ITEM_TYPE_PURCHASE = "P";
    
    public static final String ITEM_PLANNINGTYPE_MRP = "MRP";
    public static final String ITEM_PLANNINGTYPE_RPS = "RPS";
    public static final String LOT_POLICY_FOP = "FOP";
    public static final String LOT_POLICY_FOQ = "FOQ";
	
	@Expose
	private int Id;
	@Expose
	private int Item;	 
	@Expose
	private int Active;	 
	@Expose
    private String Type; 
	@Expose
    private int LeadTime;    
	@Expose
    private double ProductionCosts;  
	@Expose
    private double HoldingCosts;  
	@Expose
    private double SetupCosts;  
	@Expose
    private double BacklogCosts;  
	@Expose
    private double LostSalesCosts;
	@Expose
    private double SafetyStock;
    
	@Expose
    private String LotsizePolicy;  
	@Expose
    private int FOPPeriod;
	@Expose
    private double FOQQuantity;
	@Expose
    private String PlanningType;
	@Expose
    private int FOQMinimumLotSize;
	@Expose
    private int DataItemIndex;
	@Expose
    private double HoldingCostsWIP;
	@Expose
    private int TransportLotSize;
	@Expose
    private int DemandVariationIndex;
	
    private Routing Routing;    
    
    @Expose
    private double RPSQty;
    
    @Expose
	private int SafetyLeadTime;
    
    private double SafetyStockMinimum;
      
    /**
     * Default constructor
     */
    public Item() {
    }
    
    public double getSafetyStockMinimum() {
        return SafetyStockMinimum;
    }

    public void setSafetyStockMinimum(double SafetyStockMinimum) {
        this.SafetyStockMinimum = SafetyStockMinimum;
    }
    
    public Item(int id) {
        this.Id = id;
    }
		 
	public int getSafetyLeadTime() {
		return SafetyLeadTime;
	}


	public void setSafetyLeadTime(int safetyLeadTime) {
		SafetyLeadTime = safetyLeadTime;
	}

    
    public double getRPSQty() {
		return this.RPSQty;
	}

	public void setRPSQty(double value) {
		this.RPSQty = value;
	}
    
    public Routing getRouting() {
        return this.Routing;
     }
   
     public void setRouting(Routing value) {
        this.Routing = value;
     }
    
    public int getDemandVariationIndex() {
       return this.DemandVariationIndex;
    }
  
    public void setDemandVariationIndex(int value) {
       this.DemandVariationIndex = value;
    }
    
    public int getTransportLotSize() {
       return this.TransportLotSize;
    }
  
    public void setTransportLotSize(int value) {
       this.TransportLotSize = value;
    }
    
    public double getHoldingCostsWIP() {
       return this.HoldingCostsWIP;
    }
  
    public void setHoldingCostsWIP(double value) {
       this.HoldingCostsWIP = value;
    }
    
    public int getFOQMinimumLotSize() {
       return this.FOQMinimumLotSize;
    }
  
    public void setFOQMinimumLotSize(int value) {
       this.FOQMinimumLotSize = value;
    }
    
    public String getPlanningType() {
       return this.PlanningType;
    }
  
    public void setPlanningType(String value) {
       this.PlanningType = value;
    }
    
    public int getItem() {
        return this.Item;
     }
   
     public void setItem(int value) {
        this.Item = value;
     }
   
     public int getId() {
         return this.Id;
      }
    
      public void setId(int value) {
         this.Id = value;
      }
      
      
      public int getActive() {
          return this.Active;
       }
     
       public void setActive(int value) {
          this.Active = value;
       }
     
     public String getType() {
        return this.Type;
     }
   
     public void setType(String value) {
        this.Type = value;
     }
     
     public int getLeadTime() {
         return this.LeadTime;
      }
    
      public void setLeadTime(int value) {
         this.LeadTime = value;
      }
    
      public double getProductionCosts() {
         return this.ProductionCosts;
      }
    
      public void setProductionCosts(double value) {
         this.ProductionCosts = value;
      }
    
      public double getHoldingCosts() {
         return this.HoldingCosts;
      }
    
      public void setHoldingCosts(double value) {
         this.HoldingCosts = value;
      }
    
      public double getSetupCosts() {
         return this.SetupCosts;
      }
    
      public void setSetupCosts(double value) {
         this.SetupCosts = value;
      }
    
      public double getBacklogCosts() {
         return this.BacklogCosts;
      }
    
      public void setBacklogCosts(double value) {
         this.BacklogCosts = value;
      }
    
      public double getLostSalesCosts() {
         return this.LostSalesCosts;
      }
    
      public void setLostSalesCosts(double value) {
         this.LostSalesCosts = value;
      }
    
      public double getSafetyStock() {
          return this.SafetyStock;
       }
     
       public void setSafetyStock(double value) {
          this.SafetyStock = value;
       }
      
       public String getLotsizePolicy() {
    	      return this.LotsizePolicy;
    	   }
    	 
    	   public void setLotsizePolicy(String value) {
    	      this.LotsizePolicy = value;
    	   }
    	 
    	   public int getFOPPeriod() {
    	      return this.FOPPeriod;
    	   }
    	 
    	   public void setFOPPeriod(int value) {
    	      this.FOPPeriod = value;
    	   }
    	 
    	   public double getFOQQuantity() {
    	      return this.FOQQuantity;
    	   }
    	 
    	   public void setFOQQuantity(double value) {
    	      this.FOQQuantity = value;
    	   }
    
    	   
    	   public int getDataItemIndex() {
    	      return this.DataItemIndex;
    	   }
    	 
    	   public void setDataItemIndex(int value) {
    	      this.DataItemIndex = value;
    	   }


     public static List<Item> SetRouting(SimulationParameter simParas, List<Item> items, List<Routing> routings){

     	for(Item item : items) {
     		traceln(item.getItem());
     		if(item.getType().equalsIgnoreCase(ITEM_TYPE_SALES) || item.getType().equalsIgnoreCase(ITEM_TYPE_COMPONENT))	{
     			item.setRouting(routings.stream().filter(e -> e.getItem().getItem() == item.getItem()).findFirst().get());
     		}
     	}
    	 
     	return items;
     
     }     
     
     
     public static String GetCSVHeader() {
      	
    	 
      	StringBuilder out = new StringBuilder();
      	
      	out.append("Item;");
      	out.append("SS;");
      	out.append("LSP;");
      	out.append("FOP;");
      	out.append("FOQ;");
      	out.append("FOQMin;");
      	
      	return out.toString();    	    	
      }
      
      public static String GetCSVString(Item obj) {
      	
      	StringBuilder out = new StringBuilder();
      	
      	out.append(obj.getItem() + ";");
      	out.append(obj.getSafetyStock() + ";");
      	out.append(obj.getLotsizePolicy() + ";");
      	out.append(obj.getFOPPeriod() + ";");
      	out.append(obj.getFOQQuantity() + ";");     	
      	out.append(obj.getFOQMinimumLotSize() + ";");     	
      	    	    	    	    	
      	return out.toString();
      	
      }
      

     

     
	@Override
	public String toString() {
		return super.toString();
	}

	/**
	 * This number is here for model snapshot storing purpose<br>
	 * It needs to be changed when this class gets changed
	 */ 
	private static final long serialVersionUID = 1L;

}]]></Text>
		</JavaClass>
		<!--   =========   Java Class   ========  -->
		<JavaClass>
			<Id>1636621044476</Id>
			<Name><![CDATA[DBQueries]]></Name>
			<Text><![CDATA[import java.sql.DriverManager;  
import java.sql.Connection;  
import java.sql.SQLException;
import java.util.stream.*;
import one.util.streamex.StreamEx;
import java.text.DecimalFormat;
import java.io.*;
import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter;
import java.lang.reflect.Method;
import java.lang.reflect.InvocationTargetException;



/**
 * DBQueries
 */	
public class DBQueries implements Serializable {


	 private static final DecimalFormat df = new DecimalFormat("0.00");
	 public static final boolean TRACE_DB_RESULTS = false;
	
    public DBQueries() {
    }           
        
    public Connection ConnectH2() {
    	
    	Connection conn = null; 
    	try {
    	
    	PropertyValues properties = new PropertyValues(SimulationParameter.PROPERTIES_FILENAME);

    	//String h2Host = properties.H2Host;
    	
    	//String jdbcURL = "jdbc:h2:tcp://localhost/~/simopt";
        String username = "sa";
        String password = "simopt";
    
        Class.forName("org.h2.Driver");  
        conn = DriverManager.getConnection(properties.H2Host, username, password);	
        
    	}catch(Exception ex) {
    		traceln(ex.getMessage());    		
    	}
    	
    	return conn;
    }
    
    public Connection ConnectPostGreSql()  throws SQLException, IOException {
    	
    	Connection connection = null;

        try {
            // Register PostgreSQL JDBC driver
            Class.forName("org.postgresql.Driver");
        	PropertyValues properties = new PropertyValues(SimulationParameter.PROPERTIES_FILENAME);
            
            // Create a connection to the database
            //String url = "jdbc:postgresql://localhost:5432/postgres";
        	String url = properties.PostGresHost;
            String username = "postgres";
            String password = "simopt";
            connection = DriverManager.getConnection(url, username, password);
        } catch (ClassNotFoundException e) {
            System.out.println("PostgreSQL JDBC driver not found");
            e.printStackTrace();
        }

        return connection;
    }
    
    public Connection connect() {  
    	    	
    	Connection conn = null; 
    	try {

    		PropertyValues properties = new PropertyValues(SimulationParameter.PROPERTIES_FILENAME);    	
    		//traceln(properties.SQLiteDatabase);
    		String url = "jdbc:sqlite:" + properties.SQLiteDatabase;  
            conn = DriverManager.getConnection(url);  
        } catch (Exception e) {  
            System.out.println(e.getMessage());
        }  
        return conn;  
    }  
                
    public SimulationParameter GetSimulationParameters(){  
        
    	String sql = "SELECT * FROM SimulationParameters WHERE status = 1 order by id desc limit 1";  
        
    	SimulationParameter simParam = new SimulationParameter();

        try {  
        	
            java.sql.Connection conn = this.connect();  
            java.sql.Statement stmt  = conn.createStatement();  
            java.sql.ResultSet rs    = stmt.executeQuery(sql); 
                                
	            while (rs.next()) {              	            	
	            	simParam.setId(rs.getInt("id"));
	            	simParam.setName(rs.getString("Name"));
	            	simParam.setDescription(rs.getString("Description"));
	            	simParam.setSimOptHorizon(rs.getInt("SimOptHorizon"));
	            	simParam.setApplyOptimization(rs.getInt("ApplyOptimization"));
	            	simParam.setDemandGeneration(rs.getString("DemandGeneration"));            	            	             
	            	simParam.setMRPPlanningHorizon(rs.getInt("MRPPlanningHorizon"));            	            	             
	            	simParam.setOptimizationType(rs.getString("OptimizationType"));            	            	             
	            	simParam.setForecastUpdateHorizon(rs.getInt("ForecastUpdateHorizon"));            	            	             
	            	simParam.setForecastUpdateFrequency(rs.getInt("ForecastUpdateFrequency"));            	            	             
	            	simParam.setExperiment(rs.getString("Experiment"));           
	            	simParam.setApplyMRP(rs.getInt("ApplyMRP"));
	            	simParam.setPlanningFrequency(rs.getInt("PlanningFrequency"));
	            	simParam.setApplyForecastUpdates(rs.getInt("ApplyForecastUpdates"));            	            	            	
	            	simParam.setFrozenZone(rs.getInt("FrozenZone"));                 	
	            	simParam.setWarumUpTime(rs.getInt("WarumUpTime"));     
	            	simParam.setSimulationRunTime(rs.getInt("SimulationRunTime"));
	            	simParam.setApplyClearingFunctions(Boolean.parseBoolean(rs.getString("ApplyClearingFunctions")));
	            	simParam.setClearingFunctionsInitPhase(rs.getInt("ClearingFunctionsInitPhase"));
	            	simParam.setForecastScenario(rs.getInt("ForecastScenario"));
	            	simParam.setHost(rs.getString("Host"));
	            	simParam.setOptimizationParameterSource(rs.getString("OptimizationParameterSource"));
	            	simParam.setDemandVariationHorizon(rs.getInt("DemandVariationHorizon"));
	            	simParam.setLeadTimeHorizon(rs.getInt("LeadTimeHorizon"));   
	            	simParam.setInputFileLocation(rs.getString("InputFileLocation"));
	            	simParam.setDemandScenario(rs.getInt("DemandScenario"));
	            	simParam.setWriteMRPTableToFile(rs.getBoolean("WriteMRPTableToFile"));
	            	simParam.setWriteResultsToXLSX(rs.getBoolean("WriteResultsToXLSX"));
	            	simParam.setApplyRPS(rs.getInt("ApplyRPS"));                 		            	
	            	simParam.setForecastUpdateFrozenZone(rs.getInt("ForecastUpdateFrozenZone"));                 		            	
	            	simParam.setSetupCarryOver(rs.getInt("SetupCarryOver"));                 	
	            	simParam.setApplyConWip(rs.getInt("ApplyConWip"));
	            	simParam.setWaW(rs.getDouble("WaW"));
	            	simParam.setWipCap(rs.getDouble("WipCap"));
	            	simParam.setWipCap(rs.getDouble("WipCapComponents"));
	            	simParam.setMeanInterArrivalTime(rs.getDouble("meanInterArrivalTime"));
	            	simParam.setVarCoeInterArrivalTime(rs.getDouble("varCoeInterArrivalTime"));
	            } 
  
           conn.close();
            
        } catch (SQLException e) {  
            System.out.println(e.getMessage());  
        } 
        
        if(simParam.getId() == 0) {
        	traceln("!!!!!!!!ATTENTION no ACTIVE SimulationParameter could be found!!!!!!!!! ---> Set status to 1");
        }
        
        return simParam;
    }  
    
    
    public List<Item> GetItems(SimulationParameter simParams){  
    	
        String sql = "SELECT * FROM Item where active = 1 and experiment = '"+ simParams.getExperiment()  + "'";  
        List<Item> items = new ArrayList();
        
        try {  
            java.sql.Connection conn = this.connect();  
            java.sql.Statement stmt  = conn.createStatement();  
            java.sql.ResultSet rs    = stmt.executeQuery(sql);  
              
            // loop through the result set  
        	StringBuilder output = new StringBuilder();
            while (rs.next()) {  
            	output.setLength(0);
            	Item item = new Item();
            	
            	item.setId(rs.getInt("id"));
            	item.setItem(rs.getInt("item"));
            	item.setType(rs.getString("type").toUpperCase());
            	item.setActive(rs.getInt("active"));            	
            	
            	item.setLeadTime(rs.getInt("LeadTime"));
            	item.setProductionCosts(rs.getDouble("ProductionCosts"));
            	item.setHoldingCosts(rs.getDouble("HoldingCosts"));
            	item.setHoldingCostsWIP(rs.getDouble("HoldingCostsWIP"));
            	item.setSetupCosts(rs.getDouble("SetupCosts"));
            	item.setBacklogCosts(rs.getDouble("BacklogCosts"));
            	item.setLostSalesCosts(rs.getDouble("LostSalesCosts"));
            	item.setSafetyStock(rs.getDouble("SafetyStock"));
            	item.setLotsizePolicy(rs.getString("LotSizePolicy"));

            	item.setFOPPeriod(rs.getInt("FOPPeriod"));
            	item.setFOQQuantity(rs.getInt("FOQQuantity"));
            	item.setFOQMinimumLotSize(rs.getInt("FOQMinimumLotSize"));
            	            	            	
            	item.setPlanningType(rs.getString("PlanningType").toUpperCase());
            	item.setDataItemIndex(rs.getInt("DataItemIndex"));
            	item.setTransportLotSize(rs.getInt("TransportLotSize"));
            	item.setDemandVariationIndex(rs.getInt("DemandVariationIndex"));
            	item.setRPSQty(rs.getDouble("RPSQty"));
            	item.setSafetyStockMinimum(rs.getDouble("SafetyStockMinimum"));
            	            		            	
            	items.add(item);
            	
            	if(TRACE_DB_RESULTS){
	            	output.append("Id " + item.getId() + "\t");
	            	output.append("Item " + item.getItem() + "\t");
	            	output.append("Type " + item.getType() + "\t");
	            	output.append("Active " + item.getActive() + "\t");
	            	output.append("LeadTime " + item.getLeadTime() + "\t");
	            	output.append("ProductionCosts " + item.getProductionCosts() + "\t");
	            	output.append("HoldingCosts " + item.getHoldingCosts() + "\t");
	            	output.append("SetupCosts " + item.getSetupCosts() + "\t");
	            	output.append("BacklogCosts " + item.getBacklogCosts() + "\t");
	            	output.append("SalesCosts " + item.getLostSalesCosts() + "\t");
	            	output.append("SafetyStock " + item.getSafetyStock() + "\t");
	            	output.append("TransportLotSize " + item.getTransportLotSize() + "\t");
	            	output.append("SafetyStockMinimum " + item.getSafetyStockMinimum() + "\t");
	            	
	            	System.out.println(output.toString());              	
            	}
            }  
            conn.close();
            
        } catch (SQLException e) {  
            System.out.println(e.getMessage());  
        } 
        
        return items;
    }  
    
    public List<BOM> GetBOM(List<Item> parentItems, SimulationParameter simParams, List<Item> itemList){  
    	
    	StringBuilder inString = new StringBuilder();
    	if(parentItems.size() > 0) {
    		inString.append("in(");
	    	for(Item item : parentItems) {    		
	    		inString.append(item.getItem() + ",");    		    		
	    	}
	    	
	    	inString.deleteCharAt(inString.length()-1);  
	    	inString.append(")");
    	}
    	
    	StringBuilder sql = new StringBuilder();    	    	

        sql.append("SELECT Id, Item, ifnull(Parent,0) as Parent, ifnull(Child,0) as Child,Level, Quantity, Experiment FROM BOM where experiment = '" + simParams.getExperiment()  + "'");  
        //traceln(sql);
        
        List<BOM> bOMList = new ArrayList();
          
        try {  
            java.sql.Connection conn = this.connect();  
            java.sql.Statement stmt  = conn.createStatement();  
            java.sql.ResultSet rs    = stmt.executeQuery(sql.toString());  
                                    
            //!!!!!!! if null pointer error, when filtering bom, then be sure also to add child != null !!!!!!!!!!!!  
            
            // loop through the result set  
            while (rs.next()) {  
            	BOM bomItem = new BOM();
            	
            	bomItem.setId(rs.getInt("id"));
            	
            	int rsItem = rs.getInt("item");            	            	            	
            	            	            	
            	//traceln(rsItem);
            	bomItem.setItem(itemList.stream().filter(e -> e.getItem() == rsItem).findFirst().get());            	
            	//traceln(bomItem.getItem().getItem());
            	int rsParent = rs.getInt("parent");             	
            	
            	if(rsParent > 0)
            		bomItem.setParent(itemList.stream().filter(e -> e.getItem() == rsParent).findFirst().get());            	
            	                        	
            	int rsChild = rs.getInt("child");                    	
            	//traceln("child " + rsChild);
            	
            	if(rsChild > 0) {
            		bomItem.setChild(itemList.stream().filter(e -> e.getItem() == rsChild).findFirst().get());            	            	            	
            		//traceln(bomItem.getChild().getItem());
            	}
            	
            	bomItem.setLevel(rs.getInt("level"));
            	bomItem.setQuantity(rs.getDouble("quantity"));
            	bomItem.setExperiment(rs.getString("Experiment"));
            	
            	bOMList.add(bomItem);
            	//traceln(BOM.GetCSVString(bomItem));
            	
            	if(TRACE_DB_RESULTS) {
	                System.out.println(rs.getInt("id") +  "\t" +   
	                                   rs.getInt("parent") + "\t" +
	                                   rs.getInt("item") + "\t" +
	                                   rs.getInt("level") + "\t" +
	                                   rs.getInt("child") + "\t" +
	                                   rs.getInt("quantity") + "\t" +
	                                   rs.getInt("Experiment"));  
            	}
            }  
            conn.close();
            
        } catch (SQLException e) {  
            System.out.println(e.getMessage());  
        }  
                
        return bOMList;
    }  

    public List<Resource> GetResources(SimulationParameter simParams){  
        String sql = "SELECT * FROM Resource t1 inner join ResourceGroup t2 on t1.ResourceGroup = t2.Name where status = 1 and experiment = '"+ simParams.getExperiment()  + "'";  
        
        List<Resource> resources = new ArrayList();
        
        try {  
            java.sql.Connection conn = this.connect();  
            java.sql.Statement stmt  = conn.createStatement();  
            java.sql.ResultSet rs    = stmt.executeQuery(sql);  
              
            // loop through the result set  
            while (rs.next()) {  
            	
            	Resource resource = new Resource();
            	
            	resource.setId(rs.getInt("id"));
            	resource.setName(rs.getString("name"));
            	resource.setStatus(rs.getInt("status"));
            	resource.setDescription(rs.getString("description"));
            	resource.setResourceGroup(rs.getString("resourcegroup"));
            	resource.setCapacity(resource.DEFAULT_CAPACITY);
            	resource.setStageNumber(Integer.parseInt(resource.getResourceGroup().substring(5)));
            	
            	resources.add(resource);
            	
            	if(TRACE_DB_RESULTS) {
	                System.out.println(rs.getInt("id") +  "\t" +   
	                                   rs.getInt("name") + "\t" +  
	                                   rs.getInt("status") + "\t" +  
	                                   rs.getString("resourcegroup") + "\t" +  
	                                   rs.getString("description"));  
            	}
            }  
            conn.close();
            
        } catch (SQLException e) {  
            System.out.println(e.getMessage());  
        } 
        
        return resources;
    }  
    
    public List<BOMMatrix> GetBOMMatrix(SimulationParameter simParams){  
        String sql = "SELECT * FROM BOMMatrix where status = 1 and experiment = '"+ simParams.getExperiment()  + "'";
        
        List<BOMMatrix> bomMatrix = new ArrayList();
        
        try {  
            java.sql.Connection conn = this.connect();  
            java.sql.Statement stmt  = conn.createStatement();  
            java.sql.ResultSet rs    = stmt.executeQuery(sql);  
              
            while (rs.next()) {  
            	
            	BOMMatrix item = new BOMMatrix();
            	
            	item.setId(rs.getInt("id"));
            	item.setMatrix(rs.getString("Matrix"));
            	item.setStatus(rs.getInt("status"));
            	
            	bomMatrix.add(item);
            	
            	if(TRACE_DB_RESULTS) {
	                System.out.println(rs.getInt("id") +  "\t" +   
	                                   rs.getInt("Matrix") + "\t" +  
	                                   rs.getInt("status"));  
            	}
            }  
            conn.close();
            
        } catch (SQLException e) {  
            System.out.println(e.getMessage());  
        } 
        
        return bomMatrix;
    }  
        
    public List<OrderFuture> GetOrderFuture(SimulationParameter simParams, List<Item> itemList){  
        String sql = "SELECT * FROM ORDERFUTURE where experiment = '"+ simParams.getExperiment()  + "' and status = 1;";
        
        List<OrderFuture> items = new ArrayList();
        
        try {  
            java.sql.Connection conn = this.connect();  
            java.sql.Statement stmt  = conn.createStatement();  
            java.sql.ResultSet rs    = stmt.executeQuery(sql);  
            
            //traceln(sql);
            
            // loop through the result set  
            while (rs.next()) {  
            	
            	OrderFuture item = new OrderFuture();
            	
            	item.setId(rs.getInt("id"));            	
            	int rsItem = rs.getInt("item");
            	item.setItem(itemList.stream().filter(e -> e.getItem() == rsItem).findFirst().get());            	
            	            	
            	item.setPeriod(rs.getInt("period"));
            	item.setEOrderAmount(rs.getDouble("eorderamount"));
            	
            	item.setVarOrderAmount(rs.getDouble("varorderamount"));
            	item.setECustomerRequiredLeadTime(rs.getInt("ECustomerRequiredLeadTime"));
            	item.setVarCustomerRequiredLeadTime(rs.getInt("VarCustomerRequiredLeadTime"));
            	
            	item.setVarArrivalRate(rs.getDouble("VarArrivalRate"));
            	item.setPeriodQuantity(rs.getDouble("PeriodQuantity"));
            	item.setMinimumDemandInformationHorizon(rs.getInt("MinimumDemandInformationHorizon"));
            	item.setDistArrivalRate(rs.getString("DistArrivalRate"));
            	item.setDemandScenario(rs.getInt("DemandScenario"));
            	            	            	            	            	
            	items.add(item);            	              
            }  
            conn.close();
            
        } catch (SQLException e) {  
            System.out.println(e.getMessage());  
        } 
        
        return items;
    }  
    
    
    public double[][] GetResourceConsumption(SimulationParameter simParams, List<Routing> routings){  

    	String sql = "select t1.*, t2.Type from ResourceConsumption t1 inner JOIN Item t2 on t1.Item = t2.Item where t1.experiment = '"+ simParams.getExperiment()  + "' and t2.experiment = '" + simParams.getExperiment() + "'"; 
    	
    	String sql1 = "select distinct resource from ResourceConsumption where experiment = '"+ simParams.getExperiment()  + "'";
        
        List<ResourceConsumption> items = new ArrayList();
        List<ResourceConsumption> resources = new ArrayList();
        
        double[][] finalResult = new double[1][1];
        Routing routing;
                        
        try {  
            java.sql.Connection conn = this.connect();  
            java.sql.Statement stmt  = conn.createStatement();              
            java.sql.ResultSet rs   = stmt.executeQuery(sql);  

            while (rs.next()) {  
	        	ResourceConsumption item = new ResourceConsumption();
	        	
	        	item.setId(rs.getInt("Id"));
	        	item.setResource(rs.getString("Resource"));
	        	item.setItem(rs.getInt("item"));
	        		        		        		        		        		        		        	
	        	item.setConsumption(rs.getDouble("Consumption"));
	        	item.setSetupTime(rs.getDouble("SetupTime"));
	        	
	        	//this update is done to set the associated processing time and we are not forced to change the resource consumption table!!!!!
	        	//setup time is always updated, as it is not really arguable to have processing time without setup time.
	        	if(item.getConsumption() > 0) {
	        		routing = routings.stream().filter(e -> e.getItem().getItem()==item.getItem()).findFirst().get();
	        		item.setConsumption(routing.getEProcessingTime());
	        		item.setSetupTime(routing.getESetupTime());
	        	}	        		        	
	        	
	        	item.setType(rs.getString("Type"));
	        	
	        	items.add(item);     
            }
                
            java.sql.ResultSet rs2  = stmt.executeQuery(sql1);
            while (rs2.next()) {  
	        	ResourceConsumption item = new ResourceConsumption();	        	
	        	item.setResource(rs2.getString("Resource"));	        	
	        	resources.add(item);     
            }

           conn.close();
                        
            //Resource Consumption
    		List<ResourceConsumption> itemsSorted = new ArrayList<ResourceConsumption>();
    		itemsSorted.addAll(items.stream().filter(e -> e.getType()
    				.equalsIgnoreCase(Item.ITEM_TYPE_COMPONENT)).sorted(Comparator.comparingInt(ResourceConsumption::getItem)).collect(Collectors.toList()));
    		
    		itemsSorted.addAll(items.stream().filter(e -> e.getType()
    				.equalsIgnoreCase(Item.ITEM_TYPE_SALES)).sorted(Comparator.comparingInt(ResourceConsumption::getItem)).collect(Collectors.toList()));    		    		
    		    		
    		
    		if(resources.size() <= 0 || items.size() <= 0)
    			return null;

    		//Setup time is added in second half of the array instead of an individual one
    		double[][] result = new double[resources.size()*2][items.size()/resources.size()];

    		//first add the consumpation part to the array
    		int i = 0;    		
            for (ResourceConsumption item : resources){            	            	
            	int j = 0;
            	for(ResourceConsumption singleItem : itemsSorted) {            		
            		
            		if(singleItem.getResource().equalsIgnoreCase(item.getResource())) {
            			result[i][j] = singleItem.getConsumption();            		               			
                		j++;
            		}
            	}       
            	i++;
            }
            
            //second add the setup time to the array
            //i is not reset, to add the setup time as second part of the array
            for (ResourceConsumption item : resources){            	            	
            	int j = 0;
            	for(ResourceConsumption singleItem : itemsSorted) {            		
            		
            		if(singleItem.getResource().equalsIgnoreCase(item.getResource())) {
            			result[i][j] = singleItem.getSetupTime();            		               			
                		j++;
            		}
            	}       
            	i++;
            }
                                                            
            finalResult = result;
            
        } catch (SQLException e) {  
            System.out.println(e.getMessage());  
        } 
        
        return finalResult;
    }  
    
    
    public List<ResourceCapacity> GetResourceCapacity(SimulationParameter simParams){  
        String sql = "select * from Capacity where experiment = '"+ simParams.getExperiment()  + "' order by resource,Period";  
        
        List<ResourceCapacity> items = new ArrayList();
        
        try {  
            java.sql.Connection conn = this.connect();  
            java.sql.Statement stmt  = conn.createStatement();  
            java.sql.ResultSet rs    = stmt.executeQuery(sql);  
              
            while (rs.next()) {  
            	
            	ResourceCapacity item = new ResourceCapacity();
            	
            	item.setId(rs.getInt("id"));
            	item.setResource(rs.getString("Resource"));
            	item.setCapacity(rs.getInt("Capacity"));
            	item.setPeriod(rs.getInt("Period"));
            	
            	items.add(item);
            	            }  
            conn.close();
            
        } catch (SQLException e) {  
            System.out.println(e.getMessage());  
        } 
        
        return items;
    }  

    
    public List<Forecast> GetForecast(List<Item> itemList, SimulationParameter simParams, List<ForecastInputParameter> fcInputParameters){  
    	
        String sql = "SELECT * FROM Forecast where status = 1 and experiment = '"+ simParams.getExperiment()  + "' and demandScenario=" + simParams.getDemandScenario() + ";";
        List<Forecast> items = new ArrayList();
        
 			String	forecastScenario = Integer.toString(simParams.getForecastScenario());

			ForecastInputParameter inputParam = 
			fcInputParameters.stream().
			filter(entry -> entry.getScenario().equals(forecastScenario)).max(Comparator.comparing(ForecastInputParameter::getPBD)).orElse(null);						
			        
        try {  
            java.sql.Connection conn = this.connect();  
            java.sql.Statement stmt  = conn.createStatement();  
            java.sql.ResultSet rs    = stmt.executeQuery(sql);  
              
            // loop through the result set  
            while (rs.next()) {  
            	
            	Forecast item = new Forecast();
            	
            	item.setId(rs.getInt("id"));
            	
            	int itemRs = rs.getInt("Item");
            	
            	item.setItem(itemList.stream().filter(e -> e.getItem() == itemRs).findFirst().get());            	
            	item.setStatus(rs.getInt("status"));
            	item.setExperiment(rs.getString("experiment"));            	
            	item.setLongtermForecast(rs.getDouble("longtermforecast"));
            	item.setOriginalLongTermForecast(item.getLongtermForecast()); //erwartungswert der abrufmenge!!!!!
            	
            	//only necessary to correct if a biased forecast is applied
            	            	            	
            	if(inputParam != null && inputParam.getBiasedCorrection() > 0) {
            		item.setLongtermForecast(rs.getDouble("longtermforecast") * inputParam.getBiasedCorrection());
            	}
            	
            	item.setDemandInformationHorizon(rs.getInt("demandinformationhorizon"));     
            	item.setFrequency(rs.getInt("Frequency"));
            	item.setProbOutlier(rs.getDouble("ProbOutlier"));
            	item.setOutlierFactor(rs.getDouble("OutlierFactor"));
            	item.setDemandScenario(rs.getInt("DemandScenario"));
            	item.setDemandZyklus(rs.getInt("DemandZyklus"));
            	
            	items.add(item);            	              
            }  
            conn.close();
            
        } catch (SQLException e) {  
            System.out.println(e.getMessage());  
        } 
        
        return items;
    }         
            
    public List<Routing> GetRouting(SimulationParameter simParams,List<Item> itemList){  
        String sql = "SELECT * FROM Routing where Experiment = '" + simParams.getExperiment() + "'";
        
        List<Routing> items = new ArrayList();
        
        try {  
            java.sql.Connection conn = this.connect();  
            java.sql.Statement stmt  = conn.createStatement();  
            java.sql.ResultSet rs    = stmt.executeQuery(sql);  
              
            while (rs.next()) {  
            	
            	Routing item = new Routing();
            	
            	item.setId(rs.getInt("id"));            	            	
            	int itemRs = rs.getInt("Item");            	
            	item.setItem(itemList.stream().filter(e -> e.getItem() == itemRs).findFirst().get());            	                        	            	            	
            	item.setEProcessingTime(rs.getDouble("EProcessingTime"));
            	item.setESetupTime(rs.getDouble("ESetupTime"));
            	item.setSProcessingTime(rs.getDouble("SProcessingTime"));
            	item.setSSetupTime(rs.getDouble("SSetupTime"));
            	item.setDistProcessingTime(rs.getString("DistProcessingTime"));
            	item.setDistSetupTime(rs.getString("DistSetupTime"));
            	item.setDescription(rs.getString("Description"));
            	item.setExperiment(rs.getString("experiment"));
            	item.setResource(rs.getString("Resource"));
            	item.setStep(rs.getInt("Step"));
            	
            	items.add(item);            	              
            }  
            conn.close();
            
        } catch (SQLException e) {  
            System.out.println(e.getMessage());  
        } 
        
        return items;
    }  

    
    public List<OrderPast> GetOrderPast(SimulationParameter simParams, List<Item> itemList){  
        String sql = "SELECT * FROM OrderPast where status = 1 and experiment = '"+ simParams.getExperiment()  + "'";
        
        List<OrderPast> orderPasts = new ArrayList();
        
        try {  
            java.sql.Connection conn = this.connect();  
            java.sql.Statement stmt  = conn.createStatement();  
            java.sql.ResultSet rs    = stmt.executeQuery(sql);  
              
            while (rs.next()) {  
            	
            	int itemRs = rs.getInt("Item");
            	
            	Item item = itemList.stream().filter(e -> e.getItem() == itemRs).findFirst().get(); 
            	
            	OrderPast orderPastItem = new OrderPast(
            			rs.getInt("Id"),
            			item,
            			rs.getInt("Quantity"),
            			rs.getInt("DueDate")
            			);
            	
            	
            	orderPasts.add(orderPastItem);
            	
            	if(TRACE_DB_RESULTS) {
	                System.out.println(rs.getInt("id") +  "\t" +   
	                                   rs.getInt("Item") + "\t" +  
	                                   rs.getInt("Quantity") + "\t" +  
	                                   rs.getInt("DueDAte"));  
            	}
            }  
            conn.close();
            
        } catch (SQLException e) {  
            System.out.println(e.getMessage());  
        } 
        
        return orderPasts;
    }  

    public List<InterArrivalTime> GetInterArrivalTime(SimulationParameter simParams){  
        //String sql = "select * from InterArrivalTime where experiment = '"+ simParams.getExperiment()  + "' and status = 1 and demandScenario=" + simParams.getDemandScenario() + ";";  
        
    	String sql = "select * from InterArrivalTime where experiment = '"+ simParams.getExperiment()  + "' and status = 1;";  
            	
        List<InterArrivalTime> interArrivalTimes = new ArrayList();
        
        try {  
            java.sql.Connection conn = this.connect();  
            java.sql.Statement stmt  = conn.createStatement();  
            java.sql.ResultSet rs    = stmt.executeQuery(sql);  
              
            while (rs.next()) {  
            	
            	InterArrivalTime iAt = new InterArrivalTime();
            	
            	iAt.setId(rs.getInt("id"));
            	iAt.setExperiment(rs.getString("Experiment"));
            	iAt.setItem(rs.getInt("Item"));
            	iAt.setStatus(rs.getInt("Status"));
            	iAt.setProbabilityOfItem(rs.getDouble("ProbabilityOfItem"));
            	iAt.setMeanOrderAmount(rs.getDouble("MeanOrderAmount"));
            	iAt.setVarCoeOrderAmount(rs.getDouble("VarCoeOrderAmount"));
            	iAt.setLeadTimeFixPart(rs.getDouble("LeadTimeFixPart"));
            	iAt.setMeanLeadTimeVariablePart(rs.getDouble("MeanLeadTimeVariablePart"));
            	iAt.setVarCoeLeadTimeVariablePart(rs.getDouble("varCoeLeadTimeVariablePart"));
	           	iAt.setDemandScenario(rs.getString("DemandScenario"));
            	interArrivalTimes.add(iAt);
            	}  
            conn.close();
            
            traceln(sql);
            
        } catch (SQLException e) {  
            System.out.println(e.getMessage());  
        } 
        
        return interArrivalTimes;
    }  
    
    public void WriteResultToDb(List<Result> results, SimulationParameter simParams, boolean parameterVariation, String simulationPCName, OptimizationParameter optparam){  
    	
        StringBuilder sql = new StringBuilder();
        
        try {  
            java.sql.Connection conn = this.connect();  
                        
            if (simParams.getOptimizationParameterSource().toUpperCase().equals(SimulationParameter.OPTIMIZATION_PARAMETER_SOURCE_H2) && parameterVariation) {
            	conn = this.ConnectH2();
            }
            
            if (simParams.getOptimizationParameterSource().toUpperCase().equals(SimulationParameter.OPTIMIZATION_PARAMETER_SOURCE_POSTGRES) && parameterVariation) {
        	 conn = this.ConnectPostGreSql();         
            }
            
            StringBuilder optimizationParameter_String = new StringBuilder();
            
            if (optparam.getSimHeuristic() != null && optparam.getSimHeuristic().length() > 0) {
            	
                optimizationParameter_String.setLength(0);
                optimizationParameter_String.append("\'");

                int start = 0;
                int end = SimHeuristic.MAX_V_PARAMETERS;  // Adjust this based on the highest variable number you need

                for (int i = start; i <= end; i++) {
                    String methodName = String.format("getV%03d", i);  // Construct the getter method name (e.g., getV000, getV001, etc.)
                    try {
                        // Use reflection to invoke the getter method
                        Method method = optparam.getClass().getMethod(methodName);
                        Object value = method.invoke(optparam);

                        if (value instanceof Double) {
                            optimizationParameter_String.append(((Double) value).toString());
                        } else if (value instanceof String) {
                            optimizationParameter_String.append((String) value);
                        } else if (value != null) {
                            optimizationParameter_String.append(value.toString());
                        }

                        if (i < end) {
                            optimizationParameter_String.append(";");
                        }
                    } catch (NoSuchMethodException | IllegalAccessException | InvocationTargetException e) {
                        e.printStackTrace();
                    }
                }

                optimizationParameter_String.append("\'"); 

                traceln(optimizationParameter_String.toString());
            }
            
            
          	GsonBuilder builder  = new GsonBuilder();
        	builder.excludeFieldsWithoutExposeAnnotation();
        	Gson gson = builder.create();  	
        	DateTimeFormatter formatter = DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ss");
        	java.sql.Statement stmt  = conn.createStatement();  
            for(Result item : results){
            	sql.append("Insert into \"RESULT\" (SimParamName,Experiment,SimulationExperiment,Iteration,Replication,WIPSales,WIPComponents,InventorySales,InventoryComponents,Inventory,");
            	sql.append("TardinessMean,TardinessVariance,OverallCosts,overallcosts_inkl_not_Delivered,ServiceLevel,LeadTimeSalesMean,LeadTimeSalesVariance,LeadTimeComponentsMean,LeadTimeComponentsVariance,OptimizationParameter,SimulationPC,Description, ");
            	sql.append("UsedSimulationParameter, UsedItems, UsedRoutings, SystemUtilization, Utilizations, DemandMeanPerItem,JSI,SGI,demand,");
            	sql.append("numberCustomerOrders,numberProductionOrders,latenessMean,");
            	sql.append("latenessVariance,ontimePercentage,productionStartWaitingTimeMean,productionStartWaitingTimeVariance,productionLotSizes,");
            	sql.append("InternalLatenessSalesItemsMean,InternalLatenessSalesItemsVariance,InternalLatenessComponentsMean,InternalLatenessComponentsVariance,UtilizationPS1,UtilizationPS2,UtilizationPS3,UtilizationPS4,UsedForecasts,PLStage1,PLStage2,PLStage3,PLStage4,");
            	sql.append("PlannedLeadTimeMeanPS1,PlannedLeadTimeVariancePS1,PlannedLeadTimeMeanPS2,PlannedLeadTimeVariancePS2,PlannedLeadTimeMeanPS3,PlannedLeadTimeVariancePS3,PlannedLeadTimeMeanPS4,PlannedLeadTimeVariancePS4,");
            	sql.append("TardinessOpenOrdersMean,TardinessOpenOrdersVariance,demand_delivered,demand_not_delivered,EnergyTotalCosts,countCapacityFactorBlock,countEnergyPriceBlock,ReplicationStart,ReplicationEnd,optimization_string,");
            	sql.append("ConsumedSetupTimeMean, ConsumedSetupTimeVariance, replicationStatus ");
            	sql.append(") values "); 
            	sql.append("(");
            	sql.append("'"+item.getExperiment() + "',");
            	sql.append("'" + simParams.getExperiment() + "',");
            	sql.append("'"+item.getSimulationExperiment() + "',");

            	sql.append(item.getIteration() + ",");
            	sql.append(item.getReplication() + ",");
            	
            	sql.append(item.getWIPSales() + ",");
            	sql.append(item.getWIPComponents() + ",");
            	
            	sql.append(item.getInventorySales() + ",");
            	sql.append(item.getInventoryComponents() + ",");
            	sql.append(item.getInventory() + ",");

            	sql.append(item.getTardinessMean() + ",");
            	sql.append(item.getTardinessVariance() + ",");

            	sql.append(item.getOverallCosts() + ",");
            	       	          	
            	sql.append(item.getOverallCosts_inkl_not_Delivered() + ",");

            	sql.append(item.getServiceLevel() + ",");            	            	
            	
            	sql.append(item.getLeadTimeSalesMean() + ",");
            	sql.append(item.getLeadTimeSalesVariance() + ",");
            	sql.append(item.getLeadTimeComponentsMean() + ",");
            	sql.append(item.getLeadTimeComponentsVariance() + ",");
            	
            	sql.append(item.getOptimizationParamter() + ",");
            	sql.append("'" + simulationPCName + "',");
            	sql.append("'" + item.getDescription() + "',");            	            	
            	
            	sql.append("'" + new Gson().toJson(item.getUsedSimulationParameter()) + "',");
            	
            	//sql.append("'" + new Gson().toJson(item.getUsedItems())  + "',");
            	sql.append("'" + gson.toJson(item.getUsedItems())  + "',");
            	//sql.append("'" + new Gson().toJson(item.getUsedRoutings())  + "',");
            	sql.append("'" + gson.toJson(item.getUsedRoutings())  + "',");
            	
            	sql.append(item.getSystemUtilization() + ",");
            	
            	sql.append("'" + item.getUtilizations() + "',");
            	sql.append("'" + item.getDemandPerItem() + "',");
            	
            	sql.append("'" + item.getWIPJSI() + "',");
            	sql.append("'" + item.getWIPSGI() + "',");
            	
            	sql.append(item.getDemand() + ",");
            	
            	sql.append(item.getNumberCustomerOrders() + ",");
            	sql.append(item.getNumberProductionOrders() + ",");

            	
            	sql.append(item.getLatenessMean() + ",");
            	sql.append(item.getLatenessVariance() + ",");

            	sql.append(item.getOnTimePercentage() + ",");           	            	
            	
            	sql.append(item.getProductionStartWaitingTimeMean() + ",");
            	sql.append(item.getProductionStartWaitingTimeVariance() + ",");
            	
            	sql.append("'" + new Gson().toJson(item.getProductionLotSizes()) + "',");
            	
            	sql.append(item.getInternalLatenessSalesItemsMean() + ",");
            	sql.append(item.getInternalLatenessSalesItemsVariance() + ",");
            	            	
            	sql.append(item.getInternalLatenessComponentsMean() + ",");
            	sql.append(item.getInternalLatenessComponentsVariance() + ",");
            	sql.append(item.getUtilizationPS1() + ",");
            	sql.append(item.getUtilizationPS2() + ",");
            	sql.append(item.getUtilizationPS3() + ",");
            	sql.append(item.getUtilizationPS4()+ ",");
            	sql.append("'" + gson.toJson(item.getUsedForecasts())  + "',");
            	
            	sql.append(item.getPLStage1()+ ",");
            	sql.append(item.getPLStage2()+ ",");
            	sql.append(item.getPLStage3()+ ",");
            	sql.append(item.getPLStage4()+ ",");

            	sql.append(item.getPlannedLeadTimePS1Mean() + ",");
               	sql.append(item.getPlannedLeadTimePS1Variance() + ",");
               	
            	sql.append(item.getPlannedLeadTimePS2Mean() + ",");
               	sql.append(item.getPlannedLeadTimePS2Variance() + ",");

            	sql.append(item.getPlannedLeadTimePS3Mean() + ",");
               	sql.append(item.getPlannedLeadTimePS3Variance() + ",");

            	sql.append(item.getPlannedLeadTimePS4Mean() + ",");
               	sql.append(item.getPlannedLeadTimePS4Variance() + ",");
               	
               	sql.append(item.getTardinessOpenOrdersMean() + ",");
               	sql.append(item.getTardinessOpenOrdersVariance() + ",");
               	
               	sql.append(item.getDemandDelivered() + ",");
               	sql.append(item.getDemandNotDelivered() + ",");
               	sql.append(item.getSumEnergyCosts() + ",");
               	
               	sql.append(item.getCountCapacityFactorBlock() + ",");
               	sql.append(item.getCountEnergyPriceBlock()+ ",");
               	
               	String replicationStartformattedDateTime = item.getReplicationStart().format(formatter);
                sql.append("'" +item.getReplicationStart() + "',");
               	
                String replicationEndformattedDateTime = item.getReplicationStart().format(formatter);
               	sql.append("'" + item.getReplicationEnd() + "',");
               	
               	if(optimizationParameter_String.length() > 0) {
               		sql.append(optimizationParameter_String + ",");
               	}else {
               		sql.append("'',");
               	}
                
               	sql.append(item.getConsumedSetupTimeMean() + ",");
               	sql.append(item.getConsumedSetupTimeVariance() + ",");
               	
               	sql.append(item.getReplicationStatus());
               	
            	sql.append(");");
            	
            	traceln(sql.toString());
            	
            	stmt.executeUpdate(sql.toString());  
            	sql.setLength(0);
            }
                            	              
            conn.close();

        } catch (SQLException e) {  
            System.out.println(e.getMessage());  
	    } catch (IOException e) {  
	        System.out.println(e.getMessage());  
	    } 
        
     }  
    
            
    public OptimizationParameter GetOptimizationParameterbyStatus(SimulationParameter simParams, int status, boolean nextAvailable,
    		boolean parameterVariation, String pcName) {
    	    	
        //check for remote optimizationParaemters, if in the remote optimzation parameter table unprocessed entries exists take it.
        //Only take one of the entries
    	OptimizationParameter optParam = new OptimizationParameter();
  		StringBuilder sql = new StringBuilder();
  		traceln("Simulation PC Name: " + simParams.getSimulationPCName());
  		
  		traceln("Search next available Optimization Parameter: " + nextAvailable);
  		
  		if(nextAvailable) {
  			sql.append("select * from OptimizationParameter where status = " + OptimizationParameter.UNPROCESSED_OPTIMIZATION_PARAMETER + " ");
  		}else {
  			sql.append("select * from OptimizationParameter where status = " + status + " and SimulationPC = '" + simParams.getSimulationPCName() + "' ");  			
  		}
  		
  		sql.append("limit 1");
  		
    	traceln("Parametervariation: " + parameterVariation);
    	
        if (simParams.getOptimizationParameterSource().toUpperCase().equals(SimulationParameter.OPTIMIZATION_PARAMETER_SOURCE_H2) && parameterVariation) {
        	optParam = OptimizationParameter.GetRemoteOptimizationParameterH2(nextAvailable, status, simParams.getSimulationPCName(), simParams);
        }else if (simParams.getOptimizationParameterSource().toUpperCase().equals(SimulationParameter.OPTIMIZATION_PARAMETER_SOURCE_POSTGRES) && parameterVariation) {
        	optParam = OptimizationParameter.GetRemoteOptimizationParameterPostGres(nextAvailable, status, simParams.getSimulationPCName(), simParams);
        }else {
	  		  		
	  		try {	
	  			  			  	          			  			
	  			java.sql.Connection conn = this.connect();  
	            java.sql.Statement stmt  = conn.createStatement(ResultSet.TYPE_FORWARD_ONLY, ResultSet.CONCUR_READ_ONLY);  
	            java.sql.ResultSet rs    = stmt.executeQuery(sql.toString());  
	            traceln(sql.toString());
	       
	            if(rs.next()) { 	            	
	                optParam = OptimizationParameter.GetOptimizatioParameterFromRecordSet(rs);                            		
	            }
	            
	            conn.close();
	  		}catch(Exception e){
	            System.out.println(e.getMessage()); 
	  		}
        }
        
  		traceln("Selected Optimization Parameter id " + optParam.getId());
  		return optParam;		   		    	    	    	    	    	    	    	
    }
       
 public void SetOptimizationParameterStatusActive(OptimizationParameter optParam, SimulationParameter simParams, boolean parameterVariation) {    	
    	
        StringBuilder sql = new StringBuilder();
        sql.append("Update OptimizationParameter set status = " + OptimizationParameter.ACTIVE_OPTIMIZATION_PARAMETER + ", UpdatedAt = strftime('%Y-%m-%d %H:%M:%f','now'), simulationpc = '" + simParams.getSimulationPCName() + "' WHERE ID = " + optParam.getId());      
        
        try {  
            java.sql.Connection conn = this.connect();
            
            if (simParams.getOptimizationParameterSource().toUpperCase().equals(SimulationParameter.OPTIMIZATION_PARAMETER_SOURCE_H2) && parameterVariation) {
            	sql.setLength(0);
                sql.append("Update OptimizationParameter set status = " + OptimizationParameter.ACTIVE_OPTIMIZATION_PARAMETER + ", UpdatedAt = now(), simulationpc = '" + simParams.getSimulationPCName() + "' WHERE ID = " + optParam.getId());     
            	conn = this.ConnectH2();
            }
            
            if (simParams.getOptimizationParameterSource().toUpperCase().equals(SimulationParameter.OPTIMIZATION_PARAMETER_SOURCE_POSTGRES) && parameterVariation) {
            	sql.setLength(0);
                sql.append("Update OptimizationParameter set status = " + OptimizationParameter.ACTIVE_OPTIMIZATION_PARAMETER + ", UpdatedAt = now(), simulationpc = '" + simParams.getSimulationPCName() + "' WHERE ID = " + optParam.getId());     
            	conn = this.ConnectPostGreSql();
            }

        	java.sql.Statement stmt  = conn.createStatement();  
         	traceln(sql.toString());	
            stmt.executeUpdate(sql.toString());    	              
            conn.close();

        } catch (SQLException e) {  
            System.out.println(e.getMessage());  
        
		 } catch (IOException e) {  
		     System.out.println(e.getMessage());  
		 } 
    	    	    	
    }
    
    public void SetOptimizationParameterStatusProcessed(SimulationParameter simParams, OptimizationParameter optParam, boolean parameterVariaton, String pcName) {
    	
    	
        StringBuilder sql = new StringBuilder();        
        sql.append("Update OptimizationParameter set status = " + OptimizationParameter.PROCESSED_OPTIMIZATION_PARAMETER + " WHERE SimulationPC = '" + simParams.getSimulationPCName() + "' and status = " + OptimizationParameter.ACTIVE_OPTIMIZATION_PARAMETER + " and id = " + optParam.getId());     
                
        try {  
        	
            java.sql.Connection conn = this.connect();  
            
            if (simParams.getOptimizationParameterSource().toUpperCase().equals(SimulationParameter.OPTIMIZATION_PARAMETER_SOURCE_H2) && parameterVariaton) {
            	conn = this.ConnectH2();
            }
            
            if (simParams.getOptimizationParameterSource().toUpperCase().equals(SimulationParameter.OPTIMIZATION_PARAMETER_SOURCE_POSTGRES) && parameterVariaton) {
            	conn = this.ConnectPostGreSql();
            }
            
        	java.sql.Statement stmt  = conn.createStatement();  
         	traceln(sql.toString());	
            stmt.executeUpdate(sql.toString());  
                            	              
            conn.close();

        } catch (SQLException e) {  
            System.out.println(e.getMessage());  
        } catch (IOException e) {  
            System.out.println(e.getMessage());  
        } 
    	    	    	
    }
    
    
    public List<Resource> ResourcesPerBOMLevel(SimulationParameter simParams, int bomLevel) {
    
    	StringBuilder sql = new StringBuilder();
    	sql.append("select distinct resource from bom t1 inner join routing t2  on t1.Item = t2.item where t1.Experiment = '" + simParams.getExperiment() +"' and level = " + bomLevel + " and t2.Experiment = '" + simParams.getExperiment() + "';"); 
    			
    	List<Resource> resources = new ArrayList();
        
        try { 
        	
        	java.sql.Connection conn = this.connect();  
        	java.sql.Statement stmt  = conn.createStatement();  
            java.sql.ResultSet rs    = stmt.executeQuery(sql.toString());  
	
	    	 while (rs.next()) {  	         	         		            		            		            	
	    		Resource r = new Resource();	    		
	    		r.setName(rs.getString("RESOURCE"));	    		 
	            resources.add(r);		 
	         }  
	         conn.close();
         
        } catch (SQLException e) {  
        	System.out.println(e.getMessage());  
        } 
    	
    	return resources;
    }
    
    
    public OptimizationParameter GetOptimizationParameterbyId(SimulationParameter simParams, int id) {
    	    	
        //check for remote optimizationParaemters, if in the remote optimzation parameter table unprocessed entries exists take it.
        //Only take one of the entries
    	OptimizationParameter optParam = new OptimizationParameter();
  		StringBuilder sql = new StringBuilder();

  		sql.append("select * from OptimizationParameter where id = " + id + " ");
  		sql.append("limit 1");
	  		  		
	  		try {	
	  			  			  	          			  			
	  			java.sql.Connection conn = this.connect();  
              
	            if (simParams.getOptimizationParameterSource().toUpperCase().equals(SimulationParameter.OPTIMIZATION_PARAMETER_SOURCE_POSTGRES)) {
	            	conn = this.ConnectPostGreSql();   
      	        }	
	            
	            traceln(sql.toString());
	       
	            java.sql.Statement stmt  = conn.createStatement();  
	            java.sql.ResultSet rs    = stmt.executeQuery(sql.toString());
	            
	            if(rs.next()) { 	            	
	                optParam = OptimizationParameter.GetOptimizatioParameterFromRecordSet(rs);                            		
	            }
	            
	            conn.close();
	  		}catch(Exception e){
	            System.out.println(e.getMessage()); 
	  		}
        
  		traceln("Selected Optimization Parameter id " + optParam.getId());
  		return optParam;		   		    	    	    	    	    	    	    	
    }
    
	public void WriteCFToDb(double time, SimulationParameter simParams,
	   String machine, double sL, double pL, String stage, int rplCnt, String orders, String sLValues, int optimizationParameter) {

	   StringBuilder sql = new StringBuilder();
	   
	   boolean writeDetails = true;
	   
	   if(!writeDetails) {
		   orders = "";
		   sLValues = "";		   		   
	   }

	   try {
	     java.sql.Connection conn = this.connect();

	     if (simParams.getOptimizationParameterSource().toUpperCase().equals(SimulationParameter.OPTIMIZATION_PARAMETER_SOURCE_H2)) {
         	conn = this.ConnectH2();
         }
	     if (simParams.getOptimizationParameterSource().toUpperCase().equals(SimulationParameter.OPTIMIZATION_PARAMETER_SOURCE_POSTGRES)) {
        	 conn = this.ConnectPostGreSql();         
         }
	     
	     
	     java.sql.Statement stmt = conn.createStatement();
	     sql.append("Insert into CF (\"Time\",Stage,Machine,SL,PL,Experiment,RplCnt,Orders,SLValues,OptimizationParameter) values ");
	     sql.append("(");
	     sql.append(time + ",");
	     sql.append("'" + stage + "',");
	     sql.append("'" + machine + "',");
	     sql.append(sL + ",");
	     sql.append(pL + ",");
	     sql.append("'" + simParams.getExperiment() + "',");
	     sql.append(rplCnt + ",");
	     sql.append("'" + orders + "',");
	     sql.append("'" + sLValues + "',");
	     sql.append(optimizationParameter);
	     sql.append(");");

	     //traceln(sql.toString());

	     stmt.executeUpdate(sql.toString());
	     sql.setLength(0);

	     conn.close();

	   } catch (SQLException e) {
	     System.out.println(e.getMessage());
	   }
		 catch (IOException e) {
	     System.out.println(e.getMessage());
	   }
	}
    

    public void AdaptOptimizationParameter(SimulationParameter simParams, String query) {
                
        try {              
			DBQueries db = new DBQueries();
		    StringBuilder sqlQueryString = new StringBuilder();

			java.sql.Connection connection = db.connect();  
			
	         sqlQueryString.setLength(0);
	         sqlQueryString.append(query);

	         if (simParams.getOptimizationParameterSource().toUpperCase().equals(SimulationParameter.OPTIMIZATION_PARAMETER_SOURCE_POSTGRES)) {	
	       	  	connection = db.ConnectPostGreSql();   
	         } 
            
	         java.sql.Statement statement = connection.createStatement();
	         
         	traceln(sqlQueryString.toString());	
         	statement.executeUpdate(sqlQueryString.toString());    	              
            connection.close();

        } catch (SQLException e) {  
            System.out.println(e.getMessage());  
        
		 } catch (IOException e) {  
		     System.out.println(e.getMessage());  
		 } 
    }
    
            
	/**
	 * This number is here for model snapshot storing purpose<br>
	 * It needs to be changed when this class gets changed
	 */ 
	private static final long serialVersionUID = 1L;

}]]></Text>
		</JavaClass>
		<!--   =========   Java Class   ========  -->
		<JavaClass>
			<Id>1636638087753</Id>
			<Name><![CDATA[SimulationParameter]]></Name>
			<Text><![CDATA[import java.io.Serializable;
import com.google.gson.annotations.Expose;

/**
 * SimulationParameter
 */	

import java.net.*;

public class SimulationParameter implements Serializable {

	private int Id;
	    
	private String Description;
	
	@Expose
	private int SimOptHorizon;
	
	@Expose
	private String Name;
    
	@Expose
	private int CountEndItems;
	@Expose
	private int CountComponents;
	@Expose
	private int CountResources;
    
	private int ApplyOptimization;
    
	private String DemandGeneration;
    
	private int MRPPlanningHorizon;
    
	private int ForecastUpdateHorizon;
	
	private int ForecastUpdateFrequency;
	
	@Expose
    private String OptimizationType;
    
    private String Experiment;
    
    private int ApplyMRP;
    
    private int PlanningFrequency;
    
    private int ApplyForecastUpdates;
    
    private int FrozenZone;
     
    private int WarumUpTime;
    
    private int SimulationRunTime;
    
    private boolean ApplyClearingFunctions;
    
    private int Status;
    
    private int ForecastScenario;    
    
    private int ClearingFunctionsInitPhase;
    
    private String Host;
    
    private String OptimizationParameterSource;
    
    private int DemandVariationHorizon;
    
    private int LeadTimeHorizon;
    
    private int DemandScenario;        
    
    private String InputFileLocation;
    
    private boolean WriteMRPTableToFile;
    
    private boolean WriteResultsToXLSX;
    
    private String SimulationPCName;
    
	private int ProdStageStatistics;
	
	private int ApplyRPS;
	
	private int UseIdealCFLine;
	
	private int machineFailure;
	
	@Expose
	private int SetupCarryOver;
	
    private int CFSegments;
    
    private int ExternalCapacity;
    
    private int randomOptimizationParameter;
    
    private int applyConWip;
    
    private double WaW;
    private double WipCap;
    private double WipCapComponents;
    @Expose
    private int AvoidScenarioUpdates;
    private String locationEnergyPricesInputExcel;        
    private double energyPriceFactor;
    private double capacityFactor;
    private int energyPriceBasedRelease; 
    private int fixedPeriods;
    private double meanInterArrivalTime;
    private double varCoeInterArrivalTime;
    private int ALCFormulation;
    private int ROFormulation;
    private int SafetyStockAtBeginning;
    private int OverallCostsLimit;
    private int OverallCostsCheckRecurrenceTime;
    private int OverallCostsFirstOccurenceTime;
           
    public static final String DEMAND_GENERATION_FORECAST = "Forecast";
    public static final String DEMAND_GENERATION_ORDERPAST = "OrderPast";
    public static final String RELEASE_ORIGIN_CONWIP = "ConWip";
    public static final String RELEASE_ORIGIN_CONWIP_FROM_MACHINE = "ConWipFromMachine";
    public static final String RELEASE_ORIGIN_CF = "CF";

    public static final String DEMAND_GENERATION_CUSTOMER_REQUIRED_LEADTIME = "CRL";
    public static final String DEMAND_GENERATION_INTERARRIVAL_TIME = "InterArrivalTime";
    
    public static final boolean WRITE_RESULTS_TO_CONSOLE = false;
    //public static final boolean WRITE_RESULTS_TO_XLSX = true;
    
    public static final String OPTIMIZATION_PARAMETER_SOURCE_H2 = "H2";
    public static final String OPTIMIZATION_PARAMETER_SOURCE_POSTGRES = "POSTGRES";

    public static final String PROPERTIES_FILENAME = "config.properties";
    
    public static final String OPTIMIZATION_TYPE_DETERMINISTIC = "Deterministic";
    public static final String OPTIMIZATION_TYPE_STOCHASTIC = "Stochastic";
    public static final String OPTIMIZATION_TYPE_STOCHASTIC_FLEXIBLE = "StochasticFlexible";
    
    public static final String ALGORITHMIC_OPTIMIZATION_TYPE_SAFETY_STOCK_RELAXATION = "SafetyStockRelaxation";
    
    public static final int SIMULATIONPARAMETER_ACTIVE = 1;
    public static final int SIMULATIONPARAMETER_IN_ACTIVE = 0;
    
    public static final int AVOID_SCENARIO_UPDATES = 0;
    
    public static final int APPLY_RPS = 1;
    public static final int APPLY_CONWIP = 1;
    public static final int APPLY_CONWIP_MPS = 2;
        
    public static final int MRP_PRODUCTION_ORDER_BOOKING_BEHAVIOR_PIECEWISE = 0;    
    
    public SimulationParameter() {
    }

    // Getter and Setter for OverallCostsLimit
    public int getOverallCostsLimit() {
        return OverallCostsLimit;
    }

    public void setOverallCostsLimit(int overallCostsLimit) {
        this.OverallCostsLimit = overallCostsLimit;
    }

    // Getter and Setter for OverallCostsCheckRecurrenceTime
    public int getOverallCostsCheckRecurrenceTime() {
        return OverallCostsCheckRecurrenceTime;
    }

    public void setOverallCostsCheckRecurrenceTime(int overallCostsCheckRecurrenceTime) {
        this.OverallCostsCheckRecurrenceTime = overallCostsCheckRecurrenceTime;
    }

    // Getter and Setter for OverallCostsFirstOccurenceTime
    public int getOverallCostsFirstOccurenceTime() {
        return OverallCostsFirstOccurenceTime;
    }

    public void setOverallCostsFirstOccurenceTime(int overallCostsFirstOccurenceTime) {
        this.OverallCostsFirstOccurenceTime = overallCostsFirstOccurenceTime;
    }


    public int getSafetyStockAtBeginning() {
        return SafetyStockAtBeginning;
    }

    public void setSafetyStockAtBeginning(int safetyStockAtBeginning) {
        this.SafetyStockAtBeginning = safetyStockAtBeginning;
    }

    // Getter for MeanInterArrivalTime
    public double getMeanInterArrivalTime() {
        return meanInterArrivalTime;
    }

    // Setter for MeanInterArrivalTime
    public void setMeanInterArrivalTime(double meanInterArrivalTime) {
        this.meanInterArrivalTime = meanInterArrivalTime;
    }

    // Getter for VarCoeInterArrivalTime
    public double getVarCoeInterArrivalTime() {
        return varCoeInterArrivalTime;
    }

    // Setter for VarCoeInterArrivalTime
    public void setVarCoeInterArrivalTime(double varCoeInterArrivalTime) {
        this.varCoeInterArrivalTime = varCoeInterArrivalTime;
    }
    
    // Getter for ALCFormulation
    public int getALCFormulation() {
        return ALCFormulation;
    }

    // Setter for ALCFormulation
    public void setALCFormulation(int ALCFormulation) {
        this.ALCFormulation = ALCFormulation;
    }

    // Getter for RFormulation
    public int getROFormulation() {
        return ROFormulation;
    }

    // Setter for ORFormulation
    public void setROFormulation(int ROFormulation) {
        this.ROFormulation = ROFormulation;
    }
    
    // Getter method
    public int getFixedPeriods() {
        return fixedPeriods;
    }

    // Setter method
    public void setFixedPeriods(int fixedPeriods) {
        this.fixedPeriods = fixedPeriods;
    }
    
    
    // Getter-Methode fr den Energiepreis
    public int getEnergyBasedRelease() {
        return energyPriceBasedRelease;
    }

    // Setter-Methode fr den Energiepreis
    public void setEnergyBasedRelease(int value) {
        this.energyPriceBasedRelease = value;
    }
       
    // Getter method for capacityFactor
    public double getCapacityFactor() {
        return capacityFactor;
    }

    // Setter method for capacityFactor
    public void setCapacityFactor(double capacityFactor) {
        this.capacityFactor = capacityFactor;
    }


    // Getter for priceThreshold
    public double getEnergyPriceFactor() {
        return energyPriceFactor;
    }

    // Setter for priceThreshold
    public void setEnergyPriceFactor(double energyPriceFactor) {
        this.energyPriceFactor = energyPriceFactor;
    }
    
    // Getter for locationEnergyPricesInputExcel
    public String getLocationEnergyPricesInputExcel() {
        return locationEnergyPricesInputExcel;
    }

    // Setter for locationEnergyPricesInputExcel
    public void setLocationEnergyPricesInputExcel(String locationEnergyPricesInputExcel) {
        this.locationEnergyPricesInputExcel = locationEnergyPricesInputExcel;
    }
       

    public double getWaW() {
        return WaW;
    }

    public void setWaW(double WaW) {
        this.WaW = WaW;
    }

    public double getWipCap() {
        return WipCap;
    }

    public void setWipCap(double WipCap) {
        this.WipCap = WipCap;
    }
    
    
    public double getWipCapComponents() {
        return WipCapComponents;
    }

    public void setWipCapComponents(double WipCapComponents) {
        this.WipCapComponents = WipCapComponents;
    }
    
    // Getter
    public int getApplyConWip() {
        return applyConWip;
    }

    // Setter
    public void setApplyConWip(int applyConWip) {
        this.applyConWip = applyConWip;
    }
    
    // Getter for randomOptimizationParameter
    public int getRandomOptimizationParameter() {
        return randomOptimizationParameter;
    }

    // Setter for randomOptimizationParameter
    public void setRandomOptimizationParameter(int randomOptimizationParameter) {
        this.randomOptimizationParameter = randomOptimizationParameter;
    }
    
    // Getter for CFSegments
    public int getCFSegments() {
        return CFSegments;
    }

    // Setter for CFSegments
    public void setCFSegments(int CFSegments) {
        this.CFSegments = CFSegments;
    }
    
    // Getter for ExternalCapacity
    public int getExternalCapacity() {
        return ExternalCapacity;
    }

    // Setter for ExternalCapacity
    public void setExternalCapacity(int ExternalCapacity) {
        this.ExternalCapacity = ExternalCapacity;
    }
    
    public int getMachineFailure() {
        return machineFailure;
    }

    public void setMachineFailure(int machineFailure) {
        this.machineFailure = machineFailure;
    }
    
    public int getUseIdealCFLine()
    {
    	return UseIdealCFLine;
    }
    
    public void setUseIdealCFLine(int value) {
    	this.UseIdealCFLine = value;
    }
    
	public int getAvoidScenarioUpdates() {
		return AvoidScenarioUpdates;
	}

	public void setAvoidScenarioUpdates(int avoidScenarioUpdates) {
		this.AvoidScenarioUpdates = avoidScenarioUpdates;
	}
    
	public int getSetupCarryOver() {
		return SetupCarryOver;
	}

	public void setSetupCarryOver(int setupCarryOver) {
		SetupCarryOver = setupCarryOver;
	}
        
    public int getForecastUpdateFrozenZone() {
		return forecastUpdateFrozenZone;
	}

	public void setForecastUpdateFrozenZone(int forecastUpdateFrozenZone) {
		this.forecastUpdateFrozenZone = forecastUpdateFrozenZone;
	}

	private int forecastUpdateFrozenZone;
    
	public int getApplyRPS() {
		return ApplyRPS;
	}

	public void setApplyRPS(int applyRPS) {
		ApplyRPS = applyRPS;
	}
        
	public int getProdStageStatistics() {
		return ProdStageStatistics;
	}

	public void setProdStageStatistics(int prodStageStatistics) {
		ProdStageStatistics = prodStageStatistics;
	}
    
    public boolean getWriteResultsToXLSX() {
       return this.WriteResultsToXLSX;
    }
  
    public void setWriteResultsToXLSX(boolean value) {
       this.WriteResultsToXLSX = value;
    }
    
    public boolean getWriteMRPTableToFile() {
       return this.WriteMRPTableToFile;
    }
  
    public void setWriteMRPTableToFile(boolean value) {
       this.WriteMRPTableToFile = value;
    }
    
    public String getInputFileLocation() {
    	return this.InputFileLocation;
    }
    
    public void setInputFileLocation(String value) {
    	this.InputFileLocation = value;
    }
    
    public int getDemandScenario() {
        return this.DemandScenario;
     }
   
     public void setDemandScenario(int value) {
        this.DemandScenario = value;
     }

    
    public int getLeadTimeHorizon() {
       return this.LeadTimeHorizon;
    }
  
    public void setLeadTimeHorizon(int value) {
       this.LeadTimeHorizon = value;
    }
    
    public String getOptimizationParameterSource() {
       return this.OptimizationParameterSource;
    }
  
    public void setOptimizationParameterSource(String value) {
       this.OptimizationParameterSource = value;
    }
    
    public String getHost() {
        return this.Host;
     }
   
     public void setHost(String value) {
        this.Host = value;
     }

    
    public int getClearingFunctionsInitPhase() {
        return this.ClearingFunctionsInitPhase;
     }
   
     public void setClearingFunctionsInitPhase(int value) {
        this.ClearingFunctionsInitPhase = value;
     }
    
    public int getForecastScenario() {
       return this.ForecastScenario;
    }
  
    public void setForecastScenario(int value) {
       this.ForecastScenario = value;
    }
    
    public int getStatus() {
       return this.Status;
    }
  
    public void setStatus(int value) {
       this.Status = value;
    }
    
    public boolean getApplyClearingFunctions() {
       return this.ApplyClearingFunctions;
    }
  
    public void setApplyClearingFunctions(boolean value) {
       this.ApplyClearingFunctions = value;
    }
    
    public int getWarumUpTime() {
       return this.WarumUpTime;
    }
  
    public void setWarumUpTime(int value) {
       this.WarumUpTime = value;
    }
  
    public int getSimulationRunTime() {
       return this.SimulationRunTime;
    }
  
    public void setSimulationRunTime(int value) {
       this.SimulationRunTime = value;
    }
    
    
    public int getFrozenZone() {
       return this.FrozenZone;
    }
  
    public void setFrozenZone(int value) {
       this.FrozenZone = value;
    }
    
    public int getApplyForecastUpdates() {
       return this.ApplyForecastUpdates;
    }
  
    public void setApplyForecastUpdates(int value) {
       this.ApplyForecastUpdates = value;
    }
    
    public int getCountResources() {
        return this.CountResources;
     }
   
     public void setCountResources(int value) {
        this.CountResources = value;
     }
    
    public int getCountComponents() {
        return this.CountComponents;
     }
   
     public void setComponents(int value) {
        this.CountComponents = value;
     }

    
    public int getCountEndItems() {
        return this.CountEndItems;
     }
   
     public void setCountEndItems(int value) {
        this.CountEndItems = value;
     }
    
    public int getId() {
       return this.Id;
    }
  
    public void setId(int value) {
       this.Id = value;
    }
  
    public String getDescription() {
       return this.Description;
    }
  
    public void setDescription(String value) {
       this.Description = value;
    }
  
    public int getSimOptHorizon() {
       return this.SimOptHorizon;
    }
  
    public void setSimOptHorizon(int value) {
       this.SimOptHorizon = value;
    }
  
    public String getName() {
       return this.Name;
    }
  
    public void setName(String value) {
       this.Name = value;
    }
    
    public int getApplyOptimization() {
        return this.ApplyOptimization;
     }
   
     public void setApplyOptimization(int value) {
        this.ApplyOptimization = value;
     }
     
     public String getDemandGeneration() {
         return this.DemandGeneration;
      }
    
      public void setDemandGeneration(String value) {
         this.DemandGeneration = value;
      }
    
      public int getMRPPlanningHorizon() {
          return this.MRPPlanningHorizon;
       }
     
       public void setMRPPlanningHorizon(int value) {
          this.MRPPlanningHorizon = value;
       }    

       
       public String getOptimizationType() {
           return this.OptimizationType;
        }
      
        public void setOptimizationType(String value) {
           this.OptimizationType = value;
        }
        
	    public int getForecastUpdateHorizon() {
	        return this.ForecastUpdateHorizon;
	     }
	   
	     public void setForecastUpdateHorizon(int value) {
	        this.ForecastUpdateHorizon = value;
	     }
	     
	    public int getForecastUpdateFrequency() {
	        return this.ForecastUpdateFrequency;
	     }
	   
	     public void setForecastUpdateFrequency(int value) {
	        this.ForecastUpdateFrequency = value;
	     }
	     	     	     
	     public String getExperiment() {
	         return this.Experiment;
	      }
	    
	      public void setExperiment(String value) {
	         this.Experiment = value;
	      }
	   
	      
	      public int getApplyMRP() {
	         return this.ApplyMRP;
	      }
	    
	      public void setApplyMRP(int value) {
	         this.ApplyMRP = value;
	      }
	      
	      
	      public int getPlanningFrequency() {
	          return this.PlanningFrequency;
	       }


	      public void setPlanningFrequency(int value) {
	          this.PlanningFrequency = value;
	       }
	      	      
	      public void setSimulationPCName(String suffix, String simPcName) {
	  		
	  		String computerName = "";
	  		
		      try {	        		
		    	  if(simPcName == null) {
		  		 computerName=InetAddress.getLocalHost().getHostName() + suffix;
		    	  }else {
		    		  computerName = simPcName;
		    	  }
		  	  }catch (Exception e){
		  		  System.out.println("Exception caught ="+e.getMessage());
		  	  }
		      
	  		 this.SimulationPCName = computerName;
	  	}
	      

      public String getSimulationPCName() {
          return this.SimulationPCName;
       }
	      	      
	      public int getDemandVariationHorizon() {
	          return this.DemandVariationHorizon;
	       }
	     
	       public void setDemandVariationHorizon(int value) {
	          this.DemandVariationHorizon = value;
	       }
	      
	      
      public static void UpdateExperiment(OptimizationParameter optParam, SimulationParameter simParams) {	      	
      	
          StringBuilder sql = new StringBuilder();
          
          
          if(optParam.getSimulationParameter() == null) {
        	  traceln("!!!!!!!!!!!!!!!!!!!!ATTENTION THE COLUMN OPTIMIZATION PARAMETER is not filled correctly in the table OptimizationParameter!!!!!!!!!!!!!!!!!!!");
          }
        	  
          
          sql.append("Update SimulationParameters set status = '" + SimulationParameter.SIMULATIONPARAMETER_ACTIVE + "' WHERE NAME = '" + optParam.getSimulationParameter()+ "';");
          sql.append("Update SimulationParameters set status = '" + SimulationParameter.SIMULATIONPARAMETER_IN_ACTIVE + "' WHERE NAME <> '" + optParam.getSimulationParameter()+ "';");      

          
          try {  
        	  DBQueries db = new DBQueries();
        	  
              java.sql.Connection conn = db.connect();
              
          	java.sql.Statement stmt  = conn.createStatement();  
          	
           		traceln(sql.toString());	
           	
              stmt.executeUpdate(sql.toString());    	              
              conn.close();

          } catch (SQLException e) {  
              System.out.println(e.getMessage());  
          }       	    	    	
      }	      
	      
      public static void UpdateMRPPlanningHorizon(OptimizationParameter optParam, int mrpPlanningHorizon) {	      	
        	
          StringBuilder sql = new StringBuilder();
                    
          sql.append("Update SimulationParameters set MRPPLANNINGHORIZON = " + mrpPlanningHorizon + " WHERE NAME = '" + optParam.getSimulationParameter()+ "';");
          
          try {  
        	  DBQueries db = new DBQueries();
        	  
              java.sql.Connection conn = db.connect();
              
          	java.sql.Statement stmt  = conn.createStatement();  
          	
           		traceln(sql.toString());	
           	
              stmt.executeUpdate(sql.toString());    	              
              conn.close();

          } catch (SQLException e) {  
              System.out.println(e.getMessage());  
          }       	    	    	
      }	
            
      
	@Override
	public String toString() {
		return super.toString();
	}
	
	/**
	 * This number is here for model snapshot storing purpose<br>
	 * It needs to be changed when this class gets changed
	 */ 
	private static final long serialVersionUID = 1L;

}]]></Text>
		</JavaClass>
		<!--   =========   Java Class   ========  -->
		<JavaClass>
			<Id>1637004187799</Id>
			<Name><![CDATA[BOM]]></Name>
			<Text><![CDATA[import java.util.stream.Collectors;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
/**
 * BOM
 */	
public class BOM implements Serializable {

    /**
     * Default constructor
     */
    public BOM() {
    }

  
    private int Id;
    
    private int Level;
    
    private Item Parent;
  
    private Item Child;
  
    double Quantity;
    
    private Item item;
    
    private String Experiment;
    
    public String getExperiment() {
       return this.Experiment;
    }
  
    public void setExperiment(String value) {
       this.Experiment = value;
    }
    
    public Item getItem() {
        return this.item;
     }
   
     public void setItem(Item value) {
        this.item= value;
     }
  
    public int getId() {
       return this.Id;
    }
  
    public void setId(int value) {
       this.Id = value;
    }
    
    public int getLevel() {
        return this.Level;
    }
   
	 public void setLevel(int value) {
	    this.Level = value;
	 }
    
    public Item getParent() {
       return this.Parent;
    }
  
    public void setParent(Item value) {
       this.Parent = value;
    }
  
    public Item getChild() {
       return this.Child;
    }
  
    public void setChild(Item value) {
       this.Child = value;
    }
  
    public double getQuantity() {
       return this.Quantity;
    }
  
    public void setQuantity(double value) {
       this.Quantity = value;
    }
    
    
    public static BOM GetMaxBomLevel(List<BOM> bom, SimulationParameter simParams) {
    	 
   	 BOM maxLevel = bom.stream().filter(e -> e.getExperiment().equals(simParams.getExperiment())).max(Comparator.comparing(BOM::getLevel)).orElse(null);
   	     	     			 
   	 return maxLevel;    	 
    }

    
    public static Item GetMaxLeadTime(List<Item> items, SimulationParameter simParams) {    	    	
     	 return items.stream().max(Comparator.comparing(Item::getLeadTime)).get();
   }
    
    
    public static String GetCSVString(BOM obj) {
    	
    	StringBuilder out = new StringBuilder();
    	
    	out.append(obj.Id + ";");
    	out.append(obj.item.getItem() + ";");
    	
    	if(obj.Child != null) {
    		out.append(obj.Child.getItem() + ";");
    	}else {
    		out.append("0;");
    	}
    	
    	out.append(obj.Level + ";");
    	out.append(obj.Quantity + ";");
    	out.append(obj.Experiment + ";");    	    	    	    	    	
    	return out.toString();
    
    }
    
    
    public static List<BOM> getAggregatedBOMList(List<BOM> bomList, Item givenItem) {
        Map<String, Double> quantityMap = new HashMap<>();
        Map<String, Item> itemMap = new HashMap<>(); // Map to keep track of Item objects by their ID
        aggregateBOMQuantities(bomList, givenItem, quantityMap, itemMap, 1.0);

        // Convert the map to a list of BOM objects with aggregated quantities
        List<BOM> aggregatedBOMList = new ArrayList<>();
        for (String key : quantityMap.keySet()) {
            String[] keyParts = key.split("-");
            Item parent = itemMap.get(keyParts[0]);
            Item child = itemMap.get(keyParts[1]);
            double quantity = quantityMap.get(key);

            BOM bom = new BOM();
            bom.setItem(parent); // Assuming 'setItem' sets the 'parent' in this context
            bom.setChild(child);
            bom.setQuantity(quantity);
            aggregatedBOMList.add(bom);
        }

        return aggregatedBOMList;
    }
        
    private static void aggregateBOMQuantities(List<BOM> bomList, Item item, Map<String, Double> quantityMap, Map<String, Item> itemMap, double parentQuantity) {
        // Find direct BOMs for the given item
        List<BOM> directBOMs = bomList.stream()
                .filter(bom -> bom.getItem() != null && bom.getItem().getId() == item.getId())
                .collect(Collectors.toList());

        for (BOM bom : directBOMs) {
            String parentKey = String.valueOf(bom.getItem().getId());
            String childKey = bom.getChild() != null ? String.valueOf(bom.getChild().getId()) : "noChild";
            String key = parentKey + "-" + childKey;
            // Aggregate quantities
            quantityMap.merge(key, bom.getQuantity() * parentQuantity, Double::sum);
            // Update or add Item objects in the itemMap
            itemMap.putIfAbsent(parentKey, bom.getItem());
            if (bom.getChild() != null) {
                itemMap.putIfAbsent(childKey, bom.getChild());
            }

            // Recurse for the child item
            if (bom.getChild() != null) {
                aggregateBOMQuantities(bomList, bom.getChild(), quantityMap, itemMap, bom.getQuantity() * parentQuantity);
            }
        }
    } 
        
	@Deprecated
	private static List<Item> GetUniqueItemsOfBOM(List<BOM> bomList, OrderFuture of) {
        Set<Integer> itemIds = new HashSet<>();
        List<Item> uniqueItems = new ArrayList<>();
        
        for (BOM bom : bomList) {
            if (bom.getParent() != null && itemIds.add(bom.getParent().getId())) {
                uniqueItems.add(bom.getParent());
            }
            if (bom.getChild() != null && itemIds.add(bom.getChild().getId())) {
                uniqueItems.add(bom.getChild());
            }
            // Assuming you want to include the item's own ID if present
            if (bom.getItem() != null && itemIds.add(bom.getItem().getId())) {
                uniqueItems.add(bom.getItem());
            }
        }
        
        return uniqueItems;
    }
    
       
	@Override
	public String toString() {
		return super.toString();
	}

	/**
	 * This number is here for model snapshot storing purpose<br>
	 * It needs to be changed when this class gets changed
	 */ 
	private static final long serialVersionUID = 1L;

}]]></Text>
		</JavaClass>
		<!--   =========   Java Class   ========  -->
		<JavaClass>
			<Id>1637586671776</Id>
			<Name><![CDATA[Resource]]></Name>
			<Text><![CDATA[/**
 * Resource
 */	
public class Resource implements Serializable {
	
	
	public static final int DEFAULT_CAPACITY = 1440;
	
	public Resource() {
	}
	
	private int Id;	
	private int Status;	
	private String Description;	
	private String Name;
	private String ResourceGroup;
	private int Capacity;
	private int StageNumber;	
	private double PL;
	private double SL;
	private String PLOrder;	
	private String SLValue;	
	
	public String getSLValue() {
		return SLValue;
	}

	public void setSLValue(String sLValue) {
		SLValue = sLValue;
	}
		
	public String getPLOrder() {
		return PLOrder;
	}

	public void setPLOrder(String pLOrder) {
		PLOrder = pLOrder;
	}	

	
	public double getSL() {
		return SL;
	}

	public void setSL(double sL) {
		SL = sL;
	}
	
	public double getPL() {
		return PL;
	}

	public void setPL(double pL) {
		PL = pL;
	}
	
	public int getStageNumber() {
		return StageNumber;
	}
	public void setStageNumber(int stageNumber) {
		StageNumber = stageNumber;
	}
		
	public int getCapacity() {
		return Capacity;
	}
	
	public void setCapacity(int capacity) {
		Capacity = capacity;
	}
	      
        
    public String getResourceGroup() {
       return this.ResourceGroup;
    }
  
    public void setResourceGroup(String value) {
       this.ResourceGroup = value;
    }
    
    public int getId() {
        return this.Id;
     }
   
     public void setId(int value) {
        this.Id = value;
     }
     
     
     public String getName() {
         return this.Name;
      }
    
      public void setName(String value) {
         this.Name = value;
      }
     
      public int getStatus() {
          return this.Status;
       }
     
       public void setStatus(int value) {
          this.Status = value;
       }
     
       public String getDescription() {
           return this.Description;
        }
      
        public void setDescription(String value) {
           this.Description = value;
        }
              
	/**
	 * This number is here for model snapshot storing purpose<br>
	 * It needs to be changed when this class gets changed
	 */ 
	private static final long serialVersionUID = 1L;

}]]></Text>
		</JavaClass>
		<!--   =========   Java Class   ========  -->
		<JavaClass>
			<Id>1637591455985</Id>
			<Name><![CDATA[OrderFuture]]></Name>
			<Text><![CDATA[import java.util.stream.*;
import java.io.Serializable;
import com.google.gson.annotations.Expose;
/**
 * OrderFuture
 */	
public class OrderFuture implements Serializable {

    /**
     * Default constructor
     */
    public OrderFuture() {
    }

    @Expose
    private int Id;
    
    private Item item;
    @Expose
    private int Period;    
    @Expose
    private double EOrderAmount;
    @Expose
    private double VarOrderAmount;
    @Expose
	private int ECustomerRequiredLeadTime;	   
    @Expose
	private double VarCustomerRequiredLeadTime;
    @Expose
    private double VarArrivalRate;        
    @Expose
    private double PeriodQuantity;            
    
    double irt;
    @Expose
    private double LongtermForecast;
    @Expose
    private double MeanDemand;
    @Expose
	private double previousOrderQty;
    
    private String DistArrivalRate;
    
    private int demandScenario;

    // Getter for demandScenario
    public int getDemandScenario() {
        return demandScenario;
    }

    // Setter for demandScenario
    public void setDemandScenario(int demandScenario) {
        this.demandScenario = demandScenario;
    }

    public String getDistArrivalRate() {
       return this.DistArrivalRate;
    }
  
    public void setDistArrivalRate(String value) {
       this.DistArrivalRate = value;
    }

	public double getPreviousOrderQty() {
		return previousOrderQty;
	}

	public void setPreviousOrderQty(double previousOrderQty) {
		this.previousOrderQty = previousOrderQty;
	}
        
    public double getMeanDemand() {
        return this.MeanDemand;
     }
   
     public void setMeanDemand(double value) {
        this.MeanDemand = value;
     }
    
    public double getLongtermForecast() {
       return this.LongtermForecast;
    }
  
    public void setLongtermForecast(double value) {
       this.LongtermForecast = value;
    }
        
    private int MinimumDemandInformationHorizon;
    
    public int getMinimumDemandInformationHorizon() {
       return this.MinimumDemandInformationHorizon;
    }
  
    public void setMinimumDemandInformationHorizon(int value) {
       this.MinimumDemandInformationHorizon = value;
    }
    
    public double getPeriodQuantity() {
       return this.PeriodQuantity;
    }
  
    public void setPeriodQuantity(double value) {
       this.PeriodQuantity = value;
    }
    
    public int getId() {
        return this.Id;
     }
   
     public void setId(int value) {
        this.Id = value;
     }
        
     public Item getItem() {
         return this.item;
      }
    
      public void setItem(Item value) {
         this.item = value;
      }

      public int getPeriod() {
          return this.Period;
       }
     
       public void setPeriod(int value) {
          this.Period = value;
       }

       public double getEOrderAmount() {
           return this.EOrderAmount;
        }
      
        public void setEOrderAmount(double value) {
           this.EOrderAmount = value;
        }
      
        public double getVarOrderAmount() {
            return this.VarOrderAmount;
         }
       
         public void setVarOrderAmount(double value) {
            this.VarOrderAmount = value;
         }   
    
         public int getECustomerRequiredLeadTime() {
             return this.ECustomerRequiredLeadTime;
          }
        
          public void setECustomerRequiredLeadTime(int value) {
             this.ECustomerRequiredLeadTime = value;
          }
        
          public double getVarCustomerRequiredLeadTime() {
             return this.VarCustomerRequiredLeadTime;
          }
        
          public void setVarCustomerRequiredLeadTime(double value) {
             this.VarCustomerRequiredLeadTime = value;
          }         
          
          public double getVarArrivalRate() {
             return this.VarArrivalRate;
          }
        
          public void setVarArrivalRate(double value) {
             this.VarArrivalRate = value;
          }
         
         public static List<OrderFuture> GetItemsForPeriod(List<OrderFuture> items, int period){
        	 
        	 List<OrderFuture> orderItems = null;
        	         	         	 
        	 orderItems = items.stream().filter(e -> e.Period == period).collect(Collectors.toList());
        	         	         	         	         	         	         	         	 
        	 return orderItems;
         }
         
         
         public static double GetInterArrivalTime(OrderFuture of, double time, Random rand, String fileNameSuffix){
        	 		 
        	 //double EInterarrivalTime = (of.getPeriodQuantity()/of.getEOrderAmount())/of.getPeriod();   
        	 
        	 double EInterarrivalRate = 30/(of.getPeriodQuantity()/of.getEOrderAmount());   
        	 
	 		 //(473/15.76)/30
	 
			 //todo: Verteilung via DB
			 //ideal wren 0,5 oder 1 auftrge pro periode (Tag) 
			 //Wenn die Anknfte log normal oder was anders, dann brauchen wir den Erwartungswert der interarrival time.
			 
			 //todo: weitere Verteilung 
			 
			//double distArrivalRate = Distribution.GetDistributionValue("EXP", EArrivalRate, 0 , "OrderFuture", rand, fileNameSuffix,0,0);
        	 
        	//traceln("EInterarrivalrate " + EInterarrivalRate);
	 		double distInterArrivalTime = Distribution.GetDistributionValue(of.getDistArrivalRate(), EInterarrivalRate, of.VarArrivalRate , "OrderFuture", rand, fileNameSuffix,0,0);
	 
			//traceln("ArrivalRate " + distInterArrivalTime);
			 
			 return distInterArrivalTime;
         }
         
         
         public static CustomerOrder GenerateCustomerOrder(OrderFuture of, double time, int orderId, Random randQuantity, Random randCRL, SimulationParameter simParams, String fileNameSuffix, List<BOM> bom, Main root){
        	 
        			 CustomerOrder co = new CustomerOrder(new double[simParams.getDemandVariationHorizon()]);
        			 co.setOrderId(orderId++);
        			 co.setItem(of.getItem());
        			 co.setCreatedAt(time);
        			 co.setStatus(CustomerOrder.ORDER_STATUS_UNPROCESSED);
        			         			 
        			 double quantity = Distribution.GetDistributionValue("LOGNORMAL", of.EOrderAmount, of.VarOrderAmount,"OrderFuture Quantity Cusomter Order", randQuantity, fileNameSuffix,0,0);
        			 //co.setQuantity(quantity);
        			 co.setQuantity(Math.ceil(quantity));

        			 
        			 double dueDate = Distribution.GetDistributionValue("LOGNORMAL", of.ECustomerRequiredLeadTime, of.VarCustomerRequiredLeadTime,"OrderFuture CRL Cusomter Order", randCRL, fileNameSuffix,0,0);
        			 
        			 double fixProportion = 0;
        			 if(simParams.getExperiment().equalsIgnoreCase("WSC24_1") ||
        					 simParams.getExperiment().equalsIgnoreCase("WSC24_2") ||
        					 simParams.getExperiment().equalsIgnoreCase("WSC24_3")) {
        				 
        				         				 
        				 dueDate = Distribution.GetDistributionValue("LOGNORMAL", 5, of.VarCustomerRequiredLeadTime,"OrderFuture CRL Cusomter Order", randCRL, fileNameSuffix,0,0);
            			 
        				 
        				 if(of.getECustomerRequiredLeadTime() == 5) {
        					 fixProportion = 0;        					 
        				 }
        				 if(of.getECustomerRequiredLeadTime() == 7) {        					 
        					 fixProportion = 5;
        				 }
        				 
        				 if(of.getECustomerRequiredLeadTime() == 9) {        					 
        					 fixProportion = 10;
        				 }
        				 
        				 //traceln("variabler anteil: " + dueDate);
        				 
        				 dueDate = dueDate + fixProportion;        				 
        				 //traceln("fixanteil " + fixProportion);
        				 //traceln("due date" + dueDate);
        			 }
        			 
        			 co.setDueDate(time + of.getMinimumDemandInformationHorizon() + dueDate);
        			 co.setConWipStatus(CustomerOrder.ORDER_STATUS_UNPROCESSED);
        			         			
        			 
        	 return co;
        	 
         }
         
         public static String GetCSVHeader() {
         	
         	StringBuilder out = new StringBuilder();
         	
         	out.append("Id;");
         	out.append("Item;");
         	out.append("Period;");
         	out.append("EOrderAmount;");
         	out.append("VarOrderAmount;");
         	
         	return out.toString();    	    	
         }
         
         public static String GetCSVString(OrderFuture obj) {
         	
         	StringBuilder out = new StringBuilder();
         	
         	out.append(obj.getId() + ";");
         	out.append(obj.getItem().getItem() + ";");
         	out.append(obj.getPeriod() + ";");
         	out.append(obj.getEOrderAmount() + ";");
         	out.append(obj.getVarOrderAmount() + ";");
	    	    	    	    	
         	return out.toString();
         	
         }
    
	/**
	 * This number is here for model snapshot storing purpose<br>
	 * It needs to be changed when this class gets changed
	 */ 
	private static final long serialVersionUID = 1L;

}]]></Text>
		</JavaClass>
		<!--   =========   Java Class   ========  -->
		<JavaClass>
			<Id>1638211050241</Id>
			<Name><![CDATA[BOMMatrix]]></Name>
			<Text><![CDATA[/**
 * BOMMatrix
 */	
public class BOMMatrix implements Serializable {


	int Id;
	String Matrix;
	int Status;	
    public BOMMatrix() {
    }
    
    public int getId() {
        return this.Id;
     }
   
     public void setId(int value) {
        this.Id = value;
     }
     
     public String getMatrix() {
         return this.Matrix;
      }
    
      public void setMatrix(String value) {
         this.Matrix = value;
      }
      
      public int getStatus() {
          return this.Status;
       }
     
       public void setStatus(int value) {
          this.Status = value;
       }
      

	/**
	 * This number is here for model snapshot storing purpose<br>
	 * It needs to be changed when this class gets changed
	 */ 
	private static final long serialVersionUID = 1L;

}]]></Text>
		</JavaClass>
		<!--   =========   Java Class   ========  -->
		<JavaClass>
			<Id>1638349058997</Id>
			<Name><![CDATA[ResourceConsumption]]></Name>
			<Text><![CDATA[import java.util.stream.*;


/**
 * ResourceConsumption
 */	
public class ResourceConsumption implements Serializable {

    /**
     * Default constructor
     */
    public ResourceConsumption() {
    }

    private int Id;
    
    private  String Resource;
  
    private int Item;
    
    private String Type;
  
    private double Consumption;
      
    private double SetupTime;
    
    public double getSetupTime() {
       return this.SetupTime;
    }
  
    public void setSetupTime(double value) {
       this.SetupTime = value;
    }
    
    public int getId() {
       return this.Id;
    }
  
    public void setId(int value) {
       this.Id = value;
    }
  
    public String getResource() {
       return this.Resource;
    }
  
    public void setResource(String value) {
       this.Resource = value;
    }
  
    public int getItem() {
       return this.Item;
    }
  
    public void setItem(int value) {
       this.Item = value;
    }
  
    public double getConsumption() {
       return this.Consumption;
    }
  
    public void setConsumption(double value) {
       this.Consumption = value;
    }
    
    public String getType() {
        return this.Type;
     }
   
     public void setType(String value) {
        this.Type = value;
     }
  
}]]></Text>
		</JavaClass>
		<!--   =========   Java Class   ========  -->
		<JavaClass>
			<Id>1638353882481</Id>
			<Name><![CDATA[ResourceCapacity]]></Name>
			<Text><![CDATA[import java.util.stream.*;
import one.util.streamex.StreamEx;

/**
 * ResourceCapacity
 */	
public class ResourceCapacity implements Serializable {

    /**
     * Default constructor
     */
    public ResourceCapacity() {
    }


    private int Id;
    
    private String Resource;
  
    private int Capacity;
  
    private int Period;
      
    public int getId() {
       return this.Id;
    }
  
    public void setId(int value) {
       this.Id = value;
    }
  
    public String getResource() {
       return this.Resource;
    }
  
    public void setResource(String value) {
       this.Resource = value;
    }
  
    public int getCapacity() {
       return this.Capacity;
    }
  
    public void setCapacity(int value) {
       this.Capacity = value;
    }
  
    public int getPeriod() {
       return this.Period;
    }
  
    public void setPeriod(int value) {
       this.Period = value;
    }
         
    public static List<ResourceCapacity> SetAvailableCapacity(List<Resource> resources, SimulationParameter simParams, List<ProductionOrder> prodOrdersIn, List<ResourceCapacity> resourceCapacities, 
            List<Routing> routings, List<Item> items, List<StockBooking> bookings, double time, List<RoutingTimes> routingTimes) {

    	RoutingTimes empty = new RoutingTimes();
    	empty.setEnd(-99);
    	empty.setId(0);

    	List<ProductionOrder> prodOrders = new ArrayList();
    	
    	for(ProductionOrder in : prodOrdersIn) {
    		prodOrders.add(ProductionOrder.Copy(in));
    		
    	}	
    	
       if(prodOrders.size() <= 0) 
           return resourceCapacities;
                 
        List<ProductionOrder> selectedProdOrders = prodOrders.stream().filter(e -> e.getStatus() == ProductionOrder.PRODUCTION_ORDER_STATUS_PROCESSING || 
                e.getStatus() == ProductionOrder.PRODUCTION_ORDER_STATUS_RELEASED).collect(Collectors.toList());

        //traceln(ProductionOrder.GetCSVHeader());
        
        //for(ProductionOrder o : prodOrders) {
        	//traceln(ProductionOrder.GetCSVString(o));
        //}
        
        //traceln("processing " + selectedProdOrders.stream().filter(e -> e.getStatus() == ProductionOrder.PRODUCTION_ORDER_STATUS_PROCESSING).count());
        
        for(ProductionOrder o : selectedProdOrders.stream().filter(e -> e.getStatus() == ProductionOrder.PRODUCTION_ORDER_STATUS_PROCESSING).collect(Collectors.toList())) {             
            
        	//old version start
        	//double q = bookings.stream().filter(e -> e.getSourceId() == o.getOrderId() && e.getSource().equals(StockBooking.BOOKING_SOURCE_PRODUCTION_ORDER)).mapToDouble(StockBooking::getQuantity).sum();                                                                   
//            double newQuantity = o.getQuantity() + q;
  //          o.setQuantity(newQuantity);
        	//old version end
        	
        	double realizedSetupTime = (o.getTotalProcessingTime() - o.getNetProcessingTime()) / 1440;        	
        	double eSetupTime = o.getItem().getRouting().getESetupTime() / 1440;        	
        	
        	
        	        	        	
        	//*************************************************************
			//we have to check, if a gap between two routing times exists			
			RoutingTimes rtRunning = routingTimes.stream().filter(e -> e.getProductionOrder().getOrderId() == o.getOrderId() && e.getStatus() == RoutingTimes.ROUTING_TIME_PROCESSING).findFirst().orElse(empty);
			
			//for(RoutingTimes rrr : routingTimes) {				
				//traceln("Found Running Routing Time: " + rrr.getId() + " Start " + rrr.getStart() + " Ende " + rrr.getEnd() + " STatus " + rrr.getStatus());				
			//}
			
			traceln("Found Running Routing Time: " + rtRunning.getId() + " Start " + rtRunning.getStart() + " Ende " + rtRunning.getEnd() + " STatus " + rtRunning.getStatus());				

			
			double capaStartEndDiff = 0;
			if(rtRunning.getId() > 0) {
				traceln("Found Running Routing Time: " + rtRunning.getId() + " Start " + rtRunning.getStart() + " Ende " + rtRunning.getEnd() + " STatus " + rtRunning.getStatus());				
				
				//now we selec the finihsed with the highest id
				RoutingTimes rtMaxFinished = routingTimes.stream().filter(e -> e.getProductionOrder().getOrderId() == o.getOrderId() && e.getStatus() == RoutingTimes.ROUTING_TIME_FINISHED).max(Comparator.comparing(RoutingTimes::getId)).orElse(empty);

				if(rtMaxFinished.getId() > 0) {
					traceln("Found Running Routing Time: " + rtMaxFinished.getId() + " Start " + rtMaxFinished.getStart() + " Ende " + rtMaxFinished.getEnd() + " STatus " + rtMaxFinished.getStatus());														
					
					capaStartEndDiff = rtRunning.getStart() - rtMaxFinished.getEnd();
				}								
			}
        	//*************************************************************     	
        	
        	
        	traceln("esetup" + eSetupTime + " realized setup " + realizedSetupTime);
			
        	double remainingCapacity = ((o.getPlannedCapacity()/1440) - eSetupTime + realizedSetupTime) - (time - o.getActualStart() - capaStartEndDiff); 			        	
        	//double remainingCapacity = ((o.getTotalProcessingTime()/1440) - eSetupTime + realizedSetupTime) - (time - o.getActualStart() - capaStartEndDiff); 			        									
			traceln("(("+o.getPlannedCapacity()+ "+/1440) - "+eSetupTime+" + "+realizedSetupTime+") - ("+time+" -"+ o.getActualStart() + " - " + capaStartEndDiff + ")"); 			        	
			//traceln("(("+o.getTotalProcessingTime()+ "+/1440) - "+eSetupTime+" + "+realizedSetupTime+") - ("+time+" -"+ o.getActualStart() + " - " + capaStartEndDiff + ")"); 			        	
			
			traceln(remainingCapacity + "/(" + o.getItem().getRouting().getEProcessingTime() + "/1440)");
			
			double newQuantity = remainingCapacity / (o.getItem().getRouting().getEProcessingTime()/1440);			
			
            o.setQuantity(newQuantity);     
            
            traceln("Updated order " + o.getOrderId() + " qty " + o.getQuantity());
        }
                                
        for(Resource res : resources) {   
            
            double requiredCapacity = 0;
            double quantity  = 0;
            
        //traceln("Machine " + res.getName());   
        for(Item item : items.stream().filter(e -> e.getType().equalsIgnoreCase(Item.ITEM_TYPE_SALES) || e.getType().equalsIgnoreCase(Item.ITEM_TYPE_COMPONENT)).collect(Collectors.toList()))
        {
            Routing routing = routings.stream().filter(e ->  e.getItem().getItem() == item.getItem() && e.getResource().equalsIgnoreCase(res.getName())).findFirst().orElse(null);                                                   
                
            if(routing != null) {
                
            	traceln("---------------------");
                traceln("routing " + routing.getResource() + "item " + item.getItem());

            	//for the running orders  
                quantity  = selectedProdOrders.stream().filter(e -> e.getItem().getItem() == item.getItem() &&
                		e.getStatus() == ProductionOrder.PRODUCTION_ORDER_STATUS_PROCESSING && e.getResource().getName().equalsIgnoreCase(res.getName())).mapToDouble(ProductionOrder::getQuantity).sum();                                                                  
//                requiredCapacity += (quantity > 0 ? (quantity * routing.getEProcessingTime()) : 0);
                traceln("Empty? " + quantity);
                
                //check for partial steps in routing times
                List<ProductionOrder> ordis = selectedProdOrders.stream().filter(e -> e.getItem().getItem() == item.getItem() &&
                		e.getStatus() == ProductionOrder.PRODUCTION_ORDER_STATUS_PROCESSING && e.getResource().getName().equalsIgnoreCase(res.getName())).collect(Collectors.toList());                                                                  
                               
                traceln("Found Processing orders: " + ordis.size());
                
                traceln(ProductionOrder.GetCSVHeader());
            	List<RoutingTimes> rr = new ArrayList();
            	RoutingTimes rrRunning = new RoutingTimes();
                for(ProductionOrder o : ordis) {
                	traceln(o.getResource().getName());
                	traceln(o.getQuantity());
                	traceln(o.getQuantityOriginal());
                	traceln(ProductionOrder.GetCSVString(o));
                	                	
                	rr = routingTimes.stream().filter(e -> e.getProductionOrder().getOrderId() == o.getOrderId() && e.getResource().getName().equalsIgnoreCase(res.getName()) && e.getEnd() == time).collect(Collectors.toList());
                	                	
                	rrRunning = routingTimes.stream().filter(e -> e.getProductionOrder().getOrderId() == o.getOrderId() && e.getResource().getName().equalsIgnoreCase(res.getName()) && (e.getEnd() == 0 || e.getEnd() < time)).findFirst().orElse(empty);
                	
                	List <RoutingTimes> rr2 = routingTimes.stream().filter(e -> e.getProductionOrder().getOrderId() == o.getOrderId()).collect(Collectors.toList());
                	                	        
                	for(RoutingTimes r : rr2) {
                    	traceln(r.getProductionOrder().getOrderId() + " " + r.getResource().getName() + " Start " + r.getStart() + " End " + r.getEnd() + " Item " + r.getProductionOrder().getItem().getItem());                    	
                    }                	
                	
                    for(RoutingTimes r : rr) {
                    	traceln(r.getProductionOrder().getOrderId() + " " + r.getResource().getName() + " Start " + r.getStart() + " End " + r.getEnd() + " Item " + r.getProductionOrder().getItem().getItem());                    	
                    }                	
                                        
                    traceln("Running Routing Time: ");
                    if(rrRunning.getId() > 0) {
                    	traceln(rrRunning.getProductionOrder().getOrderId() + " " + rrRunning.getResource().getName() + " Start " + rrRunning.getStart() + " End " + rrRunning.getEnd() + " Item " + rrRunning.getProductionOrder().getItem().getItem());                    	                                    	                                                            
                    }
                }
                
                traceln("rr size: " + rr.size());
                
                if(rr.size() == 0) {
                	traceln("No Routing Time Found");
                	traceln("Qty for capacity : " + quantity);
                	                	                	
                    requiredCapacity += (quantity > 0 ? (quantity * routing.getEProcessingTime()) : 0);
                }                
                
                if(rrRunning.getId() > 0) {
                	traceln("We have a running Order Time: " + time + " Start " + rrRunning.getStart() + " id " + rrRunning.getId());
                	
                	double subtractConsumedCapacity = 0;
                	
                	if(rrRunning.getEnd() == 0) {                		
                		subtractConsumedCapacity = (time - rrRunning.getStart())*1440;                		
                	}else {
                		subtractConsumedCapacity = (rrRunning.getEnd() - rrRunning.getStart())*1440;                		                		
                	}
                		
                		
                	traceln("subtractConsumedCapacity: " + subtractConsumedCapacity);
                	requiredCapacity = max(0,requiredCapacity - subtractConsumedCapacity);
                }
                
                                                
                //section for released orders
                quantity = 0;
                
                
                //List<ProductionOrder> releasedOrders = selectedProdOrders.stream().filter(e -> e.getItem().getItem() == item.getItem() &&
                	//	e.getStatus() == ProductionOrder.PRODUCTION_ORDER_STATUS_RELEASED && e.getResource().getName().equalsIgnoreCase(res.getName())).collect(Collectors.toList());
                
                
                //List<ProductionOrder> releasedOrders = selectedProdOrders.stream().filter(e -> e.getItem().getItem() == item.getItem() &&
            		//e.getStatus() == ProductionOrder.PRODUCTION_ORDER_STATUS_RELEASED).collect(Collectors.toList());


                //for(ProductionOrder o : releasedOrders) {
                	//traceln(ProductionOrder.GetCSVString(o));
                //}
                
                //traceln("Released Orders for Machine " + res.getName() + " Item: " + item.getItem() + " Cnt: " + releasedOrders.size());
                
                quantity  = selectedProdOrders.stream().filter(e -> e.getItem().getItem() == item.getItem() &&
                		e.getStatus() == ProductionOrder.PRODUCTION_ORDER_STATUS_RELEASED).mapToDouble(ProductionOrder::getQuantity).sum();                                                                  
                                                
                requiredCapacity += (quantity > 0 ? (quantity * routing.getEProcessingTime()) + routing.getESetupTime() : 0);                                
                	       
                traceln("required capa " + requiredCapacity);                                          
            }                                   
        }
        
        //Wir starten mit 1, weil die 0er den laufenden Auftrgen gehrt
        for(int j=1; j<= simParams.getSimOptHorizon(); j++){
           
            int tmpJ = j;                                  

            ResourceCapacity targetCapacityPeriod = resourceCapacities.stream().filter(e -> e.getResource().equalsIgnoreCase(res.getName()) && e.getPeriod() == tmpJ).findFirst().get();
                             
            int freeCapacity = max((int) (targetCapacityPeriod.getCapacity() - requiredCapacity),0);                                                                                                      
            requiredCapacity = max(requiredCapacity - (targetCapacityPeriod.getCapacity() - freeCapacity),0);
            
            targetCapacityPeriod.setCapacity(freeCapacity);                                                                    
            
            traceln(freeCapacity);
        }//item                           
        }//resrouce
        return resourceCapacities;        
    }



}]]></Text>
		</JavaClass>
		<!--   =========   Java Class   ========  -->
		<JavaClass>
			<Id>1638382175822</Id>
			<Name><![CDATA[ProductionOrder]]></Name>
			<Text><![CDATA[import java.util.stream.*;
import java.util.Arrays;
import java.util.ArrayList;  

/**
 * ProductionOrder
 */	
public class ProductionOrder implements Serializable {

    /**
     * Default constructor
     */
    public ProductionOrder() {    	    	    	    	    	
    	
    }
    
    public static int PRODUCTION_ORDER_STATUS_UNPROCESSED = 1;    

    //Production order is released and material is available
    public static int PRODUCTION_ORDER_STATUS_RELEASED = 2;
    
    public static int PRODUCTION_ORDER_STATUS_PROCESSING = 5;
    
    public static int PRODUCTION_ORDER_STATUS_PROCESSED = 10;

    public static int PRODUCTION_ORDER_WAITING_FOR_MATERIAL = 99;
    
    public static int PRODUCTION_ORDER_CONWIP_STATUS_NOT_RELEASED = 50;
    
    public static int PRODUCTION_ORDER_CONWIP_STATUS_RELEASED = 100;
        
    public static int PRODUCTION_ORDER_ENERGY_RELEASED = 200;

    public static int PRODUCTION_ORDER_ENERGY_NOT_RELEASED = 250;
    
    
    private int OrderId;
    
    private Item item;
  
    private double PlannedStart;
  
    private double PlannedEnd;
  
    private double Quantity;
    
	private int Status;
	
	private double CreatedAt;
    
    private Routing Routing;
   
    private double TotalProcessingTime;
    
    private double ActualStart;
    
    private double ActualEnd;
    
    private Resource Resource;
    
    private int CurrentRoutingStep;
    
    private int MinimumRoutingStep;
    
    private int MaximumRoutingStep;

    private double NetProcessingTime;
    
    private double PlannedCapacity;
        
    private double ActualReleaseDate;
    
    private double MaterialAvailableDate;
    
    private double QuantityOriginal;    
    
	private int CFFinished;

	public double ConsumedSetupTime;

	public double ConsumedProcessingTime;
	
	private double TTR;
	
	private int ParentProdOrderId;
	
	private double workLoad; 
	
	private int customerOrderId; 
	
	private double ConWipReleasedAt;
    
	private double ConWipReleaseCheckAt;
	
    private int conWipStatus;
	
    private double systemWorkLoad; 
    
    private double componentsWorkLoad; 
    
    private double plannedStartEarliestRelease;

    // Getter method for plannedStartEarliestRelease
    public double getPlannedStartEarliestRelease() {
        return plannedStartEarliestRelease;
    }

    // Setter method for plannedStartEarliestRelease
    public void setPlannedStartEarliestRelease(double plannedStartEarliestRelease) {
        this.plannedStartEarliestRelease = plannedStartEarliestRelease;
    }

        
    public double getComponentsWorkLoad() {
        return componentsWorkLoad;
    }

    public void setComponentsWorkLoad(double componentsWorkLoad) {
        this.componentsWorkLoad = componentsWorkLoad;
    }
    
    public double getSystemWorkLoad() {
        return systemWorkLoad;
    }

    public void setSystemWorkLoad(double systemWorkLoad) {
        this.systemWorkLoad = systemWorkLoad;
    }
    
    public int getConWipStatus() {
        return conWipStatus;
    }

    public void setConWipStatus(int conWipStatus) {
        this.conWipStatus = conWipStatus;
    }
    
	public double getConWipReleasedAt() {
        return ConWipReleasedAt;
    }

    public void setConWipReleasedAt(double ConWipReleasedAt) {
        this.ConWipReleasedAt = ConWipReleasedAt;
    }

    public double getConWipReleaseCheckAt() {
        return ConWipReleaseCheckAt;
    }

    public void setConWipReleaseCheckAt(double ConWipReleaseCheckAt) {
        this.ConWipReleaseCheckAt = ConWipReleaseCheckAt;
    }		
	
    public int getCustomerOrderId() {
        return customerOrderId;
    }


    public void setCustomerOrderId(int customerOrderId) {
        this.customerOrderId = customerOrderId;
    }
	

    public double getWorkLoad() {
        return workLoad;
    }


    public void setWorkLoad(double workLoad) {
        this.workLoad = workLoad;
    }
	
    public int getParentProdOrderId() {
        return ParentProdOrderId;
    }


    public void setParentProdOrderId(int parentProdOrderId) {
        this.ParentProdOrderId = parentProdOrderId;
    }
	
	public double getTTR() {
		return TTR;
	}

	public void setTTR(double tTR) {
		TTR = tTR;
	}
	
	private double TTF;

	public double getTTF() {
		return TTF;
	}

	public void setTTF(double tTF) {
		TTF = tTF;
	}

	
	public double getConsumedProcessingTime() {
		return ConsumedProcessingTime;
	}

	public void setConsumedProcessingTime(double consumedProcessingTime) {
		ConsumedProcessingTime = consumedProcessingTime;
	}
	
	public double getConsumedSetupTime() {
		return ConsumedSetupTime;
	}

	public void setConsumedSetupTime(double consumedSetupTime) {
		ConsumedSetupTime = consumedSetupTime;
	}
	
	public double PlannedSetupTime;

	public double getPlannedSetupTime() {
		return PlannedSetupTime;
	}

	public void setPlannedSetupTime(double plannedSetupTime) {
		PlannedSetupTime = plannedSetupTime;
	}

	public int getReleaseChecked() {
		return ReleaseChecked;
	}

	public void setReleaseChecked(int releaseChecked) {
		ReleaseChecked = releaseChecked;
	}

	private int ReleaseChecked;
	
	
    public int getCFFinished() {
		return CFFinished;
	}

	public void setCFFinished(int cFFinished) {
		CFFinished = cFFinished;
	}
	    
	private double PL;
	
	public double getPL() {
		return PL;
	}

	public void setPL(double pL) {
		PL = pL;
	}
    
    public double getQuantityOriginal() {
    	return this.QuantityOriginal;
    }
    
    public void setQuantityOriginal(double value) {
    	this.QuantityOriginal = value;
    }
        
    public double getMaterialAvailableDate() {
       return this.MaterialAvailableDate;
    }
  
    public void setMaterialAvailableDate(double value) {
       this.MaterialAvailableDate = value;
    }
    
    public double getActualReleaseDate() {
       return this.ActualReleaseDate;
    }
  
    public void setActualReleaseDate(double value) {
       this.ActualReleaseDate = value;
    }
    
    public double getPlannedCapacity() {
       return this.PlannedCapacity;
    }
  
    public void setPlannedCapacity(double value) {
       this.PlannedCapacity = value;
    }
    
    public double getNetProcessingTime() {
       return this.NetProcessingTime;
    }
  
    public void setNetProcessingTime(double value) {
       this.NetProcessingTime = value;
    }
        
    public int getMaximumRoutingStep() {
        return this.MaximumRoutingStep;
     }
   
     public void setMaximumRoutingStep(int value) {
        this.MaximumRoutingStep = value;
     }
   
     public int getMinimumRoutingStep() {
        return this.MinimumRoutingStep;
     }
   
     public void setMinimumRoutingStep(int value) {
        this.MinimumRoutingStep = value;
     }
    
    public int getCurrentRoutingStep() {
        return this.CurrentRoutingStep;
     }
   
	 public void setCurrentRoutingStep(int value) {
	    this.CurrentRoutingStep = value;
	 }
        
    public Resource getResource() {
        return this.Resource;
     }
   
     public void setResource(Resource value) {
        this.Resource = value;
     }
    
    public double getActualStart() {
        return this.ActualStart;
     }
   
     public void setActualStart(double value) {
        this.ActualStart = value;
     }
   
     public double getActualEnd() {
        return this.ActualEnd;
     }
   
     public void setActualEnd(double value) {
        this.ActualEnd = value;
     }
    
    public double getTotalProcessingTime() {
       return this.TotalProcessingTime;
    }
  
    public void setTotalProcessingTime(double value) {
       this.TotalProcessingTime = value;
    }
    
   public Routing getRouting() {
      return this.Routing;
   }
 
   public void setRouting(Routing value) {
      this.Routing = value;
   }
	
    public int getOrderId() {
        return this.OrderId;
     }
   
     public void setOrderId(int value) {
        this.OrderId = value;
     }
   
     public Item getItem() {
        return this.item;
     }
   
     public void setItem(Item value) {
        this.item = value;

     }
   
     public double getPlannedStart() {
        return this.PlannedStart;
     }
   
     public void setPlannedStart(double value) {
        this.PlannedStart = value;
     }
   
     public double getPlannedEnd() {
        return this.PlannedEnd;
     }
   
     public void setPlannedEnd(double value) {
        this.PlannedEnd = value;
     }
   
     public double getQuantity() {
        return this.Quantity;
     }
   
     public void setQuantity(double value) {
        this.Quantity = value;
     }
     
     public double getCreatedAt() {
         return this.CreatedAt;
      }
    
      public void setCreatedAt(double value) {
         this.CreatedAt = value;
      }

      public int getStatus() {
          return this.Status;
       }
     
       public void setStatus(int value) {
          this.Status = value;
       }       
    	 
     public static String GetCSVHeader() {
     	
     	StringBuilder out = new StringBuilder();
     	out.append("ParentPRODOrderId;");
     	out.append("PRODOrderId;");
     	out.append("CreatedAt;");
     	out.append("PlannedStart;");
     	out.append("PlannedEnd;");
     	out.append("Item;");
     	out.append("MinRoutingStep;");
     	out.append("MaxRoutingStep;");     	
     	out.append("Quantity;");
     	out.append("Status;");
     	out.append("ActualStart;");
     	out.append("ActualEnd;");
     	out.append("TotalProcessingTime;");
     	out.append("Machine;");
     	out.append("PlannedCapacity;");
     	out.append("NetProcessingTime;");
     	out.append("SetupTime;");
     	out.append("Workload;");
     	out.append("ParentProdOrder;");
     	out.append("Resource;");
     	out.append("CurrentRoutingStep;");
     	out.append("EarliestReleaseDate");

     	
     	return out.toString();    	    	
     }
     
     public static String GetCSVString(ProductionOrder obj) {
     	
     	StringBuilder out = new StringBuilder();
     	
     	out.append(obj.getParentProdOrderId() + ";");
     	out.append(obj.getOrderId() + ";");
     	out.append(obj.getCreatedAt() + ";");
     	out.append(obj.getPlannedStart() + ";");
     	out.append(obj.getPlannedEnd() + ";");
     	out.append(obj.getItem().getItem() + ";");
     	out.append(obj.getMinimumRoutingStep() + ";");
     	out.append(obj.getMaximumRoutingStep() + ";");
     	out.append(obj.getQuantity() + ";");
     	out.append(obj.getStatus() + ";");
     	out.append(obj.getActualStart() + ";");
     	out.append(obj.getActualEnd() + ";");
     	out.append(obj.getTotalProcessingTime() / 1440 + ";");
     	out.append(obj.getPlannedCapacity() / 1440 + ";");     
     	out.append(obj.getNetProcessingTime() + ";");
     	out.append(obj.getPlannedSetupTime() + ";");
     	out.append(obj.getWorkLoad() + ";");
     	out.append(obj.getParentProdOrderId() + ";");
     	
     	out.append(obj.getResource() != null ? obj.getResource().getName() + ";" : ";");
     	out.append(obj.getCurrentRoutingStep());
     	out.append(obj.getPlannedStartEarliestRelease());

     	return out.toString();
     	
     }
     
     public static ProductionOrder Copy(ProductionOrder o) {
    	 
    	 ProductionOrder n = new ProductionOrder();
    	 
    	    n.setQuantityOriginal(o.getQuantityOriginal());             
    	    n.setMaterialAvailableDate(o.getMaterialAvailableDate());
    	    n.setActualReleaseDate(o.getActualReleaseDate());              
    	    n.setPlannedCapacity(o.getPlannedCapacity()); 
    	    n.setNetProcessingTime(o.getNetProcessingTime());                   
    	    n.setMaximumRoutingStep(o.getMaximumRoutingStep());        
    	    n.setMinimumRoutingStep(o.getMinimumRoutingStep());     
    		n.setCurrentRoutingStep(o.getCurrentRoutingStep()); 	         
    	    n.setResource(o.getResource());     
    	    n.setActualStart(o.getActualStart()); 
    	    n.setActualEnd(o.getActualEnd());     
    	    n.setTotalProcessingTime(o.getTotalProcessingTime()); 
    	    n.setRouting(o.getRouting());    	  
    	    n.setOrderId(o.getOrderId());     
    		n.setItem(o.getItem());  
    		n.setPlannedStart(o.getPlannedStart()); 
    		n.setPlannedEnd(o.getPlannedEnd());    
    		n.setQuantity(o.getQuantity());   
    		n.setCreatedAt(o.getCreatedAt()); 
    		n.setStatus(o.getStatus());     	
    		n.setPlannedStartEarliestRelease(o.getPlannedStartEarliestRelease());    		   
    	 
    	 return n;
    	 
     }
     
     
     public static double GetCurrentWip(List<ProductionOrder> prodOrders, Item item, SimulationParameter simParams) {
    	 
    	 //int sum = Arrays.stream(arr).sum();
    	 
    	 
    	 ArrayList<Double> wipArray = new ArrayList<Double>();
    	 
    	 //WIP_sales 
    	 /*
    	 prodOrders.stream().
    	 filter(e->e.getItem().getType().equals(Item.ITEM_TYPE_SALES) 
    	 && e.getCreatedAt()>= simParams.getWarumUpTime() 
    	 && e.getStatus()== ProductionOrder.PRODUCTION_ORDER_STATUS_PROCESSED).
    	 forEach(e-> wipArray.add((e.getActualEnd()-e.getActualReleaseDate())*e.getQuantity())); 

    	 //second query as here the total simulation time is required
    	 prodOrders.stream().
    	 filter(e->e.getItem().getType().equals(Item.ITEM_TYPE_SALES) 
    	 && e.getCreatedAt()>=simParams.getWarumUpTime() 
    	 && (e.getStatus()== ProductionOrder.PRODUCTION_ORDER_STATUS_RELEASED 
    	 || e.getStatus()== ProductionOrder.PRODUCTION_ORDER_STATUS_PROCESSING)).
    	 forEach(e-> wipArray.add((simParams.getSimulationRunTime()-e.getActualReleaseDate())*e.getQuantity())); 
*/
    	 /*
      	 prodOrders.stream().
    	 filter(e->e.getItem().getItem() ==item.getItem() 
    	 && e.getCreatedAt()>= simParams.getWarumUpTime() 
    	 && e.getStatus()== ProductionOrder.PRODUCTION_ORDER_STATUS_PROCESSED).
    	 forEach(e-> wipArray.add((e.getActualEnd()-e.getActualReleaseDate())*e.getQuantity())); 
*/
    	 //second query as here the total simulation time is required
    	 prodOrders.stream().
    	 filter(e->e.getItem().getItem() ==item.getItem()
    	 && e.getCreatedAt()>=simParams.getWarumUpTime() 
    	 && (e.getStatus()== ProductionOrder.PRODUCTION_ORDER_STATUS_RELEASED 
    	 || e.getStatus()== ProductionOrder.PRODUCTION_ORDER_STATUS_PROCESSING)).
    	 forEach(e-> wipArray.add((simParams.getSimulationRunTime()-e.getActualReleaseDate())*e.getQuantity())); 
    	   	 
    	 double currentSystemWip = wipArray.stream().mapToDouble(f -> f.doubleValue()).sum();
    	     	     	     	 
    	 return currentSystemWip;
    	 
     }
     
     
 	@Override
 	public String toString() {
 		return super.toString();
 	}    	 
    	 
}     
     	
                                                                                                      ]]></Text>
		</JavaClass>
		<!--   =========   Java Class   ========  -->
		<JavaClass>
			<Id>1638436032899</Id>
			<Name><![CDATA[ComponentAvailability]]></Name>
			<Text><![CDATA[import java.util.stream.*;

import org.h2.command.ddl.DeallocateProcedure;

/**
 * ComponentAvailability
 */	
public class ComponentAvailability implements Serializable {


    private String Item;
    
    private int Period;
  
    private double Quantity;
	
	
    public ComponentAvailability() {
    }
  
  
    public String getItem() {
       return this.Item;
    }
  
    public void setItem(String value) {
       this.Item = value;
    }
  
    public int getPeriod() {
       return this.Period;
    }
  
    public void setPeriod(int value) {
       this.Period = value;
    }
  
    public double getQuantity() {
       return this.Quantity;
    }
  
    public void setQuantity(double value) {
       this.Quantity = value;
    }
    
    
    public static double[][] InitializeComponentAvailability(List<Item> items, int period, boolean initialize) {
    	
    	Item it = new Item();
    	double[][] result = new double[items.stream().filter(e -> !e.getType().equals(it.ITEM_TYPE_PURCHASE)).collect(Collectors.toList()).size()][period];

    	int i = 0;
    	for(Item item : items.stream().filter(e -> !e.getType().equals(it.ITEM_TYPE_PURCHASE)).collect(Collectors.toList())) {
    		for(int j=1; j<period; j++){
    			if(initialize) {
    				result[i][j] = 0;
    			}	
    		}    		    	
    		i++;
    	}
    	
    	return result;    	
    }

    public static double[][] SetComponentAvailability(List<Item> items, SimulationParameter simParams, List<ProductionOrder> prodOrders,
    		List<StockBooking> bookings, double time, int prodOrderStatus, boolean fixOrders, List<CustomerOrder> customerOrders) {
    	    	        	
    	Item it = new Item();
    	double[][] result = new double[items.stream().filter(e -> !e.getType().equals(it.ITEM_TYPE_PURCHASE)).collect(Collectors.toList()).size()][simParams.getSimOptHorizon()];

    	List<ProductionOrder> selectedProdOrders = new ArrayList();
    	
    	if(prodOrderStatus == ProductionOrder.PRODUCTION_ORDER_STATUS_PROCESSING) {    	
    		selectedProdOrders = prodOrders.stream().filter(e -> e.getStatus() == ProductionOrder.PRODUCTION_ORDER_STATUS_PROCESSING 
    				|| e.getStatus() == ProductionOrder.PRODUCTION_ORDER_STATUS_RELEASED).collect(Collectors.toList());
    	}else if(prodOrderStatus == ProductionOrder.PRODUCTION_ORDER_STATUS_RELEASED) {
    		selectedProdOrders = prodOrders.stream().filter(e -> e.getStatus() == ProductionOrder.PRODUCTION_ORDER_STATUS_RELEASED).collect(Collectors.toList());    		
    	}
    	    	
    	int i = 0;
    	for(Item item : items.stream().filter(e -> !e.getType().equals(it.ITEM_TYPE_PURCHASE)).collect(Collectors.toList())) {
    		for(int j=0; j<simParams.getSimOptHorizon(); j++){    			    			    			    		
    			
    			double onStock = 0;    			
    			int tmpJ = j;

/*    			
    			double qty = 
						selectedProdOrders.stream().filter(
								e -> e.getItem().getItem() == item.getItem() && e.getPlannedEnd() >= tmpJ+time && e.getPlannedEnd() < tmpJ+1+time)
						.mapToDouble(ProductionOrder::getQuantity).sum();    			
*/
    			    			
    			double qty = 
						selectedProdOrders.stream().filter(
								e -> e.getItem().getItem() == item.getItem() && e.getPlannedEnd() >= tmpJ+time && e.getPlannedEnd() < tmpJ+1+time
								&& e.getTotalProcessingTime() <= 1)
						.mapToDouble(ProductionOrder::getQuantity).sum();    			
  			
									    			
    			if(!fixOrders) //do not fix orders in optimization
    				qty = 0;    			
    			    			    			    			
    			double greater = 0;
    			double delayedCustomerOrdersQty = 0;
    			//only for processing component availability the inventory is set for period 0. This avoids doubling the inventory.
    			if(j == 0 && prodOrderStatus == ProductionOrder.PRODUCTION_ORDER_STATUS_PROCESSING) {
    				onStock = StockBooking.GetStockItemQuantity(bookings, item).getQuantity();    				    				
    				
    				//virtual safetystock for optimization.     				
    				if(item.getType().equalsIgnoreCase(item.ITEM_TYPE_COMPONENT) && j >= item.getLeadTime()) {
    					onStock -= item.getSafetyStock();
    				}else if(item.getType().equalsIgnoreCase(item.ITEM_TYPE_SALES)){
    					onStock -= item.getSafetyStock();
    				}
    				
    	    		greater = 
        					prodOrders.stream().filter(
    								e -> e.getItem().getItem() == item.getItem() && e.getStatus() == ProductionOrder.PRODUCTION_ORDER_STATUS_PROCESSING && 
    								e.getTotalProcessingTime() > 1)
    						.mapToDouble(ProductionOrder::getQuantity).sum();    			
    	    		
        			delayedCustomerOrdersQty = customerOrders.stream().
        					filter(e -> e.getItem().getItem() == item.getItem() 
        					&& e.getStatus() == CustomerOrder.ORDER_STATUS_DELAYED).mapToDouble(CustomerOrder::getQuantity).sum();    			

    	    		    				    				
    			}    			    			    	
    				result[i][j] = qty + onStock + greater - delayedCustomerOrdersQty;
    		}    		    	
    		i++;
    	}
    	
    	return result;    	
    }
    
    public static double[][] GetOrdersInFrozenZone(List<Item> items, SimulationParameter simParams, List<ProductionOrder> prodOrders, double time) {
    	
    	Item it = new Item();
    	double[][] result = new double[items.stream().filter(e -> !e.getType().equals(it.ITEM_TYPE_PURCHASE)).collect(Collectors.toList()).size()][simParams.getSimOptHorizon()];
    	    	    	
    	List<ProductionOrder> selectedProdOrders = prodOrders.stream().filter(e -> e.getStatus() == ProductionOrder.PRODUCTION_ORDER_STATUS_UNPROCESSED && e.getPlannedStart() <= time + simParams.getFrozenZone()    				 
    				).collect(Collectors.toList());

    	//traceln("found for frozen zone");
    	
    	//traceln(ProductionOrder.GetCSVHeader());
    	//for(ProductionOrder o : selectedProdOrders) {
    		//traceln(ProductionOrder.GetCSVString(o));
    	//}	
    	    	    	
    	int i = 0;
    	for(Item item : items.stream().filter(e -> !e.getType().equals(it.ITEM_TYPE_PURCHASE)).collect(Collectors.toList())) {
    		for(int j=0; j<simParams.getSimOptHorizon(); j++){    			    			    			    		
    			    	
    			int tmpJ = j;
    			
    			double qty = 0;
    			
    			if(simParams.getFrozenZone() > 0) {
    				qty =
						selectedProdOrders.stream().filter(
								e -> e.getItem().getItem() == item.getItem() && e.getPlannedStart() >= tmpJ+time && e.getPlannedStart() < tmpJ+1+time)
						.mapToDouble(ProductionOrder::getQuantity).sum();    			
    			}
    			
    			result[i][j] = qty;
    		}    		    	
    		i++;
    	}
    	
    	return result;    	
    }

    
    
	/**
	 * This number is here for model snapshot storing purpose<br>
	 * It needs to be changed when this class gets changed
	 */ 
	private static final long serialVersionUID = 1L;

}]]></Text>
		</JavaClass>
		<!--   =========   Java Class   ========  -->
		<JavaClass>
			<Id>1638804077036</Id>
			<Name><![CDATA[Forecast]]></Name>
			<Text><![CDATA[import org.apache.commons.math3.*;
import org.apache.commons.math3.stat.descriptive.DescriptiveStatistics;
import org.apache.commons.math3.distribution.NormalDistribution;
import java.util.stream.*;
import com.google.gson.annotations.Expose;

/**
 * Forecast
 */	
public class Forecast implements Serializable {

		
    /**
     * Default constructor
     */
    public Forecast() {
    }

    private int Id;
    
    @Expose
    private int Status;
  
    @Expose
    private Item item;
  
    @Expose
    private String Experiment;
  
    @Expose
    private int DemandInformationHorizon;
    
    @Expose
    private double LongtermForecast;
    
    @Expose
    private int Frequency;
        
    private double ProbOutlier;
    
    private double OutlierFactor;
    
    @Expose
    private int DemandScenario;
  
    @Expose
    private int DemandZyklus;
    
    @Expose
	private double originalLongTermForecast;

	public double getOriginalLongTermForecast() {
		return originalLongTermForecast;
	}

	public void setOriginalLongTermForecast(double originalLongTermForecast) {
		this.originalLongTermForecast = originalLongTermForecast;
	}

    
    public int getDemandZyklus() {
    	return this.DemandZyklus;
    }
    
    public void setDemandZyklus(int value) {
    	this.DemandZyklus = value;
    }
    
    public double getProbOutlier() {
       return this.ProbOutlier;
    }
  
    public void setProbOutlier(double value) {
       this.ProbOutlier = value;
    }
  
    public double getOutlierFactor() {
       return this.OutlierFactor;
    }
  
    public void setOutlierFactor(double value) {
       this.OutlierFactor = value;
    }
    
    public int getFrequency() {
       return this.Frequency;
    }
  
    public void setFrequency(int value) {
       this.Frequency = value;
    }
    
    public int getId() {
       return this.Id;
    }
  
    public void setId(int value) {
       this.Id = value;
    }
  
    public int getStatus() {
       return this.Status;
    }
  
    public void setStatus(int value) {
       this.Status = value;
    }
  
    public Item getItem() {
       return this.item;
    }
  
    public void setItem(Item value) {
       this.item = value;
    }
  
    public String getExperiment() {
       return this.Experiment;
    }
  
    public void setExperiment(String value) {
       this.Experiment = value;
    }
      
    public int getDemandInformationHorizon() {
        return this.DemandInformationHorizon;
     }
   
     public void setDemandInformationHorizon(int value) {
        this.DemandInformationHorizon = value;
     }
          
     public double getLongtermForecast() {
        return this.LongtermForecast;
     }
   
     public void setLongtermForecast(double value) {
        this.LongtermForecast = value;
     }
     
     
     public int getDemandScenario() {
         return this.DemandScenario;
      }
    
      public void setDemandScenario(int value) {
         this.DemandScenario = value;
      }
                  
     public static List<CustomerOrder> UpdateForecast(List<CustomerOrder> customerOrders, double time, SimulationParameter simParams, 
    		 List<ForecastInputParameter> forecastInputParameter, List<Forecast> forecast,
    		 List<ForecastHistory> fcHistoryList, Random random, String fileNameSuffix){
    	     	 
    	int updateHorizon = simParams.getForecastUpdateHorizon();
 	 	boolean doUpdate = false;

     	 for(CustomerOrder order : customerOrders) {
    			 
     	 	int pbd = (int)ceil(order.getDueDate() - time);     	 	     	 
     	 	
    	 	if(pbd > 0 && pbd <= updateHorizon && order.getLastForecastChange() != pbd){
    	 		
	    	 		ForecastHistory fcHistory = new ForecastHistory();
	    	 		
	    	 		fcHistory.setOrderId(order.getOrderId());
	    	 		fcHistory.setOldQuantity(order.getQuantity());
	    	 			
	    	 		fcHistory.setTime(time);
	    	 		fcHistory.setDueDate(order.getDueDate());	
	    	 		fcHistory.setPbd(pbd);    	 		
	    	 		
	    	 		double newForecastValue = 0;
	    	 		double epsilon = 0;
	    	 		double mue = 0;
	    	 		double alpha = 0;
	    	 		double mean = 0;
	    	 		double sigma = 0;
	    	 		double transfer = 0;
	    	 		
	    	 		//String forecastScenario =  Integer.toString(optParam.getForecastScenario());
	    	 		
	    	 		//traceln("Current ID " + optParam.getId());
	    	 		//if(optParam.getId() == 0) {
	    	 		String	forecastScenario = Integer.toString(simParams.getForecastScenario());
	    	 		//}
	    	 		
	    	 		//String forecastStringTmp = forecastScenario;
	    	 		    	     	 		
	    	 		long pbdInInputFile = forecastInputParameter.stream().
	    	 		filter(entry -> entry.Scenario.equals(forecastScenario) && entry.PBD == pbd).count();
	    	 		
	    	 		Forecast forecastData = forecast.stream().filter(e -> e.getItem().getItem() == order.getItem().getItem() &&
		 					e.getExperiment().equals(simParams.getExperiment())).findFirst().get();    	 		    	 		    	 		    	 		    	 		
	    	 		
	    	 		//we change the forecast
	    	 		if(pbdInInputFile >= 0){	
	    	 				    	 			    	 				    	 		
	    	 			ForecastInputParameter inputParam = 
	    	 			forecastInputParameter.stream().
	    	 			filter(entry -> entry.Scenario.equals(forecastScenario) && (entry.PBD + 1) == pbd +1)
	    	 			.findFirst().get();
	    	 			
	    	 			
	    	 			mue = inputParam.getMue();
	    	 			alpha = inputParam.getAlpha();
	    	 				    	 			    	 			    	 			    	 			    	 			    	 			
	    	 			//hier den longterm forecast verwenden.
	    	 				    	 			
	    	 			mean = forecastData.getOriginalLongTermForecast() * mue; // nur fr die biased forecasts relvant!!!!	    	 			
	    	 			sigma =  forecastData.getOriginalLongTermForecast() * alpha;	    	 			    	 			    	 			
	    	            	    	 				    	 			
	    	 			double lowerBound = forecastData.getLongtermForecast() * 0.25;
	    	 				    	 			
	    	 			double max = order.getQuantity() + (2*mean);
	    	 			double min = -order.getQuantity();
	    	 		
	    	 			if(mean < 0 && order.getQuantity() <= mean*-1 ) {
	    	 				epsilon = 0;
	    	 			}else {
	    	 				epsilon = Distribution.GetDistributionValue("NORMALTRUNCATED",mean,sigma,"Forecasting", random, fileNameSuffix, min, max);
	    	 			}
	    	 				    	 				    	 				    	 			    	 			
	    	 			newForecastValue = order.getQuantity() + epsilon;    	 		    	 			
	    	 				    	 				    	 			
	    	 			if(newForecastValue < 0) {
	        	 			fcHistory.setTransfer(newForecastValue);
	    	 				newForecastValue = 0;
	    	 			}
	    	 			
	    	 		}else{
	    	 			//no change of forecast value
	    	 			newForecastValue = order.getQuantity();		
	    	 		}
	    	 						
	    	 		fcHistory.setMue(mue);
	    	 		fcHistory.setAlpha(alpha);
	    	 		fcHistory.setMean(mean);
	    	 		fcHistory.setSigma(sigma);
	    	 		fcHistory.setEpsilon(epsilon);	    	 		
	    	 		fcHistory.setNewQuantity(newForecastValue);	    	 		
	    	 		fcHistory.setLastFCChange(time);
	    	 		fcHistory.setItem(order.getItem().getItem());
	    	 		fcHistory.setLongtermForecast(forecastData.getLongtermForecast());
	    	 		fcHistory.setForecastScenario(forecastScenario);
	    	 	    
	    	 		//Avoids to stop simulation, due to order quantity of 0
	    	 		//order.setQuantity(max(Math.round(newForecastValue),lowerBound + 1));    	 		    	 		    	 		
	    	 		
	    	 		double qty = max(Math.round(newForecastValue),1);
	    	 		
	    	 		//the forzen Qty is only updated as long allowed. For MRP this means, from this point the same qty is used for planning. 
	    	 		//But Customer orders qty are still updated
	    	 		
	    	 		if(pbd >= simParams.getForecastUpdateFrozenZone()) {
    	 				order.setFrozenQty(qty);
    	 			}
	    	 		
    	 			order.setPreviousOrderQty(order.getQuantity()); //only store the previous value, to check in the optimzation if an update was performed
    	 			
	    	 		order.setQuantity(qty);    	 		    	 		    	 		
	    	 		
	    	 		order.setMeanDemand(mean);
	    	 		order.setVariationDemand(sigma);
	    	 		order.setLastForecastChange(pbd);    	 		
	    	 		order.setLastForecastHistory(fcHistory);
	    	 		
	    	 			    	 		
	    	 		if(simParams.getForecastUpdateFrequency() > 0 && simParams.getDemandVariationHorizon() > 0) {
	    	 			order.setPreviousDemandValues(pbd-1, order.getQuantity());
	    	 		}
	    	 		
	    	 		if(ForecastHistory.WriteOutputToFile) {
	    	 			ForecastHistory.AppendToFile(ForecastHistory.FC_HISTORY_FILENAME, ForecastHistory.ToCSVString(fcHistory), ForecastHistory.class, ForecastHistory.FC_HISTORY_DELETE_OUTPUTFILE);
	    	 		}
    	 	}
    	 } 
    	 return customerOrders;
     }
    
     
     public static void UpdateForecast(OptimizationParameter optParam, SimulationParameter simParams) {	      	
       	
         StringBuilder sql = new StringBuilder();
                   
         sql.append("Update Forecast set longtermforecast = " + optParam.getX000() +  " WHERE Experiment = '" + optParam.getSimulationParameter() + "' and DemandScenario=" + simParams.getDemandScenario() + ";");
         
         try {  
       	  DBQueries db = new DBQueries();
       	  
            java.sql.Connection conn = db.connect();
             
         	java.sql.Statement stmt  = conn.createStatement();  
         	
          	traceln(sql.toString());	
          	
            stmt.executeUpdate(sql.toString());    	              
            conn.close();

         } catch (SQLException e) {  
             System.out.println(e.getMessage());  
         }       	    	    	
     }	      

     
	/**
	 * This number is here for model snapshot storing purpose<br>
	 * It needs to be changed when this class gets changed
	 */ 
	private static final long serialVersionUID = 1L;

}]]></Text>
		</JavaClass>
		<!--   =========   Java Class   ========  -->
		<JavaClass>
			<Id>1638805253210</Id>
			<Name><![CDATA[CustomerOrder]]></Name>
			<Text><![CDATA[import java.util.stream.*;
import one.util.streamex.StreamEx;

/**
 * CustomerOrderObj
 */	
public class CustomerOrder implements Serializable {

	public static int ORDER_STATUS_UNPROCESSED = 0;		
	public static int ORDER_STATUS_DELAYED = 2;		
	public static int ORDER_STATUS_FINISHED = 8;
	public static int ORDER_STATUS_DELAYED_AND_BOOKED = 4;			
		
	public static int CONWIP_STATUS_RELEASED = 10;
		
	private int customer;
	private Item item;
	private double DueDate;
	private double Quantity;	
	private int OrderId;
	private double CreatedAt;
	private int Status;
	private int LastForecastChange;
	private double ActualEnd;
	private double ActualStart;
    private ForecastHistory LastForecastHistory;
    private OrderPast OrderPast;
    private int PlannedGrossrequirement;                     
    private double MeanDemand;    
    private double VariationDemand;
    private double[] PreviousDemandValues;		        
    private double LongtermForecast;        
    private double[] DemandVariation;    
    private double frozenQty;    
	private double previousOrderQty;
	private int conWipStatus; 
	private double ConWipReleasedAt;
    private double ConWipReleaseCheckAt;
    private double workLoad;   
    private int productionOrderId;

    // Getter method for orderId
    public int getProductionOrderId() {
        return productionOrderId;
    }

    // Setter method for orderId
    public void setProductionOrderId(int orderId) {
        this.productionOrderId = orderId;
    }
    
    public double getWorkLoad() {
        return workLoad;
    }

    public void setWorkLoad(double workLoad) {
        this.workLoad = workLoad;
    }
    
    public double getConWipReleasedAt() {
        return ConWipReleasedAt;
    }

    public void setConWipReleasedAt(double ConWipReleasedAt) {
        this.ConWipReleasedAt = ConWipReleasedAt;
    }

    public double getConWipReleaseCheckAt() {
        return ConWipReleaseCheckAt;
    }

    public void setConWipReleaseCheckAt(double ConWipReleaseCheckAt) {
        this.ConWipReleaseCheckAt = ConWipReleaseCheckAt;
    }	
	
    public int getConWipStatus() {
        return conWipStatus;
    }

    public void setConWipStatus(int conWipStatus) {
        this.conWipStatus = conWipStatus;
    }
	
	public double getPreviousOrderQty() {
		return previousOrderQty;
	}

	public void setPreviousOrderQty(double previousOrderQty) {
		this.previousOrderQty = previousOrderQty;
	}
    
	public double getFrozenQty() {
		return frozenQty;
	}

	public void setFrozenQty(double frozenQty) {
		this.frozenQty = frozenQty;
	}
        
    public CustomerOrder(double[] previousDemandValues) {
    	this.setPreviousDemandValues(previousDemandValues);
    }  
    
    public double[] getDemandVariation() {
       return this.DemandVariation;
    }
  
    public void setDemandVariation(double[] value) {
       this.DemandVariation = value;
    }    
    public double[] getPreviousDemandValues() {
        return this.PreviousDemandValues;
     }
   
     public void setPreviousDemandValues(double[] value) {
        this.PreviousDemandValues = value;
     }
    
     public void setPreviousDemandValues(int pbd, double qty) {
         this.PreviousDemandValues[pbd] = qty;
      }
    
    public double getLongtermForecast() {
       return this.LongtermForecast;
    }
  
    public void setLongtermForecast(double value) {
       this.LongtermForecast = value;
    }
                  
  
    public double getMeanDemand() {
       return this.MeanDemand;
    }
  
    public void setMeanDemand(double value) {
       this.MeanDemand = value;
    }
  
    public double getVariationDemand() {
       return this.VariationDemand;
    }
  
    public void setVariationDemand(double value) {
       this.VariationDemand = value;
    }
    
    public int getPlannedGrossrequirement() {
       return this.PlannedGrossrequirement;
    }
  
    public void setPlannedGrossrequirement(int value) {
       this.PlannedGrossrequirement = value;
    }
    
    public OrderPast getOrderPast() {
       return this.OrderPast;
    }
  
    public void setOrderPast(OrderPast value) {
       this.OrderPast = value;
    }
    
    public ForecastHistory getLastForecastHistory() {
       return this.LastForecastHistory;
    }
  
    public void setLastForecastHistory(ForecastHistory value) {
       this.LastForecastHistory = value;
    }
    
    public double getActualStart() {
        return this.ActualStart;
     }
   
     public void setActualStart(double value) {
        this.ActualStart = value;
     }
    
    public int getCustomer() {
        return this.customer;
    }

    
    public void setCustomer(int value) {
        this.customer = value;               
    }
        
    public int getOrderId() {
        return this.OrderId;
     }
   
     public void setOrderId(int value) {
        this.OrderId = value;
     }
   
     public double getQuantity() {
        return this.Quantity;
     }
   
     public void setQuantity(double value) {
        this.Quantity = value;
     }
   
     public double getDueDate() {
        return this.DueDate;
     }
   
     public void setDueDate(double value) {
        this.DueDate = value;
     }
   
     public Item getItem() {
        return this.item;
     }
   
     public void setItem(Item value) {
        this.item = value;
     }
     
     public double getCreatedAt() {
         return this.CreatedAt;
      }
    
      public void setCreatedAt(double value) {
         this.CreatedAt = value;
      }

      public int getStatus() {
          return this.Status;
       }
     
       public void setStatus(int value) {
          this.Status = value;
       }
      
       public int getLastForecastChange() {
    	      return this.LastForecastChange;
       }
    	 
	   public void setLastForecastChange(int value) {
	      this.LastForecastChange = value;
	   }
             	  
	   public double getActualEnd() {
	      return this.ActualEnd;
	   }
	 
	   public void setActualEnd(double value) {
	      this.ActualEnd = value;
	   }
	   
    public static String GetCSVHeader(String seperator) {
    	
    	StringBuilder out = new StringBuilder();
    	
    	out.append("OrderId" + seperator);
    	out.append("CreatedAt" + seperator);
    	out.append("DueDate" + seperator);
    	out.append("Item" + seperator);
    	out.append("Quantity" + seperator);
    	out.append("Status" + seperator);
    	out.append("ActualEnd" + seperator);
    	out.append("FrozenQty" + seperator);
    	
    	return out.toString();    	    	
    }
    
    public static String GetCSVString(CustomerOrder obj) {
    	
    	StringBuilder out = new StringBuilder();
    	
    	out.append(obj.getOrderId() + ";");
    	out.append(obj.getCreatedAt() + ";");
    	out.append(obj.getDueDate() + ";");
    	out.append(obj.getItem().getItem() + ";");
    	out.append(obj.getQuantity() + ";");
    	out.append(obj.getStatus() + ";");
    	out.append(obj.getActualEnd() + ";");
    	out.append(obj.getFrozenQty() + ";");
    	    	    	    	    	    
    	return out.toString();
    	
    }
    
    public static void GetTraceCSVString(List<CustomerOrder> objs, String delimeterBotom, String delimenterTop) {
      	
      	StringBuilder out = new StringBuilder();
      	out.append(delimenterTop + "\n");
      	out.append(CustomerOrder.GetCSVHeader("\t") + "\n");
      	
      	for(CustomerOrder obj : objs) {
	      	out.append(obj.getOrderId() + "");
	      	out.append("\t" + obj.getCreatedAt() + "");
	      	out.append("\t" + obj.getDueDate() + "");
	      	out.append("\t" + obj.getItem().getItem() + "");
	      	out.append("\t" + obj.getQuantity() + "");
	      	out.append("\t" + obj.getStatus() + "");
	      	out.append("\t" + obj.getActualEnd() + "\n");
	      	out.append("\t" + obj.getFrozenQty() + "\n");
      	}      	    	    	    	  
      	out.append(delimeterBotom + "\n");
      	
      	traceln(out.toString());
     }
    
    
    public static List<CustomerOrder> GenerateForecast(List<Forecast> forecasts, double time, int orderId,
    		SimulationParameter simParams, Random rand) {
    	
    	List<CustomerOrder> orders = new ArrayList();
    	
		double residual = time / simParams.getPlanningFrequency();
		int runningPeriod =  simParams.getPlanningFrequency() * (int) residual;
		
    	for(Forecast fc : forecasts) {

			double residualForecastGenerationFrequency = time % fc.getFrequency();									
			if(residualForecastGenerationFrequency == 0 || residualForecastGenerationFrequency <= fc.getDemandZyklus()) {
				CustomerOrder obj = new CustomerOrder(new double[simParams.getDemandVariationHorizon()]);    		
    			obj.setItem(fc.getItem());
    			obj.setOrderId(orderId++);    			    			
    			
    			boolean prob_outlier =  randomTrue(fc.getProbOutlier(), rand);
    			   			
    			if(prob_outlier == true){    			
    				obj.setQuantity(Math.ceil(fc.getLongtermForecast() * fc.getOutlierFactor()));
    			}else {
    				obj.setQuantity(fc.getLongtermForecast());
    			}
    			    		
    			obj.setDueDate(time  + fc.getDemandInformationHorizon() + 0.001);  
    			obj.setCreatedAt(time);
    			obj.setLongtermForecast(fc.getLongtermForecast());
    			orders.add(obj);
			}
    	}    	
    	
    	return(orders);
    }
    

    
    public static List<CustomerOrder> GenerateOrderPastCustomerOrders(List<OrderPast> orderPasts, double time ,int orderId, SimulationParameter simParams) {
    	
    	List<CustomerOrder> orders = new ArrayList();
    			
    	for(OrderPast op : orderPasts) {
				CustomerOrder obj = new CustomerOrder(new double[simParams.getDemandVariationHorizon()]);    		
    			obj.setItem(op.getItem());
    			obj.setOrderId(orderId++);    			    			
    			obj.setQuantity(op.getQuantity());
    			obj.setDueDate(op.getDueDate());  
    			obj.setCreatedAt(time);
    			orders.add(obj);
    	}    	
    	
    	return(orders);
    }
    
    
	public static List<CustomerOrder> SetOrderPastToCustomerOrder(SimulationParameter simParams, List<CustomerOrder> customerOrders, 
			double time, List<Item> items, int mrpCount, List<OrderPast> orderPasts) {

		List<MRP> mrpList = new ArrayList();																	
		
		//only for finished goods
		List<Item> salesItems  = StreamEx.of(items).filter(e -> e.getType().equalsIgnoreCase(Item.ITEM_TYPE_SALES)).distinct(Item::getItem).toList();												

		for(Item item : salesItems) {
			int p = 0;
						
			for(int i=mrpCount;i<= mrpCount + simParams.getMRPPlanningHorizon();i++) {
				int tmp = i;

				MRP mrpPeriod = new MRP();				
				double runningPeriod = time + p;	
																																				
				if(tmp == 0)
					runningPeriod = 0;								
				
				double from =  mrpPeriod.getRunningPeriod();
				
				if(p == 0) {
					from = 0;
				}
				
				double tmpFrom = from;				
				double grossRequirements = 0;
					
				//traceln("co " + customerOrders.size());
				
				for(CustomerOrder co : customerOrders) {
					traceln(CustomerOrder.GetCSVString(co));
				}
				
						List<CustomerOrder> grossRequirementsList = 
								customerOrders.stream().filter(									
										e -> e.getDueDate() >= tmpFrom && e.getDueDate() < mrpPeriod.getRunningPeriod() + (1-MRP.PERIOD_BALANCING)							
								&& e.getItem().getItem() == item.getItem()).
								collect(Collectors.toList());												
						
						if(grossRequirementsList.size() > 0) {																																			
								for(CustomerOrder co : grossRequirementsList) {																											
									co.setPlannedGrossrequirement((int) mrpPeriod.getRunningPeriod());																		
								}
						}													
					}																																																					
				p++;				
			}
		  								
		return customerOrders;
	}		

    
    
	@Override
	public String toString() {
		return super.toString();
	}

	/**
	 * This number is here for model snapshot storing purpose<br>
	 * It needs to be changed when this class gets changed
	 */ 
	private static final long serialVersionUID = 1L;

}]]></Text>
		</JavaClass>
		<!--   =========   Java Class   ========  -->
		<JavaClass>
			<Id>1639418639293</Id>
			<Name><![CDATA[MRP]]></Name>
			<Text><![CDATA[/**
 * MRP
 */	
import java.util.stream.*;
import org.eclipse.jetty.client.api.Response.DemandedContentListener;
import one.util.streamex.StreamEx;
import java.io.IOException;
import java.text.DecimalFormatSymbols;
import java.io.BufferedReader;
import java.io.FileReader;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.PrintWriter;
import java.io.IOException;
import java.text.SimpleDateFormat;



public class MRP implements Serializable {

	//public static final boolean WRITE_MRP_TABLE_TO_FILE = true;   	
	public static final boolean WRITE_MRP_TABLE_TO_FILE_TABLE_FORM = false; //in list form :-)	
	public static final String FILENAME_MRP_TABLE = "output\\MRPTable";
	public static final String FILENAME_MRP_TABLE_HORIZONTAL = "output\\MRPTableHorizontal.csv";
	public static final boolean MRP_DELETE_OUTPUTFILE = true;
	public static final String SCHEDULING_TYPE_BACKWARD = "SCHEDULING_TYPE_BACKWARD";
	public static final String SCHEDULING_TYPE_RELEASE_PLAN = "SCHEDULING_TYPE_RELEASE_PLAN";
	public static final boolean MRP_TABLE_NEW_PER_SIMULATION = true;
	public static final String MRP_RESULTS_EXCEL_FOLDER = "output";
	public static final int FIXED_LEAD_TIME_FOR_PRODUCTIONORDERS = 0;
	   
	public static final double PERIOD_BALANCING = 0.001;
	
    public MRP() {
    }      	
	
  
   private Item item;
   
   private double GrossRequirements;
 
   private double ProjectedOnHand;
 
   private double NetRequirements;
 
   private double PlannedOrderReceipts;
   
   private double PlannedOrderReleases;

   private int Period;
   
   private double RunningPeriod;
   
   private double Time;   
   
   private int BomLevel;
   
   private String DemandOrigin;
   
   private String ScheduledReceipts;
   
   private double ScheduledReceiptsQty;

   private double OnStock;
   
   private int CapacityNeeded;
   
   private int SafetyStockRelaxed;
   
	private double plannedEnd;		
	
	private Integer cumCapaNeeded;
	
    private int PeriodCapacityCumulatedAvailable;
	
    private int CumulatedCapacityNeededTotal;
    
    private double cumCapaNeededAfterRelaxation;

    private double SafetyStockRelaxedHistory;

    public double getSafetyStockRelaxedHistory() {
        return SafetyStockRelaxedHistory;
    }

    public void setSafetyStockRelaxedHistory(double safetyStockRelaxedHistory) {
        this.SafetyStockRelaxedHistory = safetyStockRelaxedHistory;
    }
    

    public int getCumulatedCapacityNeededTotal() {
        return CumulatedCapacityNeededTotal;
    }

    public void setCumulatedCapacityNeededTotal(int CumulatedCapacityNeededTotal) {
        this.CumulatedCapacityNeededTotal = CumulatedCapacityNeededTotal;
    }
    
    public int getPeriodCapacityCumulatedAvailable() {
        return PeriodCapacityCumulatedAvailable;
    }

    public void setPeriodCapacityCumulatedAvailable(int PeriodCapacityCumulatedAvailable) {
        this.PeriodCapacityCumulatedAvailable = PeriodCapacityCumulatedAvailable;
    }
    
	public double getPlannedEnd() {
		return plannedEnd;
	}

	public void setPlannedEnd(double plannedEnd) {
		this.plannedEnd = plannedEnd;
	}
            
    public Integer getCumCapaNeeded() {
        return cumCapaNeeded;
    }

    public void setCumCapaNeeded(Integer cumCapaNeeded) {
        this.cumCapaNeeded = cumCapaNeeded;
    }
	
    public int getCapacityNeeded() {
       return this.CapacityNeeded;
    }
  
    public void setCapacityNeeded(int value) {
       this.CapacityNeeded = value;
    }
    
    public double getOnStock() {
       return this.OnStock;
    }
  
    public void setOnStock(double value) {
       this.OnStock = value;
    }
    
    public int getBomLevel() {
       return this.BomLevel;
    }
  
    public void setBomLevel(int value) {
       this.BomLevel = value;
    }
    
    public double getScheduledReceiptsQty() {
        return this.ScheduledReceiptsQty;
     }
   
     public void setScheduledReceiptsQty(double value) {
        this.ScheduledReceiptsQty = value;
     }
     
    
    public String getScheduledReceipts() {
       return this.ScheduledReceipts;
    }
  
    public void setScheduledReceipts(String value) {
       this.ScheduledReceipts = value;
    }
    
    public double getRunningPeriod() {
        return this.RunningPeriod;
     }
   
     public void setRunningPeriod(double value) {
        this.RunningPeriod = value;
     }
    
    public Item getItem() {
        return this.item;
     }
   
     public void setItem(Item value) {
        this.item = value;
     }
   
     public double getGrossRequirements() {
        return this.GrossRequirements;
     }
   
     public void setGrossRequirements(double value) {
        this.GrossRequirements = value;
     }
   
     public double getProjectedOnHand() {
        return this.ProjectedOnHand;
     }
   
     public void setProjectedOnHand(double value) {
        this.ProjectedOnHand = value;
     }
   
     public double getNetRequirements() {
        return this.NetRequirements;
     }
   
     public void setNetRequirements(double value) {
        this.NetRequirements = value;
     }
   
     public double getPlannedOrderReceipts() {
        return this.PlannedOrderReceipts;
     }
   
     public void setPlannedOrderReceipts(double value) {
        this.PlannedOrderReceipts = value;
     }

     public int getPeriod() {
         return this.Period;
      }
    
      public void setPeriod(int value) {
         this.Period = value;
      }
     
      public double getTime() {
          return this.Time;
       }
     
       public void setTime(double value) {
          this.Time = value;
       }
       
       public double getPlannedOrderReleases() {
    	      return this.PlannedOrderReleases;
    	   }
    	 
	   public void setPlannedOrderReleases(double value) {
	      this.PlannedOrderReleases = value;
	   }       
    
       public String getDemandOrigin() {
  	      return this.DemandOrigin;
     }
  	 
 	   public void setDemandOrigin(String value) {
 	      this.DemandOrigin = value;
 	   }   

 	   public int getSafetyStockRelaxed() {
 	      return this.SafetyStockRelaxed;
 	   }
 	 
 	   public void setSafetyStockRelaxed(int value) { 		   
 	      this.SafetyStockRelaxed = value;
 	   }
   
 	  // Getter method
 	    public double getCumCapaNeededAfterRelaxation() {
 	        return cumCapaNeededAfterRelaxation;
 	    }

 	    // Setter method
 	    public void setCumCapaNeededAfterRelaxation(double cumCapaNeededAfterRelaxation) {
 	        this.cumCapaNeededAfterRelaxation = cumCapaNeededAfterRelaxation;
 	    }
 	   
	public static List<MRP> ComputeGrossRequirements(SimulationParameter simParams, List<CustomerOrder> customerOrders, 
			double time, List<Item> items, List<StockBooking> bookings, int mrpCount, List<ProductionOrder> prodOrders, 
			int bomLevel, List<BOM> bomList, List<MRP> previousMRPPeriods) {

		List<MRP> mrpList = new ArrayList();																	
				
		List<BOM> distinctByItemAndBOMLevel  = StreamEx.of(bomList).filter(e -> e.getLevel() == bomLevel && 
				e.getItem().getPlanningType().equals(Item.ITEM_PLANNINGTYPE_MRP) && 
				!e.getItem().getType().equals(Item.ITEM_TYPE_PURCHASE)).distinct(BOM::getItem).toList();				

		boolean traceParameters = true;
		
		for(BOM bomItem : distinctByItemAndBOMLevel) {

			int p = 0;
						
			for(int i=mrpCount;i<= mrpCount + simParams.getMRPPlanningHorizon();i++) {
				int tmp = i;

				MRP mrpPeriod = new MRP();
				
				mrpPeriod.setItem(bomItem.getItem());				
				
				if(i==mrpCount && time == 0) {
					traceln("MRP applied ");
					traceln(" Parameters:Lotpolicy= " + mrpPeriod.getItem().getLotsizePolicy());
					traceln(" Item: " + mrpPeriod.getItem().getItem());
					traceln(" Parameters:FOP= " + mrpPeriod.getItem().getFOPPeriod());
					traceln(" Parameters:FOQ= " + mrpPeriod.getItem().getFOQQuantity());
					traceln(" Parameters:FOQ= " + mrpPeriod.getItem().getFOQMinimumLotSize());
					traceln(" PlannedLeadTime=" + mrpPeriod.getItem().getLeadTime());
					traceln(" SafetyStock=" + mrpPeriod.getItem().getSafetyStock());
					traceParameters = false;
				}
				
				//traceln("item: " + mrpPeriod.getItem().getItem() + "SS: " + mrpPeriod.getItem().getSafetyStock() + " LT: " + mrpPeriod.getItem().getLeadTime() + " FOP: " + 
				//mrpPeriod.getItem().getFOPPeriod());
				
				mrpPeriod.setPeriod(p);
				double runningPeriod = time + p;	
				
				mrpPeriod.setTime(time);
				mrpPeriod.setBomLevel(bomLevel);
																																
				if(tmp == 0)
					runningPeriod = 0;
				
				mrpPeriod.setRunningPeriod(runningPeriod);
				
				double from =  mrpPeriod.getRunningPeriod();
				
				if(p == 0) {
					from = 0;
				}
				
				double tmpFrom = from;				
				double grossRequirements = 0;
					
					//BOM Level 0															
					if(bomLevel == 0) {						
						
						 List<CustomerOrder> grossRequirementsList = customerOrders.stream().filter(									
									e -> e.getDueDate() >= tmpFrom && e.getDueDate() < mrpPeriod.getRunningPeriod() + (1-PERIOD_BALANCING)							
							&& e.getItem() == bomItem.getItem() && e.getStatus() < CustomerOrder.ORDER_STATUS_DELAYED_AND_BOOKED).
							collect(Collectors.toList());							
													 							
						if(grossRequirementsList.size() > 0) {
							StringBuilder demandOrigin = new StringBuilder();
							demandOrigin.setLength(0);
														
							//Consider Forecast Update Qty which is no longer updated. Forecasts are still updated, but MRP does not get notice if it.
							if(simParams.getForecastUpdateFrozenZone() > 0) {
								grossRequirements = grossRequirementsList.stream().mapToDouble(CustomerOrder::getFrozenQty).sum();																					
							}else {
								grossRequirements = grossRequirementsList.stream().mapToDouble(CustomerOrder::getQuantity).sum();																													
							}
							
							if(simParams.getWriteMRPTableToFile()) {
								for(CustomerOrder item : grossRequirementsList) {
									if(grossRequirementsList.size() > 1) {
										demandOrigin.append(item.getOrderId()  + " DD:  "+ item.getDueDate() + ",");												
									}else {
										demandOrigin.append(item.getOrderId());												
										demandOrigin.append(item.getOrderId()  + " DD:  "+ item.getDueDate());												
									}
								}
								
								mrpPeriod.setDemandOrigin(demandOrigin.toString());
							}					
						}																																				
					}else {													
						List<BOM> childOf = bomList.stream().filter(e -> e.getChild() != null && e.getChild().getItem() == bomItem.getItem().getItem() 
								&& e.getLevel() == bomLevel - 1).collect(Collectors.toList());
						
						StringBuilder demandOrigin = new StringBuilder();
						demandOrigin.setLength(0);						
						
						//for components we have to add grossrequiremnts of lower BOM levels if they have not get the material and are still waiting for it.
						//concerns production orders
						
						/*
						List<ProductionOrder> scheduledReceipts = prodOrders.stream().filter(e -> e.getItem().getItem()
								== mrpPeriod.getItem().getItem() &&							
								 e.getPlannedEnd() >= tmpFrom && e.getPlannedEnd() <= mrpPeriod.getRunningPeriod() + (1-PERIOD_BALANCING)	
								 && e.getStatus() < ProductionOrder.PRODUCTION_ORDER_STATUS_PROCESSED
								).collect(Collectors.toList());
						*/
						
						for(BOM grItem : childOf) {					
							double rp = runningPeriod;
							
							double qty = previousMRPPeriods.stream().filter(e -> e.item.getItem() == grItem.getItem().getItem() 							
									&& e.getTime() == time
									&& e.getBomLevel() == bomLevel-1
									&& e.getRunningPeriod() == rp
									).mapToDouble(MRP::getPlannedOrderReleases).sum();	
							
							grossRequirements += qty;
							double lateOrdersQty = 0;
							List<ProductionOrder> lateOrders = new ArrayList<ProductionOrder>();
							if(p==0) {
																
								lateOrders = prodOrders.stream().filter(e -> e.getItem().getItem() == grItem.getItem().getItem() &&														
										e.getPlannedEnd() <= (mrpPeriod.getRunningPeriod() - PERIOD_BALANCING) && //--> changed for RO
										//e.getPlannedEnd() <= mrpPeriod.getRunningPeriod() + (1-PERIOD_BALANCING) && //--> before RO change
										(e.getStatus() == ProductionOrder.PRODUCTION_ORDER_WAITING_FOR_MATERIAL || e.getStatus() == ProductionOrder.PRODUCTION_ORDER_STATUS_UNPROCESSED)
										).collect(Collectors.toList());
								
								lateOrdersQty = lateOrders.stream().mapToDouble(ProductionOrder::getQuantity).sum();
								
								grossRequirements += lateOrdersQty;
							}
							
							if(simParams.getWriteMRPTableToFile()) {
								if(grossRequirements > 0) {
									demandOrigin.append("BL:" + (bomLevel -1) + "Item:" + grItem.getItem().getItem() + "Qty:"+ qty);									
								}
								if(lateOrders.size() > 0) {
									for(ProductionOrder po : lateOrders) {
										demandOrigin.append("LO: Id:" + po.getOrderId() + "Qty:"+ lateOrdersQty + "i:" + grItem.getItem().getItem());
									}									
								}
								mrpPeriod.setDemandOrigin(demandOrigin.toString());
	
							}// write mrp
						}
					}
																				
					mrpPeriod.setGrossRequirements(Math.round(grossRequirements));

						if(p == 0){
							double qty = StockBooking.GetStockItemQuantity(bookings, mrpPeriod.getItem()).getQuantity();
														
							mrpPeriod.setOnStock(qty);
							
							mrpPeriod.setProjectedOnHand(qty - mrpPeriod.getGrossRequirements());					
						}else {
							int pp = p;
							
							double projectOnHandInventoryPreviousPeriod = 
									mrpList.stream().filter(e -> e.getItem() == bomItem.getItem() && e.getPeriod() == pp-1)
									.mapToDouble(MRP::getProjectedOnHand).sum();
														
							double netRequirementsPeviousPeriod = NetRequirementsPrevPeriod(mrpList, mrpPeriod);
							
							mrpPeriod.setProjectedOnHand(projectOnHandInventoryPreviousPeriod - mrpPeriod.getGrossRequirements() + netRequirementsPeviousPeriod);													
						}					
					
						
					//add scheduled receipts
					ProductionOrder s = new ProductionOrder();
					
						//mehrere auftrge fr andere perioden, dynamische planbergangszeiten
						//situation, auftrag kommt rein, der mit der zugang an dieser periode des es aber schon gibt
						//d.h. mehrere auftrge mit gleicher periode. bei 1er periode aufsummierung der verspteten auftrge.
						
						//wenn maerial schon abgefasst wurde so wie bsp order id 56 und 72, dann drfen sie nicht
						//im bruttobedarf von der vorstufe auftauchen, nur , wenn sie das material noch nicht 
						//abgefasst haben, dann mssen sie auftauchen. variante 1 geht, variante 2 wren auftrge mit
						//status 99, die logik muss ich mir noch ansehenj.
					
						// 1. so lange wir noch keine komplette Zubuchung auf das Lager haben, bleibt der Auftrag ein scheduduled receipt
						// 2. Ist ein Produktionsauftrag versptet, dann gehen wir davon aus, dass der Zugang dann in der ersten Periode ist. Er ist somit im Rckstand. Der Bruttobedarf
						// fr die darunter liegende Stufe, muss dann auch fr dise Periode weitergeben werden.
					
						List<ProductionOrder> scheduledReceipts = prodOrders.stream().filter(e -> e.getItem().getItem()
								== mrpPeriod.getItem().getItem() &&							
								 e.getPlannedEnd() >= tmpFrom && e.getPlannedEnd() <= mrpPeriod.getRunningPeriod() + (1-PERIOD_BALANCING)	
								 && (e.getStatus() < ProductionOrder.PRODUCTION_ORDER_STATUS_PROCESSED || e.getStatus() == ProductionOrder.PRODUCTION_ORDER_WAITING_FOR_MATERIAL)
								).collect(Collectors.toList());
												
						if(prodOrders.size() > 0) {

							double scheduledReceiptsQty = scheduledReceipts.stream().mapToDouble(ProductionOrder::getQuantity).sum();

							StringBuilder scheduledReceiptsString = new StringBuilder();

							if(simParams.getWriteMRPTableToFile()) {
								for(ProductionOrder item : scheduledReceipts) {
									if(scheduledReceipts.size() > 1) {
										scheduledReceiptsString.append(item.getOrderId() + ",");												
									}else {
										scheduledReceiptsString.append(item.getOrderId());												
									}
								}
								mrpPeriod.setScheduledReceipts(scheduledReceiptsString.toString());
							}
														
							mrpPeriod.setScheduledReceiptsQty(scheduledReceiptsQty);						
							mrpPeriod.setProjectedOnHand(mrpPeriod.getProjectedOnHand() + mrpPeriod.getScheduledReceiptsQty());

						}			
				p++;			
				mrpList.add(mrpPeriod);
	
			}
		  }

		return mrpList;
	}		
	
	public static double NetRequirementsPrevPeriod(List<MRP> mrpList, MRP currentMrpPeriod) {
				
		MRP targetMrpPeriod = mrpList.stream().filter(e -> e.getItem().getItem() == currentMrpPeriod.getItem().getItem() 
				&& e.getRunningPeriod() == currentMrpPeriod.getRunningPeriod() - 1).findFirst().get();
		
		double safetyStock = targetMrpPeriod.item.getSafetyStock();
		
		double netRequirments = 0;
				
		if(targetMrpPeriod.getProjectedOnHand() <= targetMrpPeriod.item.getSafetyStock()) {
			netRequirments = targetMrpPeriod.item.getSafetyStock() - targetMrpPeriod.getProjectedOnHand();			
		//if(targetMrpPeriod.getProjectedOnHand() <= safetyStock) {
			//		netRequirments = safetyStock - targetMrpPeriod.getProjectedOnHand();			
		}		
		return netRequirments;
		
	}
	
	public static List<MRP> Netting(int mRPPlanningHorizon, List<MRP> mRPList, double time, SimulationParameter simParams, List<MRP> 
	relaxedItems, List<ItemRelaxedStatus> itemRelaxedStatusList,Main main) {

		List<MRP> distinctByItem = StreamEx.of(mRPList).distinct(MRP::getItem).toList();
		
			for(MRP mrpEntry : distinctByItem) {			

				
				int startRunningI = 0;
				
				if(simParams.getOptimizationType().equalsIgnoreCase(SimulationParameter.ALGORITHMIC_OPTIMIZATION_TYPE_SAFETY_STOCK_RELAXATION)){
					startRunningI = main.var_safetyStockRelaxationStartPeriod;
				}
				
				for(int i = startRunningI;i<= simParams.getMRPPlanningHorizon();i++) {

					int tmp = i;
					
					MRP mrpPeriod = mRPList.stream().filter(e -> e.getItem().getItem() == mrpEntry.getItem().getItem() && e.getPeriod() == tmp && e.getTime() == (int) time).findFirst().get();
	
					double netRequirments = 0;
					
					mrpPeriod.setNetRequirements(0);
					
					double safetyStock = mrpPeriod.item.getSafetyStock();
					
					// Start safetystock relaxation integration
					//if(mrpPeriod.getTime() > 0 && relaxedItems.size() > 0) {
					if(simParams.getOptimizationType().equalsIgnoreCase(SimulationParameter.ALGORITHMIC_OPTIMIZATION_TYPE_SAFETY_STOCK_RELAXATION)){
					
						MRP emptyMRP = new MRP();
						emptyMRP.setTime(-99);
												
						//MRP relaxedItem = relaxedItems.stream().filter(e -> e.getPeriod() == tmp && e.getTime() == (int) time && e.getItem().getItem() == mrpEntry.getItem().getItem()).findFirst().orElse(emptyMRP);

						traceln("RelaxedItem Status Size at MRP Netting: " + itemRelaxedStatusList.size() + " item " + mrpPeriod.getItem().getItem() + " time " + time + " period " + tmp);
						for(ItemRelaxedStatus o : itemRelaxedStatusList) {
							if(mrpPeriod.getItem().getItem() == o.getItem().getItem());
								traceln("========> item " + o.getItem().getItem() + " time " + o.getTime() + " period " + o.getPeriod() + " qty " + o.getQuantity());
							
						}
						
						long existsEntryForItem = itemRelaxedStatusList.stream().filter(e -> e.getItem().getItem() ==  mrpPeriod.getItem().getItem()
								&& e.getTime() >= time && e.getPeriod() <= mrpPeriod.getPeriod()).count();
						
											
						if(existsEntryForItem > 0) {
							ItemRelaxedStatus itemRelaxedStatus = itemRelaxedStatusList.stream().filter(e -> e.getItem().getItem() ==  mrpPeriod.getItem().getItem()).findFirst().get();									
							safetyStock = (int)itemRelaxedStatus.getQuantity();
							traceln("old Relaxed Value: " + mrpPeriod.getSafetyStockRelaxed());
							mrpPeriod.setSafetyStockRelaxedHistory(mrpPeriod.getSafetyStockRelaxedHistory() + mrpPeriod.getSafetyStockRelaxed());
							
							mrpPeriod.setSafetyStockRelaxed((int)safetyStock);	
							traceln("!!!!!!!!!!!!!!!!! Found Relaxed Item: " + mrpPeriod.getItem().getItem() + " qty: " + safetyStock + " time: " + itemRelaxedStatus.getTime() + " period: " + itemRelaxedStatus.getPeriod());
						}
								
					}
					//finish safetystock relaxation integration
					//traceln("~~~~~~~~~~~~~~~~~~ Apply Safetystock for Netting " + mrpPeriod.getItem().getItem() + " time " + time + " period " + mrpPeriod.getPeriod() + " safety stock " + safetyStock);
					//if(mrpPeriod.getProjectedOnHand() <= mrpPeriod.item.getSafetyStock()) {
					if(mrpPeriod.getProjectedOnHand() <= safetyStock) {
//						netRequirments = mrpPeriod.item.getSafetyStock() - mrpPeriod.getProjectedOnHand();
						netRequirments = safetyStock - mrpPeriod.getProjectedOnHand();
						mrpPeriod.setNetRequirements(netRequirments);
					}
					//traceln("SET Netrequirements: " +  mrpPeriod.getNetRequirements() + "SafetyStock - ProOnHand =" + safetyStock + "-" + mrpPeriod.getProjectedOnHand());

				}									
			}			
			
		return mRPList;		
	}
	
	
	public static List<MRP> LotSizing(int mRPPlanningHorizon, List<MRP> mRPList, double time, SimulationParameter simParams, 
			List<MRP> relaxedItems, List<ItemRelaxedStatus> itemRelaxedStatusList,Main main) {

		List<MRP> distinctByItem = StreamEx.of(mRPList).distinct(MRP::getItem).toList();
						
		double lotSize = 0;

		for(MRP mrpEntry : distinctByItem) {	
			boolean startFopGroup = false;
			int cntFopGroup = 0;
			
			boolean newFOQLot = false;
			
			double plannedOrderReceiptsSum = 0;
			double nettRequirementsSum = 0;
			boolean doIt = false;
			
			int startRunningI = 0;
			
			if(simParams.getOptimizationType().equalsIgnoreCase(SimulationParameter.ALGORITHMIC_OPTIMIZATION_TYPE_SAFETY_STOCK_RELAXATION)){
				startRunningI = main.var_safetyStockRelaxationStartPeriod;
			}
			
			for(int i = startRunningI;i<= simParams.getMRPPlanningHorizon();i++) {

				int tmp = i;				
				
				String lotSizePolicy = mrpEntry.getItem().getLotsizePolicy();

				MRP mrpPeriod = mRPList.stream().filter(e -> e.getItem() == mrpEntry.getItem() && e.getPeriod() == tmp && e.getTime() <= (int) time).findFirst().orElseGet(null);
								
				switch(lotSizePolicy.toString()) {
					case("LFL"):
						if(mrpPeriod.getNetRequirements() > 0) {
							mrpPeriod.setPlannedOrderReceipts(mrpPeriod.getNetRequirements());
						}
					break;
					case("FOP"): case("FOPBacklog"):
						
							//todo: gleich FOQ Backlog, innerhalb i < inkl. berechnung projekcted on hand < 0, ansonsten standardverhalten.
							doIt = false;
							nettRequirementsSum += mrpPeriod.getNetRequirements();
							plannedOrderReceiptsSum += mrpPeriod.getPlannedOrderReceipts(); //Ist beim ersten Einstig in die If-Anweisung 0 !!!!!!!!!!!!!!!!!
							//variante Bercksichtigung von Rckstnden, "Kundenbedarf" wird innerhalb der Leattime hinten angestellt. 
							if((
								(nettRequirementsSum >= plannedOrderReceiptsSum 
									&& i >= 
									mrpPeriod.getItem().getLeadTime())
								||
									(nettRequirementsSum >= plannedOrderReceiptsSum 
									&& i < 
									mrpPeriod.getItem().getLeadTime()
									&& mrpPeriod.getProjectedOnHand() < 0) 
									
									&& mrpPeriod.getItem().getLotsizePolicy().equalsIgnoreCase("FOPBacklog"))
		
							){							
		
								doIt = true;
							}
							
							if(mrpPeriod.getItem().getLotsizePolicy().equalsIgnoreCase("FOP")) {
								doIt = true;
							}
							
							if(doIt){
							
									if(mrpPeriod.getNetRequirements() > 0 && !startFopGroup && cntFopGroup == 0) {
										startFopGroup = true;
										cntFopGroup = 0;
		
									}
									if(startFopGroup && cntFopGroup < mrpPeriod.getItem().getFOPPeriod()) {
										lotSize += mrpPeriod.getNetRequirements();
										cntFopGroup ++;
									}
									
									if(startFopGroup && (cntFopGroup == mrpPeriod.getItem().getFOPPeriod() || tmp == simParams.getMRPPlanningHorizon())){															
										int rargetFOP = cntFopGroup;
										//traceln("item " + mrpEntry.getItem().getItem() + " FOP " + rargetFOP);
										MRP targetmrpPeriod = mRPList.stream().filter(e -> e.getItem() == mrpEntry.getItem() && e.getPeriod() == (tmp - rargetFOP + 1) && e.getTime() == (int) time).findFirst().orElseGet(null);
										targetmrpPeriod.setPlannedOrderReceipts(lotSize);
										
										
										//safety stock relaxation integration begin:										
										if(simParams.getOptimizationType().equalsIgnoreCase(SimulationParameter.ALGORITHMIC_OPTIMIZATION_TYPE_SAFETY_STOCK_RELAXATION)){
	
											
											traceln("RelaxedItem Status Size at MRP Refill: " + itemRelaxedStatusList.size() + " item " + mrpPeriod.getItem().getItem() + " time " + time + " period " + tmp);
											for(ItemRelaxedStatus o : itemRelaxedStatusList) {
												if(targetmrpPeriod.getItem().getItem() == o.getItem().getItem());
													traceln("++++++++++++++++> item " + o.getItem().getItem() + " time " + o.getTime() + " period " + o.getPeriod() + " qty " + o.getQuantity());
												
											}
											
											long existsEntryForItem = itemRelaxedStatusList.stream().filter(e -> e.getItem().getItem() ==  targetmrpPeriod.getItem().getItem() 
													&& e.getTime() >= time && e.getPeriod() < targetmrpPeriod.getPeriod()).count();
											
																											
											if(existsEntryForItem > 0) {
												ItemRelaxedStatus itemRelaxedStatus = itemRelaxedStatusList.stream().filter(e -> e.getItem().getItem() ==  targetmrpPeriod.getItem().getItem()).findFirst().get();									

												int refillValue = (int) Math.max(0,targetmrpPeriod.getItem().getSafetyStock() - itemRelaxedStatus.getQuantity());
												itemRelaxedStatus.setQuantity(targetmrpPeriod.getItem().getSafetyStock());
												double oldqty = targetmrpPeriod.getPlannedOrderReceipts();
												targetmrpPeriod.setPlannedOrderReceipts(targetmrpPeriod.getPlannedOrderReceipts() + refillValue);
												traceln("Refill " + time + " TargetPeriod " + targetmrpPeriod.getPeriod() + " old qty " + oldqty + " new qty " + targetmrpPeriod.getPlannedOrderReceipts() + " Item: " + targetmrpPeriod.getItem().getItem() + " refill qty: " + refillValue + " time: " + itemRelaxedStatus.getTime() + " period: " + itemRelaxedStatus.getPeriod());
											}
										}
										//safety stock relaxation integration end:
										
										startFopGroup = false;
										cntFopGroup = 0;
										lotSize = 0;
									}			
							}
						
					break;
					case("FOQ"): case("FOQBacklog"):
						
						if(mrpPeriod.getNetRequirements() > 0){
														
							nettRequirementsSum += mrpPeriod.getNetRequirements();
							
							//ACHTUNG: Plannedorder Receipts sind hier zu Beginn 0. Die werden erst im Laufe der Iteration gefllt, daher funktioniert dann auch die
							//Losgrenbildung
							
							plannedOrderReceiptsSum += mrpPeriod.getPlannedOrderReceipts(); //Ist beim ersten Einstig in die If-Anweisung 0 !!!!!!!!!!!!!!!!!
														
							int foqLotSize = 0;
							
							doIt = false;
							
							//variante Bercksichtigung von Rckstnden, "Kundenbedarf" wird innerhalb der Leattime hinten angestellt. 
							if((
								(nettRequirementsSum >= plannedOrderReceiptsSum 
									&& i >= 
									mrpPeriod.getItem().getLeadTime())
								||
									(nettRequirementsSum >= plannedOrderReceiptsSum 
									&& i < 
									mrpPeriod.getItem().getLeadTime()
									&& mrpPeriod.getProjectedOnHand() < 0) 
									
									&& mrpPeriod.getItem().getLotsizePolicy().equalsIgnoreCase("FOQBacklog"))

							){							

								doIt = true;
							}
							
							if(nettRequirementsSum >= plannedOrderReceiptsSum && mrpPeriod.getItem().getLotsizePolicy().equalsIgnoreCase("FOQ")) {
								doIt = true;
							}
							
							if(doIt) {
							 foqLotSize = (int) Math.ceil((nettRequirementsSum-plannedOrderReceiptsSum)/mrpPeriod.getItem().getFOQMinimumLotSize());
							 //traceln(foqLotSize);
							 foqLotSize = foqLotSize * mrpPeriod.getItem().getFOQMinimumLotSize();
							 //traceln(foqLotSize);
							 plannedOrderReceiptsSum += foqLotSize; 
							}
							
							doIt = false;
							
							mrpPeriod.setPlannedOrderReceipts(foqLotSize);							
														
						}
																	
					break;
										
				}														
			}									
		}
		return mRPList;												
	}	
	
	public static List<MRP> TimePhasing(int mRPPlanningHorizon, List<MRP> mRPList, double time, SimulationParameter simParams,
			String schedulingType, List<ProductionOrder> prodOrders, List<MRP> planItems) {

		List<MRP> distinctByItem = StreamEx.of(mRPList).distinct(MRP::getItem).toList();
		
		traceln("timephasing ::::::::::::::::::::::::::::::::::::::");
		
		if(schedulingType == SCHEDULING_TYPE_RELEASE_PLAN)
			distinctByItem = planItems;
		
		for(MRP mrpEntry : distinctByItem) {			
			for(int i=0;i<= simParams.getMRPPlanningHorizon();i++) {
				int tmp = i;					
				MRP mrpPeriod = mRPList.stream().filter(e -> e.getItem() == mrpEntry.getItem() && e.getPeriod() == tmp && e.getTime() == (int) time).findFirst().orElseGet(null);
				if(mrpPeriod.getPlannedOrderReceipts() > 0 || schedulingType.equalsIgnoreCase(SCHEDULING_TYPE_RELEASE_PLAN)) {

					//traceln("PoR: " + mrpPeriod.getPlannedOrderReceipts() + " " + mrpPeriod.getItem().getItem() + " st: " + schedulingType);

					MRP t = new MRP();
					
					if(schedulingType.equalsIgnoreCase(SCHEDULING_TYPE_BACKWARD)) {
						
						double plannedStartDate = max((mrpPeriod.getRunningPeriod() - mrpPeriod.getItem().getLeadTime()), time) - time;														
						
						MRP targetMRPPeriod = mRPList.stream().filter(e -> e.getItem() == mrpEntry.getItem() && e.getPeriod() == plannedStartDate && e.getTime() == (int) time).findFirst().orElse(t);
						
						if(targetMRPPeriod.getPeriod() >= 0) {
							targetMRPPeriod.setPlannedOrderReleases(mrpPeriod.getPlannedOrderReceipts());	
							targetMRPPeriod.setPlannedEnd(mrpPeriod.getRunningPeriod());
							
							traceln("PoR: " + mrpPeriod.getPlannedOrderReceipts() + " " + mrpPeriod.getItem().getItem() + " st: " + schedulingType);
							traceln(MRP.GetCSVString(targetMRPPeriod));
						}
						
					}else if(schedulingType.equalsIgnoreCase(SCHEDULING_TYPE_RELEASE_PLAN)) {
						//use ReleasePlan and set start date of production order as plannedOrderRelease
						
						
						
						
						List<ProductionOrder> selectedProdOrders = prodOrders.stream().filter(e -> e.getItem().getItem() == mrpEntry.getItem().getItem() 
							&& e.getPlannedStart() == mrpPeriod.getRunningPeriod() + MRP.PERIOD_BALANCING).collect(Collectors.toList());												
						
						traceln("MRP RunningPeriod: " + mrpPeriod.getRunningPeriod());
						traceln("Production Orders for Releaseplan");
						
						traceln(ProductionOrder.GetCSVHeader());
						for(ProductionOrder o : selectedProdOrders) {
							traceln(ProductionOrder.GetCSVString(o));						
						}
						
						double qty = 0.0;
						MRP targetMRPPeriod = new MRP();
						traceln("at Releaseplan scheduling");
						for(ProductionOrder o : selectedProdOrders) {
							
							traceln(o.getPlannedStart() + " rp " + mrpPeriod.getRunningPeriod() + " item " + mrpEntry.getItem().getItem() + " size " + prodOrders.size() + " id " + o.getOrderId());
	
							if(o.getPlannedStart() >= 0) {
								traceln("getPlannedStart: " + o.getPlannedStart() + " item " +  o.getItem().getItem() + " created at " + o.getCreatedAt());
	
								targetMRPPeriod = mRPList.stream().filter(e -> e.getItem() == mrpEntry.getItem() && (e.getRunningPeriod() + MRP.PERIOD_BALANCING) == o.getPlannedStart()
									).findFirst().orElse(t);												
	
								qty += o.getQuantity();							
								
								}								
							}//for ProductionOrder
					
						if(qty > 0) {
							targetMRPPeriod.setPlannedOrderReleases(qty);	
							traceln("set it " + targetMRPPeriod.getPlannedOrderReleases() + " " + targetMRPPeriod.getRunningPeriod());
						}
						
					}
				}
			}									
		}

		return mRPList;
	}

	public static List<ProductionOrder> CreateProductionOrders(List<MRP> mrpTable, double time, int prodOrderId, List<Routing> routingList, SimulationParameter simParams, List<Item> items){

		traceln("create prodorder #####################################");
		
		List<ProductionOrder> productionOrders = new ArrayList();
						
		for(MRP mrpPeriod : mrpTable.stream().filter(e -> e.getPlannedOrderReleases() > 0 && (e.getRunningPeriod() - e.getTime() ) <= 0).collect(Collectors.toList())) {		
			
			traceln(" iii " + mrpPeriod.getItem());
			
			ProductionOrder order = new ProductionOrder();			
		
			order.setOrderId(prodOrderId++);
			order.setItem(mrpPeriod.getItem());	
			
			int minimumRoutingStep = Routing.GetMinimumStep(routingList, order.getItem() , simParams);
			int maximumRoutingStep = Routing.GetMaximumStep(routingList, order.getItem() , simParams);
			
			order.setMinimumRoutingStep(minimumRoutingStep);
			order.setMaximumRoutingStep(maximumRoutingStep);			
			order.setCurrentRoutingStep(minimumRoutingStep);
			
			order.setQuantity(mrpPeriod.PlannedOrderReleases);		
			
			order.setPlannedCapacity(Routing.GetPlannedCapacityPerItem(routingList, order.getItem(), simParams, order));
			order.setPlannedSetupTime(Routing.GetPlannedSetupTimePerItem(routingList, order.getItem(), simParams, order));
			
			order.setCreatedAt(time);
			
			order.setPlannedStart(mrpPeriod.getRunningPeriod() + PERIOD_BALANCING);
			
			
			if(FIXED_LEAD_TIME_FOR_PRODUCTIONORDERS==1) {
				order.setPlannedEnd(mrpPeriod.getRunningPeriod() + mrpPeriod.getItem().getLeadTime());
			}else {
				order.setPlannedEnd(mrpPeriod.getPlannedEnd());
			}
			
			order.setStatus(ProductionOrder.PRODUCTION_ORDER_STATUS_UNPROCESSED);
			
			Routing routingObject = routingList.stream().filter(e -> e.getItem().getItem() == order.getItem().getItem() && e.getStep() == minimumRoutingStep).findFirst().get();			
			order.setRouting(routingObject);
			
			traceln("CREATE prodorder ----------------------------------------------------");
			traceln(ProductionOrder.GetCSVString(order));
			
			productionOrders.add(order);
									
		}
									
		return productionOrders;
	}
				
			
    public static String GetCSVHeader() {
     	
     	StringBuilder out = new StringBuilder();
     	
     	out.append("Time;");
     	out.append("Period;");
     	out.append("RunningPeriod;");
     	out.append("BOMLevel;");
     	out.append("Item;");
     	out.append("GrossRequirements;");
     	out.append("ProjectedOnHand;");
     	out.append("NetRequirements;");
     	out.append("PlannedOrderReceipts;");
     	out.append("PlannedOrderReleases;");
     	out.append("DemandOrigin;");
     	out.append("ScheduledReceipts;");
     	out.append("ScheduledReceiptsQty;");
     	out.append("OnStock;");
     	out.append("SafetyStock;");
     	out.append("ReleaxedSafetyStock;");
     	//out.append("ReleaxedSafetyStockMRP;");
     	out.append("CapacityNeeded;");

     	     	     	
     	return out.toString();    	    	
     }
     
     public static String GetCSVString(MRP obj) {
     	
     	StringBuilder out = new StringBuilder();
     	
     	out.append(obj.getTime() + ";");
     	out.append(obj.getPeriod() + ";");
     	out.append(obj.getRunningPeriod() + ";");
     	out.append(obj.getBomLevel() + ";");
        out.append(obj.getItem().getItem() + ";");
     	out.append(obj.getGrossRequirements() + ";");
     	out.append(obj.getProjectedOnHand() + ";");
     	out.append(obj.getNetRequirements() + ";");
     	out.append(obj.getPlannedOrderReceipts() + ";");
     	out.append(obj.getPlannedOrderReleases() + ";");
     	out.append(obj.getDemandOrigin() + ";");
     	out.append(obj.getScheduledReceipts()+ ";");     	
        out.append(obj.getScheduledReceiptsQty() + ";");
        out.append(obj.getOnStock() + ";");
        out.append(obj.getItem().getSafetyStock() + ";");
        
        /*
        if(obj.getItemRelaxed() != null) {
        	out.append(obj.getItemRelaxed().getSafetyStock() + ";");
        }else {
        	out.append(";");
        }
*/
        
        out.append(obj.getSafetyStockRelaxed() + ";");

        out.append(obj.getCapacityNeeded() + ";");
        
     	
     	     	
     	return out.toString();
     	
     }
     
     public static void GetMRPTableCSVString(List<MRP> mrpTable, double time, String fileNameSuffix, List<StockBooking> stockBookings) {      	      	

       	String fileName = FILENAME_MRP_TABLE_HORIZONTAL;

    	 
      	try{            
		
		 
      	if(MRP_TABLE_NEW_PER_SIMULATION) {
      		//SimpleDateFormat simpleDateFormat =
      		//new SimpleDateFormat("YYYYMMddhhmmss");
      		//String dateAsString = simpleDateFormat.format(new Date());
      		        		       		
      		fileName = MRP_RESULTS_EXCEL_FOLDER + "\\MRPTableHorizontal_" + fileNameSuffix + ".csv";
      	}
		
    	FileOutputStream outputStream = new FileOutputStream(fileName, true);
			
      		StringBuilder out = new StringBuilder();
      		StringBuilder outPeriod = new StringBuilder();
      		StringBuilder outGrossRequirements = new StringBuilder();
      		StringBuilder outProjectedOnHand = new StringBuilder();
      		StringBuilder outNetRequirements = new StringBuilder();
      		StringBuilder outPlannedOrderReceipts = new StringBuilder();
      		StringBuilder outPlannedOrderReleases = new StringBuilder();
      		StringBuilder outDemandOrigin = new StringBuilder();
      		StringBuilder outScheduledReceipts = new StringBuilder();
      		StringBuilder outScheduledReceiptsQty = new StringBuilder();
      		StringBuilder outOnStock = new StringBuilder();
      		StringBuilder outSafetyStock = new StringBuilder();
      		StringBuilder outSafetyStockMinimum = new StringBuilder();
      		StringBuilder outRelaxedSafetyStock = new StringBuilder();
      		StringBuilder outRelaxedSafetyStockHistory = new StringBuilder();

      		StringBuilder outCapacityNeeded = new StringBuilder();
      		StringBuilder outPeriodCapacityCumulatedAvailable = new StringBuilder();
      		StringBuilder outCumulatedCapacityNeededTotal = new StringBuilder();
      		StringBuilder outCumulatedCapacityNeededTotalAfterRelaxation = new StringBuilder();


			//List<MRP> distinctByItem = StreamEx.of(mrpTable).filter(e -> e.getItem().getItem() == 11).distinct(MRP::getItem).toList();
      		
      		List<MRP> distinctByItem = StreamEx.of(mrpTable).distinct(MRP::getItem).toList();
			
			
			//Period
			for(MRP item : distinctByItem) {
				out.append("Time " + time  + " BOM Level " + item.getBomLevel() + " Item " +item.getItem().getItem() + "\r\n");
				
				outPeriod.setLength(0);
				outGrossRequirements.setLength(0);
				outProjectedOnHand.setLength(0);
				outNetRequirements.setLength(0);
				outPlannedOrderReceipts.setLength(0);
				outPlannedOrderReleases.setLength(0);
				outDemandOrigin.setLength(0);
				outScheduledReceipts.setLength(0);
				outScheduledReceiptsQty.setLength(0);
				outOnStock.setLength(0);
				outSafetyStock.setLength(0);
				outRelaxedSafetyStock.setLength(0);
				outRelaxedSafetyStockHistory.setLength(0);

				outSafetyStockMinimum.setLength(0);
				outCapacityNeeded.setLength(0);
				outPeriodCapacityCumulatedAvailable.setLength(0);
				outCumulatedCapacityNeededTotal.setLength(0);
				outCumulatedCapacityNeededTotalAfterRelaxation.setLength(0);
			
				outPeriod.append("Period" + ";");
				
				double onStock = StockBooking.GetStockItemQuantity(stockBookings, item.getItem()).getQuantity();
				
				outGrossRequirements.append("GrossRequirements Dt" + ";");
				outProjectedOnHand.append("ProjectOnHand" + ";");
				outNetRequirements.append("NetRequirments" + ";");
				outPlannedOrderReceipts.append("PlannedOrderReceipts Xt" + ";");
				outPlannedOrderReleases.append("PlannedOrderReleases Rt" + ";");
				outDemandOrigin.append("DemandOrigin" + ";");
				outScheduledReceipts.append("ScheduledReceipts" + ";");
				outScheduledReceiptsQty.append("ScheduledReceiptsQty" + ";");
				outOnStock.append("OnStock" + ";");
				outSafetyStock.append("StandardSafetyStock" + ";");
				outRelaxedSafetyStock.append("RelaxedSafetyStock" + ";");
				outRelaxedSafetyStockHistory.append("RelaxedSafetyStockHistory" + ";");

				outSafetyStockMinimum.append("MinimumSafetStock" + ";");

				outCapacityNeeded.append("CapacityNeeded" + ";");
				outPeriodCapacityCumulatedAvailable.append("CumCapaAvailable" + ";");
				outCumulatedCapacityNeededTotal.append("CumCapaNeeded" + ";");
				outCumulatedCapacityNeededTotalAfterRelaxation.append("CumCapaNeededAfterRelaxation" + ";");

				
				
				for(MRP entry : mrpTable.stream().filter(e -> e.getItem().getItem() == item.getItem().getItem()).collect(Collectors.toList())) {				
					outPeriod.append(entry.getRunningPeriod() + "-" + (entry.getRunningPeriod() + (1 - PERIOD_BALANCING)) + ";");									
					outGrossRequirements.append(entry.getGrossRequirements() + ";");
					outProjectedOnHand.append(entry.getProjectedOnHand() + ";");
					outNetRequirements.append(entry.getNetRequirements() + ";");
					outPlannedOrderReceipts.append(entry.getPlannedOrderReceipts() + ";");
					outPlannedOrderReleases.append(entry.getPlannedOrderReleases() + ";");																				
					outDemandOrigin.append(entry.getDemandOrigin() != null ? entry.getDemandOrigin() + ";": " " + ";");
					outScheduledReceipts.append(entry.getScheduledReceipts() != null ? entry.getScheduledReceipts() + ";" : " " + ";");					
					outScheduledReceiptsQty.append(entry.getScheduledReceiptsQty() + ";");										
					outOnStock.append(entry.getOnStock() + ";");	
					outSafetyStock.append(entry.getItem().getSafetyStock() + ";");
										
					outRelaxedSafetyStock.append(entry.getSafetyStockRelaxed() + ";");
					outRelaxedSafetyStockHistory.append(entry.getSafetyStockRelaxedHistory() + ";");

					
					outSafetyStockMinimum.append(entry.getItem().getSafetyStockMinimum() + ";");

					
					outCapacityNeeded.append(entry.getCapacityNeeded() + ";");
					outPeriodCapacityCumulatedAvailable.append(entry.getPeriodCapacityCumulatedAvailable() + ";");
					outCumulatedCapacityNeededTotal.append(entry.getCumulatedCapacityNeededTotal() + ";");
					outCumulatedCapacityNeededTotalAfterRelaxation.append(entry.getCumCapaNeededAfterRelaxation() + ";");					
					
				}
								
				outPeriod.append("\r\n");
				outGrossRequirements.append("\r\n");								
				outProjectedOnHand.append("\r\n");
				outNetRequirements.append("\r\n");
				outPlannedOrderReceipts.append("\r\n");
				outPlannedOrderReleases.append("\r\n");
				outDemandOrigin.append("\r\n");
				outScheduledReceipts.append("\r\n");
				outScheduledReceiptsQty.append("\r\n");
				outOnStock.append("\r\n");
				outSafetyStock.append("\r\n");
				outRelaxedSafetyStock.append("\r\n");
				outRelaxedSafetyStockHistory.append("\r\n");

				outSafetyStockMinimum.append("\r\n");
				outCapacityNeeded.append("\r\n");
				outPeriodCapacityCumulatedAvailable.append("\r\n");
				outCumulatedCapacityNeededTotal.append("\r\n");
				outCumulatedCapacityNeededTotalAfterRelaxation.append("\r\n");
				
				
				out.append(outPeriod);
				out.append(outGrossRequirements);				
				out.append(outProjectedOnHand);
				out.append(outNetRequirements);
				out.append(outPlannedOrderReceipts);
				out.append(outPlannedOrderReleases);
				out.append(outDemandOrigin);
				out.append(outScheduledReceipts);
				out.append(outScheduledReceiptsQty);
				out.append(outOnStock);
				out.append(outSafetyStock);
				
				out.append(outRelaxedSafetyStock);
				out.append(outRelaxedSafetyStockHistory);

				out.append(outSafetyStockMinimum);
				out.append(outCapacityNeeded);
				out.append(outPeriodCapacityCumulatedAvailable);
				out.append(outCumulatedCapacityNeededTotal);
				out.append(outCumulatedCapacityNeededTotalAfterRelaxation);
				
			}			
			
		    byte[] strToBytes = out.toString().getBytes();								
		    outputStream.write(strToBytes);												
								    		    		    
		  
		    outputStream.close();
		   }
		catch (Exception e)
		{
			traceln("Could not write to file " + fileName + " " +  e.getMessage());
		}
      	
      }
  
	
	

}]]></Text>
		</JavaClass>
		<!--   =========   Java Class   ========  -->
		<JavaClass>
			<Id>1639563457150</Id>
			<Name><![CDATA[Stock]]></Name>
			<Text><![CDATA[/**
 * Stock
 */	
public class Stock implements Serializable {

    /**
     * Default constructor
     */
    public Stock() {
    }

	@Override
	public String toString() {
		return super.toString();
	}

	/**
	 * This number is here for model snapshot storing purpose<br>
	 * It needs to be changed when this class gets changed
	 */ 
	private static final long serialVersionUID = 1L;

}]]></Text>
		</JavaClass>
		<!--   =========   Java Class   ========  -->
		<JavaClass>
			<Id>1639645115494</Id>
			<Name><![CDATA[ForecastInputParameter]]></Name>
			<Text><![CDATA[import org.apache.poi.ss.usermodel.*;
import org.apache.poi.xssf.usermodel.XSSFWorkbook;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.util.Iterator;
import java.text.SimpleDateFormat;  
import java.util.Date;  
import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.PrintWriter;
import java.lang.*;
import java.text.DecimalFormat;
import java.sql.*;
import java.io.IOException;
import java.text.DecimalFormatSymbols;


/**
 * ForecastInputParameter
 */	
public class ForecastInputParameter implements Serializable {

	public static boolean WriteOutputToFile = false;
	
	//public static String excelInputFile = "input.xlsx";
	
	   String Scenario;
	 
	   String Description;
	   
	   int PBD;
	   
	   double Mue;	 
	   
	   double Alpha;
	   
	   private double BiasedCorrection;

	 
	   public ForecastInputParameter(String scenario, int pbd, double mue, double alpha, String description, double biasedCorrection) {
		   
		   this.Scenario = scenario;
		   this.PBD = pbd;
		   this.Mue = mue;
		   this.Alpha = alpha;
		   this.Description = description;
		   this.BiasedCorrection = biasedCorrection;
		   
	   }
	 	  	   
	   public String getScenario() {
	      return this.Scenario;
	   }
	 
	   public void setScenario(String value) {
	      this.Scenario = value;
	   }
	 
	   public String getDescription() {
	      return this.Description;
	   }
		 
	   public void setDescription(String value) {
	      this.Description = value;
	   }
	   
	   public int getPBD() {
	      return this.PBD;
	   }
	 
	   public void setPBD(int value) {
	      this.PBD = value;
	   }
	 
	   public double getMue() {
	      return this.Mue;
	   }
	 
	   public void setMue(double value) {
	      this.Mue = value;
	   }
	 
	   public double getAlpha() {
	      return this.Alpha;
	   }
	 
	   public void setAlpha(double value) {
	      this.Alpha = value;
	   } 
	   
		public double getBiasedCorrection() {
			return BiasedCorrection;
		}

		public void setBiasedCorrection(double biasedCorrection) {
			this.BiasedCorrection = biasedCorrection;
		}

	   
	   public static List<ForecastInputParameter> ReadForecastExcelIntputParameters(String excelInputFile) {
	   
		   List<ForecastInputParameter> outList = new ArrayList<ForecastInputParameter>();
		   
	   try {
		   traceln("Try to read Input File: " + excelInputFile);
           FileInputStream excelFile = new FileInputStream(new File(excelInputFile));
           Workbook workbook = new XSSFWorkbook(excelFile);
                                                       
           for (int i = 0; i < workbook.getNumberOfSheets(); i++)
           {
        	   //traceln("open Worksheet: " + i);
	           Sheet datatypeSheet = workbook.getSheetAt(i);
	           
	           Iterator<Row> iterator = datatypeSheet.iterator();
	           
	           String description = datatypeSheet.getSheetName();
	           double biasedCorrection = 0;
	           
	           while (iterator.hasNext()) {
	
	               Row currentRow = iterator.next();
	               
	               if(currentRow.getRowNum() >= 1) {
	               Iterator<Cell> cellIterator = currentRow.iterator();
	    	               		               
	                  Cell pbdCell = currentRow.getCell(1);
	                  int pbd = (int)pbdCell.getNumericCellValue();
	                  
	                  Cell mueCell = currentRow.getCell(2);
	                  double mue = mueCell.getNumericCellValue();
	                  
	                  Cell alphaCell = currentRow.getCell(3);
	                  double alpha = alphaCell.getNumericCellValue();
	                  	                  
	                  if(currentRow.getRowNum() == 1) {
		                  Cell biasedCorrectionCell = currentRow.getCell(14);
		                  if(biasedCorrectionCell != null) {
		                	  biasedCorrection = biasedCorrectionCell.getNumericCellValue();	                	  
		                  }
	                  }
	                   
	                   ForecastInputParameter outItem = new ForecastInputParameter(
	                		   String.valueOf(i),pbd,mue,alpha,description,biasedCorrection); 
	                   	                   
	                   outList.add(outItem);
	               }
	           }   
           }
           
       } catch (FileNotFoundException e) {
           e.printStackTrace();
       } catch (IOException e) {
           e.printStackTrace();
       } 

	   return outList;
	   
   }   
	      
		public static String GetCSVHeader() {
			
			StringBuilder o = new StringBuilder();
			
			o.append("Scenario");
			o.append(";");
			o.append("Description");
			o.append(";");
			o.append("PBD");
			o.append(";");
			o.append("Mue");
			o.append(";");
			o.append("Alpha");
			
			return o.toString();
		}
		   
		public String ToCSVString(ForecastInputParameter in) {
			
			StringBuilder o = new StringBuilder();
			
			o.append(in.getScenario());
			o.append(";");
			o.append(in.getDescription());
			o.append(";");
			o.append(in.getPBD());
			o.append(";");
			o.append(in.getMue());
			o.append(";");
			o.append(in.getAlpha());

			return o.toString();
			
		}
		   
	
		public static void WriteToFile(List<ForecastInputParameter> objectsToWrite) {
			
			SimpleDateFormat simpleDateFormat =
			new SimpleDateFormat("YYYYMMddhhmmss");
			String dateAsString = simpleDateFormat.format(new Date());
							
				File directory = new File ("output");
							
				if(!directory.exists())
					directory.mkdir();

				Random random = new Random();
				
				File file = new File(directory, "ForecastInputParameter"+dateAsString + random.nextInt(10)+ ".csv");
				
				       try(PrintWriter pw = new PrintWriter(new FileOutputStream(file))){
			               pw.println(ForecastInputParameter.GetCSVHeader());
				           for (ForecastInputParameter element : objectsToWrite) {
				               pw.println(element.ToCSVString(element));			               			               			               
				           }
				       }catch(Exception e)		{
				    	   traceln(e.getMessage());
				       }		       		
			}	
		   	   	
		public static String GetCurrentDateTimeFormatted() {
			SimpleDateFormat simpleDateFormat =
			new SimpleDateFormat("YYYY-MM-dd hh:mm:ss");
			return simpleDateFormat.format(new Date());		
		}
				
		
	@Override
	public String toString() {
		return super.toString();
	}

	/**
	 * This number is here for model snapshot storing purpose<br>
	 * It needs to be changed when this class gets changed
	 */ 
	private static final long serialVersionUID = 1L;
}
]]></Text>
		</JavaClass>
		<!--   =========   Java Class   ========  -->
		<JavaClass>
			<Id>1639645133373</Id>
			<Name><![CDATA[ForecastHistory]]></Name>
			<Text><![CDATA[import java.text.SimpleDateFormat;  
import java.util.Date;  
import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.PrintWriter;
import java.lang.*;
import java.text.DecimalFormat;
import java.sql.*;
import java.io.IOException;
import java.text.DecimalFormatSymbols;
import java.io.BufferedReader;
import java.io.FileReader;


/**
 * ForecastHistory
 */	
public class ForecastHistory implements Serializable {

	   public static final boolean WriteOutputToFile = false;
	   public static final boolean FC_HISTORY_DELETE_OUTPUTFILE = false;
	   public static final String FC_HISTORY_FILENAME = "output\\ForecastHistory.csv";
	
	   int OrderId;
	   
	   double OldQuantity;
	 
	   double NewQuantity;
	 
	   double Mue;
	 
	   double Alpha;
	 
	   double Item;
	 
	   double Epsilon;
	 
	   double Time;
	 
	   double DueDate;
	 
	   double Pbd;
	 
	   double Mean;
	 
	   double Sigma;
	   
	   double LastFCChange;
	   
	   double longtermForecast;
	   
	   String forecastScenario;
	   
	   double Transfer;
	   
	   public double getTransfer() {
	      return this.Transfer;
	   }
	 
	   public void setTransfer(double value) {
	      this.Transfer = value;
	   }
	   	 
	   public ForecastHistory() {
	   }
	 
	   public int getOrderId() {
	      return this.OrderId;
	   }
	 
	   public void setOrderId(int value) {
	      this.OrderId = value;
	   }
	 
	   public double getOldQuantity() {
	      return this.OldQuantity;
	   }
	 
	   public void setOldQuantity(double value) {
	      this.OldQuantity = value;
	   }
	 
	   public double getNewQuantity() {
	      return this.NewQuantity;
	   }
	 
	   public void setNewQuantity(double value) {
	      this.NewQuantity = value;
	   }
	 
	   public double getMue() {
	      return this.Mue;
	   }
	 
	   public void setMue(double value) {
	      this.Mue = value;
	   }
	 
	   public double getAlpha() {
	      return this.Alpha;
	   }
	 
	   public void setAlpha(double value) {
	      this.Alpha = value;
	   }
	 
	   public double getItem() {
	      return this.Item;
	   }
	 
	   public void setItem(double value) {
	      this.Item = value;
	   }
	 
	   public double getEpsilon() {
	      return this.Epsilon;
	   }
	 
	   public void setEpsilon(double value) {
	      this.Epsilon = value;
	   }
	 
	   public double getTime() {
	      return this.Time;
	   }
	 
	   public void setTime(double value) {
	      this.Time = value;
	   }
	 
	   public double getDueDate() {
	      return this.DueDate;
	   }
	 
	   public void setDueDate(double value) {
	      this.DueDate = value;
	   }
	 
	   public double getPbd() {
	      return this.Pbd;
	   }
	 
	   public void setPbd(double value) {
	      this.Pbd = value;
	   }
	 
	   public double getMean() {
	      return this.Mean;
	   }
	 
	   public void setMean(double value) {
	      this.Mean = value;
	   }
	 
	   public double getSigma() {
	      return this.Sigma;
	   }
	 
	   public void setSigma(double value) {
	      this.Sigma = value;
	   }

	   public double getLastFCChange() {
		      return this.LastFCChange;
		}
		 
	   public void setLastFCChange(double value) {
	      this.LastFCChange = value;
	   }

	   
	   public double getLongtermForecast() {
	      return this.longtermForecast;
	   }
		 
	   public void setLongtermForecast(double value) {
	      this.longtermForecast = value;
	   }

	   
	   public String getForecastScenario() {
		      return this.forecastScenario;
		   }
			 
	   public void setForecastScenario(String value) {
	      this.forecastScenario = value;
	   }
	   
	public static String GetCSVHeader() {
		
		StringBuilder o = new StringBuilder();
		
		o.append("OrderId");
		o.append(";");
		o.append("Time");
		o.append(";");
		o.append("DueDate");
		o.append(";");
		o.append("Pbd");
		o.append(";");
		o.append("OldQantity");
		o.append(";");
		o.append("NewQuantity");
		o.append(";");
		o.append("Epsilon");
		o.append(";");
		o.append("Alpha");
		o.append(";");
		o.append("Mue");
		o.append(";");
		o.append("Mean");
		o.append(";");
		o.append("Sigma");
		o.append(";");
		o.append("Item");
		o.append(";");
		o.append("LastFCChange");
		o.append(";");
		o.append("LongtermForecast");
		o.append(";");
		o.append("Scenario");
		o.append(";");
		o.append("Transfer");

		return o.toString();
	}
	   
	public static String ToCSVString(ForecastHistory in) {
		
		StringBuilder o = new StringBuilder();
		
		o.append(in.getOrderId());
		o.append(";");
		o.append(in.getTime());
		o.append(";");
		o.append(in.getDueDate());
		o.append(";");
		o.append(in.getPbd());
		o.append(";");
		o.append(in.getOldQuantity());
		o.append(";");
		o.append(in.getNewQuantity());
		o.append(";");
		o.append(in.getEpsilon());
		o.append(";");
		o.append(in.getAlpha());
		o.append(";");
		o.append(in.getMue());
		o.append(";");
		o.append(in.getMean());
		o.append(";");
		o.append(in.getSigma());
		o.append(";");
		o.append(in.getItem());
		o.append(";");
		o.append(in.getLastFCChange());
		o.append(";");
		o.append(in.getLongtermForecast());
		o.append(";");
		o.append(in.getForecastScenario());
		o.append(";");
		o.append(in.getTransfer());
					
		return o.toString();
		
	}
	
	public static void WriteToFile(List<ForecastHistory> objectsToWrite) {
		
		SimpleDateFormat simpleDateFormat =
		new SimpleDateFormat("YYYYMMddhhmmss");
		String dateAsString = simpleDateFormat.format(new Date());
						
			File directory = new File ("output");
						
			if(!directory.exists())
				directory.mkdir();

			Random random = new Random();
			
			File file = new File(directory, "ForecastHistory"+dateAsString + random.nextInt(10)+ ".csv");
			
			       try(PrintWriter pw = new PrintWriter(new FileOutputStream(file))){
		               pw.println(ForecastHistory.GetCSVHeader());
			           for (ForecastHistory element : objectsToWrite) {
			               pw.println(element.ToCSVString(element));			               			               			               
			           }
			       }catch(Exception e)		{
			    	   traceln(e.getMessage());
			       }		       		
		}	
	   

	
	public static void DeleteFile(String fileName) {
		
	File myObj = new File(fileName); 
	
		try {
			if(myObj.exists()) {
			    if (myObj.delete()) { 
			      System.out.println("Deleted the file: " + myObj.getName());
			    } else {
			      System.out.println("Failed to delete the file: " + myObj.getName());
			    } 
			}
		}
		catch (Exception e)
		{
			traceln("Could not delete file " + fileName + " " +  e.getMessage());
		}    
	}

	
	public static void AppendToFile(String fileName, String textToAppend, Class classType, boolean deleteFile) {
				
		try{            
						
			FileOutputStream outputStream = new FileOutputStream(fileName, true);
			BufferedReader br = new BufferedReader(new FileReader(fileName));     			
									
			if (br.readLine() == null) {

				if(classType.getTypeName() == ForecastHistory.class.getTypeName())
					textToAppend = ForecastHistory.GetCSVHeader() + "\r\n" + textToAppend + "\r\n";
				
				if(classType.getTypeName() == MRP.class.getTypeName())
					textToAppend = MRP.GetCSVHeader() + "\r\n" + textToAppend + "\r\n";
				
				if(classType.getTypeName() == Distribution.class.getTypeName())
					textToAppend = Distribution.GetCSVHeader() + "\r\n" + textToAppend + "\r\n";
			
				if(classType.getTypeName() == CumulatedCapacity.class.getTypeName())
					textToAppend = CumulatedCapacity.GetCSVHeader() + "\r\n" + textToAppend + "\r\n";

				if(classType.getTypeName() == InventoryPosition.class.getTypeName())
					textToAppend = InventoryPosition.GetCSVHeader() + "\r\n" + textToAppend + "\r\n";

				
				
			}else {						    
				textToAppend = textToAppend + "\r\n";
			}
		    byte[] strToBytes = textToAppend.getBytes();		    		   
		    
		    br.close();
		    
		    outputStream.write(strToBytes);
		  
		    outputStream.close();
		   }
		catch (Exception e)
		{
			traceln("Could not write to file " + fileName + " " +  e.getMessage());
		}
		
		
	}
	

	@Override
	public String toString() {
		return super.toString();
	}

	/**
	 * This number is here for model snapshot storing purpose<br>
	 * It needs to be changed when this class gets changed
	 */ 
	private static final long serialVersionUID = 1L;

}]]></Text>
		</JavaClass>
		<!--   =========   Java Class   ========  -->
		<JavaClass>
			<Id>1639666338993</Id>
			<Name><![CDATA[OptimizationParameter]]></Name>
			<Text><![CDATA[import java.sql.DriverManager;
/**
 * OptimizationParameter
 */
public class OptimizationParameter implements Serializable {

  private int Id;

  private int ForecastScenario;
  private String Description;
  private Date CreatedAt;
  private Date UpdatedAt;
  private int Status;
  private String Experiment;
  private double X000;
  private double X001;
  private double X002;
  private double X003;
  private double X004;
  private double X005;
  private double X006;
  private double X007;
  private double X008;
  private double X009;
  private double X010;
  private double X011;
  private double X012;
  private double X013;
  private double X014;
  private double X015;
  private double X016;
  private double X017;
  private double X018;  
  private double X019;
  private double X020;
  
  private String SP000;
  private String SP001;
  private String SP002;
  private String SP003;
  private String SP004;
  private String SP005;
  private String SP006;
  private String SP007;
  private String SP008;
  private String SP009;
  private String SP010;
  private int SBM;
  private int SBMInitPhase;
  private int SBMLowerBoundReplications;
  private int FixedNumberReplications;
  private double SBMPercentilLB;
  private double SBMPercentilUB;
  private String S1;
  private String SimulationPC;
  private int MaxIterations;
  private String version;
  private Integer initializationPhase;
  private Double defaultCreditRange;
  private String simHeuristic;
  private Integer simAnnealing;
  private Double maxPercentil;
  private Double percentilStart;
  private Integer outlierCorrectionType;
  private Integer historyValues;
  private Double alpha;
  private String distributionType;
  private Double cbrrlb;
  private Integer minCBRRItems;
  private Integer defaultSAReset;  
  private String SimulationParameter;
  private int warmupPhase;
  private double V000;
  private double V001;
  private double V002;
  private double V003;
  private double V004;
  private double V005;
  private double V006;
  private double V007;
  private double V008;
  private double V009;
  private double V010;
  private double V011;
  private double V012;
  private double V013;
  private double V014;
  private double V015;
  private double V016;
  private double V017;
  private double V018;
  private double V019;
  private double V020;
  private double V021;
  private double V022;
  private double V023;
  private double V024;
  private double V025;
  private double V026;
  private double V027;
  private double V028;
  private double V029;
  private double V030;
  private double V031;
  private double V032;
  private double V033;
  private double V034;
  private double V035;
  private double V036;
  private double V037;
  private double V038;
  private double V039;
  private double V040;
  private double V041;
  private double V042;
  private double V043;
  private double V044;
  private double V045;
  private double V046;
  private double V047;
  private double V048;
  private double V049;
  private double V050;
  private double V051;
  private double V052;
  private double V053;
  private double V054;
  private String simulationExperiment;

  //public static final int OPTIMIZATION_PARAMETER_UNPROCESSED = 0;        
  public static final int ACTIVE_OPTIMIZATION_PARAMETER = 1;
  public static final int UNPROCESSED_OPTIMIZATION_PARAMETER = 0;
  public static final int PROCESSED_OPTIMIZATION_PARAMETER = 2;

  /**
   * Default constructor
   */
  public OptimizationParameter() {}
  
  
public String getSimulationExperiment() {
   return this.simulationExperiment;
}

public void setSimulationExperiment(String simulationExperiment) {
   this.simulationExperiment = simulationExperiment;
}
  
  public double getV000() {
      return V000;
  }

  public void setV000(double V000) {
      this.V000 = V000;
  }

  public double getV001() {
      return V001;
  }

  public void setV001(double V001) {
      this.V001 = V001;
  }

  public double getV002() {
      return V002;
  }

  public void setV002(double V002) {
      this.V002 = V002;
  }

  public double getV003() {
      return V003;
  }

  public void setV003(double V003) {
      this.V003 = V003;
  }

  public double getV004() {
      return V004;
  }

  public void setV004(double V004) {
      this.V004 = V004;
  }

  public double getV005() {
      return V005;
  }

  public void setV005(double V005) {
      this.V005 = V005;
  }

  public double getV006() {
      return V006;
  }

  public void setV006(double V006) {
      this.V006 = V006;
  }

  public double getV007() {
      return V007;
  }

  public void setV007(double V007) {
      this.V007 = V007;
  }

  public double getV008() {
      return V008;
  }

  public void setV008(double V008) {
      this.V008 = V008;
  }

  public double getV009() {
      return V009;
  }

  public void setV009(double V009) {
      this.V009 = V009;
  }

  public double getV010() {
      return V010;
  }

  public void setV010(double V010) {
      this.V010 = V010;
  }

  public double getV011() {
      return V011;
  }

  public void setV011(double V011) {
      this.V011 = V011;
  }

  public double getV012() {
      return V012;
  }

  public void setV012(double V012) {
      this.V012 = V012;
  }

  public double getV013() {
      return V013;
  }

  public void setV013(double V013) {
      this.V013 = V013;
  }

  public double getV014() {
      return V014;
  }

  public void setV014(double V014) {
      this.V014 = V014;
  }

  public double getV015() {
      return V015;
  }

  public void setV015(double V015) {
      this.V015 = V015;
  }

  public double getV016() {
      return V016;
  }

  public void setV016(double V016) {
      this.V016 = V016;
  }

  public double getV017() {
      return V017;
  }

  public void setV017(double V017) {
      this.V017 = V017;
  }

  public double getV018() {
      return V018;
  }

  public void setV018(double V018) {
      this.V018 = V018;
  }

  public double getV019() {
      return V019;
  }

  public void setV019(double V019) {
      this.V019 = V019;
  }

  public double getV020() {
      return V020;
  }

  public void setV020(double V020) {
      this.V020 = V020;
  }

  public double getV021() {
      return V021;
  }

  public void setV021(double V021) {
      this.V021 = V021;
  }

  public double getV022() {
      return V022;
  }

  public void setV022(double V022) {
      this.V022 = V022;
  }

  public double getV023() {
      return V023;
  }

  public void setV023(double V023) {
      this.V023 = V023;
  }

  public double getV024() {
      return V024;
  }

  public void setV024(double V024) {
      this.V024 = V024;
  }

  public double getV025() {
      return V025;
  }

  public void setV025(double V025) {
      this.V025 = V025;
  }

  public double getV026() {
      return V026;
  }

  public void setV026(double V026) {
      this.V026 = V026;
  }

  public double getV027() {
      return V027;
  }

  public void setV027(double V027) {
      this.V027 = V027;
  }

  public double getV028() {
      return V028;
  }

  public void setV028(double V028) {
      this.V028 = V028;
  }

  public double getV029() {
      return V029;
  }

  public void setV029(double V029) {
      this.V029 = V029;
  }
  
  public double getV030() {
      return V030;
  }

  public void setV030(double V030) {
      this.V030 = V030;
  }
  
  public double getV031() {
      return V031;
  }

  public void setV031(double V031) {
      this.V031 = V031;
  }
 
  public double getV032() {
      return V032;
  }

  public void setV032(double V032) {
      this.V032 = V032;
  }


	public double getV033() {
	    return V033;
	}

	public void setV033(double V033) {
	    this.V033 = V033;
	}

	public double getV034() {
	    return V034;
	}

	public void setV034(double V034) {
	    this.V034 = V034;
	}

	public double getV035() {
	    return V035;
	}

	public void setV035(double V035) {
	    this.V035 = V035;
	}

	public double getV036() {
	    return V036;
	}

	public void setV036(double V036) {
	    this.V036 = V036;
	}

	public double getV037() {
	    return V037;
	}

	public void setV037(double V037) {
	    this.V037 = V037;
	}

	public double getV038() {
	    return V038;
	}

	public void setV038(double V038) {
	    this.V038 = V038;
	}

	public double getV039() {
	    return V039;
	}

	public void setV039(double V039) {
	    this.V039 = V039;
	}

	public double getV040() {
	    return V040;
	}

	public void setV040(double V040) {
	    this.V040 = V040;
	}

	public double getV041() {
	    return V041;
	}

	public void setV041(double V041) {
	    this.V041 = V041;
	}

	public double getV042() {
	    return V042;
	}

	public void setV042(double V042) {
	    this.V042 = V042;
	}

	public double getV043() {
	    return V043;
	}

	public void setV043(double V043) {
	    this.V043 = V043;
	}


	public double getV044() {
	    return V044;
	}

	public void setV044(double V044) {
	    this.V044 = V044;
	}

	public double getV045() {
	    return V045;
	}

	public void setV045(double V045) {
	    this.V045 = V045;
	}

	public double getV046() {
	    return V046;
	}

	public void setV046(double V046) {
	    this.V046 = V046;
	}

	public double getV047() {
	    return V047;
	}

	public void setV047(double V047) {
	    this.V047 = V047;
	}

	public double getV048() {
	    return V048;
	}

	public void setV048(double V048) {
	    this.V048 = V048;
	}

	public double getV049() {
	    return V049;
	}

	public void setV049(double V049) {
	    this.V049 = V049;
	}

	public double getV050() {
	    return V050;
	}

	public void setV050(double V050) {
	    this.V050 = V050;
	}

	public double getV051() {
	    return V051;
	}

	public void setV051(double V051) {
	    this.V051 = V051;
	}

	public double getV052() {
	    return V052;
	}

	public void setV052(double V052) {
	    this.V052 = V052;
	}
	
	public double getV053() {
	    return V053;
	}

	public void setV053(double V053) {
	    this.V053 = V053;
	}

	public double getV054() {
	    return V054;
	}

	public void setV054(double V054) {
	    this.V054 = V054;
	}
	
	
  public int getWarmupPhase() {
      return warmupPhase;
  }

  public void setWarmupPhase(int warmupPhase) {
      this.warmupPhase = warmupPhase;
  }
  
  
  public Integer getInitializationPhase() {
      return initializationPhase;
  }

  public void setInitializationPhase(Integer initializationPhase) {
      this.initializationPhase = initializationPhase;
  }

  public Double getDefaultCreditRange() {
      return defaultCreditRange;
  }

  public void setDefaultCreditRange(Double defaultCreditRange) {
      this.defaultCreditRange = defaultCreditRange;
  }

  public String getSimHeuristic() {
      return simHeuristic;
  }

  public void setSimHeuristic(String simHeuristic) {
      this.simHeuristic = simHeuristic;
  }

  public Integer getSimAnnealing() {
      return simAnnealing;
  }

  public void setSimAnnealing(Integer simAnnealing) {
      this.simAnnealing = simAnnealing;
  }

  public Double getMaxPercentil() {
      return maxPercentil;
  }

  public void setMaxPercentil(Double maxPercentil) {
      this.maxPercentil = maxPercentil;
  }

  public Double getPercentilStart() {
      return percentilStart;
  }

  public void setPercentilStart(Double percentilStart) {
      this.percentilStart = percentilStart;
  }

  public Integer getOutlierCorrectionType() {
      return outlierCorrectionType;
  }

  public void setOutlierCorrectionType(Integer outlierCorrectionType) {
      this.outlierCorrectionType = outlierCorrectionType;
  }

  public Integer getHistoryValues() {
      return historyValues;
  }

  public void setHistoryValues(Integer historyValues) {
      this.historyValues = historyValues;
  }

  public Double getAlpha() {
      return alpha;
  }

  public void setAlpha(Double alpha) {
      this.alpha = alpha;
  }

  public String getDistributionType() {
      return distributionType;
  }

  public void setDistributionType(String distributionType) {
      this.distributionType = distributionType;
  }

  public Double getCbrrlb() {
      return cbrrlb;
  }

  public void setCbrrlb(Double cbrrlb) {
      this.cbrrlb = cbrrlb;
  }

  public Integer getMinCBRRItems() {
      return minCBRRItems;
  }

  public void setMinCBRRItems(Integer minCBRRItems) {
      this.minCBRRItems = minCBRRItems;
  }

  public Integer getDefaultSAReset() {
      return defaultSAReset;
  }

  public void setDefaultSAReset(Integer defaultSAReset) {
      this.defaultSAReset = defaultSAReset;
  }
  
  // Getter method for version
  public String getVersion() {
      return version;
  }

  // Setter method for version
  public void setVersion(String version) {
      this.version = version;
  }
  
  public double getX018() {
     return this.X018;
  }

  public void setX018(double value) {
     this.X018 = value;
  }

  public double getX019() {
     return this.X019;
  }

  public void setX019(double value) {
     this.X019 = value;
  }

  public double getX020() {
     return this.X020;
  }

  public void setX020(double value) {
     this.X020 = value;
  }
  

  public String getSP000() {
    return this.SP000;
  }

  public void setSP000(String value) {
    this.SP000 = value;
  }

  public String getSP001() {
    return this.SP001;
  }

  public void setSP001(String value) {
    this.SP001 = value;
  }

  public String getSP002() {
    return this.SP002;
  }

  public void setSP002(String value) {
    this.SP002 = value;
  }

  public String getSP003() {
    return this.SP003;
  }

  public void setSP003(String value) {
    this.SP003 = value;
  }

  public String getSP004() {
    return this.SP004;
  }

  public void setSP004(String value) {
    this.SP004 = value;
  }

  public String getSP005() {
    return this.SP005;
  }

  public void setSP005(String value) {
    this.SP005 = value;
  }

  public String getSP006() {
    return this.SP006;
  }

  public void setSP006(String value) {
    this.SP006 = value;
  }

  public String getSP007() {
    return this.SP007;
  }

  public void setSP007(String value) {
    this.SP007 = value;
  }
  
  public String getSP008() {
      return this.SP008;
  }
 
   public void setSP008(String value) {
      this.SP008 = value;
  }
  
  public String getSP009() {
    return this.SP009;
  }

  public void setSP009(String value) {
    this.SP009 = value;
  }

  public String getSP010() {
    return this.SP010;
  }

  public void setSP010(String value) {
    this.SP010 = value;
  }

  public String getSimulationParameter() {
    return this.SimulationParameter;
  }

  public void setSimulationParameter(String value) {
    this.SimulationParameter = value;
  }

  public int getMaxIterations() {
    return this.MaxIterations;
  }

  public void setMaxIterations(int value) {
    this.MaxIterations = value;
  }

  public double getSBMPercentilLB() {
    return this.SBMPercentilLB;
  }

  public void setSBMPercentilLB(double value) {
    this.SBMPercentilLB = value;
  }

  public double getSBMPercentilUB() {
    return this.SBMPercentilUB;
  }

  public void setSBMPercentilUB(double value) {
    this.SBMPercentilUB = value;
  }

  public int getFixedNumberReplications() {
    return this.FixedNumberReplications;
  }

  public void setFixedNumberReplications(int value) {
    this.FixedNumberReplications = value;
  }

  public int getSBMLowerBoundReplications() {
    return this.SBMLowerBoundReplications;
  }

  public void setSBMLowerBoundReplications(int value) {
    this.SBMLowerBoundReplications = value;
  }

  public int getSBM() {
    return this.SBM;
  }

  public void setSBM(int value) {
    this.SBM = value;
  }

  public int getSBMInitPhase() {
    return this.SBMInitPhase;
  }

  public void setSBMInitPhase(int value) {
    this.SBMInitPhase = value;
  }

  public int getId() {
    return this.Id;
  }

  public void setId(int value) {
    this.Id = value;
  }

  public int getForecastScenario() {
    return this.ForecastScenario;
  }

  public void setForecastScenario(int value) {
    this.ForecastScenario = value;
  }

  public String getDescription() {
    return this.Description;
  }

  public void setDescription(String value) {
    this.Description = value;
  }

  public Date getCreatedAt() {
    return this.CreatedAt;
  }

  public void setCreatedAt(Date value) {
    this.CreatedAt = value;
  }

  public Date getUpdatedAt() {
    return this.UpdatedAt;
  }

  public void setUpdatedAt(Date value) {
    this.UpdatedAt = value;
  }

  public int getStatus() {
    return this.Status;
  }

  public void setStatus(int value) {
    this.Status = value;
  }

  public String getExperiment() {
    return this.Experiment;
  }

  public void setExperiment(String value) {
    this.Experiment = value;
  }

  public double getX000() {
    return this.X000;
  }

  public void setX000(double value) {
    this.X000 = value;
  }

  public double getX001() {
    return this.X001;
  }

  public void setX001(double value) {
    this.X001 = value;
  }

  public double getX002() {
    return this.X002;
  }

  public void setX002(double value) {
    this.X002 = value;
  }

  public double getX003() {
    return this.X003;
  }

  public void setX003(double value) {
    this.X003 = value;
  }

  public double getX004() {
    return this.X004;
  }

  public void setX004(double value) {
    this.X004 = value;
  }

  public double getX005() {
    return this.X005;
  }

  public void setX005(double value) {
    this.X005 = value;
  }

  public double getX006() {
    return this.X006;
  }

  public void setX006(double value) {
    this.X006 = value;
  }

  public double getX007() {
    return this.X007;
  }

  public void setX007(double value) {
    this.X007 = value;
  }

  public double getX008() {
    return this.X008;
  }

  public void setX008(double value) {
    this.X008 = value;
  }

  public double getX009() {
    return this.X009;
  }

  public void setX009(double value) {
    this.X009 = value;
  }

  public double getX010() {
    return this.X010;
  }

  public void setX010(double value) {
    this.X010 = value;
  }

  public double getX011() {
    return this.X011;
  }

  public void setX011(double value) {
    this.X011 = value;
  }

  public double getX012() {
    return this.X012;
  }

  public void setX012(double value) {
    this.X012 = value;
  }

  public double getX013() {
    return this.X013;
  }

  public void setX013(double value) {
    this.X013 = value;
  }

  public double getX014() {
    return this.X014;
  }

  public void setX014(double value) {
    this.X014 = value;
  }

  public double getX015() {
    return this.X015;
  }

  public void setX015(double value) {
    this.X015 = value;
  }

  public double getX016() {
    return this.X016;
  }

  public void setX016(double value) {
    this.X016 = value;
  }

  public double getX017() {
    return this.X017;
  }

  public void setX017(double value) {
    this.X017 = value;
  }

  public String getS1() {
    return this.S1;
  }

  public void setS1(String value) {
    this.S1 = value;
  }

  public String getSimulationPC() {
    return this.SimulationPC;
  }

  public void setSimulationPC(String value) {
    this.SimulationPC = value;
  }

  public static OptimizationParameter GetRemoteOptimizationParameterH2(boolean nextAvailable, int status, String pcName, SimulationParameter simParams) {

    OptimizationParameter optParam = new OptimizationParameter();
    optParam.setId(0);

    try {

      DBQueries db = new DBQueries();
      Connection connection = db.ConnectH2();
      StringBuilder sql = new StringBuilder();

      if (nextAvailable) {
    	  traceln("Random Optimizationparameter: " + simParams.getRandomOptimizationParameter());
    	if(simParams.getRandomOptimizationParameter() == 1) {    		
    		sql.append("select top 1 * from OptimizationParameter where status = " + OptimizationParameter.UNPROCESSED_OPTIMIZATION_PARAMETER + " ORDER BY rand(); ");
    	}else {
    		sql.append("select top 1 * from OptimizationParameter where status = " + OptimizationParameter.UNPROCESSED_OPTIMIZATION_PARAMETER + " ");    		
    	}
        
      } else {
        sql.append("select * from OptimizationParameter where status = " + status + " and SimulationPC = '" + pcName + "' ");
      }

      java.sql.Statement statement = connection.createStatement();
      java.sql.ResultSet resultSet = statement.executeQuery(sql.toString());
      
      traceln("sqlString " + sql.toString());
      
      if (resultSet.next()) {
        optParam = GetOptimizatioParameterFromRecordSet(resultSet);
      }

      connection.close();

    } catch (Exception e) {
      traceln("error:" + e);
    }

    return optParam;

  }

  
  public static OptimizationParameter GetRemoteOptimizationParameterPostGres(boolean nextAvailable, int status, String pcName, SimulationParameter simParams) {

	    OptimizationParameter optParam = new OptimizationParameter();
	    optParam.setId(0);
	    traceln("Remoteparameter PostGres");

	    try {

	      DBQueries db = new DBQueries();
	      Connection connection = db.ConnectPostGreSql();
	      StringBuilder sql = new StringBuilder();

	      if (nextAvailable) {
	    	  traceln("Random Optimizationparameter: " + simParams.getRandomOptimizationParameter());
	    	if(simParams.getRandomOptimizationParameter() == 1) {    		
	    		sql.append("select * from OptimizationParameter where status = " + OptimizationParameter.UNPROCESSED_OPTIMIZATION_PARAMETER + " ORDER BY random() Limit 1; ");
	    	}else {
	    		sql.append("select * from OptimizationParameter where status = " + OptimizationParameter.UNPROCESSED_OPTIMIZATION_PARAMETER + " Limit 1;");    		
	    	}
	        
	      } else {
	        sql.append("select * from OptimizationParameter where status = " + status + " and SimulationPC = '" + pcName + "' ");
	      }

	      java.sql.Statement statement = connection.createStatement();
	      java.sql.ResultSet resultSet = statement.executeQuery(sql.toString());
	      
	      traceln("sqlString " + sql.toString());
	      
	      if (resultSet.next()) {
	        optParam = GetOptimizatioParameterFromRecordSet(resultSet);
	      }

	      connection.close();

	    } catch (Exception e) {
	      traceln("error:" + e);
	    }

	    return optParam;

	  }
  
  public static OptimizationParameter GetOptimizatioParameterFromRecordSet(java.sql.ResultSet rs) {

    OptimizationParameter optParam = new OptimizationParameter();
    optParam.setId(0);
    try {
    	
      optParam.setId(rs.getInt("Id"));
      optParam.setDescription(rs.getString("Description"));
      optParam.setExperiment(rs.getString("Experiment"));
      optParam.setStatus(rs.getInt("Status"));
      optParam.setForecastScenario(rs.getInt("ForecastScenario"));
      optParam.setSimulationPC(rs.getString("SimulationPC"));
      optParam.setSBM(rs.getInt("SBM"));
      optParam.setSBMInitPhase(rs.getInt("SBMInitPhase"));
      optParam.setSBMLowerBoundReplications(rs.getInt("SBMLowerBoundReplications"));
      optParam.setFixedNumberReplications(rs.getInt("FixedNumberReplications"));
      optParam.setSBMPercentilLB(rs.getDouble("SBMPercentilLB"));
      optParam.setSBMPercentilUB(rs.getDouble("SBMPercentilUB"));
      optParam.setMaxIterations(rs.getInt("MaxIterations"));
      optParam.setSimulationParameter(rs.getString("SimulationParameter"));
      optParam.setVersion(rs.getString("version"));

      optParam.setX000(rs.getDouble("X000"));
      optParam.setX001(rs.getDouble("X001"));
      optParam.setX002(rs.getDouble("X002"));

      optParam.setX003(rs.getDouble("X003"));
      optParam.setX004(rs.getDouble("X004"));
      optParam.setX005(rs.getDouble("X005"));

      optParam.setX006(rs.getDouble("X006"));
      optParam.setX007(rs.getDouble("X007"));
      optParam.setX008(rs.getDouble("X008"));

      optParam.setX009(rs.getDouble("X009"));
      optParam.setX010(rs.getDouble("X010"));
      optParam.setX011(rs.getDouble("X011"));

      optParam.setX012(rs.getDouble("X012"));
      optParam.setX013(rs.getDouble("X013"));
      optParam.setX014(rs.getDouble("X014"));

      optParam.setX015(rs.getDouble("X015"));
      optParam.setX016(rs.getDouble("X016"));
      optParam.setX017(rs.getDouble("X017"));
      optParam.setX018(rs.getDouble("X018"));
      optParam.setX019(rs.getDouble("X019"));
      optParam.setX020(rs.getDouble("X020"));
      
      optParam.setSP000(rs.getString("SP000"));
      optParam.setSP001(rs.getString("SP001"));
      optParam.setSP002(rs.getString("SP002"));
      optParam.setSP003(rs.getString("SP003"));
      optParam.setSP004(rs.getString("SP004"));
      optParam.setSP005(rs.getString("SP005"));
      optParam.setSP006(rs.getString("SP006"));
      optParam.setSP007(rs.getString("SP007"));
      optParam.setSP008(rs.getString("SP008"));
      optParam.setSP009(rs.getString("SP009"));
      optParam.setSP010(rs.getString("SP010"));
      
      optParam.setInitializationPhase(rs.getInt("InitializationPhase"));

      optParam.setDefaultCreditRange(rs.getDouble("DefaultCreditRange"));
      optParam.setSimAnnealing(rs.getInt("SimAnnealing"));
      optParam.setMaxPercentil(rs.getDouble("MaxPercentil"));
      optParam.setPercentilStart(rs.getDouble("PercentilStart"));

      optParam.setOutlierCorrectionType(rs.getInt("outlierCorrectionType"));
      optParam.setHistoryValues(rs.getInt("historyValues"));
      optParam.setAlpha(rs.getDouble("alpha"));
      optParam.setCbrrlb(rs.getDouble("cbrrlb"));

      optParam.setMinCBRRItems(rs.getInt("minCBRRItems"));
      optParam.setDefaultSAReset(rs.getInt("defaultSAReset"));
      optParam.setWarmupPhase(rs.getInt("WarmUpPhase"));
      optParam.setDistributionType(rs.getString("distributionType"));

      optParam.setSimHeuristic(rs.getString("simheuristic"));
      optParam.setVersion(rs.getString("version"));

      optParam.setV000(rs.getDouble("V000"));
      optParam.setV001(rs.getDouble("V001"));
      optParam.setV002(rs.getDouble("V002"));
      optParam.setV003(rs.getDouble("V003"));
      optParam.setV004(rs.getDouble("V004"));
      optParam.setV005(rs.getDouble("V005"));
      optParam.setV006(rs.getDouble("V006"));
      optParam.setV007(rs.getDouble("V007"));
      optParam.setV008(rs.getDouble("V008"));
      optParam.setV009(rs.getDouble("V009"));

      optParam.setV010(rs.getDouble("V010"));
      optParam.setV011(rs.getDouble("V011"));
      optParam.setV012(rs.getDouble("V012"));
      optParam.setV013(rs.getDouble("V013"));
      optParam.setV014(rs.getDouble("V014"));
      optParam.setV015(rs.getDouble("V015"));
      optParam.setV016(rs.getDouble("V016"));
      optParam.setV017(rs.getDouble("V017"));
      optParam.setV018(rs.getDouble("V018"));
      optParam.setV019(rs.getDouble("V019"));

      optParam.setV020(rs.getDouble("V020"));
      optParam.setV021(rs.getDouble("V021"));
      optParam.setV022(rs.getDouble("V022"));
      optParam.setV023(rs.getDouble("V023"));
      optParam.setV024(rs.getDouble("V024"));
      optParam.setV025(rs.getDouble("V025"));
      optParam.setV026(rs.getDouble("V026"));
      optParam.setV027(rs.getDouble("V027"));
      optParam.setV028(rs.getDouble("V028"));
      optParam.setV029(rs.getDouble("V029"));
      optParam.setV030(rs.getDouble("V030"));
      optParam.setV031(rs.getDouble("V031"));
      optParam.setV032(rs.getDouble("V032"));
      optParam.setV033(rs.getDouble("V033"));
      optParam.setV034(rs.getDouble("V034"));
      optParam.setV035(rs.getDouble("V035"));
      optParam.setV036(rs.getDouble("V036"));
      optParam.setV037(rs.getDouble("V037"));
      optParam.setV038(rs.getDouble("V038"));
      optParam.setV039(rs.getDouble("V039"));
      optParam.setV040(rs.getDouble("V040"));
      optParam.setV041(rs.getDouble("V041"));
      optParam.setV042(rs.getDouble("V042"));
      optParam.setV043(rs.getDouble("V043"));
      optParam.setV044(rs.getDouble("V044"));
      optParam.setV045(rs.getDouble("V045"));
      optParam.setV046(rs.getDouble("V046"));
      optParam.setV047(rs.getDouble("V047"));
      optParam.setV048(rs.getDouble("V048"));
      optParam.setV049(rs.getDouble("V049"));
      optParam.setV050(rs.getDouble("V050"));
      optParam.setV051(rs.getDouble("V051"));
      optParam.setV052(rs.getDouble("V052"));
      optParam.setV053(rs.getDouble("V053"));
      optParam.setV054(rs.getDouble("V054"));
      
      optParam.setSimulationExperiment(rs.getString("SimulationExperiment"));
      
    } catch (Exception ex) {
      traceln(ex.getMessage());
    }

    return optParam;

  }

  public static int GetNumberNotProcessedParameters(SimulationParameter simParams, boolean parameterVariation, boolean allOptimizationParameters) {

    int count = 0;
    StringBuilder sqlQueryString = new StringBuilder();

    try {
    	
    	if(allOptimizationParameters) {
    		sqlQueryString.append("select count(*) as COUNT from OPTIMIZATIONPARAMETER;");
    	}else {
    		sqlQueryString.append("select count(*) as COUNT from OPTIMIZATIONPARAMETER where status < " + PROCESSED_OPTIMIZATION_PARAMETER + ";");
    	}

      traceln(sqlQueryString);
      DBQueries db = new DBQueries();

      java.sql.Connection conn = db.connect();

      if (simParams.getOptimizationParameterSource().toUpperCase().equals(simParams.OPTIMIZATION_PARAMETER_SOURCE_H2) && parameterVariation) {
        conn = db.ConnectH2();
      }else if(simParams.getOptimizationParameterSource().toUpperCase().equalsIgnoreCase(simParams.OPTIMIZATION_PARAMETER_SOURCE_POSTGRES) && parameterVariation) {    	  
          conn = db.ConnectPostGreSql();
      }

      java.sql.Statement stmt = conn.createStatement();
      java.sql.ResultSet rs = stmt.executeQuery(sqlQueryString.toString());;

      while (rs.next()) {
        count = rs.getInt("COUNT");
      }

      conn.close();
    } catch (Exception e) {
      System.out.println("error:" + e);
    }

    return count;

  }

  public static String GetCSVHeader() {

    StringBuilder out = new StringBuilder();

    out.append("Id;");
    out.append("Description;");
    out.append("Experiment;");
    out.append("Status;");
    out.append("ForecastScenario;");
    out.append("SimulationPC;");
    out.append("X000;");
    out.append("X001;");
    out.append("X002;");
    out.append("X003;");
    out.append("X004;");
    out.append("X005;");
    out.append("X006;");
    out.append("X007;");
    out.append("X008;");
    out.append("X009;");
    out.append("X010;");
    out.append("X011;");
    out.append("X012;");
    out.append("X013;");
    out.append("S1;");

    return out.toString();
  }

  public static String GetCSVString(OptimizationParameter obj) {

    StringBuilder out = new StringBuilder();

    out.append(obj.getId() + ";");
    out.append(obj.getDescription() + ";");
    out.append(obj.getExperiment() + ";");
    out.append(obj.getStatus() + ";");
    out.append(obj.getForecastScenario() + ";");
    out.append(obj.getSimulationPC() + ";");
    out.append(obj.getX000() + ";");
    out.append(obj.getX001() + ";");
    out.append(obj.getX002() + ";");
    out.append(obj.getX003() + ";");
    out.append(obj.getX004() + ";");
    out.append(obj.getX005() + ";");
    out.append(obj.getX006() + ";");
    out.append(obj.getX007() + ";");
    out.append(obj.getX008() + ";");
    out.append(obj.getX009() + ";");
    out.append(obj.getX010() + ";");
    out.append(obj.getX011() + ";");
    out.append(obj.getX012() + ";");
    out.append(obj.getX013() + ";");
    out.append(obj.getS1() + ";");

    return out.toString();

  }
  
  @Override
  public String toString() {
      return "OptimizationParameter{" +
              "Id=" + Id +
              ", ForecastScenario=" + ForecastScenario +
              ", Description='" + Description + '\'' +
              ", CreatedAt=" + CreatedAt +
              ", UpdatedAt=" + UpdatedAt +
              ", Status=" + Status +
              ", Experiment='" + Experiment + '\'' +
              ", X000=" + X000 +
              ", X001=" + X001 +
              ", X002=" + X002 +
              ", X003=" + X003 +
              ", X004=" + X004 +
              ", X005=" + X005 +
              ", X006=" + X006 +
              ", X007=" + X007 +
              ", X008=" + X008 +
              ", X009=" + X009 +
              ", X010=" + X010 +
              ", X011=" + X011 +
              ", X012=" + X012 +
              ", X013=" + X013 +
              ", X014=" + X014 +
              ", X015=" + X015 +
              ", X016=" + X016 +
              ", X017=" + X017 +
              ", X018=" + X018 +
              ", X019=" + X019 +
              ", X020=" + X020 +
              ", SP000='" + SP000 + '\'' +
              ", SP001='" + SP001 + '\'' +
              ", SP002='" + SP002 + '\'' +
              ", SP003='" + SP003 + '\'' +
              ", SP004='" + SP004 + '\'' +
              ", SP005='" + SP005 + '\'' +
              ", SP006='" + SP006 + '\'' +
              ", SP007='" + SP007 + '\'' +
              ", SP008='" + SP008 + '\'' +
              ", SP009='" + SP009 + '\'' +
              ", SP010='" + SP010 + '\'' +
              ", SBM=" + SBM +
              ", SBMInitPhase=" + SBMInitPhase +
              ", SBMLowerBoundReplications=" + SBMLowerBoundReplications +
              ", FixedNumberReplications=" + FixedNumberReplications +
              ", SBMPercentilLB=" + SBMPercentilLB +
              ", SBMPercentilUB=" + SBMPercentilUB +
              ", S1='" + S1 + '\'' +
              ", SimulationPC='" + SimulationPC + '\'' +
              ", MaxIterations=" + MaxIterations +
              ", version='" + version + '\'' +
              ", initializationPhase=" + initializationPhase +
              ", defaultCreditRange=" + defaultCreditRange +
              ", simHeuristic='" + simHeuristic + '\'' +
              ", simAnnealing=" + simAnnealing +
              ", maxPercentil=" + maxPercentil +
              ", percentilStart=" + percentilStart +
              ", outlierCorrectionType=" + outlierCorrectionType +
              ", historyValues=" + historyValues +
              ", alpha=" + alpha +
              ", distributionType='" + distributionType + '\'' +
              ", cbrrlb=" + cbrrlb +
              ", minCBRRItems=" + minCBRRItems +
              ", defaultSAReset=" + defaultSAReset +
              ", SimulationParameter='" + SimulationParameter + '\'' +
              ", warmupPhase=" + warmupPhase +
              ", V000=" + V000 +
              ", V001=" + V001 +
              ", V002=" + V002 +
              ", V003=" + V003 +
              ", V004=" + V004 +
              ", V005=" + V005 +
              ", V006=" + V006 +
              ", V007=" + V007 +
              ", V008=" + V008 +
              ", V009=" + V009 +
              ", V010=" + V010 +
              ", V011=" + V011 +
              ", V012=" + V012 +
              ", V013=" + V013 +
              ", V014=" + V014 +
              ", V015=" + V015 +
              ", V016=" + V016 +
              ", V017=" + V017 +
              ", V018=" + V018 +
              ", V019=" + V019 +
              ", V020=" + V020 +
              ", V021=" + V021 +
              ", V022=" + V022 +
              ", V023=" + V023 +
              ", V024=" + V024 +
              ", V025=" + V025 +
              ", V026=" + V026 +
              ", V027=" + V027 +
              ", V028=" + V028 +
              ", V029=" + V029 +
              ", V030=" + V030 +
              ", V031=" + V031 +
              ", V032=" + V032 +
              ", V033=" + V033 +
              ", V034=" + V034 +
				", V035=" + V035 +
				", V036=" + V036 +
				", V037=" + V037 +
				", V038=" + V038 +
				", V039=" + V039 +
				", V040=" + V040 +
				", V041=" + V041 +
				", V042=" + V042 +
				", V043=" + V043 +
				", V044=" + V044 +
				", V045=" + V045 +
				", V046=" + V046 +
				", V047=" + V047 +
				", V048=" + V048 +
				", V049=" + V049 +
				", V050=" + V050 +
				", V051=" + V051 + 
				", V052=" + V052 + 
				", V053=" + V053 + 
				", V054=" + V054 + 

              ", simulationExperiment='" + simulationExperiment + '\'' +
              '}';
  }


}]]></Text>
		</JavaClass>
		<!--   =========   Java Class   ========  -->
		<JavaClass>
			<Id>1639990266208</Id>
			<Name><![CDATA[Routing]]></Name>
			<Text><![CDATA[import java.io.Serializable;
import com.google.gson.annotations.Expose;

/**
 * Routing
 */	
public class Routing implements Serializable {

	@Expose
    private int Id;
	
   private Item Item;
	@Expose 
   private double EProcessingTime;
	@Expose
   private double ESetupTime;
	@Expose
   private String Description;
	@Expose
   private String Experiment;
	@Expose
   private String DistProcessingTime;
	@Expose
   private String DistSetupTime;
	@Expose
   private String Resource;
	@Expose
   private double SSetupTime;
	@Expose
   private double SProcessingTime;
	@Expose
   private int Step;

   public int getStep() {
	   return this.Step;
   }
	 
   public void setStep(int value) {
      this.Step = value;
   }
   
   public double getSSetupTime() {
      return this.SSetupTime;
   }
 
   public void setSSetupTime(double value) {
      this.SSetupTime = value;
   }
 
   public double getSProcessingTime() {
      return this.SProcessingTime;
   }
 
   public void setSProcessingTime(double value) {
      this.SProcessingTime = value;
   }
   
   public String getResource() {
      return this.Resource;
   }
 
   public void setResource(String value) {
      this.Resource = value;
   }
   
    public Routing() {
    }

    public int getId() {
        return this.Id;
     }
   
     public void setId(int value) {
        this.Id = value;
     }
   
     public Item getItem() {
        return this.Item;
     }
   
     public void setItem(Item value) {
        this.Item = value;
     }
   
     public double getEProcessingTime() {
        return this.EProcessingTime;
     }
   
     public void setEProcessingTime(double value) {
        this.EProcessingTime = value;
     }
   
     public double getESetupTime() {
        return this.ESetupTime;
     }
   
     public void setESetupTime(double value) {
        this.ESetupTime = value;
     }
   
     public String getDescription() {
        return this.Description;
     }
   
     public void setDescription(String value) {
        this.Description = value;
     }
   
     public String getExperiment() {
        return this.Experiment;
     }
   
     public void setExperiment(String value) {
        this.Experiment = value;
     }
   
     public String getDistProcessingTime() {
        return this.DistProcessingTime;
     }
   
     public void setDistProcessingTime(String value) {
        this.DistProcessingTime = value;
     }
   
     public String getDistSetupTime() {
        return this.DistSetupTime;
     }
   
     public void setDistSetupTime(String value) {
        this.DistSetupTime = value;
     }
     
     public static int GetMinimumStep(List<Routing> routings, Item item, SimulationParameter simParams) {	 
    	 
    	 Routing minStep = routings.stream().filter(e -> e.getItem().getItem() == item.getItem() 
    			 && e.getExperiment().equals(simParams.getExperiment())).min(Comparator.comparing(Routing::getStep)).orElse(null);
    	 
    	 return minStep.getStep();    	 
     }
     
     public static int GetMaximumStep(List<Routing> routings, Item item, SimulationParameter simParams) {
     	 
    	 Routing maxStep = routings.stream().filter(e -> e.getItem().getItem() == item.getItem() 
    			 && e.getExperiment().equals(simParams.getExperiment())).max(Comparator.comparing(Routing::getStep)).orElse(null);
    	     	     			 
    	 return maxStep.getStep();    	 
     }

     
     public static Routing GetResourceForRoutingStep(List<Routing> routings, Item item, int step, SimulationParameter simParams) {
     	    	
    	 
    	 Routing maxStep = routings.stream().filter(e -> e.getItem().getItem() == item.getItem() && e.getStep() == step
    			 && e.getExperiment().equals(simParams.getExperiment())).max(Comparator.comparing(Routing::getStep)).orElse(null);
    	     	     			 
    	 return maxStep;    	 
     }          
          
     
     public static double GetPlannedCapacityPerItem(List<Routing> routings, Item item, SimulationParameter simParams, ProductionOrder prodOrder) {
     	 
    	 double eProcessingTime = routings.stream().filter(e -> e.getItem().getItem() == item.getItem() 
    			 && e.getExperiment().equals(simParams.getExperiment())).mapToDouble(Routing::getEProcessingTime).sum();
    	     	 
    	 double eSetupTime = routings.stream().filter(e -> e.getItem().getItem() == item.getItem() 
    			 && e.getExperiment().equals(simParams.getExperiment())).mapToDouble(Routing::getESetupTime).sum();
    	 
    	 double plannedCapacity = eProcessingTime * prodOrder.getQuantity() + eSetupTime;
    	     	     			 
    	 return plannedCapacity;    	 
     }
     
     
     public static double GetPlannedSetupTimePerItem(List<Routing> routings, Item item, SimulationParameter simParams, ProductionOrder prodOrder) {
    	     	 
    	 double eSetupTime = routings.stream().filter(e -> e.getItem().getItem() == item.getItem() 
    			 && e.getExperiment().equals(simParams.getExperiment())).mapToDouble(Routing::getESetupTime).sum();
    	    	     			 
    	 return eSetupTime;    	 
     }  
     
     
     public static double GetPlannedCapacityPerItemAndMachine(Main main, ProductionOrder prodOrder, String MachineName) {
     	 
    	 double eProcessingTime = main.routings.stream().filter(e -> e.getItem().getItem() == prodOrder.getItem().getItem() 
    			 && e.getExperiment().equals(main.simParams.getExperiment()) && e.getResource().equalsIgnoreCase(MachineName)
    					 ).mapToDouble(Routing::getEProcessingTime).sum();
    	     	 
    	 double eSetupTime = main.routings.stream().filter(e -> e.getItem().getItem() == prodOrder.getItem().getItem() 
    			 && e.getExperiment().equals(main.simParams.getExperiment()) && e.getResource().equalsIgnoreCase(MachineName)
    					 ).mapToDouble(Routing::getESetupTime).sum();
    	 
    	 double plannedCapacity = eProcessingTime * prodOrder.getQuantity() + eSetupTime;
    	 
    	 //traceln("Planned Capacity ---------------> orderid " + prodOrder.getOrderId() + " item " + prodOrder.getItem().getItem() + " Machinen " + MachineName + " esetuptitme " + eSetupTime +
    		//	 " eprocessingtime" + eProcessingTime + " qty " + prodOrder.getQuantity() + " plannedcapacity " + plannedCapacity);
    	 
    	 return plannedCapacity;    	 
     }
     
     @Override
     public String toString() {
         return "Routing{" +
                 "Id=" + Id +
                 ", Item=" + (Item != null ? Item.toString() : "null") +
                 ", EProcessingTime=" + EProcessingTime +
                 ", ESetupTime=" + ESetupTime +
                 ", Description='" + Description + '\'' +
                 ", Experiment='" + Experiment + '\'' +
                 ", DistProcessingTime='" + DistProcessingTime + '\'' +
                 ", DistSetupTime='" + DistSetupTime + '\'' +
                 ", Resource='" + Resource + '\'' +
                 ", SSetupTime=" + SSetupTime +
                 ", SProcessingTime=" + SProcessingTime +
                 ", Step=" + Step +
                 '}';
     }
     
}]]></Text>
		</JavaClass>
		<!--   =========   Java Class   ========  -->
		<JavaClass>
			<Id>1639992180958</Id>
			<Name><![CDATA[Distribution]]></Name>
			<Text><![CDATA[import org.apache.commons.math3.*;
import org.apache.commons.math3.stat.descriptive.DescriptiveStatistics;
import org.apache.commons.math3.distribution.NormalDistribution;
import org.apache.commons.math3.distribution.LogNormalDistribution;
import org.apache.commons.math3.distribution.ExponentialDistribution;
import org.apache.commons.math3.random.RandomGenerator;
import org.apache.commons.math3.random.RandomAdaptor;
import java.util.Random;
import org.apache.commons.math3.random.JDKRandomGenerator;


public class Distribution implements Serializable {

	public static boolean LOG_DISTRIUBTION = false;
	public static final String FILENAME_DISTRIUBTION = "output\\Distribution";
	public static final boolean LOG_DISTRIUBTION_DELETE_OUTPUTFILE = true;	
	public static final String DISTRIBUTION_TYPE_DETERMINISTIC = "DETERMINISTIC";
	public static final String DISTRIBUTION_TYPE_LOGNORMAL = "LOGNORMAL";
	public static final String DISTRIBUTION_TYPE_EXP = "EXP";
	
    public Distribution() {
    }

	/**
	 * @param distribution
	 * @param expectedValue is our expected value (average value)
	 * @param sigma is our standard deviation!
	 * @return
	 */
    public static double GetDistributionValue (String distribution, double expectedValue, double CV, 
    		String source, Random rand, String fileNameSuffix, double left, double right) {
    	    	
    	double value = 0;
    	String info = "";

    	StringBuffer out = new StringBuffer();

    	if(CV == 0.0 && !distribution.toUpperCase().equals("EXP")) {
    		distribution = "DETERMINISTIC";
    		info = "sigma 0";
    	}	

    	switch(distribution.toUpperCase()){
	    	case "DETERMINISTIC":
	    		value = expectedValue;
	            break; 
	    	case "NORMAL":
	    		//traceln("sigma " + sigma);
	    		//traceln("expected Value " : expectedValue);
	 			value = Utilities.normal(CV,expectedValue,rand);
	            break; 
	    	case "NORMALTRUNCATED":
	 			value = Utilities.normal(left, right,expectedValue,CV,rand);
	 			break;
	    	case "LOGNORMAL":
	    		
	    		//traceln("Lognormal Distribution Expected Value: " + expectedValue + " CV " + CV);
	    			    		
	    		// Calculate the absolute variance
	    		double sigma = CV * expectedValue;  // sigma is relative variance here

	    		// Calculate the correct mu (mean) for the underlying normal distribution
	    		double expectedValueLogNormiert = Math.log(Math.pow(expectedValue, 2) / Math.sqrt(Math.pow(sigma, 2) +  Math.pow(expectedValue, 2)));
	    		    		
	    		double sigmaLogNormiert = Math.sqrt(Math.log(Math.pow(sigma, 2) / Math.pow(expectedValue, 2) + 1));	    			    				    		
	    		
	    		// Now use the correct mu and sigma in the lognormal distribution	    	
	    		value = Utilities.lognormal(expectedValueLogNormiert, sigmaLogNormiert, 0, rand);
	    			    		
	    		//traceln("Generated Distribution Value: " + value);
	    	    	
	            break; 
	    	case "EXP":
	     		//ExponentialDistribution exponentialDistribution = new ExponentialDistribution(expectedValue,rand);
	 			//value = exponentialDistribution.sample();
	    		
	    		//todo: mit Klaus nochmal durchsprechen, wenn wir exp verwenden, dann sollten wir auf lognormal verwenden.....
	    		
	    		value = Utilities.exponential(expectedValue,CV, rand);
	    		
	            break; 
	    	case "TRIANGULAR":
	    		//todo: not yet implemented
	            break; 
	    	case "UNIFORM":
	    		//todo: not yet implemnted
	            break; 
    	}
    	
    	if(LOG_DISTRIUBTION) {
    		
    		out.append(distribution + ";");
    		out.append(expectedValue + ";");    		
    		out.append(CV + ";");
    		out.append(value + ";");
    		out.append(source + ";");
    		out.append(info);

    		ForecastHistory.AppendToFile(FILENAME_DISTRIUBTION + "_" + fileNameSuffix + ".csv", out.toString(), Distribution.class, LOG_DISTRIUBTION_DELETE_OUTPUTFILE);
    		
    	}
    	
    	return value;
    	
    }	

    public static String GetCSVHeader() {
    	
    	StringBuilder out = new StringBuilder();
    	
    	out.append("Distribution;");
    	out.append("expectedValueIn;");
    	out.append("expectedValue;");
    	out.append("sigmaIn;");
    	out.append("sigma;");
    	out.append("CalculatedValue;");
    	out.append("Info;");
    	
    	return out.toString();    	    	
    }
    
    
}]]></Text>
		</JavaClass>
		<!--   =========   Java Class   ========  -->
		<JavaClass>
			<Id>1640782970708</Id>
			<Name><![CDATA[StockBooking]]></Name>
			<Text><![CDATA[import java.util.stream.*;

/**
 * StockBooking
 */	
public class StockBooking implements Serializable {

	
	public static String BOOKING_SOURCE_PRODUCTION_ORDER = "PRODUCTION";
	public static String BOOKING_SOURCE_CUSTOMER_ORDER = "CUSTOMERORDER";	

    public StockBooking(Item item, double qty, double time, String source, int sourceId, double actualInventory, double timeBetweenBookings) {    	

    	Item = item;
    	Quantity = qty;
    	Time = time;
    	Source = source;
    	SourceId = sourceId;    	
    	NewInventory = qty + actualInventory;
    	TimeBetweenBookings = timeBetweenBookings;
    	
    }


    public StockBooking(double qty, double timeBetweenBookings) {  
    	
    	Quantity = qty;
    	TimeBetweenBookings = timeBetweenBookings;
    	
    }
    
    private Item Item;
    
    private double Quantity;
  
    private double Time;
  
    private Stock Stock;
    
    private String Source;
        
    private int SourceId;
    
    private String Description;
    
    private double NewInventory;
    
    private double TimeBetweenBookings;
    
    public double getTimeBetweenBookings() {
       return this.TimeBetweenBookings;
    }
  
    public void setTimeBetweenBookings(double value) {
       this.TimeBetweenBookings = value;
    }
    
    public String getDescription() {
       return this.Description;
    }
  
    public void setDescription(String value) {
       this.Description = value;
    }
    
    public double getNewInventory() {
       return this.NewInventory;
    }
  
    public void setNewInventory(double value) {
       this.NewInventory = value;
    }
    
    public String getSource() {
        return this.Source;
     }
   
     public void setSource(String value) {
        this.Source = value;
     }
   
     public int getSourceId() {
        return this.SourceId;
     }
   
     public void setSourceId(int value) {
        this.SourceId = value;
     }
    
    public Item getItem() {
       return this.Item;
    }
  
    public void setItem(Item value) {
       this.Item = value;
    }
  
    public double getQuantity() {
       return this.Quantity;
    }
  
    public void setQuantity(double value) {    	        	    	    	    	
       this.Quantity = value;              
    }
  
    public double getTime() {
       return this.Time;
    }
  
    public void setTime(double value) {
       this.Time = value;
    }
  
    public Stock getStock() {
       return this.Stock;
    }
  
    public void setStock(Stock value) {
       this.Stock = value;
    }
    
    public static StockBooking  GetStockItemQuantity(List<StockBooking> bookings, Item item){
    	
    	
    	List<StockBooking> bookingsPerItem = bookings.stream().filter(e -> e.getItem().getItem() == item.getItem()).collect(Collectors.toList());
    	double min = 0;
    	
    	if(bookingsPerItem.size() > 0) {
    		min = bookingsPerItem.stream().mapToDouble(StockBooking::getTime).max().getAsDouble();
    	}
    	        	
    	double quantity = bookingsPerItem.stream().mapToDouble(StockBooking::getQuantity).sum();
    	
    	StockBooking result = new StockBooking(quantity, min);
    	
    	return result;
    }
    
    
    public static List<StockBooking> CheckMaterialAvailability(ProductionOrder prodOrder, List<StockBooking> stockBookings, List<BOM> bomList, double time){
    	    	
    	boolean materialAvailable = false;
		//traceln("################################## Check Availability at " + time + " prod order "+ prodOrder.getOrderId() + " item " + prodOrder.getItem().getItem() + " status " + prodOrder.getStatus() + " planned start " + prodOrder.getPlannedStart());

    	List<StockBooking> bookings = new ArrayList();
    	
    	if(prodOrder.getStatus() > ProductionOrder.PRODUCTION_ORDER_STATUS_RELEASED && prodOrder.getStatus() != ProductionOrder.PRODUCTION_ORDER_WAITING_FOR_MATERIAL) {
    		return bookings;
    	}
    		List<BOM> childOf = bomList.stream().filter(e -> e.getChild() != null && e.getItem().getItem() == prodOrder.getItem().getItem()).collect(Collectors.toList());    	
    		
    		//traceln("childs of " + prodOrder.getItem().getItem());
    		int qtyCount = 0;
    		for(BOM i : childOf) {
    			//traceln(i.getChild().getItem());
    		    		
    			double qty = GetStockItemQuantity(stockBookings, i.getChild()).getQuantity();
    			//traceln(time + " Found quantiy " + qty + " requires " + prodOrder.getQuantity() + "prod order-id " + prodOrder.getOrderId());
    		
	    		if(qty >= prodOrder.getQuantity()) {
	    			qtyCount++;
	    			
	    			StockBooking book = new StockBooking(
	    			i.getChild(),
	    			prodOrder.getQuantity() * i.getQuantity() * -1,
	       			time,
	    			StockBooking.BOOKING_SOURCE_PRODUCTION_ORDER,
	    			prodOrder.getOrderId(),
	    			qty,
	    			GetStockItemQuantity(stockBookings, i.getChild()).getTimeBetweenBookings());
	    			
	    			book.setDescription("Availability Check");
	    				 
	    			bookings.add(book);
    				    			
	    		}	    		    		    		    		
    		}
    	
    	  //not all materials are available
    	  if(qtyCount < bookings.size())
    		  bookings.clear();
    		
    		    		
    	//traceln("bookings size " + bookings.size() + " qty cnt " + qtyCount);
    	return bookings;    	 
    	
    }
    
    public static double GetWIPComponents(List<StockBooking> stockBookings) {
    	    	    	    	
    	return stockBookings.stream().
    			filter(e->e.getItem().getType().equals(new Item().ITEM_TYPE_COMPONENT)).mapToDouble(StockBooking::getQuantity).sum();    	    	
    }
    

    
    
 public static String GetCSVHeader() {
     	
     	StringBuilder out = new StringBuilder();
     	
     	out.append("Time;");
     	out.append("Item;");
     	out.append("Quantity;");
     	out.append("Source;");
     	out.append("SourceId;");
     	out.append("Description;");
     	out.append("NewInventory;");
     	out.append("TimeBetweenBookings;");

     	return out.toString();    	    	
     }
     
 
     public static String GetCSVString(StockBooking obj) {
     	
     	StringBuilder out = new StringBuilder();
     	
     	out.append(obj.getTime() + ";");
     	out.append(obj.getItem().getItem() + ";");
     	out.append(obj.getQuantity() + ";");
     	out.append(obj.getSource() + ";");
     	out.append(obj.getSourceId() + ";");
     	out.append(obj.getDescription() + ";");
     	out.append(obj.getNewInventory() + ";");
     	out.append(obj.getTimeBetweenBookings() + ";");
     	    	    	    	    	
     	return out.toString();
     	
     }
     
     
     public static void GetTraceCSVString(List<StockBooking> objs, String delimeterBotom, String delimenterTop) {
      	
      	StringBuilder out = new StringBuilder();
      	out.append(delimenterTop + "\n");
      	out.append(StockBooking.GetCSVHeader());
      	
      	for(StockBooking obj : objs) {
	      	out.append(obj.getTime() + "");
	      	out.append("\t" + obj.getItem().getItem() + "");
	      	out.append("\t" + obj.getQuantity() + "");
	      	out.append("\t" + obj.getSource() + "");
	      	out.append("\t" + obj.getSourceId() + "");
	      	out.append("\t" + obj.getDescription() + "");
	      	out.append("\t" + obj.getNewInventory() + "");
	      	out.append("\t" + obj.getTimeBetweenBookings() + "\n");
      	}      	    	    	    	  
      	out.append(delimeterBotom + "\n");
      	
      	//traceln(out.toString());
     }
    
}]]></Text>
		</JavaClass>
		<!--   =========   Java Class   ========  -->
		<JavaClass>
			<Id>1642246176155</Id>
			<Name><![CDATA[Result]]></Name>
			<Text><![CDATA[import org.apache.poi.ss.usermodel.*;
import org.apache.poi.xssf.usermodel.XSSFWorkbook;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.util.Iterator;
import java.text.SimpleDateFormat;
import java.util.Date;
import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.PrintWriter;
import java.lang.*;
import java.text.DecimalFormat;
import java.sql.*;
import java.io.IOException;
import java.text.DecimalFormatSymbols;
import org.apache.poi.xssf.usermodel.XSSFCell;
import org.apache.poi.xssf.usermodel.XSSFRow;
import org.apache.poi.xssf.usermodel.XSSFSheet;
import org.apache.poi.xssf.usermodel.XSSFWorkbook;
import java.util.stream.*;
import java.time.LocalDateTime;
import java.math.BigDecimal;
import java.math.RoundingMode;

public class Result implements Serializable {

    public static final String OUTPUT_EXCEL_FILENAME = "output\\output.xlsx";
    public static boolean OUTPUT_EXCEL_FILENAME_NEW_PER_SIMULATION = true;
    public static final String OUTPUT_EXCEL_FOLDER = "output";

    public static final String OUTPUT_EXCEL_FILENAME_PARAMETERVARIATION = "output\\outputPV.xlsx";
    public static final boolean OUTPUT_REDIRECT_TO_DATABASE = false;
    
    /**
     * Default constructor
     */
    public Result() {}        
    
    public Result(String experiment, int iteration, int replication, 
    		double wIPSales, double wIPComponents,
    		double inventorySales, 
    		double inventoryComponents,
    		double inventory,
    		double tardinessMean,
    		double tardinessVariance,
    		double overallCosts,
    		double serviceLevel,
    		
    		double leadTimeSalesMean,
    		double leadTimeSalesVariance,
    		double leadTimeComponentsMean,
    		double leadTimeComponentsVariance,
    		
    		int optimizationParameter,    		
    		
    		String description,
    		SimulationParameter usedSimulationParameter,
    		List<Item> usedItems,
    		List<Routing> usedRoutings,
    		KPI utilization,
    		KPI demandPerItem,
    		KPI WIPJSIandSGI,
    		double demand,
    		int numberCustomerOrders,
    		double latenessMean,
    		double latenessVariance,
    		int numberProductionOrders,
    		double ontimePercentage,
    		double productionStartWaitingTimeMean,
    		double productionStartWaitingTimeVariance,    		    		
    		List<KPI> productionLotSizes,
    		double internalLatenessSalesItemsMean,
    		double internalLatenessSalesItemsVariance,
    		double internalLatenessComponentsMean,
    		double internalLatenessComponentsVariance,
    		double UtilizationPS1,
    		double UtilizationPS2,
    		double UtilizationPS3,
    		double UtilizationPS4,
    		List<Forecast> usedForecasts,
    		double pLStage1,
    		double pLStage2,
    		double pLStage3,
    		double pLStage4,
    		double plannedLeadTimePS1Mean,
    		double plannedLeadTimePS1Variance,
    		double plannedLeadTimePS2Mean,
    		double plannedLeadTimePS2Variance,
    		double plannedLeadTimePS3Mean,
    		double plannedLeadTimePS3Variance,
    		double plannedLeadTimePS4Mean,
    		double plannedLeadTimePS4Variance,
    		double tardinessOpenOrdersMean,
    		double tardinessOpenOrdersVariance,
    		double demandDelivered,
    		double demandNotDelivered,
    		double sumEnergyCosts,
    		int countCapacityFactorBlock,
    		int countEnergyPriceBlock,
    		LocalDateTime replicationStart,
    		LocalDateTime replicationEnd,
    		String simulationExperiment,
    		double consumedSetupTimeMean,
    		double consumeSetupTimeVariance,
    		int replicationStatus,
    		Main main    		
    		) {
    	      	
    	this.simulationExperiment = simulationExperiment;
    	this.Experiment = experiment;
    	this.Iteration = iteration;
    	this.Replication = replication;
    	
    	this.WIPSales = wIPSales;
    	this.WIPComponents = wIPComponents;    	
    	
    	this.InventorySales = inventorySales;
    	this.InventoryComponents = inventoryComponents;
    	this.Inventory = inventory;
    	    	    	
    	this.TardinessMean = tardinessMean;
    	this.TardinessVariance = tardinessVariance;
    	
    	this.LeadTimeSalesMean = leadTimeSalesMean;
    	this.LeadTimeSalesVariance = leadTimeSalesVariance;
    	
    	this.LeadTimeComponentsMean = leadTimeComponentsMean;
    	this.LeadTimeComponentsVariance = leadTimeComponentsVariance;
    	
    	this.OverallCosts = overallCosts;    	    	
    	this.ServiceLevel = serviceLevel;    	
    	
    	this.OptimizationParamter = optimizationParameter;
    	this.Description = description;
    	
    	this.UsedSimulationParameter = usedSimulationParameter;
    	
    	//is necessary as tojson cannot export list of object with obect as property
    	//for(Item i : usedItems)
    		//i.setRouting(null);
    	
    	this.UsedItems = usedItems;
    	    	
    	this.UsedRoutings = usedRoutings;    	
    	
    	this.SystemUtilization = utilization.getValue();
    	this.Utilizations = utilization.getValueString();
    	
    	this.DemandPerItem = demandPerItem.getValueString();
    	this.WIPJSI = WIPJSIandSGI.getValue();
    	this.WIPSGI = Double.parseDouble(WIPJSIandSGI.getValueString());    	
    	
    	this.Demand = demand;
    	this.NumberCustomerOrders = numberCustomerOrders;
    	this.LatenessMean = latenessMean;
    	this.LatenessVariance = latenessVariance;
    	this.NumberProductionOrders = numberProductionOrders;
    	this.OnTimePercentage = ontimePercentage;
    	this.ProductionStartWaitingTimeMean = productionStartWaitingTimeMean;
    	this.ProductionStartWaitingTimeVariance = productionStartWaitingTimeVariance;
    	this.ProductionLotSizes = productionLotSizes;
    	
    	this.InternalLatenessSalesItemsMean = internalLatenessSalesItemsMean;
    	this.InternalLatenessSalesItemsVariance = internalLatenessSalesItemsVariance;
    	
    	this.InternalLatenessComponentsMean = internalLatenessComponentsMean;
    	this.InternalLatenessComponentsVariance = internalLatenessComponentsVariance;
    	
    	this.UtilizationPS1 = UtilizationPS1;
    	this.UtilizationPS2 = UtilizationPS2;
    	this.UtilizationPS3 = UtilizationPS3;
    	this.UtilizationPS4 = UtilizationPS4;    	
    	
    	this.UsedForecasts = usedForecasts;
    	
    	this.PLStage1 = pLStage1;
    	this.PLStage2 = pLStage2;
    	this.PLStage3 = pLStage3;
    	this.PLStage4 = pLStage4;
    	this.PlannedLeadTimePS1Mean = plannedLeadTimePS1Mean;
    	this.PlannedLeadTimePS1Variance = plannedLeadTimePS1Variance;
    	
    	this.PlannedLeadTimePS2Mean = plannedLeadTimePS2Mean;
    	this.PlannedLeadTimePS2Variance = plannedLeadTimePS2Variance;
    	
    	this.PlannedLeadTimePS3Mean = plannedLeadTimePS3Mean;
    	this.PlannedLeadTimePS3Variance = plannedLeadTimePS3Variance;
    	
    	this.PlannedLeadTimePS4Mean = plannedLeadTimePS4Mean;
    	this.PlannedLeadTimePS4Variance = plannedLeadTimePS4Variance;
    	
    	this.tardinessOpenOrdersMean = tardinessOpenOrdersMean;
    	this.tardinessOpenOrdersVariance = tardinessOpenOrdersVariance;
    	
    	this.demandDelivered = demandDelivered;
    	this.demandNotDelivered = demandNotDelivered;
    	this.sumEnergyCosts = sumEnergyCosts;
    	
    	this.countCapacityFactorBlock = countCapacityFactorBlock;
    	this.countEnergyPriceBlock = countEnergyPriceBlock;
    	
    	this.replicationStart = replicationStart;
    	this.replicationEnd = replicationEnd;
    	    	
    	double tmp_overallcosts_inkl_not_Delivered = overallcosts_inkl_not_Delivered(this.InventorySales,this.InventoryComponents, this.WIPSales, 
                this.WIPComponents, this.TardinessMean, this.demandDelivered,
                this.tardinessOpenOrdersMean, this.demandNotDelivered, true,main);
    	
    	this.overallCosts_inkl_not_Delivered = tmp_overallcosts_inkl_not_Delivered;
    	
    	this.consumedSetupTimeMean = consumedSetupTimeMean;
    	this.consumedSetupTimeVariance = consumeSetupTimeVariance;
    	
    	this.replicationStatus = replicationStatus;
    	
    }
    
    private int Id;

    private String Experiment;

    private int Iteration;

    private int Replication;

    private double TardinessMean;

    private double TardinessVariance;

    private double ServiceLevel;
    
    private double TardinessCostsMedium;

    private int OptimizationParamter;
        
    private double WIPSales;
    
    private double WIPComponents;
      
    private double InventorySales;
    
    private double InventoryComponents;
      
    private double OverallCosts;
        
    private String SimulationPC;
      
    private String Description;
    
    private SimulationParameter UsedSimulationParameter;
    
    private List<Item> UsedItems;
    
    private List<Routing> UsedRoutings;
    
    private double SystemUtilization;
    
    private String Utilizations;
  
    private String DemandPerItem;
        
    private double WIPSGI;
    
    private double WIPJSI;
  
    private double Demand;
    
    private int NumberCustomerOrders;
  
    private double LatenessMean;
    
    private double LatenessVariance;
        
    private double LeadTimeSalesMean;
    
    private double LeadTimeSalesVariance;
  
    private double LeadTimeComponentsMean;
  
    private double LeadTimeComponentsVariance;
    
    private double Inventory;
    
    private double NumberProductionOrders;
    
    private double OnTimePercentage;
    
    private double ProductionStartWaitingTimeMean;
    
    private double ProductionStartWaitingTimeVariance;

    private List<KPI> ProductionLotSizes;
    
    private double InternalLatenessComponentsMean;
    
    private double InternalLatenessComponentsVariance;
  
    private double InternalLatenessSalesItemsMean;
  
    private double InternalLatenessSalesItemsVariance;
  
    double UtilizationPS1;
    
    double UtilizationPS2;
  
    double UtilizationPS3;
  
    double UtilizationPS4;
    
	private List<Forecast> UsedForecasts;
	
	private double PLStage1;
	private double PLStage2;
	private double PLStage3;
	private double PLStage4;
	
	private double PlannedLeadTimePS1Mean;	
	private double PlannedLeadTimePS1Variance;
	private double PlannedLeadTimePS2Mean;
	private double PlannedLeadTimePS2Variance;
	private double PlannedLeadTimePS3Mean;
	private double PlannedLeadTimePS3Variance;
	private double PlannedLeadTimePS4Mean;
	private double PlannedLeadTimePS4Variance;
	private double tardinessOpenOrdersVariance;
	private double tardinessOpenOrdersMean;	
	private double demandDelivered;
	private double demandNotDelivered;
	private int countEnergyPriceBlock;
	private int countCapacityFactorBlock;
    private LocalDateTime replicationStart;
    private LocalDateTime replicationEnd;
    private String simulationExperiment;
    private double overallCosts_inkl_not_Delivered;
    private double consumedSetupTimeMean;
    private double consumedSetupTimeVariance;
    
    private int replicationStatus;

    public int getReplicationStatus() {
        return replicationStatus;
    }

    public void setReplicationStatus(int replicationStatus) {
        this.replicationStatus = replicationStatus;
    }
    
    public double getConsumedSetupTimeMean() {
        return consumedSetupTimeMean;
    }

    public void setConsumedSetupTimeMean(double consumedSetupTimeMean) {
        this.consumedSetupTimeMean = consumedSetupTimeMean;
    }

    public double getConsumedSetupTimeVariance() {
        return consumedSetupTimeVariance;
    }

    public void setConsumedSetupTimeVariance(double consumedSetupTimeVariance) {
        this.consumedSetupTimeVariance = consumedSetupTimeVariance;
    }

    
    public String getSimulationExperiment() {
    	   return this.simulationExperiment;
	}

	public void setSimulationExperiment(String SimulationExperiment) {
	   this.simulationExperiment = SimulationExperiment;
	}

    public double getOverallCosts_inkl_not_Delivered() {
        return overallCosts_inkl_not_Delivered;
    }

    public void setOverallCosts_inkl_not_Delivered(double overallCosts_inkl_not_Delivered) {
        this.overallCosts_inkl_not_Delivered = overallCosts_inkl_not_Delivered;
    }

    public LocalDateTime getReplicationStart() {
        return replicationStart;
    }

    // Setter for replicationStart
    public void setReplicationStart(LocalDateTime replicationStart) {
        this.replicationStart = replicationStart;
    }

    // Getter for replicationEnd
    public LocalDateTime getReplicationEnd() {
        return replicationEnd;
    }

    // Setter for replicationEnd
    public void setReplicationEnd(LocalDateTime replicationEnd) {
        this.replicationEnd = replicationEnd;
    }    
	
	  // Getter for countEnergyPriceBlock
    public int getCountEnergyPriceBlock() {
        return countEnergyPriceBlock;
    }

    // Setter for countEnergyPriceBlock
    public void setCountEnergyPriceBlock(int countEnergyPriceBlock) {
        this.countEnergyPriceBlock = countEnergyPriceBlock;
    }

    // Getter for countCapacityFactorBlock
    public int getCountCapacityFactorBlock() {
        return countCapacityFactorBlock;
    }

    // Setter for countCapacityFactorBlock
    public void setCountCapacityFactorBlock(int countCapacityFactorBlock) {
        this.countCapacityFactorBlock = countCapacityFactorBlock;
    }
	
	// Private field to hold the sum of energy costs
    private double sumEnergyCosts;

    // Getter method for sumEnergyCosts
    public double getSumEnergyCosts() {
        return sumEnergyCosts;
    }

    // Setter method for sumEnergyCosts
    public void setSumEnergyCosts(double sumEnergyCosts) {
        this.sumEnergyCosts = sumEnergyCosts;
    }
	
	
	public double getDemandDelivered() {
        return demandDelivered;
    }

    public void setDemandDelivered(double demandDelivered) {
        this.demandDelivered = demandDelivered;
    }

    public double getDemandNotDelivered() {
        return demandNotDelivered;
    }

    public void setDemandNotDelivered(double demandNotDelivered) {
        this.demandNotDelivered = demandNotDelivered;
    }
	
	public double getTardinessOpenOrdersVariance() {
		return tardinessOpenOrdersVariance;
	}


	public void setTardinessOpenOrdersVariance(double tardinessOpenOrdersVariance) {
		this.tardinessOpenOrdersVariance = tardinessOpenOrdersVariance;
	}


	public double getTardinessOpenOrdersMean() {
		return tardinessOpenOrdersMean;
	}


	public void setTardinessOpenOrdersMean(double tardinessOpenOrdersMean) {
		this.tardinessOpenOrdersMean = tardinessOpenOrdersMean;
	}



	
	public double getPlannedLeadTimePS1Mean() {
		return PlannedLeadTimePS1Mean;
	}


	public void setPlannedLeadTimePS1Mean(double plannedLeadTimePS1Mean) {
		PlannedLeadTimePS1Mean = plannedLeadTimePS1Mean;
	}


	public double getPlannedLeadTimePS1Variance() {
		return PlannedLeadTimePS1Variance;
	}


	public void setPlannedLeadTimePS1Variance(double plannedLeadTimePS1Variance) {
		PlannedLeadTimePS1Variance = plannedLeadTimePS1Variance;
	}


	public double getPlannedLeadTimePS2Mean() {
		return PlannedLeadTimePS2Mean;
	}


	public void setPlannedLeadTimePS2Mean(double plannedLeadTimePS2Mean) {
		PlannedLeadTimePS2Mean = plannedLeadTimePS2Mean;
	}


	public double getPlannedLeadTimePS2Variance() {
		return PlannedLeadTimePS2Variance;
	}


	public void setPlannedLeadTimePS2Variance(double plannedLeadTimePS2Variance) {
		PlannedLeadTimePS2Variance = plannedLeadTimePS2Variance;
	}


	public double getPlannedLeadTimePS3Mean() {
		return PlannedLeadTimePS3Mean;
	}


	public void setPlannedLeadTimePS3Mean(double plannedLeadTimePS3Mean) {
		PlannedLeadTimePS3Mean = plannedLeadTimePS3Mean;
	}


	public double getPlannedLeadTimePS3Variance() {
		return PlannedLeadTimePS3Variance;
	}


	public void setPlannedLeadTimePS3Variance(double plannedLeadTimePS3Variance) {
		PlannedLeadTimePS3Variance = plannedLeadTimePS3Variance;
	}


	public double getPlannedLeadTimePS4Mean() {
		return PlannedLeadTimePS4Mean;
	}


	public void setPlannedLeadTimePS4Mean(double plannedLeadTimePS4Mean) {
		PlannedLeadTimePS4Mean = plannedLeadTimePS4Mean;
	}


	public double getPlannedLeadTimePS4Variance() {
		return PlannedLeadTimePS4Variance;
	}


	public void setPlannedLeadTimePS4Variance(double plannedLeadTimePS4Variance) {
		PlannedLeadTimePS4Variance = plannedLeadTimePS4Variance;
	}

	
	public double getPLStage1() {
		return PLStage1;
	}
	public void setPLStage1(double pLStage1) {
		PLStage1 = pLStage1;
	}
	public double getPLStage2() {
		return PLStage2;
	}
	public void setPLStage2(double pLStage2) {
		PLStage2 = pLStage2;
	}
	public double getPLStage3() {
		return PLStage3;
	}
	public void setPLStage3(double pLStage3) {
		PLStage3 = pLStage3;
	}
	public double getPLStage4() {
		return PLStage4;
	}
	public void setPLStage4(double pLStage4) {
		PLStage4 = pLStage4;
	}
	
	public List<Forecast> getUsedForecasts() {
		return UsedForecasts;
	}

	public void setUsedForecasts(List<Forecast> usedForecasts) {
		UsedForecasts = usedForecasts;
	}

  
    public double getUtilizationPS1() {
       return this.UtilizationPS1;
    }
  
    public void setUtilizationPS1(double value) {
       this.UtilizationPS1 = value;
    }
  
    public double getUtilizationPS2() {
       return this.UtilizationPS2;
    }
  
    public void setUtilizationPS2(double value) {
       this.UtilizationPS2 = value;
    }
  
    public double getUtilizationPS3() {
       return this.UtilizationPS3;
    }
  
    public void setUtilizationPS3(double value) {
       this.UtilizationPS3 = value;
    }
  
    public double getUtilizationPS4() {
       return this.UtilizationPS4;
    }
  
    public void setUtilizationPS4(double value) {
       this.UtilizationPS4 = value;
    }
    
    
    public double getInternalLatenessComponentsMean() {
       return this.InternalLatenessComponentsMean;
    }
  
    public void setInternalLatenessComponentsMean(double value) {
       this.InternalLatenessComponentsMean = value;
    }
  
    public double getInternalLatenessComponentsVariance() {
       return this.InternalLatenessComponentsVariance;
    }
  
    public void setInternalLatenessComponentsVariance(double value) {
       this.InternalLatenessComponentsVariance = value;
    }
  
    public double getInternalLatenessSalesItemsMean() {
       return this.InternalLatenessSalesItemsMean;
    }
  
    public void setInternalLatenessSalesItemsMean(double value) {
       this.InternalLatenessSalesItemsMean = value;
    }
  
    public double getInternalLatenessSalesItemsVariance() {
       return this.InternalLatenessSalesItemsVariance;
    }
  
    public void setInternalLatenessSalesItemsVariance(double value) {
       this.InternalLatenessSalesItemsVariance = value;
    }
    
    public List<KPI> getProductionLotSizes() {
       return this.ProductionLotSizes;
    }
  
    public void setProductionLotSizes(List<KPI> value) {
       this.ProductionLotSizes = value;
    }
    
    public double getOnTimePercentage() {
       return this.OnTimePercentage;
    }
      
    public double getProductionStartWaitingTimeMean() {
       return this.ProductionStartWaitingTimeMean;
    }
  
    public void setProductionStartWaitingTimeMean(double value) {
       this.ProductionStartWaitingTimeMean = value;
    }
  
    public double getProductionStartWaitingTimeVariance() {
       return this.ProductionStartWaitingTimeVariance;
    }
  
    public void setProductionStartWaitingTimeVariance(double value) {
       this.ProductionStartWaitingTimeVariance = value;
    }
    
  
    public void setOnTimePercentage(double value) {
       this.OnTimePercentage = value;
    }
    
    
    public double getNumberProductionOrders() {
       return this.NumberProductionOrders;
    }
  
    public void setNumberProductionOrders(double value) {
       this.NumberProductionOrders = value;
    }
    
  
    public double getInventory() {
       return this.Inventory;
    }
  
    public void setInventory(double value) {
       this.Inventory = value;
    }
    
    public double getLeadTimeSalesMean() {
       return this.LeadTimeSalesMean;
    }
  
    public void setLeadTimeSalesMean(double value) {
       this.LeadTimeSalesMean = value;
    }
  
    public double getLeadTimeSalesVariance() {
       return this.LeadTimeSalesVariance;
    }
  
    public void setLeadTimeSalesVariance(double value) {
       this.LeadTimeSalesVariance = value;
    }
  
    public double getLeadTimeComponentsMean() {
       return this.LeadTimeComponentsMean;
    }
  
    public void setLeadTimeComponentsMean(double value) {
       this.LeadTimeComponentsMean = value;
    }
  
    public double getLeadTimeComponentsVariance() {
       return this.LeadTimeComponentsVariance;
    }
  
    public void setLeadTimeComponentsVariance(double value) {
       this.LeadTimeComponentsVariance = value;
    }
  
    public double getLatenessMean() {
       return this.LatenessMean;
    }
  
    public void setLatenessMean(double value) {
       this.LatenessMean = value;
    }
  
    public double getLatenessVariance() {
       return this.LatenessVariance;
    }
  
    public void setLatenessVariance(double value) {
       this.LatenessVariance = value;
    }
    
    public double getDemand() {
       return this.Demand;
    }
  
    public void setDemand(double value) {
       this.Demand = value;
    }
  
    public int getNumberCustomerOrders() {
       return this.NumberCustomerOrders;
    }
  
    public void setNumberCustomerOrders(int value) {
       this.NumberCustomerOrders = value;
    }
    
    
    public double getWIPSGI() {
       return this.WIPSGI;
    }
  
    public void setWIPSGI(double value) {
       this.WIPSGI = value;
    }
  
    public double getWIPJSI() {
       return this.WIPJSI;
    }
  
    public void setWIPJSI(double value) {
       this.WIPJSI = value;
    }

    
    public String getDemandPerItem() {
       return this.DemandPerItem;
    }
  
    public void setDemandPerItem(String value) {
       this.DemandPerItem = value;
    }
    
    public double getSystemUtilization() {
       return this.SystemUtilization;
    }
  
    public void setSystemUtilization(double value) {
       this.SystemUtilization = value;
    }
  
    public String getUtilizations() {
       return this.Utilizations;
    }
  
    public void setUtilizations(String value) {
       this.Utilizations = value;
    }
    
    
    public List<Routing> getUsedRoutings() {
       return this.UsedRoutings;
    }
  
    public void setUsedRoutings(List<Routing> value) {
       this.UsedRoutings = value;
    }
    
    public List<Item> getUsedItems() {
       return this.UsedItems;
    }
  
    public void setUsedItems(List<Item> value) {
       this.UsedItems = value;
    }
        
    public SimulationParameter getUsedSimulationParameter() {
       return this.UsedSimulationParameter;
    }
  
    public void setUsedSimulationParameter(SimulationParameter value) {
       this.UsedSimulationParameter = value;
    }
    
    
    public String getDescription() {
       return this.Description;
    }
  
    public void setDescription(String value) {
       this.Description = value;
    }
    
    public String getSimulationPC() {
       return this.SimulationPC;
    }
  
    public void setSimulationPC(String value) {
       this.SimulationPC = value;
    }
        
    public double getOverallCosts() {
       return this.OverallCosts;
    }
  
    public void setOverallCosts(double value) {
       this.OverallCosts = value;
    }
        
    public double getInventorySales() {
       return this.InventorySales;
    }
  
    public void setInventorySales(double value) {
       this.InventorySales = value;
    }
  
    public double getInventoryComponents() {
       return this.InventoryComponents;
    }
  
    public void setInventoryComponents(double value) {
       this.InventoryComponents = value;
    }
        
    public double getWIPSales() {
       return this.WIPSales;
    }
  
    public void setWIPSales(double value) {
       this.WIPSales = value;
    }
  
    public double getWIPComponents() {
       return this.WIPComponents;
    }
  
    public void setWIPComponents(double value) {
       this.WIPComponents = value;
    }
    
    public int getOptimizationParamter() {
       return this.OptimizationParamter;
    }
  
    public void setOptimizationParamter(int value) {
       this.OptimizationParamter = value;
    }
    
    public double getTardinessCostsMedium() {
        return this.TardinessCostsMedium;
    }

    public void setTardinessCostsMedium(double value) {
        this.TardinessCostsMedium = value;
    }

    public int getId() {
        return this.Id;
    }

    public void setId(int value) {
        this.Id = value;
    }

    public String getExperiment() {
        return this.Experiment;
    }

    public void setExperiment(String value) {
        this.Experiment = value;
    }

    public int getIteration() {
        return this.Iteration;
    }

    public void setIteration(int value) {
        this.Iteration = value;
    }

    public int getReplication() {
        return this.Replication;
    }

    public void setReplication(int value) {
        this.Replication = value;
    }

  
    public double getTardinessMean() {
        return this.TardinessMean;
    }

    public void setTardinessMean(double value) {
        this.TardinessMean = value;
    }
    
    public double getTardinessVariance() {
        return this.TardinessVariance;
    }

    public void setTardinessVariance(double value) {
        this.TardinessVariance = value;
    }

    public double getServiceLevel() {
        return this.ServiceLevel;
    }

    public void setServiceLevel(double value) {
        this.ServiceLevel = value;
    }

    public static void WriteXlxsResults(List < CustomerOrder > customerOrders, List < ProductionOrder > productionOrders,
        List < StockBooking > stockBookings, List < RoutingTimes > routingTimes, SimulationParameter simParams, String fileName, OptimizationParameter optParam) {


        try {
        	
        	if(OUTPUT_EXCEL_FILENAME_NEW_PER_SIMULATION) {
        		SimpleDateFormat simpleDateFormat =
        		new SimpleDateFormat("YYYYMMddhhmmss");
        		String dateAsString = simpleDateFormat.format(new Date());
        		
        		String postFix = "";
        		
        		if(simParams.getApplyClearingFunctions()==true)
        			postFix += "_CF";
        		if(simParams.getApplyMRP()==1)
        			postFix += "_MRP";
        		
        		//if(optParam != null)
        			postFix += "_" + optParam.getId();
        		
        		fileName = OUTPUT_EXCEL_FOLDER + "\\Output_" + dateAsString + postFix + ".xlsx";
        	}
        	
            File file = new File(fileName);


            XSSFWorkbook emptyWorkbook = new XSSFWorkbook();
            XSSFSheet spreadsheet = emptyWorkbook.createSheet("Customer Orders");
            spreadsheet = emptyWorkbook.createSheet("Production Orders");
            spreadsheet = emptyWorkbook.createSheet("Booking List");
            spreadsheet = emptyWorkbook.createSheet("Routing Times");
            spreadsheet = emptyWorkbook.createSheet("Simulation Parameters");

            FileOutputStream ostream
                = new FileOutputStream(file);

            emptyWorkbook.write(ostream);
            ostream.close();

            FileInputStream fis = new FileInputStream(new File(fileName));

            XSSFWorkbook workbook = new XSSFWorkbook(fis);

            //write Customer Orders
            XSSFSheet sheet = workbook.getSheetAt(0);
            //write header row
            XSSFRow row1 = sheet.createRow(0);
            XSSFCell r1c1 = row1.createCell(0);
            r1c1.setCellValue("OrderId");
            XSSFCell r1c2 = row1.createCell(1);
            r1c2.setCellValue("CreatedAt");
            XSSFCell r1c3 = row1.createCell(2);
            r1c3.setCellValue("DueDate");
            XSSFCell r1c4 = row1.createCell(3);
            r1c4.setCellValue("Item");
            XSSFCell r1c5 = row1.createCell(4);
            r1c5.setCellValue("Quantity");
            XSSFCell r1c6 = row1.createCell(5);
            r1c6.setCellValue("Status");
            XSSFCell r1c7 = row1.createCell(6);
            r1c7.setCellValue("ActualStart");
            XSSFCell r1c8 = row1.createCell(7);
            r1c8.setCellValue("ActualEnd");
            XSSFCell r1c81 = row1.createCell(8);
            r1c81.setCellValue("LongTermForecast");
            XSSFCell r1c82 = row1.createCell(9);
            r1c82.setCellValue("PreviousDemands");
            XSSFCell r1c83 = row1.createCell(10);
            r1c83.setCellValue("DemandVariations");
            
            XSSFCell r1c84 = row1.createCell(11);
            r1c84.setCellValue("FrozenQty");
            
            XSSFCell r1c85 = row1.createCell(12);
            r1c85.setCellValue("ConWipReleaseCheckAt");
            
            XSSFCell r1c86 = row1.createCell(13);
            r1c86.setCellValue("ConWipReleasedAt");

            XSSFCell r1c87 = row1.createCell(14);
            r1c87.setCellValue("ConWipWorkLoad");
            
            XSSFCell r1c88 = row1.createCell(15);
            r1c88.setCellValue("ProductionOrder");
            
            int rowCount = 1;
            
            StringBuilder sqlResultCustomerOrder = new StringBuilder();
            
            for (CustomerOrder item: customerOrders) {
            	
            	sqlResultCustomerOrder.setLength(0);
            	if(OUTPUT_REDIRECT_TO_DATABASE) {
            		sqlResultCustomerOrder.append("INSERT INTO ResultCustomerOrder (Experiment, OrderId, Status, Customer, Item, Quantity, DueDate, CreatedAt, ActualStart, ActualEnd)" +
            		  " VALUES  ('" + simParams.getExperiment() + "', " + item.getOrderId() + ", "  + item.getStatus() +", " + item.getCustomer() + ", " + item.getItem().getItem()+ ", " + item.getQuantity() + ", " + item.getDueDate() + ", " + item.getCreatedAt() + ", "  + item.getActualStart()+", " + item.getActualEnd() + ");");	
            		            		
            		InsertResultToDb(sqlResultCustomerOrder);            		            		            		
            	}
            	
                //Create First Row
                XSSFRow row = sheet.createRow(rowCount);
                rowCount++;

                XSSFCell orderId = row.createCell(0);
                orderId.setCellValue(item.getOrderId());

                XSSFCell createdat = row.createCell(1);
                createdat.setCellValue(item.getCreatedAt());

                XSSFCell dueDate = row.createCell(2);
                dueDate.setCellValue(item.getDueDate());

                XSSFCell itemItem = row.createCell(3);
                itemItem.setCellValue(item.getItem().getItem());

                XSSFCell quantity = row.createCell(4);
                quantity.setCellValue(item.getQuantity());

                XSSFCell status = row.createCell(5);
                status.setCellValue(item.getStatus());

                XSSFCell actualStart = row.createCell(6);
                actualStart.setCellValue(item.getActualStart());

                XSSFCell actualEnd = row.createCell(7);
                actualEnd.setCellValue(item.getActualEnd());
                
                XSSFCell longtermForecast = row.createCell(8);
                longtermForecast.setCellValue(item.getLongtermForecast());
                
                DoubleStream myStream = Arrays.stream(item.getPreviousDemandValues());                                
                StringBuilder o = new StringBuilder();
                myStream.forEach(str -> o.append(str + ";"));
                
                XSSFCell previousDemands = row.createCell(9);
                previousDemands.setCellValue(o.toString());
                               
                if(item.getDemandVariation() != null) {
	                myStream = Arrays.stream(item.getDemandVariation());                                
	                o.setLength(0);
	                myStream.forEach(str -> o.append(str + ";"));
	                
	                XSSFCell demandVariations = row.createCell(10);
	                demandVariations.setCellValue(o.toString());
                }
                
                XSSFCell frozenQty = row.createCell(11);
                frozenQty.setCellValue(item.getFrozenQty());                
                
                XSSFCell conWipReleaseCheckAt = row.createCell(12);
                conWipReleaseCheckAt.setCellValue(item.getConWipReleaseCheckAt());
                
                XSSFCell conWipReleasedAt = row.createCell(13);
                conWipReleasedAt.setCellValue(item.getConWipReleasedAt());
                
                XSSFCell conWipWorkLoad = row.createCell(14);
                conWipWorkLoad.setCellValue(item.getWorkLoad());
                
                XSSFCell productionOrder = row.createCell(15);
                productionOrder.setCellValue(item.getProductionOrderId());
                
                
            }
                                    
            //write Production Orders
            sheet = workbook.getSheetAt(1);
            //write header row
            row1 = sheet.createRow(0);

            r1c1 = row1.createCell(0);
            r1c1.setCellValue("OrderId");

            r1c2 = row1.createCell(1);
            r1c2.setCellValue("CreatedAt");

            r1c3 = row1.createCell(2);
            r1c3.setCellValue("PlannedStart");

            r1c4 = row1.createCell(3);
            r1c4.setCellValue("PlannedEnd");

            r1c5 = row1.createCell(4);
            r1c5.setCellValue("Item");

            r1c6 = row1.createCell(5);
            r1c6.setCellValue("MinRoutingStep");

            r1c7 = row1.createCell(6);
            r1c7.setCellValue("MaxRoutingStep");

            r1c8 = row1.createCell(7);
            r1c8.setCellValue("Quantity");

            XSSFCell r1c9 = row1.createCell(8);
            r1c9.setCellValue("Status");

            XSSFCell r1c10 = row1.createCell(9);
            r1c10.setCellValue("ActualStart");

            XSSFCell r1c11 = row1.createCell(10);
            r1c11.setCellValue("ActualEnd");

            XSSFCell r1c12 = row1.createCell(11);
            r1c12.setCellValue("TotalProcessingTime");

            XSSFCell r1c13 = row1.createCell(12);
            r1c13.setCellValue("LastMachineInRouting");

            XSSFCell r1c14 = row1.createCell(13);
            r1c14.setCellValue("PlannedCapacity");
            
            XSSFCell r1c15 = row1.createCell(14);
            r1c15.setCellValue("ActualReleaseDate");
                      
            XSSFCell r1c16 = row1.createCell(15);
            r1c16.setCellValue("QuantityOriginal");

            XSSFCell r1c17 = row1.createCell(16);
            r1c17.setCellValue("ProcessedLoad");

            XSSFCell r1c18 = row1.createCell(17);
            r1c18.setCellValue("TTR");
            
            XSSFCell r1c19 = row1.createCell(18);
            r1c19.setCellValue("TTF");
                                    
            XSSFCell r1c20 = row1.createCell(19);
            r1c20.setCellValue("PlannedSetupTime");
            
            XSSFCell r1c21 = row1.createCell(20);
            r1c21.setCellValue("ConsumedProcessingTime");
            
            XSSFCell r1c22 = row1.createCell(21);
            r1c22.setCellValue("CustomerOrderId");
            
            XSSFCell r1c23 = row1.createCell(22);
            r1c23.setCellValue("ParentProdOrderId");
            
            XSSFCell r1c24 = row1.createCell(23);
            r1c24.setCellValue("WorkLoad");
            
            XSSFCell r1c25 = row1.createCell(24);
            r1c25.setCellValue("ConWipReleaseCheckAt");
            
            XSSFCell r1c26 = row1.createCell(25);
            r1c26.setCellValue("ConWipReleasedAt");
            
            XSSFCell r1c27 = row1.createCell(26);
            r1c27.setCellValue("SystemWorkLoad");
            
            XSSFCell r1c28 = row1.createCell(27);
            r1c28.setCellValue("ComponentsWorkLoad");
            
            XSSFCell r1c29 = row1.createCell(28);
            r1c29.setCellValue("ConsumedSeupTime");
                                   
            XSSFCell r1c30 = row1.createCell(29);
            r1c30.setCellValue("PlannedProcessing");
            
            XSSFCell r1c31 = row1.createCell(30);
            r1c31.setCellValue("EarliestRelease");

            
            rowCount = 1;
            
            for (ProductionOrder item: productionOrders) {
                //Create First Row
                XSSFRow row = sheet.createRow(rowCount);
                rowCount++;

                XSSFCell orderId = row.createCell(0);
                orderId.setCellValue(item.getOrderId());

                XSSFCell createdat = row.createCell(1);
                createdat.setCellValue(item.getCreatedAt());

                XSSFCell plannedStart = row.createCell(2);
                plannedStart.setCellValue(item.getPlannedStart());

                XSSFCell plannedEnd = row.createCell(3);
                plannedEnd.setCellValue(item.getPlannedEnd());

                XSSFCell itemItem = row.createCell(4);
                itemItem.setCellValue(item.getItem().getItem());

                XSSFCell minRoutingStep = row.createCell(5);
                minRoutingStep.setCellValue(item.getMinimumRoutingStep());

                XSSFCell maxRoutingStep = row.createCell(6);
                maxRoutingStep.setCellValue(item.getMaximumRoutingStep());

                XSSFCell quantity = row.createCell(7);
                quantity.setCellValue(item.getQuantity());

                XSSFCell status = row.createCell(8);
                status.setCellValue(item.getStatus());

                XSSFCell actualStart = row.createCell(9);
                actualStart.setCellValue(item.getActualStart());

                XSSFCell actualEnd = row.createCell(10);
                actualEnd.setCellValue(item.getActualEnd());

                XSSFCell totalProcessingTime = row.createCell(11);
                totalProcessingTime.setCellValue(item.getTotalProcessingTime() / 1440);

                XSSFCell machine = row.createCell(12);
                machine.setCellValue(item.getResource() != null ? item.getResource().getName() : "");
                
                XSSFCell plannedCapacity = row.createCell(13);
                plannedCapacity.setCellValue(item.getPlannedCapacity() / 1440);
                
                XSSFCell actualReleaseDate = row.createCell(14);
                actualReleaseDate.setCellValue(item.getActualReleaseDate());
                
                XSSFCell quantityOriginal = row.createCell(15);
                quantityOriginal.setCellValue(item.getQuantityOriginal());
                
                XSSFCell processedLoad = row.createCell(16);
                processedLoad.setCellValue(item.getPL() / 1440);

                XSSFCell tTR = row.createCell(17);
                tTR.setCellValue(item.getTTR() / 1440);
                
                XSSFCell tTF = row.createCell(18);
                tTF.setCellValue(item.getTTF() / 1440);
                
                XSSFCell plannedSetupTime = row.createCell(19);
                plannedSetupTime.setCellValue(item.getPlannedSetupTime());
                                
                XSSFCell consumedProcessingTime = row.createCell(20);
                consumedProcessingTime.setCellValue(item.getConsumedProcessingTime());                
                
                XSSFCell customerOrderId = row.createCell(21);
                customerOrderId.setCellValue(item.getCustomerOrderId());
                
                XSSFCell parentProdOrderId = row.createCell(22);
                parentProdOrderId.setCellValue(item.getParentProdOrderId());                
                
                XSSFCell workLoad = row.createCell(23);
                workLoad.setCellValue(item.getWorkLoad());                
                
                XSSFCell conWipReleaseCheckAt = row.createCell(24);
                conWipReleaseCheckAt.setCellValue(item.getConWipReleaseCheckAt());                
                
                XSSFCell conWipReleasedAt = row.createCell(25);
                conWipReleasedAt.setCellValue(item.getConWipReleasedAt());                
                
                XSSFCell systemWorkLoad = row.createCell(26);
                systemWorkLoad.setCellValue(item.getSystemWorkLoad());                
                
                XSSFCell componentsWorkLoad = row.createCell(27);
                componentsWorkLoad.setCellValue(item.getComponentsWorkLoad());                

                XSSFCell consumedSetupTime = row.createCell(28);
                consumedSetupTime.setCellValue(item.getConsumedSetupTime());                
                
                XSSFCell plannedProcessingTime = row.createCell(29);
                plannedProcessingTime.setCellValue(item.getRouting().getEProcessingTime());                
                
                XSSFCell earliestRelease = row.createCell(30);
                earliestRelease.setCellValue(item.getPlannedStartEarliestRelease());                

            }

            //write Stock Bookings
            sheet = workbook.getSheetAt(2);
            //write header row
            row1 = sheet.createRow(0);

            r1c1 = row1.createCell(0);
            r1c1.setCellValue("CreatedAt");

            r1c2 = row1.createCell(1);
            r1c2.setCellValue("Item");

            r1c3 = row1.createCell(2);
            r1c3.setCellValue("Quantity");

            r1c4 = row1.createCell(3);
            r1c4.setCellValue("Source");

            r1c5 = row1.createCell(4);
            r1c5.setCellValue("SourceId");

            r1c6 = row1.createCell(5);
            r1c6.setCellValue("Description");
            
            r1c7 = row1.createCell(6);
            r1c7.setCellValue("NewInventory");
            
            r1c8 = row1.createCell(7);
            r1c8.setCellValue("TimeBetweenBookings");

            rowCount = 1;
            StringBuilder sqlResultBookingList = new StringBuilder();
            
            for (StockBooking item: stockBookings) {
            	
            	sqlResultBookingList.setLength(0);
            	if(OUTPUT_REDIRECT_TO_DATABASE) {
            		sqlResultBookingList.append("INSERT INTO ResultBookingList (CreatedAt, Item, Quantity, Source, SourceId, Description, NewInventory, TimeBetweenBookings, Experiment) ");
            		sqlResultBookingList.append("VALUES  (" + item.getTime() + "," + item.getItem().getItem() +"," + item.getQuantity()+", '" + item.getSource()+ "', " + item.getSourceId()+", '" + item.getDescription()+"', " + item.getNewInventory()+", " + item.getTimeBetweenBookings() + ",'" + simParams.getExperiment() + "')");

            		InsertResultToDb(sqlResultBookingList);            		            		            		
            	}

            	
            	//Create First Row
                XSSFRow row = sheet.createRow(rowCount);
                rowCount++;

                XSSFCell createdAt = row.createCell(0);
                createdAt.setCellValue(item.getTime());

                XSSFCell itemItem = row.createCell(1);
                itemItem.setCellValue(item.getItem().getItem());

                XSSFCell quantity = row.createCell(2);
                quantity.setCellValue(item.getQuantity());

                XSSFCell source = row.createCell(3);
                source.setCellValue(item.getSource());

                XSSFCell sourceId = row.createCell(4);
                sourceId.setCellValue(item.getSourceId());

                XSSFCell description = row.createCell(5);
                description.setCellValue(item.getDescription());
                
                XSSFCell newInventory = row.createCell(6);
                newInventory.setCellValue(item.getNewInventory());
                
                XSSFCell timeBetweenBookings = row.createCell(7);
                timeBetweenBookings.setCellValue(item.getTimeBetweenBookings());
            }

            //InventoryPerItem ipi = new InventoryPerItem();
            //List<InventoryPerItem> inventoryPerItem = ipi.GetInventoryPerItem(simParams);

            /*traceln
            traceln("$$$$$ OverallInventory per Item $$$$$");
            traceln("Item;HoldingCosts;OverallInventory;OverallInventoryCosts");
            for(InventoryPerItem item : inventoryPerItem) {
            	traceln(item.getItem() + ";" + item.getHoldingCosts() + ";" + item.getOverallInventory() + ";" + item.getOverallInventorycosts());            	            	
            }
            */
            
            //write Routing Times
            sheet = workbook.getSheetAt(3);
            //write header row
            row1 = sheet.createRow(0);

            r1c1 = row1.createCell(0);
            r1c1.setCellValue("Id");

            r1c2 = row1.createCell(1);
            r1c2.setCellValue("CreatedAt");

            r1c3 = row1.createCell(2);
            r1c3.setCellValue("Status");

            r1c4 = row1.createCell(3);
            r1c4.setCellValue("Start");

            r1c5 = row1.createCell(4);
            r1c5.setCellValue("End");

            r1c6 = row1.createCell(5);
            r1c6.setCellValue("Machine");

            r1c7 = row1.createCell(6);
            r1c7.setCellValue("ProductionOrder");

            r1c8 = row1.createCell(7);
            r1c8.setCellValue("Item");

            r1c9 = row1.createCell(8);
            r1c9.setCellValue("ProcessingTime");
            
            r1c10 = row1.createCell(9);
            r1c10.setCellValue("EnergyPriceAtEnterDelay");

            rowCount = 1;

            for (RoutingTimes item: routingTimes.stream().sorted(Comparator.comparing(RoutingTimes::getId)).collect(Collectors.toList())) {            	            	            	
            	
                //Create First Row
                XSSFRow row = sheet.createRow(rowCount);
                rowCount++;

                XSSFCell id = row.createCell(0);
                id.setCellValue(item.getId());

                XSSFCell createdAt = row.createCell(1);
                createdAt.setCellValue(item.getCreatedAt());

                XSSFCell status = row.createCell(2);
                status.setCellValue(item.getStatus());

                XSSFCell start = row.createCell(3);
                start.setCellValue(item.getStart());

                XSSFCell end = row.createCell(4);
                end.setCellValue(item.getEnd());

                XSSFCell machine = row.createCell(5);
                machine.setCellValue(item.getResource() != null ? item.getResource().getName() : "");


                //if(item.getRoutingType() != null){       		
                //if(item.getRoutingType().toUpperCase().equals(RoutingTimes.ROUTING_TYPE_PRODUCTIONORDER)) {

                XSSFCell order = row.createCell(6);
                order.setCellValue(item.getProductionOrder() != null ? item.getProductionOrder().getOrderId() : -99);

                XSSFCell itemItem = row.createCell(7);
                itemItem.setCellValue(item.getProductionOrder() != null ? item.getProductionOrder().getItem().getItem() : -99);

                //}else if (item.getRoutingType().toUpperCase().equals(RoutingTimes.ROUTING_TYPE_CUSTOMERORDER)) {

                //order.setCellValue(item.getCustomerOrder() != null ? item.getCustomerOrder().getOrderId() : -99);	
                //itemItem.setCellValue(item.getCustomerOrder() != null ? item.getCustomerOrder().getItem().getItem() : -99);	        			        			        		
                //}
                //}

                XSSFCell processingTime = row.createCell(8);
                processingTime.setCellValue(item.getProcessingTime());

                XSSFCell energyPriceAtEnterDelay = row.createCell(9);
                energyPriceAtEnterDelay.setCellValue(item.getUsedEnergyPriceAtEnterDelay());
               
                
                //XSSFCell routintType = row.createCell(9);
                //processingTime.setCellValue(item.getRoutingType());


            }

            // Simulation Parameters

            //write Routing Times
            sheet = workbook.getSheetAt(4);
            //write header row
            row1 = sheet.createRow(0);

            r1c1 = row1.createCell(0);
            r1c1.setCellValue("Id");

            r1c2 = row1.createCell(1);
            r1c2.setCellValue("Experiment");

            r1c3 = row1.createCell(2);
            r1c3.setCellValue("Status");

            r1c4 = row1.createCell(3);
            r1c4.setCellValue("ApplyClearingFunctions");                                    

            rowCount = 1;
            //Create First Row
            XSSFRow row = sheet.createRow(rowCount);
            rowCount++;

            XSSFCell id = row.createCell(0);
            id.setCellValue(simParams.getId());

            XSSFCell experiment = row.createCell(1);
            experiment.setCellValue(simParams.getExperiment());

            XSSFCell status = row.createCell(2);
            status.setCellValue(simParams.getStatus());

            XSSFCell cf = row.createCell(3);
            cf.setCellValue(simParams.getApplyClearingFunctions());            
            

            FileOutputStream fos = new FileOutputStream(file);
            workbook.write(fos);
            fos.close();

            //System.out.println("Done");

        } catch (FileNotFoundException e) {
            e.printStackTrace();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }                        
    
                
    public static Result CreateResult(Main main, int iteration, int replication, LocalDateTime replicationEnd) {
    	
    	Result result = new Result(main.simParams.getExperiment(), iteration, replication, 
    			main.var_wip_sales,
    			main.var_wip_components,
    			main.var_inventory_sales,
    			main.var_inventory_components,
    			main.var_inventory,
    			main.var_tardiness_mean,
    			main.var_tardiness_variance,
    			main.var_overall_costs,
    			main.StatisticServiceLevel.mean(),
    			main.var_leadtime_sales_mean,
    			main.var_leadtime_sales_variance,
    			main.var_leadtime_components_mean,
    			main.var_leadtime_components_variance,
    			main.optimizationParameters.getId(),
    			main.optimizationParameters.getDescription(),
    			main.simParams,
    			main.items,
    			main.routings,
    			main.kPIAgent.function_computeSystemUtilization(true),
    			main.kPIAgent.function_computeMeanDemandPerItem(),
    			main.kPIAgent.function_computeSGIandJSI(),
    			main.var_demand,
    			(int)main.var_number_of_customer_orders,
    			main.var_lateness_mean,
    			main.var_lateness_variance,
    			main.var_number_of_production_orders,
    			main.var_ontime_percentage,
    			main.var_production_start_waiting_time_mean,
    			main.var_production_start_waiting_time_variance,
    			main.var_productionLotSizes,
    			main.var_internal_lateness_sales_items_mean,
    			main.var_internal_lateness_sales_items_variance,
    			main.var_internal_lateness_components_mean,
    			main.var_internal_lateness_components_variance,
    			main.clearingFunctionAgent.statisticStage1.mean(),
    			main.clearingFunctionAgent.statisticStage2.mean(),
    			main.clearingFunctionAgent.statisticStage3.mean(),
    			main.clearingFunctionAgent.statisticStage4.mean(),
    			main.forecastMasterdata,
    			main.clearingFunctionAgent.statisticPLStage1.mean(),
    			main.clearingFunctionAgent.statisticPLStage2.mean(),
    			main.clearingFunctionAgent.statisticPLStage3.mean(),
    			main.clearingFunctionAgent.statisticPLStage4.mean(),
    			main.var_avg_planned_leadtime_mean_PS1,
    			main.var_avg_planned_leadtime_variance_PS1,
    			main.var_avg_planned_leadtime_mean_PS2,
    			main.var_avg_planned_leadtime_variance_PS2,
    			main.var_avg_planned_leadtime_mean_PS3,
    			main.var_avg_planned_leadtime_variance_PS3,
    			main.var_avg_planned_leadtime_mean_PS4,
    			main.var_avg_planned_leadtime_variance_PS4,
    			main.var_tardiness_open_orders_mean,
    			main.var_tardiness_open_orders_variance,
    			main.var_demand_delivered,
    			main.var_demand_not_delivered,
    			main.sumEnergyCosts,
    			main.countCapacityFactorBlock,
    			main.countEnergyPriceBlock,
    			main.replicationStart,
    			replicationEnd,
    			main.optimizationParameters.getSimulationExperiment(),
    			main.var_consumed_setup_time_mean,
    			main.var_consumed_setup_time_variance,
    			main.replicationStatus,
    			main    			
    			);
    	    	    	
    	return result;
    }
    
    public static void InsertResultToDb(StringBuilder sql){  
    	                
        try {  

            DBQueries db = new DBQueries();
            java.sql.Connection conn = db.connect();
        	java.sql.Statement stmt  = conn.createStatement();  
            	
            	//traceln(sql.toString());
            	stmt.executeUpdate(sql.toString());  
            	sql.setLength(0);
                            	              
            conn.close();

        } catch (SQLException e) {  
            System.out.println(e.getMessage());  
        } 
     }  
    
    public static void DeleteResultsFromDb(String table, String experiment){  
        
        try {  
        	StringBuilder sql = new StringBuilder();
        	
        	sql.append("delete from " + table + " where experiment = '" + experiment + "'");
        	
            DBQueries db = new DBQueries();
            java.sql.Connection conn = db.connect();
        	java.sql.Statement stmt  = conn.createStatement();  
            	
            	stmt.executeUpdate(sql.toString());  
            	sql.setLength(0);
                            	              
            conn.close();

        } catch (SQLException e) {  
            System.out.println(e.getMessage());  
        } 
     }
    
    public static int GetLastSimulatedReplication(OptimizationParameter optParam){  
        String sql = "select max(Replication) as MaxReplication from \"RESULT\" where OptimizationParameter = " + optParam.getId() + " order by id DESC";
        
        int result = 0;
        
        try {  
        	DBQueries db = new DBQueries();
            java.sql.Connection conn = db.connect();  
            java.sql.Statement stmt  = conn.createStatement(ResultSet.TYPE_FORWARD_ONLY, ResultSet.CONCUR_READ_ONLY);  
            java.sql.ResultSet rs    = stmt.executeQuery(sql);  
            
            if(rs.next()) {        
            	result = rs.getInt("MaxReplication");    
            }
            conn.close();
            
        } catch (SQLException e) {  
            System.out.println(e.getMessage());  
        } 
        
        return result;
    } 
    
    public static double overallcosts_inkl_not_Delivered(double inventorySalesAvg, double inventoryComponentsAvg, double wipSalesAvg,
            double wipComponentsAvg, double tardinessMeanAvg, double demandDeliveredAvg,
            double tardinessOpenOrdersMeanAvg, double demandNotDeliveredAvg, boolean printCostingElements,
             Main main) {

        // Round all input values to 4 decimal places like SQL does
        inventorySalesAvg = round(inventorySalesAvg, 4);
        inventoryComponentsAvg = round(inventoryComponentsAvg, 4);
        wipSalesAvg = round(wipSalesAvg, 4);
        wipComponentsAvg = round(wipComponentsAvg, 4);
        tardinessMeanAvg = round(tardinessMeanAvg, 4);
        demandDeliveredAvg = round(demandDeliveredAvg, 4);
        tardinessOpenOrdersMeanAvg = round(tardinessOpenOrdersMeanAvg, 4);
        demandNotDeliveredAvg = round(demandNotDeliveredAvg, 4);

        // Print each parameter before the result is computed
        if(printCostingElements) {
	        System.out.println("inventorySalesAvg: " + inventorySalesAvg);
	        System.out.println("inventoryComponentsAvg: " + inventoryComponentsAvg);
	        System.out.println("wipSalesAvg: " + wipSalesAvg);
	        System.out.println("wipComponentsAvg: " + wipComponentsAvg);
	        System.out.println("tardinessMeanAvg: " + tardinessMeanAvg);
	        System.out.println("demandDeliveredAvg: " + demandDeliveredAvg); //here is the differnece
	        System.out.println("tardinessOpenOrdersMeanAvg: " + tardinessOpenOrdersMeanAvg);
	        System.out.println("demandNotDeliveredAvg: " + demandNotDeliveredAvg);
	        }
        // Perform rounding after each operation like SQL does
        double inventorySalesComponent = inventorySalesAvg * 2;
        double inventoryComponentsComponent = inventoryComponentsAvg * 1;
        double wipSalesComponent = wipSalesAvg * 1;
        double wipComponentsComponent = wipComponentsAvg * 0.5;

        double tardinessDeliveredComponent = tardinessMeanAvg * demandDeliveredAvg * 38; //difference
        double tardinessNotDeliveredComponent = tardinessOpenOrdersMeanAvg * demandNotDeliveredAvg * 38;
        
        if(printCostingElements) {
	        System.out.println("inventorySalesComponent: " + inventorySalesComponent);
	        System.out.println("inventoryComponentsComponent: " + inventoryComponentsComponent);
	        System.out.println("wipSalesComponent: " + wipSalesComponent);
	        System.out.println("wipComponentsComponent: " + wipComponentsComponent);
	        System.out.println("tardinessDeliveredComponent: " + tardinessDeliveredComponent);
	        System.out.println("tardinessNotDeliveredComponent: " + tardinessNotDeliveredComponent);
        }
        
        // Sum all the rounded components
        double sum = inventorySalesComponent + inventoryComponentsComponent + wipSalesComponent +
                wipComponentsComponent + tardinessDeliveredComponent + tardinessNotDeliveredComponent;
        
        if(printCostingElements) {
        	System.out.println("Sum of components: " + sum);
        }
        
        // Divide by 360 and round the final result to 0 decimal places, like SQL does
        double result = round(sum / 360, 0);
        
        if(printCostingElements) {
        	System.out.println("Final result: " + result);
        }      
        
        if(main.time() < main.simParams.getSimulationRunTime() && main.fallbackOverallCostValueInklNotDelivered > 0) {
        	traceln("OverallCost Default Value was Set: " + main.fallbackOverallCostValueInklNotDelivered);
        	result = main.fallbackOverallCostValueInklNotDelivered;
        	main.fallbackOverallCostValueInklNotDelivered = 0;
        }
        
        return result;
		}

	private static double round(double value, int places) {
		if (places < 0) throw new IllegalArgumentException();		
			BigDecimal bd = BigDecimal.valueOf(value);
			bd = bd.setScale(places, RoundingMode.HALF_UP);
		return bd.doubleValue();
	}

	@Override
	public String toString() {
	    return "Result{" +
	            "Experiment='" + Experiment + '\'' +
	            "SimulationExperiment='" + simulationExperiment + '\'' +
	            ", Iteration=" + Iteration +
	            ", Replication=" + Replication +
	            ", OverallCosts_Inkl_Not_Delivered=" + overallCosts_inkl_not_Delivered +	            
	            ", WIPSales=" + WIPSales +
	            ", WIPComponents=" + WIPComponents +
	            ", InventorySales=" + InventorySales +
	            ", InventoryComponents=" + InventoryComponents +
	            ", Inventory=" + Inventory +
	            ", TardinessMean=" + TardinessMean +
	            ", TardinessVariance=" + TardinessVariance +
	            ", OverallCosts=" + OverallCosts +
	            ", ServiceLevel=" + ServiceLevel +
	            ", LeadTimeSalesMean=" + LeadTimeSalesMean +
	            ", LeadTimeSalesVariance=" + LeadTimeSalesVariance +
	            ", LeadTimeComponentsMean=" + LeadTimeComponentsMean +
	            ", LeadTimeComponentsVariance=" + LeadTimeComponentsVariance +
	            ", OptimizationParameter=" + OptimizationParamter +
	            ", Description='" + Description + '\'' +
	            ", UsedSimulationParameter=" + (UsedSimulationParameter != null ? UsedSimulationParameter.toString() : "null") +
	            ", UsedItems=" + (UsedItems != null ? UsedItems.stream().map(Item::toString).collect(Collectors.joining(", ")) : "null") +
	            ", UsedRoutings=" + (UsedRoutings != null ? UsedRoutings.stream().map(Routing::toString).collect(Collectors.joining(", ")) : "null") +
	            ", UtilizationPS1=" + UtilizationPS1 +
	            ", UtilizationPS2=" + UtilizationPS2 +
	            ", UtilizationPS3=" + UtilizationPS3 +
	            ", UtilizationPS4=" + UtilizationPS4 +
	            ", ProductionLotSizes=" + (ProductionLotSizes != null ? ProductionLotSizes.stream().map(KPI::toString).collect(Collectors.joining(", ")) : "null") +
	            ", InternalLatenessSalesItemsMean=" + InternalLatenessSalesItemsMean +
	            ", InternalLatenessSalesItemsVariance=" + InternalLatenessSalesItemsVariance +
	            ", InternalLatenessComponentsMean=" + InternalLatenessComponentsMean +
	            ", InternalLatenessComponentsVariance=" + InternalLatenessComponentsVariance +
	            ", demandDelivered=" + demandDelivered +
	            ", demandNotDelivered=" + demandNotDelivered +
	            ", sumEnergyCosts=" + sumEnergyCosts +
	            ", countCapacityFactorBlock=" + countCapacityFactorBlock +
	            ", countEnergyPriceBlock=" + countEnergyPriceBlock +
	            ", replicationStart=" + (replicationStart != null ? replicationStart.toString() : "null") +
	            ", replicationEnd=" + (replicationEnd != null ? replicationEnd.toString() : "null") +
	            '}';
	}

	
}                                                                                                                                                                                                                                              ]]></Text>
		</JavaClass>
		<!--   =========   Java Class   ========  -->
		<JavaClass>
			<Id>1643640664621</Id>
			<Name><![CDATA[RoutingTimes]]></Name>
			<Text><![CDATA[/**
 * RoutingTimes
 */	
public class RoutingTimes implements Serializable {

    /**
     * Default constructor
     */
    public RoutingTimes() {
    }


    public static final int ROUTING_TIME_CREATED = 1;
    
    public static final int ROUTING_TIME_PROCESSING = 10;
    
    public static final int ROUTING_TIME_FINISHED = 20;
    
    public static String ROUTING_TYPE_CUSTOMERORDER = "Customer Order";
    
    public static String ROUTING_TYPE_PRODUCTIONORDER = "Production Order";
    
    private int Id;    
    private ProductionOrder ProductionOrder;  
    private double CreatedAt;  
    private double Start;  
    private double End;  
    private double Quantity;  
    private int Status;  
    private Resource Resource;
    private double ProcessingTime;    
    private double usedEnergyPriceAtEnterDelay;            
    private String RoutingType;
    
    // Getter method for usedEnergyPriceAtEnterDelay
    public double getUsedEnergyPriceAtEnterDelay() {
        return usedEnergyPriceAtEnterDelay;
    }

    // Setter method for usedEnergyPriceAtEnterDelay
    public void setUsedEnergyPriceAtEnterDelay(double usedEnergyPriceAtEnterDelay) {
        this.usedEnergyPriceAtEnterDelay = usedEnergyPriceAtEnterDelay;
    }
    
    private CustomerOrder CustomerOrder;
    
    public CustomerOrder getCustomerOrder() {
       return this.CustomerOrder;
    }
  
    public void setCustomerOrder(CustomerOrder value) {
       this.CustomerOrder = value;
    }
    
    public String getRoutingType() {
       return this.RoutingType;
    }
  
    public void setRoutingType(String value) {
       this.RoutingType = value;
    }
    
    public double getProcessingTime() {
        return this.ProcessingTime;
     }
   
     public void setProcessingTime(double value) {
        this.ProcessingTime = value;
     }
    
    public int getId() {
       return this.Id;
    }
  
    public void setId(int value) {
       this.Id = value;
    }
  
    public ProductionOrder getProductionOrder() {
       return this.ProductionOrder;
    }
  
    public void setProductionOrder(ProductionOrder value) {
       this.ProductionOrder = value;
    }
  
    public double getCreatedAt() {
       return this.CreatedAt;
    }
  
    public void setCreatedAt(double value) {
       this.CreatedAt = value;
    }
  
    public double getStart() {
       return this.Start;
    }
  
    public void setStart(double value) {
       this.Start = value;
    }
  
    public double getEnd() {
       return this.End;
    }
  
    public void setEnd(double value) {
       this.End = value;
    }
  
    public double getQuantity() {
       return this.Quantity;
    }
  
    public void setQuantity(double value) {
       this.Quantity = value;
    }
  
    public int getStatus() {
       return this.Status;
    }
  
    public void setStatus(int value) {
       this.Status = value;
    }
  
    public Resource getResource() {
       return this.Resource;
    }
  
    public void setResource(Resource value) {
       this.Resource = value;
    }
    

 public static String GetCSVHeader() {
     	
	 
     	StringBuilder out = new StringBuilder();
     	
     	out.append("Id;");
     	out.append("CreatedAt;");
     	out.append("Status;");
     	out.append("Start;");
     	out.append("End;");
     	out.append("Machine;");
     	out.append("ProductionOrder;");
     	out.append("Item;");
     	out.append("ProcessingTime;");
     	
     	return out.toString();    	    	
     }
     
     public static String GetCSVString(RoutingTimes obj) {
     	
     	StringBuilder out = new StringBuilder();
     	
     	out.append(obj.getId() + ";");
     	out.append(obj.getCreatedAt() + ";");
     	out.append(obj.getStatus() + ";");
     	out.append(obj.getStart() + ";");
     	out.append(obj.getEnd() + ";");     	
     	out.append(obj.getResource() != null ? obj.getResource().getName() + ";" : ";");
     	out.append(obj.getProductionOrder() != null ? obj.getProductionOrder().getOrderId() + ";" : ";");
     	out.append(obj.getProductionOrder() != null ? obj.getProductionOrder().getItem().getItem() + ";" : ";");     	     	     	
     	out.append(obj.getProcessingTime() + ";");
     	    	    	    	    	
     	return out.toString();
     	
     }
     
    
}]]></Text>
		</JavaClass>
		<!--   =========   Java Class   ========  -->
		<JavaClass>
			<Id>1645590643006</Id>
			<Name><![CDATA[SimulationBudgetManagement]]></Name>
			<Text><![CDATA[import java.sql.DriverManager;  
import java.sql.Connection;  
import java.sql.SQLException;
import java.util.stream.*;
import one.util.streamex.StreamEx;
import java.text.DecimalFormat;	

/**
 * SimulationBudgetManagement
 */	
public class SimulationBudgetManagement implements Serializable {

	public static final int SBM_ACTIVE = 2;
	public static final boolean SBM_STOP_AFTER_MAX_REPLICATIONS = true;
	
    /**
     * Default constructor
     */
    public SimulationBudgetManagement() {
    }

    
    public static double[] GetAVGCostPreviousIterations(int currentIteration, OptimizationParameter optParams, List<Result> iterationResults) {
        double[] dataArray = new double[currentIteration];

        try {
            // Stream directly to avoid intermediate list creation
            int[] index = {0};
            iterationResults.stream()
                    .filter(res -> res.getReplication() > 0 && res.getOverallCosts_inkl_not_Delivered() > 0)
                    .limit(currentIteration)
                    .forEach(res -> {
                        dataArray[index[0]] = res.getOverallCosts_inkl_not_Delivered();
                        index[0]++;
                    });

            traceln("Processed IterationResults size: " + index[0]);
        } catch (Exception e) {
            System.err.println("Error: " + e.getMessage());
            e.printStackTrace();
        }

        return dataArray;
    }

    
    
@Deprecated    
public static double[] GetAVGCostPreviousIterations__OldVersion(int currentIteration, OptimizationParameter optParams, List<Result> iterationResults){
	
	
	StringBuilder sqlQueryString = new StringBuilder();
    double[] dataArray = new double[currentIteration];

			
	try { 	     
          		
	    int i = 0;
	    traceln("Size Iterationresults at GetAVGCostPreviousIterations: " + iterationResults.size());	    
	    for(Result res : iterationResults.stream().filter(e -> e.getReplication() > 0 
	    		&& e.getOverallCosts_inkl_not_Delivered() > 0).collect(Collectors.toList())) {	    	
	    
			dataArray[i] = res.getOverallCosts_inkl_not_Delivered();
			traceln("Add getOverallCosts_inkl_not_Delivered: " + res.getOverallCosts_inkl_not_Delivered() + " i: " + i);
			i++;
			
		}
	}
	catch(Exception e){
		System.out.println("error:"+e);
	}
	
	return dataArray;		   		   					
	
	}	



	@Override
	public String toString() {
		return super.toString();
	}

	/**
	 * This number is here for model snapshot storing purpose<br>
	 * It needs to be changed when this class gets changed
	 */ 
	private static final long serialVersionUID = 1L;

}]]></Text>
		</JavaClass>
		<!--   =========   Java Class   ========  -->
		<JavaClass>
			<Id>1646212837000</Id>
			<Name><![CDATA[ServiceLevelPerItem]]></Name>
			<Text><![CDATA[public class ServiceLevelPerItem implements Serializable {

	  int Item;

	  private int OrdersNotDelayed;

	  private int AllOrders;

	  private double ServiceLevel;

	  public int getItem() {
	    return this.Item;
	  }

	  public void setItem(int value) {
	    this.Item = value;
	  }

	  public int getOrdersNotDelayed() {
	    return this.OrdersNotDelayed;
	  }

	  public void setOrdersNotDelayed(int value) {
	    this.OrdersNotDelayed = value;
	  }

	  public int getAllOrders() {
	    return this.AllOrders;
	  }

	  public void setAllOrders(int value) {
	    this.AllOrders = value;
	  }

	  public double getServiceLevel() {
	    return this.ServiceLevel;
	  }

	  public void setServiceLevel(double value) {
	    this.ServiceLevel = value;
	  }

	  public List < ServiceLevelPerItem > GetServiceLevelPerItem(SimulationParameter simParams) {

	    StringBuilder sql = new StringBuilder();

	    sql.append("SELECT * FROM ServiceLevelPerItem where experiment = '" + simParams.getExperiment() + "'");
	    List < ServiceLevelPerItem > items = new ArrayList < ServiceLevelPerItem > ();

	    try {
	      DBQueries db = new DBQueries();
	      java.sql.Connection conn = db.connect();
	      java.sql.Statement stmt = conn.createStatement(ResultSet.TYPE_FORWARD_ONLY, ResultSet.CONCUR_READ_ONLY);
	      java.sql.ResultSet rs = stmt.executeQuery(sql.toString());

	      while (rs.next()) {

	        ServiceLevelPerItem item = new ServiceLevelPerItem();

	        item.setItem(rs.getInt("Item"));
	        item.setOrdersNotDelayed(rs.getInt("OrdersNotDelayed"));
	        item.setAllOrders(rs.getInt("AllOrders"));
	        item.setServiceLevel(rs.getDouble("ServiceLevel"));

	        items.add(item);
	      }

	      conn.close();

	    } catch (Exception e) {
	      System.out.println(e.getMessage());
	    }

	    return items;

	  }
	}]]></Text>
		</JavaClass>
		<!--   =========   Java Class   ========  -->
		<JavaClass>
			<Id>1646296101228</Id>
			<Name><![CDATA[TardinessPerItem]]></Name>
			<Text><![CDATA[/**
 * TardinessPerItem
 */	
public class TardinessPerItem implements Serializable {

	   private int item;
	 
	   private double BacklogCosts;
	 
	   private double SumTardinessDelayedOrders;
	 
	   private double OverallTardinessCosts;
	 
	   private int AllOrders;
	 
	   public int getItem() {
	      return this.item;
	   }
	 
	   public void setItem(int value) {
	      this.item = value;
	   }
	 
	   public double getBacklogCosts() {
	      return this.BacklogCosts;
	   }
	 
	   public void setBacklogCosts(double value) {
	      this.BacklogCosts = value;
	   }
	 
	   public double getSumTardinessDelayedOrders() {
	      return this.SumTardinessDelayedOrders;
	   }
	 
	   public void setSumTardinessDelayedOrders(double value) {
	      this.SumTardinessDelayedOrders = value;
	   }
	 
	   public double getOverallTardinessCosts() {
	      return this.OverallTardinessCosts;
	   }
	 
	   public void setOverallTardinessCosts(double value) {
	      this.OverallTardinessCosts = value;
	   }
	 
	   public int getAllOrders() {
	      return this.AllOrders;
	   }
	 
	   public void setAllOrders(int value) {
	      this.AllOrders = value;
	   }

	   
	   public List < TardinessPerItem > GetTardinessPerItem(SimulationParameter simParams) {

		    StringBuilder sql = new StringBuilder();

		    sql.append("SELECT * FROM TardinessPerItem where experiment = '" + simParams.getExperiment() + "'");
		    List < TardinessPerItem > items = new ArrayList < TardinessPerItem > ();

		    try {
		      DBQueries db = new DBQueries();
		      java.sql.Connection conn = db.connect();
		      java.sql.Statement stmt = conn.createStatement(ResultSet.TYPE_FORWARD_ONLY, ResultSet.CONCUR_READ_ONLY);
		      java.sql.ResultSet rs = stmt.executeQuery(sql.toString());

		      while (rs.next()) {

		        TardinessPerItem item = new TardinessPerItem();

		        item.setItem(rs.getInt("Item"));
		        item.setBacklogCosts(rs.getInt("BacklogCosts"));
		        item.setSumTardinessDelayedOrders(rs.getInt("SumTardinessDelayedOrders"));
		        item.setOverallTardinessCosts(rs.getDouble("OverallTardinessCosts"));
		        item.setAllOrders(rs.getInt("AllOrders"));

		        items.add(item);
		      }

		      conn.close();

		    } catch (Exception e) {
		      System.out.println(e.getMessage());
		    }
		    return items;
		  }
	   
	   
	@Override
	public String toString() {
		return super.toString();
	}

	/**
	 * This number is here for model snapshot storing purpose<br>
	 * It needs to be changed when this class gets changed
	 */ 
	private static final long serialVersionUID = 1L;

}]]></Text>
		</JavaClass>
		<!--   =========   Java Class   ========  -->
		<JavaClass>
			<Id>1646304980460</Id>
			<Name><![CDATA[InventoryPerItem]]></Name>
			<Text><![CDATA[/**
 * InventoryPerItem
 */	
public class InventoryPerItem implements Serializable {

    /**
     * Default constructor
     */
    public InventoryPerItem() {
    }
        
    private int Item;
    
    private double HoldingCosts;
  
    private double OverallInventory;
  
    private double OverallInventorycosts;
  
    public int getItem() {
       return this.Item;
    }
  
    public void setItem(int value) {
       this.Item = value;
    }
  
    public double getHoldingCosts() {
       return this.HoldingCosts;
    }
  
    public void setHoldingCosts(double value) {
       this.HoldingCosts = value;
    }
  
    public double getOverallInventory() {
       return this.OverallInventory;
    }
  
    public void setOverallInventory(double value) {
       this.OverallInventory = value;
    }
  
    public double getOverallInventorycosts() {
       return this.OverallInventorycosts;
    }
  
    public void setOverallInventorycosts(double value) {
       this.OverallInventorycosts = value;
    }
    

    public List < InventoryPerItem > GetInventoryPerItem(SimulationParameter simParams) {

	    StringBuilder sql = new StringBuilder();

	    sql.append("SELECT * FROM OverallCostInventory where experiment = '" + simParams.getExperiment() + "'");
	    List < InventoryPerItem > items = new ArrayList < InventoryPerItem > ();

	    try {
	      DBQueries db = new DBQueries();
	      java.sql.Connection conn = db.connect();
	      java.sql.Statement stmt = conn.createStatement(ResultSet.TYPE_FORWARD_ONLY, ResultSet.CONCUR_READ_ONLY);
	      java.sql.ResultSet rs = stmt.executeQuery(sql.toString());

	      while (rs.next()) {

	    	  InventoryPerItem item = new InventoryPerItem();

	        item.setItem(rs.getInt("Item"));
	        item.setHoldingCosts(rs.getDouble("Holdingcosts"));
	        item.setOverallInventory(rs.getDouble("OverallInventory"));
	        item.setOverallInventorycosts(rs.getDouble("OverallInventoryCosts"));

	        items.add(item);
	      }

	      conn.close();

	    } catch (Exception e) {
	      System.out.println(e.getMessage());
	    }
	    return items;
	  }
   
    
    
	@Override
	public String toString() {
		return super.toString();
	}

	/**
	 * This number is here for model snapshot storing purpose<br>
	 * It needs to be changed when this class gets changed
	 */ 
	private static final long serialVersionUID = 1L;

}]]></Text>
		</JavaClass>
		<!--   =========   Java Class   ========  -->
		<JavaClass>
			<Id>1648402609444</Id>
			<Name><![CDATA[PropertyValues]]></Name>
			<Text><![CDATA[import java.io.FileNotFoundException;
import java.io.IOException;
import java.io.InputStream;
import java.util.Date;
import java.util.Properties;
import java.util.*;
import java.io.*;

  
public class PropertyValues {
	
	
	String SQLiteDatabase;
	String H2Host;
	String FileName;
	String ProductionStageStatistics;
	String ApplyRPS;
	String WriteResultsPerReplicationToDb;
	String PostGresHost;
	String CFSegments;
	String ExternalCapacity;
	String RandomOptimizationParameter;
	String LocationEnergyPricesInputExcel;
	String EnergyPriceBasedRelease;
	String SafetyStockAtBeginning;
	String ForecastInputFile;
	String OverallCostsLimit;
	String OverallCostsCheckRecurrenceTime;
	String OverallCostsFirstOccurenceTime;
	
	public PropertyValues(String fileName) throws IOException {
		
		FileName = fileName;
		GetPropValues();
	}
	
	private void GetPropValues() throws IOException {
 
		Properties prop = new Properties();
		 FileInputStream fis = null;
		try {
			
			fis = new FileInputStream(FileName);
			prop.load(fis);				
 
			if (fis != null) {
				prop.load(fis);
			} else {
				throw new FileNotFoundException("property file '" + FileName + "' not found in the classpath");
			}
 
			Date time = new Date(System.currentTimeMillis());
 
			// get the property value and print it out
			H2Host = prop.getProperty("H2host");
			SQLiteDatabase = prop.getProperty("SQLiteDatabase");
			ProductionStageStatistics = prop.getProperty("ProductionStageStatistics");
			WriteResultsPerReplicationToDb = prop.getProperty("WriteResultsPerReplicationToDb");
			PostGresHost = prop.getProperty("PostGresHost");
			CFSegments = prop.getProperty("CFSegments");
			ExternalCapacity = prop.getProperty("ExternalCapacity");
			RandomOptimizationParameter = prop.getProperty("RandomOptimizationParameter");
			LocationEnergyPricesInputExcel = prop.getProperty("LocationEnergyPricesInputExcel");										
			EnergyPriceBasedRelease = prop.getProperty("EnergyPriceBasedRelease");
			SafetyStockAtBeginning = prop.getProperty("SafetyStockAtBeginning");
			ForecastInputFile = prop.getProperty("ForecastInputFile");
			OverallCostsLimit = prop.getProperty("OverallCostsLimit");
			OverallCostsCheckRecurrenceTime = prop.getProperty("OverallCostsCheckRecurrenceTime");
			OverallCostsFirstOccurenceTime = prop.getProperty("OverallCostsFirstOccurenceTime");

			 			
			//traceln("H2Host " + H2Host);
			//traceln("SQLiteDatabase " + SQLiteDatabase);
			
		} catch (Exception e) {
			System.out.println("Exception: " + e);
		} finally {
			fis.close();
		}
	}
}]]></Text>
		</JavaClass>
		<!--   =========   Java Class   ========  -->
		<JavaClass>
			<Id>1651554917745</Id>
			<Name><![CDATA[ResourceGroup]]></Name>
			<Text><![CDATA[/**
 * ResourceGroup
 */	
public class ResourceGroup implements Serializable {

    /**
     * Default constructor
     */
    public ResourceGroup() {
    }

    private int Id;
    
    private String Name;
    
    public int getId() {
       return this.Id;
    }
  
    public void setId(int value) {
       this.Id = value;
    }
  
    public String getName() {
       return this.Name;
    }
  
    public void setName(String value) {
       this.Name = value;
    }
     
		
  public static List<ResourceGroup> GetResourcesGroups(SimulationParameter simParams){  
        String sql = "SELECT * FROM ResourceGroup";  
        
        List<ResourceGroup> resources = new ArrayList();
        
        try {  
        	DBQueries db = new DBQueries();
            java.sql.Connection conn = db.connect();  
            java.sql.Statement stmt  = conn.createStatement();  
            java.sql.ResultSet rs    = stmt.executeQuery(sql);             
              
            // loop through the result set  
            while (rs.next()) {  
            	
            	ResourceGroup resource = new ResourceGroup();
            	
            	resource.setId(rs.getInt("id"));
            	resource.setName(rs.getString("name"));
            	
            	resources.add(resource);
            	
            	if(DBQueries.TRACE_DB_RESULTS) {
	                System.out.println(rs.getInt("id") +  "\t" +   
	                                   rs.getString("name"));  
            	}
            }  
            conn.close();
            
        } catch (SQLException e) {  
            System.out.println(e.getMessage());  
        } 
        
        return resources;
    }  
	
	@Override
	public String toString() {
		return super.toString();
	}

}]]></Text>
		</JavaClass>
		<!--   =========   Java Class   ========  -->
		<JavaClass>
			<Id>1652790126820</Id>
			<Name><![CDATA[ClearingFunction]]></Name>
			<Text><![CDATA[import java.util.stream.*;
import one.util.streamex.StreamEx;

/**
 * ClearingFunction
 */	
public class ClearingFunction implements Serializable {

	public static final String FILENAME_RELEASE_ORDER = "output\\ReleaseOrder";
	public static final boolean LOG_CF_RELEASE_ORDER_DELETE_OUTPUTFILE = true;		

	
    /**
     * Default constructor
     */
    public ClearingFunction(double capacityProvided, double capacityAvailable, double workInSystem) {    	
    	this.CapacityProvided = capacityProvided;
    	this.CapacityAvailable = capacityAvailable;
    	this.WorkInSystem = workInSystem;    	
    }
    
    private double WorkInSystem;
    
    private double CapacityProvided;
  
    private double CapacityAvailable;
  
    public double getWorkInSystem() {
       return this.WorkInSystem;
    }
  
    public void setWorkInSystem(double value) {
       this.WorkInSystem = value;
    }
  
    public double getCapacityProvided() {
       return this.CapacityProvided;
    }
  
    public void setCapacityProvided(double value) {
       this.CapacityProvided = value;
    }
  
    public double getCapacityAvailable() {
       return this.CapacityAvailable;
    }
  
    public void setCapacityAvailable(double value) {
       this.CapacityAvailable = value;
    }
    
       
    
    
	@Override
	public String toString() {
		return super.toString();
	}

	/**
	 * This number is here for model snapshot storing purpose<br>
	 * It needs to be changed when this class gets changed
	 */ 
	private static final long serialVersionUID = 1L;

}]]></Text>
		</JavaClass>
		<!--   =========   Java Class   ========  -->
		<JavaClass>
			<Id>1654761443635</Id>
			<Name><![CDATA[KPI]]></Name>
			<Text><![CDATA[/**
 * KPI
 */	

import java.util.stream.*;
import simopt.Item;


public class KPI implements Serializable {

    /**
     * Default constructor
     */
    public KPI(double value, String valueString) {
    	this.Value = value;
    	this.ValueString = valueString;
    }
    
    public KPI(int item, double value, String valueString) {
    	this.Item = item;
    	this.Value = value;
    	this.ValueString = valueString;
    }
        
    private double Value;
    
    private String ValueString;
  
    private int Item;
    
    public int getItem() {
       return this.Item;
    }
  
    public void setItem(int value) {
       this.Item = value;
    }
    
    public double getValue() {
        return this.Value;
     }
   
     public void setValue(double value) {
        this.Value = value;
     }
   
     public String getValueString() {
        return this.ValueString;
     }
   
     public void setValueString(String value) {
        this.ValueString = value;
     }
    
    
     public static double GetInventorySales(Main main, double time) {
    	 

    	 Item dummyItem = new Item();
    	
    	double inventory_sales = 0;
    	for(Item item : main.items.stream().filter(e->e.getType().equals(dummyItem.ITEM_TYPE_SALES)).collect(Collectors.toList())){

    		main.stockBookings.stream().filter(e->e.getItem().getType().equals(dummyItem.ITEM_TYPE_SALES) 
    		//&& e.getTime()>=time
    		&& e.getItem().getItem() == item.getItem()).
    		forEach(
    			e-> main.stat_inventory_sales.
    			add(e.getNewInventory() , e.getTime()));		
    			
    		inventory_sales = inventory_sales +
    		main.stat_inventory_sales.integral(Double.valueOf(main.simParams.getSimulationRunTime()));	
    			
    		main.stat_inventory_sales.reset();
    	}

    	//traceln("Inventory sales items (1): " + inventory_sales);
		
    	main.stat_inventory_sales.reset();

    	return inventory_sales;

     }
    	
     public static double GetInventoryComponents(Main main, double time) {

    	 
    	 Item dummyItem = new Item();

    	 double inventory_components = 0;
    	 
    	for(Item item : main.items.stream().filter(e->e.getType().equals(dummyItem.ITEM_TYPE_COMPONENT)).collect(Collectors.toList())){
    		main.stockBookings.stream().filter(e->e.getItem().getType().equals(dummyItem.ITEM_TYPE_COMPONENT) 
    		//&& e.getTime()>=time
    		&& e.getItem().getItem() == item.getItem()).
    		forEach(e-> main.stat_inventory_components.
    		add(e.getNewInventory() , e.getTime()));
    		
    		inventory_components = inventory_components +
    		main.stat_inventory_components.integral(Double.valueOf(main.simParams.getSimulationRunTime()));	
    		
    		main.stat_inventory_components.reset();
    	}

    	//traceln("Inventory Components (2): " + inventory_components);
    	
		main.stat_inventory_components.reset();
    
    	return inventory_components;
     }

     public static double GetWIPSales(Main main, double time) {

    	Item dummyItem = new Item();
    	
    	double wip_sales = 0;
    	
    	main.productionOrders.stream().
    	filter(e->e.getItem().getType().equals(dummyItem.ITEM_TYPE_SALES) 
    	&& e.getStatus()== ProductionOrder.PRODUCTION_ORDER_STATUS_PROCESSED).
    	forEach(e-> main.stat_wip_sales.add((e.getActualEnd()-max(0,e.getActualReleaseDate()))*e.getQuantity())); 

    	main.productionOrders.stream().
    	filter(e->e.getItem().getType().equals(dummyItem.ITEM_TYPE_SALES) 
    	&& (e.getStatus()== ProductionOrder.PRODUCTION_ORDER_STATUS_RELEASED 
    	|| e.getStatus()== ProductionOrder.PRODUCTION_ORDER_STATUS_PROCESSING)).
    	forEach(e-> main.stat_wip_sales.add((main.simParams.getSimulationRunTime()-max(0,e.getActualReleaseDate()))*e.getQuantity())); 

    	wip_sales = main.stat_wip_sales.sum();

    	//traceln("WIP Sales Items (3): " + wip_sales);
    	
    	main.stat_wip_sales.reset();
    	
    	return wip_sales;
     }
     
     public static double GetWIPComponents(Main main, double time) {

    	
    	Item dummyItem = new Item();
    	double wip_components = 0; 
    	
    	main.productionOrders.stream().filter(e->e.getItem().getType().equals(dummyItem.ITEM_TYPE_COMPONENT) 
    	&& e.getStatus()== ProductionOrder.PRODUCTION_ORDER_STATUS_PROCESSED).
    	forEach(e-> main.stat_wip_components.add((e.getActualEnd()-max(0,e.getActualReleaseDate()))*e.getQuantity())); 

    	main.productionOrders.stream().
    	filter(e->e.getItem().getType().equals(dummyItem.ITEM_TYPE_COMPONENT) 
    	&& (e.getStatus()== ProductionOrder.PRODUCTION_ORDER_STATUS_RELEASED 
    	|| e.getStatus()== ProductionOrder.PRODUCTION_ORDER_STATUS_PROCESSING)).
    	forEach(e-> main.stat_wip_components.add((main.simParams.getSimulationRunTime()-max(0,e.getActualReleaseDate()))*e.getQuantity())); 

    	wip_components = main.stat_wip_components.sum();
    	
    	//traceln("WIP Components (4): " + wip_components);
    	
    	main.stat_wip_components.reset();
    	
    	return wip_components;
    	 
     }

     public static double GetTardinessMean(Main main, double time) {
    	     	 
    	 main. customerOrders.stream().
    	 filter(e->e.getStatus() != CustomerOrder.ORDER_STATUS_UNPROCESSED). 
    	 //&& e.getCreatedAt()>=time).
    	 forEach(e->main.stat_tardiness.add(max(0,e.getActualEnd()-e.getDueDate())));

    	 double tardiness_mean = main.stat_tardiness.mean();
    	 
    	 //traceln("Tardiness (Mean): " + tardiness_mean);
    	 
    	 main.stat_tardiness.reset();
    	 
    	 return tardiness_mean;
    	 
     }

     public static double GetDemandDelivered(Main main, double time) {
	     main.customerOrders.stream().
	     filter(e->(e.getStatus() == CustomerOrder.ORDER_STATUS_DELAYED_AND_BOOKED 
	     || e.getStatus() == CustomerOrder.ORDER_STATUS_FINISHED)).
	     forEach(e->main.stat_demand_delivered.add(e.getQuantity()));
	     
	     double demand_delivered = main.stat_demand_delivered.sum();
	     
	     //traceln("Demand (Total all sales items independent of delivery status): " + demand_delivered);
	 
	     main.stat_demand_delivered.reset();
	     
	     return demand_delivered;
     
     }

     public static double GetDemandNotDelivered(Main main, double time){
	     main.customerOrders.stream().
	     filter(e->(e.getStatus() == CustomerOrder.ORDER_STATUS_DELAYED)).
	     forEach(e->main.stat_demand_not_delivered.add(e.getQuantity()));
	     
	     double demand_not_delivered = main.stat_demand_not_delivered.sum();
	     
	     //traceln("Demand (Total all sales items Not delivered): " + demand_not_delivered);
	     
	     main.stat_demand_not_delivered.reset();
	     
	     return demand_not_delivered;
     }
     
     public static double GetTardinessOpenOrdersMean(Main main, double time) {

			main.customerOrders.stream().
			filter(e->e.getStatus() == CustomerOrder.ORDER_STATUS_DELAYED).
			forEach(e->main.stat_tardiness_open_orders.add(max(0,time-e.getDueDate())));
								
			double tardiness_open_orders_mean = main. stat_tardiness_open_orders.mean();
			
			//traceln("Tardiness Late Orders (Mean): " +tardiness_open_orders_mean);
    	 
			main.stat_tardiness_open_orders.reset();
			
			return tardiness_open_orders_mean;
			
     }
     
	@Override
	public String toString() {
		return super.toString();
	}

	/**
	 * This number is here for model snapshot storing purpose<br>
	 * It needs to be changed when this class gets changed
	 */ 
	private static final long serialVersionUID = 1L;

}]]></Text>
		</JavaClass>
		<!--   =========   Java Class   ========  -->
		<JavaClass>
			<Id>1661920034159</Id>
			<Name><![CDATA[OrderPast]]></Name>
			<Text><![CDATA[/**
 * OrderPast
 */	
public class OrderPast implements Serializable {

    /**
     * Default constructor
     */
    public OrderPast(int id, Item item, int quantity, int dueDate) {    	
    	this.id = id;
    	this.item = item;
    	this.Quantity = quantity;
    	this.DueDate = dueDate;    		    	
    }
    
    private int id;
    
    private Item item;
  
    private int Quantity;
  
    private int DueDate;
  
    public int getId() {
       return this.id;
    }
  
    public void setId(int value) {
       this.id = value;
    }
  
    public Item getItem() {
       return this.item;
    }
  
    public void setItem(Item value) {
       this.item = value;
    }
  
    public int getQuantity() {
       return this.Quantity;
    }
  
    public void setQuantity(int value) {
       this.Quantity = value;
    }
  
    public int getDueDate() {
       return this.DueDate;
    }
  
    public void setDueDate(int value) {
       this.DueDate = value;
    }
    

	@Override
	public String toString() {
		return super.toString();
	}

	/**
	 * This number is here for model snapshot storing purpose<br>
	 * It needs to be changed when this class gets changed
	 */ 
	private static final long serialVersionUID = 1L;

}]]></Text>
		</JavaClass>
		<!--   =========   Java Class   ========  -->
		<JavaClass>
			<Id>1662121195770</Id>
			<Name><![CDATA[OptimizationResult]]></Name>
			<Text><![CDATA[import java.io.IOException;
import java.text.DecimalFormatSymbols;
import org.apache.poi.xssf.usermodel.XSSFCell;
import org.apache.poi.xssf.usermodel.XSSFRow;
import org.apache.poi.xssf.usermodel.XSSFSheet;
import org.apache.poi.xssf.usermodel.XSSFWorkbook;
import java.util.stream.*;
import org.apache.poi.ss.usermodel.*;
import org.apache.poi.xssf.usermodel.XSSFWorkbook;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.IOException;
import java.text.SimpleDateFormat;
import ilog.concert.*;
import ilog.cplex.*;

/**
 * OptimizationResult
 */	
public class OptimizationResult implements Serializable {

	
	public static final boolean OPTIMIZATION_RESULTS_EXCEL_FILENAME_NEW_PER_SIMULATION = true;
    public static final String OPTIMIZATION_RESULTS_EXCEL_FILENAME = "output\\opptimizationResults.xlsx";
    public static final String OPTIMIZATION_RESULTS_FOR_PERIOD_EXCEL_FOLDER = "output\\";
    public static final int OPTIMIZATION_RESULT_FOR_PERIOD = 0;
    
    public static final String OPTIMIZATION_RESULTS_EXCEL_FOLDER = "output";
    public static final boolean WRITE_OPTIMIZATION_RESULTS_TO_XLXS = true;

	
    /**
     * Default constructor
     */
    
	public OptimizationResult(int product, double time, int t, int wip, int x, double release, double p, double pL, double l, int mc,
			int cF1, int cF2, int cF3, int inv, int iBl, int wB, int objPP, double ct, int bt, double pTime,
			double sTime, double pLConst, double lt, int iCo, int wCo, int bco, int co, double z) {
		this.product = product;
		this.time = time;
		this.t = t;
		this.wip = wip;
		this.x = x;
		this.release = release;
		this.p = p;
		this.pL = pL;
		this.l = l;
		this.mc = mc;		
		this.cF1 = cF1;
		this.cF2 = cF2;
		this.cF3 = cF3;
		this.inv = inv;
		this.iBl = iBl;
		this.wB = wB;
		this.objPP = objPP;
		this.ct = ct;
		this.bt = bt;
		this.pTime = pTime;
		this.sTime = sTime;
		this.pLConst = pLConst;
		this.lt = lt;
		this.iCo = iCo;
		this.wCo = wCo;
		this.bco = bco;
		this.co = co;
		this.z = z;
	}
	
	
	private int product;
	private double time;
	private int t;
	private int wip;
	private int x;
	private double release;
	private double p;
	private double pL;
	private double l;
	private int mc;
	private int cF1;
	private int cF2;
	private int cF3;
	private int inv;
	private int iBl;
	private int wB;
	private int objPP;
	private double ct;
	private int bt;
	private double pTime;
	private double sTime;
	private double pLConst;
	private double lt;
	private int iCo;
	private int wCo;
	private int bco;
	private int co;	
	private double z; // Private variable for encapsulation
	
    // Getter for z
    public double getZ() {
        return z;
    }

    // Setter for z
    public void setZ(double newZ) {
        z = newZ;
    }
	
	public int getProduct() {
		return product;
	}
	public void setProduct(int product) {
		this.product = product;
	}
	public double getTime() {
		return time;
	}
	public void setTime(double time) {
		this.time = time;
	}
	public int getT() {
		return t;
	}
	public void setT(int t) {
		this.t = t;
	}
	public int getWip() {
		return wip;
	}
	public void setWip(int wip) {
		this.wip = wip;
	}
	public int getX() {
		return x;
	}
	public void setX(int x) {
		this.x = x;
	}
	public double getRelease() {
		return release;
	}
	public void setRelease(double release) {
		this.release = release;
	}
	public double getP() {
		return p;
	}
	public void setP(double p) {
		this.p = p;
	}
	public double getpL() {
		return pL;
	}
	public void setpL(double pL) {
		this.pL = pL;
	}
	public double getL() {
		return l;
	}
	public void setL(double l) {
		this.l = l;
	}
	public int getMc() {
		return mc;
	}
	public void setMc(int mc) {
		this.mc = mc;
	}	
	public int getcF1() {
		return cF1;
	}
	public void setcF1(int cF1) {
		this.cF1 = cF1;
	}
	public int getcF2() {
		return cF2;
	}
	public void setcF2(int cF2) {
		this.cF2 = cF2;
	}
	public int getcF3() {
		return cF3;
	}
	public void setcF3(int cF3) {
		this.cF3 = cF3;
	}
	public int getInv() {
		return inv;
	}
	public void setInv(int inv) {
		this.inv = inv;
	}
	public int getiBl() {
		return iBl;
	}
	public void setiBl(int iBl) {
		this.iBl = iBl;
	}
	public int getwB() {
		return wB;
	}
	public void setwB(int wB) {
		this.wB = wB;
	}
	public int getObjPP() {
		return objPP;
	}
	public void setObjPP(int objPP) {
		this.objPP = objPP;
	}
	public double getCt() {
		return ct;
	}
	public void setCt(double ct) {
		this.ct = ct;
	}
	public int getBt() {
		return bt;
	}
	public void setBt(int bt) {
		this.bt = bt;
	}
	public double getpTime() {
		return pTime;
	}
	public void setpTime(double pTime) {
		this.pTime = pTime;
	}
	public double getsTime() {
		return sTime;
	}
	public void setsTime(double sTime) {
		this.sTime = sTime;
	}
	public double getpLConst() {
		return pLConst;
	}
	public void setpLConst(double pLConst) {
		this.pLConst = pLConst;
	}
	public double getLt() {
		return lt;
	}
	public void setLt(double lt) {
		this.lt = lt;
	}
	public int getiCo() {
		return iCo;
	}
	public void setiCo(int iCo) {
		this.iCo = iCo;
	}
	public int getwCo() {
		return wCo;
	}
	public void setwCo(int wCo) {
		this.wCo = wCo;
	}
	public int getBco() {
		return bco;
	}
	public void setBco(int bco) {
		this.bco = bco;
	}
	public int getCo() {
		return co;
	}
	public void setCo(int co) {
		this.co = co;
	}
	

    
    public static void WriteXlsxOptimizationResults(List<OptimizationResult> optResults, SimulationParameter simpParams) {   
    
    	 try {
         	    		
    		 String fileName = OPTIMIZATION_RESULTS_EXCEL_FILENAME; 
    		 
         	if(OPTIMIZATION_RESULTS_EXCEL_FILENAME_NEW_PER_SIMULATION) {
         		SimpleDateFormat simpleDateFormat =
         		new SimpleDateFormat("YYYYMMddhhmmss");
         		String dateAsString = simpleDateFormat.format(new Date());
         		        		       		
         		fileName = OPTIMIZATION_RESULTS_EXCEL_FOLDER + "\\optimizationResult_" + dateAsString + ".xlsx";
         	}
         	
             File file = new File(fileName);

             XSSFWorkbook emptyWorkbook = new XSSFWorkbook();
             XSSFSheet spreadsheet = emptyWorkbook.createSheet("Optimization Results");


             FileOutputStream ostream
                 = new FileOutputStream(file);

             emptyWorkbook.write(ostream);
             ostream.close();

             FileInputStream fis = new FileInputStream(new File(fileName));

             XSSFWorkbook workbook = new XSSFWorkbook(fis);

             //write Customer Orders
             XSSFSheet sheet = workbook.getSheetAt(0);
             //write header row
             XSSFRow row1 = sheet.createRow(0);
             
             XSSFCell r1c0 = row1.createCell(0);
             r1c0.setCellValue("p");
             XSSFCell r1c1 = row1.createCell(1);                         
             
             r1c1.setCellValue("Time");
             XSSFCell r1c2 = row1.createCell(2);
             r1c2.setCellValue("t");
             XSSFCell r1c3 = row1.createCell(3);
             r1c3.setCellValue("Wip");
             XSSFCell r1c4 = row1.createCell(4);
             r1c4.setCellValue("X");
             XSSFCell r1c5 = row1.createCell(5);
             r1c5.setCellValue("Release");
             XSSFCell r1c6 = row1.createCell(6);
             r1c6.setCellValue("P");
             XSSFCell r1c7 = row1.createCell(7);
             r1c7.setCellValue("PL");
             
             XSSFCell r1c8 = row1.createCell(8);
             r1c8.setCellValue("L");
             XSSFCell r1c9 = row1.createCell(9);
             r1c9.setCellValue("MC");
             
             XSSFCell r1c10 = row1.createCell(10);
             r1c10.setCellValue("CF1");
             XSSFCell r1c11 = row1.createCell(11);
             r1c11.setCellValue("CF2");
             XSSFCell r1c12 = row1.createCell(12);
             r1c12.setCellValue("CF3");
             
             XSSFCell r1c13 = row1.createCell(13);
             r1c13.setCellValue("Inv");
             
             XSSFCell r1c14 = row1.createCell(14);
             r1c14.setCellValue("IBl");
             
             XSSFCell r1c15 = row1.createCell(15);
             r1c15.setCellValue("WB");
             
             XSSFCell r1c16 = row1.createCell(16);
             r1c16.setCellValue("ObjPP");
             
             XSSFCell r1c17 = row1.createCell(17);
             r1c17.setCellValue("Ct");
             
             XSSFCell r1c18 = row1.createCell(18);
             r1c18.setCellValue("Bt");
             
             XSSFCell r1c19 = row1.createCell(19);
             r1c19.setCellValue("PTime");
             
             XSSFCell r1c20 = row1.createCell(20);
             r1c20.setCellValue("STime");
             
             XSSFCell r1c21 = row1.createCell(21);
             r1c21.setCellValue("PL");
             
             XSSFCell r1c22 = row1.createCell(22);
             r1c22.setCellValue("Lt");
             
             XSSFCell r1c23 = row1.createCell(23);
             r1c23.setCellValue("Ico");
             
             XSSFCell r1c24 = row1.createCell(24);
             r1c24.setCellValue("Wco");
             
             XSSFCell r1c25 = row1.createCell(25);
             r1c25.setCellValue("Bco");
             
             XSSFCell r1c26 = row1.createCell(26);
             r1c26.setCellValue("Co");
             
             XSSFCell r1c27 = row1.createCell(27);
             r1c27.setCellValue("Iteration");             
                         
             int rowCount = 1;
                          
             StringBuilder sqlResultCustomerOrder = new StringBuilder();
             
             for (OptimizationResult item: optResults) {
             	
             	sqlResultCustomerOrder.setLength(0);
             	
                 //Create First Row
                 XSSFRow row = sheet.createRow(rowCount);
                 rowCount++;

                 XSSFCell p = row.createCell(0);
                 p.setCellValue(item.getProduct());
                 
                 XSSFCell time = row.createCell(1);
                 time.setCellValue(item.getTime());
                 
                 XSSFCell t = row.createCell(2);
                 t.setCellValue(item.getT());
                 
                 XSSFCell wip = row.createCell(3);
                 wip.setCellValue(item.getWip());
                 
                 XSSFCell X = row.createCell(4);
                 X.setCellValue(item.getX());
                 
                 XSSFCell Release = row.createCell(5);
                 Release.setCellValue(item.getRelease());               
                 
                 XSSFCell P = row.createCell(6);
                 P.setCellValue(item.getP());
                 
                 XSSFCell PL = row.createCell(7);
                 PL.setCellValue(item.getpL());
                 
                 XSSFCell L = row.createCell(8);
                 L.setCellValue(item.getL());
                 
                 XSSFCell MC = row.createCell(9);
                 MC.setCellValue(item.getMc());
                 
                 XSSFCell CF1 = row.createCell(10);
                 CF1.setCellValue(item.getcF1());
                 
                 XSSFCell CF2 = row.createCell(11);
                 CF2.setCellValue(item.getcF2());
                 
                 XSSFCell CF3 = row.createCell(12);
                 CF3.setCellValue(item.getcF3());
                 
                 XSSFCell Inv = row.createCell(13);
                 Inv.setCellValue(item.getInv());
                 
                 XSSFCell IBl = row.createCell(14);
                 IBl.setCellValue(item.getiBl());
                 
                 XSSFCell WB = row.createCell(15);
                 WB.setCellValue(item.getwB());
                 
                 XSSFCell ObjPP = row.createCell(16);
                 ObjPP.setCellValue(item.getObjPP());
                 
                 XSSFCell Ct = row.createCell(17);
                 Ct.setCellValue(item.getCt());
                 
                 XSSFCell Bt = row.createCell(18);
                 Bt.setCellValue(item.getBt());
                 
                 XSSFCell PTime = row.createCell(19);
                 PTime.setCellValue(item.getpTime());
                 
                 XSSFCell STime = row.createCell(20);
                 STime.setCellValue(item.getsTime());
                 
                 XSSFCell PlConst = row.createCell(21);
                 PlConst.setCellValue(item.getpLConst());
                 
                 XSSFCell Lt = row.createCell(22);
                 Lt.setCellValue(item.getLt());
                 
                 XSSFCell ICo = row.createCell(23);
                 ICo.setCellValue(item.getiCo());
                 
                 XSSFCell WCo = row.createCell(24);
                 WCo.setCellValue(item.getwCo());
                 
                 XSSFCell BCo = row.createCell(25);
                 BCo.setCellValue(item.getBco());
                 
                 XSSFCell Co = row.createCell(26);
                 Co.setCellValue(item.getCo());
                 
                 XSSFCell Iteration = row.createCell(27);
                 Iteration.setCellValue(item.getTime() - item.getT());

                 
              	//p	Time	t	Wip	X	Release	P	PL	L	MC	CF1	CF2	CF3	Inv	IBl	WB	ObjPP	Ct	Bt	PTime	STime	PL	Lt	ICo	WCo	Bco	Co
                 
                 
             }                                                 

             FileOutputStream fos = new FileOutputStream(file);
             workbook.write(fos);
             fos.close();

         } catch (FileNotFoundException e) {
             e.printStackTrace();
         } catch (IOException e) {
             e.printStackTrace();
         }                                   
    
    }   

    public static double getValueOrDefault(IloCplex cplex, IloNumVar[][] Z, int p, int t, double defaultValue) {
        try {
            if (Z != null && p >= 0 && p < Z.length && Z[p] != null && t >= 0 && t < Z[p].length) {
                return cplex.getValue(Z[p][t]);
            }
        } catch (IloException e) {
            //System.out.println("Exception while accessing Z[" + p + "][" + t + "]: " + e.getMessage());
        }
        return defaultValue;
    }
        
	@Override
	public String toString() {
		return super.toString();
	}

	/**
	 * This number is here for model snapshot storing purpose<br>
	 * It needs to be changed when this class gets changed
	 */ 
	private static final long serialVersionUID = 1L;

}]]></Text>
		</JavaClass>
		<!--   =========   Java Class   ========  -->
		<JavaClass>
			<Id>1663312606093</Id>
			<Name><![CDATA[MRPExtensions]]></Name>
			<Text><![CDATA[import java.util.stream.*;
/**
 * MRPExtensions
 */	
public class MRPExtensions extends simopt.MRP implements Serializable {

	
	public static final String FILENAME_CAPACITY_NEEDED = "output\\CapacityNeeded";
	public static final String FILENAME_MRP_ITEMS_RELAXED = "output\\MRPItemsRelaxed";
	public static final boolean LOG_CAPACITY_NEEDED_DELETE_OUTPUTFILE = true;	
	public static final boolean LOG_MRP_ITEMS_RELAXED_DELETE_OUTPUTFILE = true;	

	public static final int SAFETY_STOCK_RELAXATION_METHOD_1 = 1;
	public static final int SAFETY_STOCK_RELAXATION_METHOD_2 = 2;
	public static final int SAFETY_STOCK_RELAXATION_METHOD_3 = 3;	
	
    /**
     * Default constructor
     */
    public MRPExtensions() {
    }

        
    public static List<MRP> Capacitating(List<MRP> mrpTable, double time, SimulationParameter simParams, int currentBomLevel,
    		List<ProductionOrder> prodOrders, List<Routing> routings, List<ResourceCapacity> capacities, 
    		int method, String fileOutSuffix, List<ItemRelaxedStatus> itemRelaxedStatusList, Main main){
    	
    	DBQueries db = new DBQueries();    	
        StringBuilder outString = new StringBuilder();
        
        List<CumulatedCapacity> cumList = new ArrayList();
        List<MRP> resultMRP = new ArrayList();
                
        String tab = ";";
        
        	List<Resource> bomLevelResources = db.ResourcesPerBOMLevel(simParams, currentBomLevel);        	        	

        	for (Resource r : bomLevelResources) {
        	        		
        		List<Integer> itemsOfResource = new ArrayList(); 
        		List<Routing> itemsOfResourceList = routings.stream().filter(e-> e.getResource().equalsIgnoreCase(r.getName())).collect(Collectors.toList());        		        		
        		itemsOfResourceList.forEach(e -> itemsOfResource.add(e.getItem().getItem()));
        	        		        	            	
            	List<Integer> periodCapacities = capacities.stream().filter(e -> e.getResource().equalsIgnoreCase(r.getName())).map(ResourceCapacity::getCapacity).collect(Collectors.toList());
            
            	double cumulatedCapacityNeeded = 0;
        		double cumulatedItemsNeeded = 0;
				double cumulatedCapacityAvailable=0;
				
				int lateOrdersRunningCapacityCumulated = 0;
				int prodOrdersRunningCapacityCumulated = 0;
        		double cumulatedScheduledReceiptsNeededCapacity = 0;

        		traceln("############################## TIME " + time + " PERIODE " + (main.var_safetyStockRelaxationStartPeriod  - 1) + " #######################################################################");
				
        		for(int i=main.var_safetyStockRelaxationStartPeriod;i<= simParams.getMRPPlanningHorizon();i++) {			
        			main.var_safetyStockRelaxationStartPeriod++;
	        		traceln("--------------------> Time: " + time  + " Periode: " + i + " Machine: " +  r.getName() + " Relaxation Start Period: " + (main.var_safetyStockRelaxationStartPeriod-1));

					int capaProblemCnt = 0;					
					CumulatedCapacity cumItem = new CumulatedCapacity();					
					int runningPeriod = i + (int) time;
	        		
	        		cumItem.setTime(time);
	        		cumItem.setPeriod(i);
	        		cumItem.setBOMLevel(currentBomLevel);
	        		cumItem.setMachine(r.getName());
	        		cumItem.setMachineCntBomLevel(bomLevelResources.size());	        		
	        		
					//capacityNeeded = 
					//den aktuellen MRP und die scheduledreceipts und planned order receipts summieren die zu die auf dieser maschine laufen.
					//I need all qunantites of items running on that machine 
	        		
					int tmp_i = i;

					List<MRP> mrpPeriods = mrpTable.stream().filter(e -> itemsOfResource.contains(e.getItem().getItem()) 
					&& e.getPeriod() == tmp_i && e.getTime() <= (int) time)
					.collect(Collectors.toList());
			
					traceln("Size period capacities: " + periodCapacities.size());
					double periodCapacity = periodCapacities.get(i-1);
					cumulatedCapacityAvailable += periodCapacity;
										
					cumItem.setPeriodCapacity((int)periodCapacity);
					cumItem.setPeriodCapacityCumulatedAvailable((int)cumulatedCapacityAvailable);
					
					//auftrge im system die in der zukunft liegen, werden auch mit dem endedatum der periode zugeordnet
					//auftrge deren enddtam in der vergangheit sind,w erden zu periode 0 gezhlt
					//bei laufenden auftrgen wird nur die restmenge * bearbeitungszeit bercksichtigt. setup ist schon erfolgt darum keine setupt time
					//capacityNeeded = mrpPeriods.stream().mapToDouble(MRP::getPlannedOrderReceipts).sum();
					
	        		double PeriodCapacityNeeded = 0;
	        		double PeriodItemsNeeded = 0;
	        		
	        		double cumulatedScheduledReceiptsNeededQty = 0;	        		
	        		double capacityAvailable = 0;        		        		
	        			        			        		        		
	        		double periodCapacityNeeded = 0;
	        		double periodItemsNeeded = 0;
	        		
	        		StringBuilder outFlat = new StringBuilder();
	        		StringBuilder outFlat2 = new StringBuilder();
	        		
					//production orders Running and also identify late orders
	        		double prodOrdersRunningQty = 0;
	        		double lateOrdersQty = 0;
	        		double lateOrdersCapacity = 0;
	        		double runningOrdersCapacity = 0;
	        		
	        		if(i == 1) {
						List<ProductionOrder> prodOrdersRunning = prodOrders.stream().filter(e -> itemsOfResource.contains(e.getItem().getItem()) &&
								e.getStatus() == ProductionOrder.PRODUCTION_ORDER_STATUS_PROCESSING).collect(Collectors.toList());
						
						for(ProductionOrder poR : prodOrdersRunning) {
							double remainingCapacity = (poR.getPlannedCapacity()/1440) - (runningPeriod-1 - poR.getActualStart()); 
							prodOrdersRunningQty += remainingCapacity/(poR.getPlannedCapacity()/1440/poR.getQuantity());
							runningOrdersCapacity += remainingCapacity*1440;
						}
																						
						List<ProductionOrder> lateOrders = prodOrders.stream().filter(e -> itemsOfResource.contains(e.getItem().getItem()) &&														
								e.getPlannedEnd() < runningPeriod &&
								(e.getStatus() == ProductionOrder.PRODUCTION_ORDER_WAITING_FOR_MATERIAL || e.getStatus() == ProductionOrder.PRODUCTION_ORDER_STATUS_UNPROCESSED || 
								e.getStatus() == ProductionOrder.PRODUCTION_ORDER_STATUS_RELEASED)
								).collect(Collectors.toList());
						
						lateOrdersQty = lateOrders.stream().mapToDouble(ProductionOrder::getQuantity).sum();												
						lateOrdersCapacity = lateOrders.stream().mapToDouble(ProductionOrder::getPlannedCapacity).sum();												
						lateOrders.stream().forEach(e-> outFlat.append(e.getOrderId() + ","));
												
	        			prodOrdersRunning.stream().forEach(e-> outFlat2.append(e.getOrderId() + ","));
	        				        			
		        		cumItem.setLateOrders((int) Math.round(lateOrdersQty));
		        		cumItem.setLateOrdersIds("["  + outFlat.toString() + "]");
		        		cumItem.setLateOrdersCapacity((int) Math.round(lateOrdersCapacity));
		        		lateOrdersRunningCapacityCumulated += cumItem.getLateOrdersCapacity();
		        		
		        		cumItem.setRunningOrders((int) Math.round(prodOrdersRunningQty));
		        		cumItem.setRunningOrdersIds("[" + outFlat2.toString()  + "]");
		        		cumItem.setRunningOrdersCapacity((int) Math.round(runningOrdersCapacity));
		        		prodOrdersRunningCapacityCumulated += cumItem.getRunningOrdersCapacity();
	
	        		}
	        		
	        		cumItem.setLateOrdersCapacityCumulated(lateOrdersRunningCapacityCumulated);
	        		cumItem.setRunningOrdersCapacityCumulated(prodOrdersRunningCapacityCumulated);

	        		outFlat.setLength(0);
					outFlat2.setLength(0);
	        								
						double[] periodItems = new double[mrpPeriods.size()];
						double[] periodCapacityItems = new double[mrpPeriods.size()];
						String scheduledReceiptsNeededIds = "";

						int mi = 0;
						
						//Here all the MRP periods of the Items of the current BOM Level and Machine are summed up
						//resultMRP.clear();
						for(MRP m : mrpPeriods) {
														
							Routing routing = routings.stream().filter(e -> e.getItem().getItem() == m.getItem().getItem()).findFirst().get();																		
							
							// planned order receipts
							if(m.getPlannedOrderReceipts() > 0) {
								periodCapacityNeeded = (m.getPlannedOrderReceipts() * routing.getEProcessingTime()) + routing.getESetupTime();
								periodItemsNeeded = m.getPlannedOrderReceipts();
							}else {
								periodCapacityNeeded = 0;								
								periodItemsNeeded = 0;
							}
							
							periodItems[mi] = periodItemsNeeded;
							periodCapacityItems[mi] = periodCapacityNeeded;
							mi++;
							
							//Capacities needed based on PlannedOrderReceipts
							String o = cumItem.getPeriodItemsCapaciesNeeded();							
							if(o == null) o = "";							
							cumItem.setPeriodItemsCapaciesNeeded(o + "," + periodCapacityNeeded);														
							PeriodCapacityNeeded += periodCapacityNeeded; 
							
							//Quantities needed based on PlannedOrderReceipts
							o = cumItem.getPeriodItemsQtys();							
							if(o == null) o = "";
							cumItem.setPeriodItemsQtys(o + "," + periodItemsNeeded);
							PeriodItemsNeeded += periodItemsNeeded;
							
													
							//if(method == SAFETY_STOCK_RELAXATION_METHOD_1 && cumItem.getPeriodItemsCapacityNeeded() > 0) {							
							m.setCapacityNeeded((int)periodCapacityNeeded);
							m.setPeriodCapacityCumulatedAvailable(cumItem.getPeriodCapacityCumulatedAvailable());						

							resultMRP.add(m);
								
							//scheduled receipts
							if(m.getScheduledReceiptsQty() > 0) {
								cumulatedScheduledReceiptsNeededQty += m.getScheduledReceiptsQty();								
								scheduledReceiptsNeededIds += m.getScheduledReceipts() + ",";
								cumulatedScheduledReceiptsNeededCapacity += (m.getScheduledReceiptsQty() * routing.getEProcessingTime()) + routing.getESetupTime();
							}														
						}																				
						
						//is the sum of all capacity needed of the mrp periods
						cumulatedCapacityNeeded += PeriodCapacityNeeded;
						cumulatedItemsNeeded	+= PeriodItemsNeeded;																		
						
						cumItem.setPeriodItemsCapacityNeeded((int)PeriodCapacityNeeded);
						
						//plannedOrderReceipts
						cumItem.setCumulatedCapacityNeeded((int) Math.round(cumulatedCapacityNeeded));
						cumItem.setCumulatedItemsNeeded((int) Math.round(cumulatedItemsNeeded));
																								
						//scheduledReceipts												
						cumItem.setScheduledReceiptCumulatedQty((int) Math.round(cumulatedScheduledReceiptsNeededQty));
						cumItem.setCumulatedScheduledReceiptsCapacity((int) Math.round(cumulatedScheduledReceiptsNeededCapacity));
						cumItem.setScheduledReceiptsIds(scheduledReceiptsNeededIds);
						
						//the capacities of late and running orders, planned order receipts and scheduled receipts are summed up
						cumItem.setCumulatedCapacityNeededTotal(
								cumItem.getCumulatedCapacityNeeded() +
								cumItem.getCumulatedScheduledReceiptsCapacity() + 
								cumItem.getLateOrdersCapacityCumulated() +
								cumItem.getRunningOrdersCapacityCumulated()
								);
						
						//m.setCumulatedCapacityNeededTotal(cumItem.getCumulatedCapacityNeededTotal());
						
						cumItem.setCapacityProblem((int) Math.round((cumItem.getCumulatedCapacityNeededTotal() - cumulatedCapacityAvailable)));
						
						//update the output in the out mrp table with the cumulated values
						List<MRP> outMRP = resultMRP.stream().filter(e -> e.getRunningPeriod() == cumItem.getTime() + cumItem.getPeriod()).collect(Collectors.toList());
						for(MRP entry : outMRP) {
							entry.setCumulatedCapacityNeededTotal(cumItem.getCumulatedCapacityNeededTotal());							
						}
						
						//we have a capacity problem. When this condtion is fullfiled first capacity problem occurs.
						ForecastHistory.AppendToFile(FILENAME_CAPACITY_NEEDED + fileOutSuffix + ".csv",
								CumulatedCapacity.GetCSVString(cumItem),
								CumulatedCapacity.class,
								LOG_CAPACITY_NEEDED_DELETE_OUTPUTFILE);										
						
						traceln("Capacity Problem: " + cumItem.getCapacityProblem() + " ProblemCnt " + capaProblemCnt);

						
						if(cumItem.getCapacityProblem() > 0 && capaProblemCnt==0){								
							//return resultMRP;											
							capaProblemCnt++;
							if(method == 1) {
								int remaining = cumItem.getCapacityProblem();
								traceln("Capacity Problem: Period " + cumItem.getPeriod() +  " Problem of " + remaining + " TU at Machine " + r.getName() + "!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!");
								//Loop 1
								
								for(MRP mI : resultMRP.stream().filter(e -> e.getCapacityNeeded() > 0 && e.getPeriod() >= tmp_i && e.getTime() >= (int) time).
										sorted(Comparator.comparing(MRP::getCapacityNeeded).reversed()).collect(Collectors.toList())) {																																		

									//todo: check ob folgendes eh gemacht wird
									//todo: Reihenfolge der Relaxierung
									//todo: Lower Bound
									//zuerst oberstes item nehmen, bis auf lb reduzieren und auf capaproblem checken
									//wenn das capa problem nicht mehr vorhandne ist dann feritg
									//alle items durch sind nichts mehr zu relaxiere da
									// and oder alle Sicherheitsbestnde auf LowerBound reduziert wurden
									
									//todo: 1. eintrag: lower bound
									//todo: 2. eintrag: reducable wl (diff zwischen ausgangssicherheitsbestand - lb)*erwartungswert der prozesszeit
									//todo: 3. eintrag: order der relaxierung
									if(remaining > 0 && mI.getCapacityNeeded() > 0) {
										
										//calculate the possible Reduction based on the remaining needed Overcapacity CN > CA
										int safetyStockReduction =  (int) Math.ceil(remaining/mI.getItem().getRouting().getEProcessingTime());
										
										traceln("Item: " + mI.getItem().getItem());
										traceln("Item Expected Planned Processing Time: " + mI.getItem().getRouting().getEProcessingTime());
										traceln("Calculation of Item Amount to Reduce -> to Capacity Problem: (capacityProblem/ExpectedPlannedProcessingTime) " + safetyStockReduction + " = " + remaining + "/" + mI.getItem().getRouting().getEProcessingTime() + " TU");
									
										//Safe the Safety Stock before Reduction
										
										int oldSafetyStock = 0;																												
										
										long existsEntryForItem = itemRelaxedStatusList.stream().filter(e -> e.getItem().getItem() ==  mI.getItem().getItem()).count();
										
										ItemRelaxedStatus itemRelaxedStatus = new ItemRelaxedStatus();
																				
										if(existsEntryForItem == 0) {
											itemRelaxedStatus.setItem(mI.getItem());
											itemRelaxedStatus.setTime(time);
											itemRelaxedStatus.setPeriod(cumItem.getPeriod());
											itemRelaxedStatus.setQuantity((int) mI.getItem().getSafetyStock());
											oldSafetyStock = (int)itemRelaxedStatus.getQuantity();
											itemRelaxedStatusList.add(itemRelaxedStatus);
											
										}
																					
										//Get the new reduced (relaxed) Safety Stock and consider the Minimum Safety Stock (Lower Bound)
										
										existsEntryForItem = itemRelaxedStatusList.stream().filter(e -> e.getItem().getItem() ==  mI.getItem().getItem()).count();
										itemRelaxedStatus = itemRelaxedStatusList.stream().filter(e -> e.getItem().getItem() ==  mI.getItem().getItem()).findFirst().get();									

										if(existsEntryForItem > 0) {
											itemRelaxedStatus.setTime(time);
											itemRelaxedStatus.setPeriod(cumItem.getPeriod());
											oldSafetyStock = (int)itemRelaxedStatus.getQuantity();										
											itemRelaxedStatus.setTime(time);
											itemRelaxedStatus.setPeriod(cumItem.getPeriod());
										}
										
										int newSafetyStock = max((int)mI.getItem().getSafetyStockMinimum(),oldSafetyStock-safetyStockReduction);

										if(existsEntryForItem > 0) {
											itemRelaxedStatus.setQuantity(newSafetyStock);
										}
										
										//S_i,t
										mI.setSafetyStockRelaxedHistory(mI.getSafetyStockRelaxed());

										mI.setSafetyStockRelaxed(newSafetyStock);
																													
										remaining -= (oldSafetyStock - newSafetyStock)*mI.getItem().getRouting().getEProcessingTime();									
										
										/*
										for(int f=1;f<=mI.getItem().getFOPPeriod()-1;f++) {																				
																																	
											MRP a = new MRP();
											a.setTime(mI.getTime());
											a.setPeriod(mI.getPeriod());
											a.setItem(mI.getItem());
											a.setPeriod(mI.getPeriod()+f);
											a.setRunningPeriod(mI.getRunningPeriod());
											//a.setSafetyStockRelaxed(mI.getSafetyStockRelaxed());
											resultMRP.add(a);												
										}
										*/
										
										traceln("Old Safety Stock: " + oldSafetyStock);
										traceln("New Safety Stock: " + mI.getSafetyStockRelaxed());
										traceln("Remaining Capacity Problem: " + remaining + " TU");
										traceln("Item Safety Stock Lower Bound (LB): " + mI.getItem().getSafetyStockMinimum());

										traceln("Entry Relaxed Item which is passed to MRP Run. ");
										traceln(MRP.GetCSVHeader());
										traceln(MRP.GetCSVString(mI));																								
										
										outMRP = resultMRP.stream().filter(e -> e.getRunningPeriod() == cumItem.getTime() + cumItem.getPeriod()).collect(Collectors.toList());
										for(MRP entry : outMRP) {
											entry.setCumCapaNeededAfterRelaxation(entry.getCumulatedCapacityNeededTotal() - (safetyStockReduction) * mI.getItem().getRouting().getEProcessingTime());										
										}
										
										traceln("--------------------- Exit Relaxation  ------------------------------");
									}//	if(remaining > 0 && mI.getCapacityNeeded() > 0) {
									
								}// Loop 1
								
								//alter Stand
								//hier gleich die RefillFunction aufrufen, wie merken, dass der Refill noch nicht gemacht wurde?
								//das delta dient als input, ob es was zu refillen gibt.
								//da wir gerade auf den mrp periode sind, jetzt, wenn die restlichen perioden durchlaufen werden 
								//auch das identifizieren.
								
								//return resultMRP;
							}
							//bei einer der methoden, capacitysbedarf mal sicherheitsbestand der noch verfgbar ist.							
														
							return resultMRP;
						}else if(cumItem.getCapacityProblem() <= 0 ){							
							resultMRP.clear();
						}																	

    			}// for MRP Horizon  
        	}// for BOM Level Resources    
        	
    	return resultMRP;
    	
    }
    
    // not yet used
    public static void RefillSafetyStock(Main main, Item itemToRefill, double time, double relaxStartPeriod) {
    	
    	
    	//durchlaufe aktuele mrp tabelle fr alle perioden die grer als die Relaxierungsperiode sind und bei denen 
    	//es bereits einen planned order receipt gibt.
    	    	    
		for(MRP mI : main.mrpTable.stream().filter(e -> e.getItem().getItem() == itemToRefill.getItem() && e.getRunningPeriod() >= time && 
				e.getPeriod() > relaxStartPeriod && e.getPlannedOrderReceipts() > 0)
				.collect(Collectors.toList())) {																																		
				
			int refillDelta = (int)itemToRefill.getSafetyStock() - mI.getSafetyStockRelaxed();
			Routing routingOfitemToRefill = main.routings.stream().filter(e -> e.getItem().getItem() == itemToRefill.getItem()).findFirst().orElseThrow();
			
			if(mI.getPeriodCapacityCumulatedAvailable() > mI.getCumCapaNeeded()) {
				while(refillDelta < itemToRefill.getSafetyStock()) {
					//so lange stckweise auffllen bis reilldelta erreicht ist.
					if(mI.getCumulatedCapacityNeededTotal() + routingOfitemToRefill.getEProcessingTime() <= mI.getPeriodCapacityCumulatedAvailable()) {
						mI.setPlannedOrderReceipts(mI.getPlannedOrderReceipts()+1);
						mI.setCumCapaNeeded(mI.getCumCapaNeeded() + (int)routingOfitemToRefill.getEProcessingTime());
						refillDelta++;
					}else {
						break; //no more capacity available
					}
				}//whie				
			}
		}
    	
    }

    public static String GetCSVHeader() {
    	
    	StringBuilder out = new StringBuilder();
    	
    	out.append("Time;");
    	out.append("Period;");
    	out.append("BOMLevel;");
    	out.append("Machine;");
    	out.append("MachineCntBomLevel;");
    	out.append("MachineCapacity;");
    	out.append("MachineCapacityCummulated;");
    	out.append("ProdOrdersRunningQty;");
    	out.append("ProdOrdersRunningIds;");
    	
    	out.append("TotalCapacityNeeded;");
    	out.append("TotalItemsNeeded;");
    	out.append("CapacityProblem;");
    	
    	out.append("ProdOrdersLateQty;");
    	out.append("ProdOrdersLateIds;");
    	out.append("ProdOrdersInFutureQty(ScheduledReceipts);");
    	out.append("PeriodItemsNeeded;");
    	out.append("PeriodCapacityItemsNeeded;");
    	out.append("ScheduledReceiptIds;");    	
    	return out.toString();    	    	
    }
    
    
    
	@Override
	public String toString() {
		return super.toString();
	}

	/**
	 * This number is here for model snapshot storing purpose<br>
	 * It needs to be changed when this class gets changed
	 */ 
	private static final long serialVersionUID = 1L;

}]]></Text>
		</JavaClass>
		<!--   =========   Java Class   ========  -->
		<JavaClass>
			<Id>1663996687871</Id>
			<Name><![CDATA[SpecialObject]]></Name>
			<Text><![CDATA[/**
 * SpecialObject
 */	
public class SpecialObject implements Serializable {

    /**
     * Default constructor
     */
    public SpecialObject(int item, int quantity, double dueDate) {
    	this.item = item;
    	this.quantity = quantity;
    	this.dueDate = dueDate;
    }
    
    // Cunstructor for Running Orders
    public SpecialObject(int item, int quantity, double dueDate, int runningQty) {
    	this.item = item;
    	this.quantity = quantity;
    	this.dueDate = dueDate;
    	this.quantityRunning = runningQty;
    }

    
    private int item;
    
    private int quantity;
  
    private double dueDate;
    
    private int quantityRunning;
  
    public int getItem() {
       return this.item;
    }
  
    public void setItem(int value) {
       this.item = value;
    }
  
    public double getQuantity() {
       return this.quantity;
    }
  
    public void setQuantity(int value) {
       this.quantity = value;
    }
  
    public double getDueDate() {
       return this.dueDate;
    }
  
    public void setDueDate(int value) {
       this.dueDate = value;
    }
    
    
    public double getQuantityRunning() {
        return this.quantityRunning;
     }
   
     public void setQuantityRunning(int value) {
        this.quantityRunning = value;
     }
    
	@Override
	public String toString() {
		return super.toString();
	}

	/**
	 * This number is here for model snapshot storing purpose<br>
	 * It needs to be changed when this class gets changed
	 */ 
	private static final long serialVersionUID = 1L;

}]]></Text>
		</JavaClass>
		<!--   =========   Java Class   ========  -->
		<JavaClass>
			<Id>1670832190251</Id>
			<Name><![CDATA[CumulatedCapacity]]></Name>
			<Text><![CDATA[/**
 * CumulatedCapacity
 */	
public class CumulatedCapacity implements Serializable {

    /**
     * Default constructor
     */
    public CumulatedCapacity() {
    }

    
    private double Time;
    
    private int Period;
    
    private int BOMLevel;
    
    private String Machine;
    
    private int MachineCntBomLevel;
    
    private int MachineCapacity;
    
    private int MachineCapacityCummulated;
    
    private int ProdOrdersRunningQty;
    
    private int PeriodCapacity;
    
    private int PeriodCapacityCumulatedAvailable;
    
    private int LateOrders;
    
    private String LateOrdersIds;
  
    private int RunningOrders;
  
    private String RunningOrdersIds;
    
    private String PeriodItemsQtys;
    
    private String PeriodItemsCapaciesNeeded;      
    
    private int ScheduledReceiptCumulatedQty;
  
    private String ScheduledReceiptsIds;
    
    private int CapacityProblem;
        
    private int CumulatedCapacityNeeded;
    
    private int CumulatedItemsNeeded;
  
    private int CumulatedScheduledReceiptsCapacity;
    
    private int CumulatedCapacityNeededTotal;
        
    private int LateOrdersCapacity;
    
    private int RunningOrdersCapacity;
  
    private int LateOrdersCapacityCumulated;
    
    private int RunningOrdersCapacityCumulated;
    
    private int PeriodItemsCapacityNeeded;      

    public int getPeriodItemsCapacityNeeded() {
        return this.PeriodItemsCapacityNeeded;
     }
   
     public void setPeriodItemsCapacityNeeded(int value) {
        this.PeriodItemsCapacityNeeded = value;
     }
    
    public int getLateOrdersCapacityCumulated() {
       return this.LateOrdersCapacityCumulated;
    }
  
    public void setLateOrdersCapacityCumulated(int value) {
       this.LateOrdersCapacityCumulated = value;
    }
  
    public int getRunningOrdersCapacityCumulated() {
       return this.RunningOrdersCapacityCumulated;
    }
  
    public void setRunningOrdersCapacityCumulated(int value) {
       this.RunningOrdersCapacityCumulated = value;
    }
    
    public int getLateOrdersCapacity() {
       return this.LateOrdersCapacity;
    }
  
    public void setLateOrdersCapacity(int value) {
       this.LateOrdersCapacity = value;
    }
  
    public int getRunningOrdersCapacity() {
       return this.RunningOrdersCapacity;
    }
  
    public void setRunningOrdersCapacity(int value) {
       this.RunningOrdersCapacity = value;
    }
    
    public int getCumulatedCapacityNeededTotal() {
       return this.CumulatedCapacityNeededTotal;
    }
  
    public void setCumulatedCapacityNeededTotal(int value) {
       this.CumulatedCapacityNeededTotal = value;
    }
    
    
    public int getCumulatedScheduledReceiptsCapacity() {
       return this.CumulatedScheduledReceiptsCapacity;
    }
  
    public void setCumulatedScheduledReceiptsCapacity(int value) {
       this.CumulatedScheduledReceiptsCapacity = value;
    }
   
    
    public int getCumulatedCapacityNeeded() {
       return this.CumulatedCapacityNeeded;
    }
  
    public void setCumulatedCapacityNeeded(int value) {
       this.CumulatedCapacityNeeded = value;
    }
  
    public int getCumulatedItemsNeeded() {
       return this.CumulatedItemsNeeded;
    }
  
    public void setCumulatedItemsNeeded(int value) {
       this.CumulatedItemsNeeded = value;
    }
    
    public int getCapacityProblem() {
       return this.CapacityProblem;
    }
  
    public void setCapacityProblem(int value) {
       this.CapacityProblem = value;
    }
    
    
    public int getScheduledReceiptCumulatedQty() {
       return this.ScheduledReceiptCumulatedQty;
    }
  
    public void setScheduledReceiptCumulatedQty(int value) {
       this.ScheduledReceiptCumulatedQty = value;
    }
  
    public String getScheduledReceiptsIds() {
       return this.ScheduledReceiptsIds;
    }
  
    public void setScheduledReceiptsIds(String value) {
       this.ScheduledReceiptsIds = value;
    }
    
    public String getPeriodItemsQtys() {
       return this.PeriodItemsQtys;
    }
  
    public void setPeriodItemsQtys(String value) {
       this.PeriodItemsQtys = value;
    }
  
    public String getPeriodItemsCapaciesNeeded() {
       return this.PeriodItemsCapaciesNeeded;
    }
  
    public void setPeriodItemsCapaciesNeeded(String value) {
       this.PeriodItemsCapaciesNeeded = value;
    }
    
  
    public int getLateOrders() {
       return this.LateOrders;
    }
  
    public void setLateOrders(int value) {
       this.LateOrders = value;
    }
  
    public String getLateOrdersIds() {
       return this.LateOrdersIds;
    }
  
    public void setLateOrdersIds(String value) {
       this.LateOrdersIds = value;
    }
  
    public int getRunningOrders() {
       return this.RunningOrders;
    }
  
    public void setRunningOrders(int value) {
       this.RunningOrders = value;
    }
  
    public String getRunningOrdersIds() {
       return this.RunningOrdersIds;
    }
  
    public void setRunningOrdersIds(String value) {
       this.RunningOrdersIds = value;
    }
    
    
    public int getPeriodCapacity() {
    	return this.PeriodCapacity;
    }
    public void setPeriodCapacity(int value) {
    	this.PeriodCapacity = value;
    }
    public int getPeriodCapacityCumulatedAvailable() {
    	return this.PeriodCapacityCumulatedAvailable;
    }

    public void setPeriodCapacityCumulatedAvailable(int value) {
    	this.PeriodCapacityCumulatedAvailable = value;
    }
	
    public double getTime() {
    	return this.Time;
    }
    
    public void setTime(double value) {
    this.Time = value;
    }
    
    public int getPeriod() {
    return this.Period;
    }
    
    public void setPeriod(int value) {
    this.Period = value;
    }
    
    public int getBOMLevel() {
    return this.BOMLevel;
    }
    
    public void setBOMLevel(int value) {
    this.BOMLevel = value;
    }
    
    public String getMachine() {
    return this.Machine;
    }
    
    public void setMachine(String value) {
    this.Machine = value;
    }
    
    public int getMachineCntBomLevel() {
    return this.MachineCntBomLevel;
    }
    
    public void setMachineCntBomLevel(int value) {
    this.MachineCntBomLevel = value;
    }
    
    public int getMachineCapacity() {
    return this.MachineCapacity;
    }
    
    public void setMachineCapacity(int value) {
    this.MachineCapacity = value;
    }
    
    public int getMachineCapacityCummulated() {
    return this.MachineCapacityCummulated;
    }
    
    public void setMachineCapacityCummulated(int value) {
    this.MachineCapacityCummulated = value;
    }
    
    public int getProdOrdersRunningQty() {
    return this.ProdOrdersRunningQty;
    }
    
    public void setProdOrdersRunningQty(int value) {
    this.ProdOrdersRunningQty = value;
    }    
    
    
    public static String GetCSVHeader() {
     	
     	StringBuilder out = new StringBuilder();
     	
     	out.append("Time;");
     	out.append("Period;");
     	out.append("RunningPeriod;");
     	out.append("BomLevel;");
     	out.append("Machine;");

     	
     	out.append("PeriodCapacityCumulatedAvailable;");
     	out.append("TCumulatedCapacityNeededTotal;");
     	
     	out.append("!CapacityProblem;");
     	
     	out.append("1 CumulatedCapacityNeeded;");
     	out.append("CumulatedItemsNeeded;");
     	
     	out.append("MachineCntBomLevel;");
     	out.append("PeriodCapacity;");
     	     	     	
     	out.append("2 LateOrdersCapacityCumulated;");
     	out.append("LateOrdersQty;");
     	out.append("LateOrdersCapacity;");
     	out.append("LateOrdersIds;");
     	
     	out.append("3 RunningOrdersCapacityCumulated;");
     	out.append("RunningOrdersQty;");
     	out.append("RunningOrdersCapacity;");
     	out.append("RunningOrdersIds;");
     	
     	out.append("PeriodItemsCapacitiesNeeded;");
     	out.append("PeriodItemsQtys;");
     	out.append("PeriodItemsCapacityNeeded;");
     	
     	out.append("ScheduledReceiptCumulatedQty;");     	     	     	
     	out.append("4 ScheduledReceiptCumulatedCapacity;");     	     	     	
     	out.append("ScheduledReceiptsIds;");
     	
     	     	
     	return out.toString();    	    	
     }
     
     public static String GetCSVString(CumulatedCapacity obj) {
     	
     	StringBuilder out = new StringBuilder();
     	
     	out.append(obj.getTime() + ";");
     	out.append(obj.getPeriod() + ";");
     	out.append(obj.getTime() + obj.getPeriod() + ";");
     	out.append(obj.getBOMLevel() + ";");
     	out.append(obj.getMachine() + ";");
     	
     	out.append(obj.getPeriodCapacityCumulatedAvailable() + ";");
     	out.append(obj.getCumulatedCapacityNeededTotal() + ";");
     	
     	out.append(obj.getCapacityProblem() + ";");
     	
     	out.append(obj.getCumulatedCapacityNeeded() + ";");
     	out.append(obj.getCumulatedItemsNeeded() + ";");
     	     	
     	out.append(obj.getMachineCntBomLevel() + ";");
     	out.append(obj.getPeriodCapacity() + ";");
     	     	     	
     	out.append(obj.getLateOrdersCapacityCumulated() + ";");
     	out.append(obj.getLateOrders() + ";");
     	out.append(obj.getLateOrdersCapacity() + ";");
     	out.append(obj.getLateOrdersIds() + ";");
     	
     	out.append(obj.getRunningOrdersCapacityCumulated() + ";");
     	out.append(obj.getRunningOrders() + ";");
     	out.append(obj.getRunningOrdersCapacity() + ";");
     	out.append(obj.getRunningOrdersIds() + ";");
     	
     	out.append("[" + obj.getPeriodItemsCapaciesNeeded() + "];");
     	out.append("[" + obj.getPeriodItemsQtys() + "];");
     	out.append(obj.getPeriodItemsCapacityNeeded() + ";");
     	
     	out.append(obj.getScheduledReceiptCumulatedQty()+ ";");
     	out.append(obj.getCumulatedScheduledReceiptsCapacity()+ ";");
     	out.append(obj.getScheduledReceiptsIds() + ";");
     	
    	    	    	    	
     	return out.toString();
     	
     }
    
	@Override
	public String toString() {
		return super.toString();
	}

	/**
	 * This number is here for model snapshot storing purpose<br>
	 * It needs to be changed when this class gets changed
	 */ 
	private static final long serialVersionUID = 1L;

}]]></Text>
		</JavaClass>
		<!--   =========   Java Class   ========  -->
		<JavaClass>
			<Id>1672638438330</Id>
			<Name><![CDATA[ItemRelaxed]]></Name>
			<Text><![CDATA[/**
 * ItemRelaxed
 */	
public class ItemRelaxed extends Item implements Serializable {

    /**
     * Default constructor
     */
    public ItemRelaxed() {
    }

	@Override
	public String toString() {
		return super.toString();
	}

	/**
	 * This number is here for model snapshot storing purpose<br>
	 * It needs to be changed when this class gets changed
	 */ 
	private static final long serialVersionUID = 1L;

}]]></Text>
		</JavaClass>
		<!--   =========   Java Class   ========  -->
		<JavaClass>
			<Id>1675602149610</Id>
			<Name><![CDATA[RPS]]></Name>
			<Text><![CDATA[import java.util.stream.*;
import one.util.streamex.StreamEx;


/**
 * RPS
 */	
public class RPS implements Serializable {

	public static final String FILENAME_INVENTORY_POSITION = "output\\InventoryPosition";
	public static final boolean LOG_INVENTORY_POSITION_DELETE_OUTPUTFILE = true;		
	public static final boolean WRITE_OUT_IP_TO_FILE = false;
	
	/**
     * Default constructor
     */
    public RPS() {
    }

       
    public static List<ProductionOrder> CheckInventoryPositions(SimulationParameter simParams, List<CustomerOrder> customerOrders, 
			double time, List<Item> items, List<StockBooking> bookings, 
			int bomLevel, List<BOM> bomList, List<ProductionOrder> prodOrders, int orderId, String fileOutSuffix, List<Routing> routingList) {
		    	    	
    	List<ProductionOrder> prodOrdersFromRPS = new ArrayList();
    	
		List<BOM> distinctByItemAndBOMLevel  = StreamEx.of(bomList).filter(e -> e.getLevel() == bomLevel && 
				e.getItem().getPlanningType().equals(Item.ITEM_PLANNINGTYPE_RPS) && 
				!e.getItem().getType().equals(Item.ITEM_TYPE_PURCHASE)).distinct(BOM::getItem).toList();				

		List<InventoryPosition> invPosList = new ArrayList();
		
		for(BOM bomItem : distinctByItemAndBOMLevel) {
			
			
			//Late Production Orders --------------------------------						
			
			List<ProductionOrder> lateOrders = prodOrders.stream().filter(e -> e.getItem().getItem() == bomItem.getItem().getItem() &&														
					e.getPlannedEnd() < time &&
					(e.getStatus() == ProductionOrder.PRODUCTION_ORDER_WAITING_FOR_MATERIAL || e.getStatus() == ProductionOrder.PRODUCTION_ORDER_STATUS_UNPROCESSED || 
					e.getStatus() == ProductionOrder.PRODUCTION_ORDER_STATUS_RELEASED)
					).collect(Collectors.toList());
			
			double prodOrdersLateQty = lateOrders.stream().mapToDouble(ProductionOrder::getQuantity).sum();															
    		StringBuilder outFlat1 = new StringBuilder();
			lateOrders.stream().forEach(e-> outFlat1.append(e.getOrderId() + ","));
																				
			
			//Running Production Orders ------------------------------
			List<ProductionOrder> prodOrdersRunning = prodOrders.stream().filter(e -> e.getItem().getItem() == bomItem.getItem().getItem() &&
					e.getStatus() == ProductionOrder.PRODUCTION_ORDER_STATUS_PROCESSING).collect(Collectors.toList()); 

			double prodOrdersRunningQty = 0;
			for(ProductionOrder poR : prodOrdersRunning) {
				//double remainingCapacity = (poR.getPlannedCapacity()/1440) - (time - poR.getActualStart()); 

				//traceln("(" + poR.getPlannedCapacity()/1440 +") - (" + time + "-1 -" +  poR.getActualStart()+ ")"); 
				//traceln(remainingCapacity);

				//prodOrdersRunningQty += poR.getQuantity() - Math.round(remainingCapacity/((poR.getPlannedCapacity()/1440)/poR.getQuantity()));				
				prodOrdersRunningQty += poR.getQuantity();
				//traceln("qqq " + prodOrdersRunningQty);
				//traceln(poR.getOrderId());
				//traceln(time);
				
			}			
			
    		StringBuilder outFlat2 = new StringBuilder();
			prodOrdersRunning.stream().forEach(e-> outFlat2.append(e.getOrderId() + "|" + e.getQuantity() + ","));
			
			
			//Scheduled Production Orders --------------------------------
			List<ProductionOrder> prodOrdersScheduled = prodOrders.stream().filter(e -> e.getItem().getItem() == bomItem.getItem().getItem() &&														
					e.getPlannedEnd() >= time &&
					(e.getStatus() == ProductionOrder.PRODUCTION_ORDER_WAITING_FOR_MATERIAL || e.getStatus() == ProductionOrder.PRODUCTION_ORDER_STATUS_UNPROCESSED || 
					e.getStatus() == ProductionOrder.PRODUCTION_ORDER_STATUS_RELEASED)
					).collect(Collectors.toList());
			
			double prodOrdersScheduledQty = prodOrdersScheduled.stream().mapToDouble(ProductionOrder::getQuantity).sum();															
    		StringBuilder outFlat3 = new StringBuilder();
			prodOrdersScheduled.stream().forEach(e-> outFlat3.append(e.getOrderId() + ","));
								
			//customer orders for backlog
			double backorders = 0;
			StringBuilder outFlat4 = new StringBuilder();
			
			List<CustomerOrder> customerOrderBacklog = customerOrders.stream().filter(e -> e.getItem().getItem() == bomItem.getItem().getItem() 
					&& (e.getStatus() == CustomerOrder.ORDER_STATUS_UNPROCESSED || e.getStatus() == CustomerOrder.ORDER_STATUS_DELAYED) &&
					e.getDueDate() < time).collect(Collectors.toList());
			
			backorders = customerOrderBacklog.stream().mapToDouble(CustomerOrder::getQuantity).sum();			
			customerOrderBacklog.stream().forEach(e-> outFlat4.append(e.getOrderId() + ","));

			List<ProductionOrder> allOrders = prodOrders.stream().filter(e -> e.getItem().getItem() == bomItem.getItem().getItem() &&														
					e.getStatus() != ProductionOrder.PRODUCTION_ORDER_STATUS_PROCESSED
					).collect(Collectors.toList());
			
			double allOrdersQty = allOrders.stream().mapToDouble(ProductionOrder::getQuantity).sum();															
    		StringBuilder outFlat5 = new StringBuilder();
    		allOrders.stream().forEach(e-> outFlat5.append(e.getOrderId() + ","));
			
    		
    		if(bomItem.getItem().getType().equalsIgnoreCase(Item.ITEM_TYPE_COMPONENT)) {
    		
    		//if current item is a component, the demand are all the production orders of the parent item
				List<BOM> childOf = bomList.stream().filter(e -> e.getChild() != null && e.getChild().getItem() == bomItem.getItem().getItem() 
						&& e.getLevel() == bomLevel - 1).collect(Collectors.toList());
				
				for(BOM grItem : childOf) {
					
					backorders+= prodOrders.stream().filter(e -> e.getItem().getItem() == grItem.getItem().getItem() && 
														
							(e.getStatus() == ProductionOrder.PRODUCTION_ORDER_WAITING_FOR_MATERIAL || e.getStatus() == ProductionOrder.PRODUCTION_ORDER_STATUS_UNPROCESSED || 
							e.getStatus() == ProductionOrder.PRODUCTION_ORDER_STATUS_RELEASED)
							
							
							).mapToDouble(ProductionOrder::getQuantity).sum();	
					
					customerOrderBacklog.stream().forEach(e-> outFlat4.append(e.getOrderId() + ","));
					
				}
    		}
			
			//Quantity on Stock
			int onStock = (int)StockBooking.GetStockItemQuantity(bookings, bomItem.getItem()).getQuantity();
			
			//Wir berechnen
			//int invPosition = onStock + (int)prodOrdersRunningQty + (int)prodOrdersScheduledQty + (int)prodOrdersLateQty - (int) backorders;						
			int invPosition = onStock + (int)allOrdersQty - (int) backorders;						
			
			int tmpOrderId = 0; //only used to write out the correct prodOrderId

			//if(invPosition < bomItem.getItem().getSafetyStock()) {
			
			//traceln("invpos: " + invPosition);
			
			//traceln("bom item qty: " + bomItem.getItem().getRPSQty());
			
			if(invPosition < bomItem.getItem().getRPSQty()) {
					
				//meldebestand = 1600
				//kudnenabruf = 850
				//invpos = 750
				
				//1600-750=850 min auffllen
				
				double numberLots = (bomItem.getItem().getRPSQty() - invPosition)  / bomItem.getItem().getFOQMinimumLotSize();
				//double numberLots = (bomItem.getItem().getSafetyStock() - invPosition)  / bomItem.getItem().getFOQMinimumLotSize();
				
				//traceln("Item: " + bomItem.getItem().getItem());
				//traceln("RPS: " + bomItem.getItem().getRPSQty());
				//traceln("InvPos: " + invPosition);
				//traceln("MinFOQLotSize:" + bomItem.getItem().getFOQMinimumLotSize());
				//traceln("NumberLots: " +  Math.ceil(numberLots));
				 
				//traceln("Lots " + Math.ceil(numberLots));
				for(int lotI = 1; lotI <= Math.ceil(numberLots); lotI++) {				
					ProductionOrder pO = new ProductionOrder();

					//traceln(bomItem.getItem().getFOQMinimumLotSize() + " " +  bomItem.getItem().getSafetyStock()  + "numl" + numberLots );
					
					orderId++;
					tmpOrderId = orderId;
	
					pO.setCreatedAt(time);
					pO.setOrderId(orderId);
					pO.setQuantity(bomItem.getItem().getFOQQuantity());
					pO.setItem(bomItem.getItem());
					pO.setPlannedStart(time + MRP.PERIOD_BALANCING);
					pO.setPlannedEnd(time + bomItem.getItem().getLeadTime());				
					
					int minimumRoutingStep = Routing.GetMinimumStep(routingList, pO.getItem() , simParams);
					int maximumRoutingStep = Routing.GetMaximumStep(routingList, pO.getItem() , simParams);
					
					pO.setMinimumRoutingStep(minimumRoutingStep);
					pO.setMaximumRoutingStep(maximumRoutingStep);			
					pO.setCurrentRoutingStep(minimumRoutingStep);
					
					pO.setPlannedCapacity(Routing.GetPlannedCapacityPerItem(routingList, pO.getItem(), simParams, pO));
					pO.setStatus(ProductionOrder.PRODUCTION_ORDER_STATUS_UNPROCESSED);
														
					Routing routingObject = routingList.stream().filter(e -> e.getItem().getItem() == pO.getItem().getItem() && e.getStep() == minimumRoutingStep).findFirst().get();			
					pO.setRouting(routingObject);
					
					prodOrdersFromRPS.add(pO);
					
					//Wirte out staff
					if(WRITE_OUT_IP_TO_FILE) {
					InventoryPosition iP = new InventoryPosition(time,bomItem.getItem(),invPosition,onStock, 
							"[" + outFlat1 + "]", (int)prodOrdersLateQty, 
							"[" + outFlat2 + "]", (int)prodOrdersRunningQty,
							"[" + outFlat3 + "]", (int)prodOrdersScheduledQty,
							pO,lotI,
							"[" + outFlat4 + "]", (int)backorders,
							"[" + outFlat5 + "]", (int)allOrdersQty
							);	
					
					ForecastHistory.AppendToFile(FILENAME_INVENTORY_POSITION + fileOutSuffix + ".csv",
							InventoryPosition.GetCSVString(iP),
							InventoryPosition.class,
							LOG_INVENTORY_POSITION_DELETE_OUTPUTFILE);													
					}
					//end WriteoutStaff
				}//for
			}else {
				//Wirte out staff
				if(WRITE_OUT_IP_TO_FILE) {
					//ProductionOrder pO = new ProductionOrder();

					
				InventoryPosition iP = new InventoryPosition(time,bomItem.getItem(),invPosition,onStock, 
						"[" + outFlat1 + "]", (int)prodOrdersLateQty, 
						"[" + outFlat2 + "]", (int)prodOrdersRunningQty,
						"[" + outFlat3 + "]", (int)prodOrdersScheduledQty,
						new ProductionOrder(),0,
						"[" + outFlat4 + "]", (int)backorders,
						"[" + outFlat5 + "]", (int)allOrdersQty
						);	
				
				ForecastHistory.AppendToFile(FILENAME_INVENTORY_POSITION + fileOutSuffix + ".csv",
						InventoryPosition.GetCSVString(iP),
						InventoryPosition.class,
						LOG_INVENTORY_POSITION_DELETE_OUTPUTFILE);													
				}
				//end WriteoutStaff
				
			}//if inventory position
			
		  }//for				
		
		return prodOrdersFromRPS;
	}		
    
    
	@Override
	public String toString() {
		return super.toString();
	}

	/**
	 * This number is here for model snapshot storing purpose<br>
	 * It needs to be changed when this class gets changed
	 */ 
	private static final long serialVersionUID = 1L;

}]]></Text>
		</JavaClass>
		<!--   =========   Java Class   ========  -->
		<JavaClass>
			<Id>1675672600345</Id>
			<Name><![CDATA[InventoryPosition]]></Name>
			<Text><![CDATA[/**
 * InventoryPosition
 */	
public class InventoryPosition implements Serializable {

    /**
     * Default constructor
     */
    public InventoryPosition() {
    }
    
    
	public InventoryPosition(double time, Item item, int inventoryPosition, int onStockQty, String lateOrdersIds, int lateOrdersQty,
			String runningOrdersIds, int runningOrdersQty, String scheduledOrdersIds, int scheduledOrdersQty, ProductionOrder prodOrder,
			int lotNumber, String customerDemandIds, int customerDemandQty, String allOrdersIds, int allOrdersQty) {

		this.time = time;
		this.item = item;
		this.inventoryPosition = inventoryPosition;
		this.onStockQty = onStockQty;
		this.lateOrdersIds = lateOrdersIds;
		this.lateOrdersQty = lateOrdersQty;
		this.runningOrdersIds = runningOrdersIds;
		this.runningOrdersQty = runningOrdersQty;
		this.scheduledOrdersIds = scheduledOrdersIds;
		this.scheduledOrdersQty = scheduledOrdersQty;
		this.prodOrder = prodOrder;
		this.lotNumber = lotNumber;
		this.customerDemandQty = customerDemandQty;
		this.customerDemandIds = customerDemandIds;
		this.allOrdersIds = allOrdersIds;
		this.allOrdersQty = allOrdersQty;
	}
	
	private double time;
	private Item item;
	private int inventoryPosition;
	private int onStockQty;
	private String lateOrdersIds;
	private int lateOrdersQty;
	private String runningOrdersIds;
	private int runningOrdersQty;
	private String scheduledOrdersIds;
	private int scheduledOrdersQty;
	private ProductionOrder prodOrder;
	private int lotNumber;
	private int customerDemandQty;
	private String customerDemandIds;
	private String allOrdersIds;
	private int allOrdersQty;


	
	public String getAllOrdersIds() {
		return allOrdersIds;
	}
	public void setAllOrdersIds(String allOrdersIds) {
		this.allOrdersIds = allOrdersIds;
	}
	public int getAllOrdersQty() {
		return allOrdersQty;
	}
	public void setAllOrdersQty(int allOrdersQty) {
		this.allOrdersQty = allOrdersQty;
	}
	
	public String getCustomerDemandIds() {
		return customerDemandIds;
	}

	public void setCustomerDemandIds(String customerDemandIds) {
		this.customerDemandIds = customerDemandIds;
	}
		
	public int getCustomerDemandQty() {
		return customerDemandQty;
	}

	public void setCustomerDemandQty(int customerDemandQty) {
		this.customerDemandQty = customerDemandQty;
	}
				
	private int getLotNumber() {
		return lotNumber;
	}

	private void setLotNumber(int lotNumber) {
		this.lotNumber = lotNumber;
	}

	
	public ProductionOrder getProdOrder() {
		return prodOrder;
	}

	public void setProdOrderId(ProductionOrder prodOrder) {
		this.prodOrder = prodOrder;
	}
	
	private double getTime() {
		return time;
	}
	private void setTime(double time) {
		this.time = time;
	}
	
	private Item getItem() {
		return item;
	}
	private void setItem(int Item) {
		this.item = item;
	}
	private int getInventoryPosition() {
		return inventoryPosition;
	}
	private void setInventoryPosition(int inventoryPosition) {
		this.inventoryPosition = inventoryPosition;
	}
	private int getOnStockQty() {
		return onStockQty;
	}
	private void setOnStockQty(int onStockQty) {
		this.onStockQty = onStockQty;
	}
	private String getLateOrdersIds() {
		return lateOrdersIds;
	}
	private void setLateOrdersIds(String lateOrdersIds) {
		this.lateOrdersIds = lateOrdersIds;
	}
	private int getLateOrdersQty() {
		return lateOrdersQty;
	}
	private void setLateOrdersQty(int lateOrdersQty) {
		this.lateOrdersQty = lateOrdersQty;
	}
	private String getRunningOrdersIds() {
		return runningOrdersIds;
	}
	private void setRunningOrdersIds(String runningOrdersIds) {
		this.runningOrdersIds = runningOrdersIds;
	}
	private int getRunningOrdersQty() {
		return runningOrdersQty;
	}
	private void setRunningOrdersQty(int runningOrdersQty) {
		this.runningOrdersQty = runningOrdersQty;
	}
	private String getScheduledOrdersIds() {
		return scheduledOrdersIds;
	}
	private void setScheduledOrdersIds(String scheduledOrdersIds) {
		this.scheduledOrdersIds = scheduledOrdersIds;
	}
	private int getScheduledOrdersQty() {
		return scheduledOrdersQty;
	}
	private void setScheduledOrdersQty(int scheduledOrdersQty) {
		this.scheduledOrdersQty = scheduledOrdersQty;
	}
    

    public static String GetCSVHeader() {
    	
    	StringBuilder out = new StringBuilder();
    	
    	out.append("Time;");
    	out.append("Item;");
    	
    	out.append("SafetStock;");
    	out.append("RPQty;");
    	out.append("InventoryPosition;");
    	out.append("OnStockQty;");
    	
    	out.append("LateOrdersIds;");
    	out.append("LateOrdersQty;");
    	
    	out.append("RunningOrdersIds;");
    	out.append("RuningsOrdersQty;");
    	
    	out.append("ScheduledRcptsIds;");
    	out.append("ScheduledRcptsQty;");
    	
    	out.append("CustomerDemandIds;");
    	out.append("CustomerDemandQty;");
    	
    	out.append("allOrdersIds;");
    	out.append("allOrdersQty;");
    	
    	    	
    	out.append("ProdOrderId;");
    	out.append("ProdOrderQty;");
    	out.append("ProdOrderPlannedStart;");
    	out.append("ProdOrderPlannedEnd;");
    	out.append("LotNumber;");
    	    	
    	
    	return out.toString();    	    	
    }

    
    
     public static String GetCSVString(InventoryPosition obj) {
     	
     	StringBuilder out = new StringBuilder();
     	
     	out.append(obj.getTime() + ";");
     	out.append(obj.getItem().getItem() + ";");
     	out.append(obj.getItem().getSafetyStock() + ";");
     	out.append(obj.getItem().getRPSQty() + ";");
     	
     	out.append(obj.getInventoryPosition() + ";");
     	
     	out.append(obj.getOnStockQty() + ";");
     	out.append(obj.getLateOrdersIds() + ";");
     	out.append(obj.getLateOrdersQty() + ";");
     	out.append(obj.getRunningOrdersIds() + ";");
     	out.append(obj.getRunningOrdersQty() + ";");
     	out.append(obj.getScheduledOrdersIds() + ";");
     	out.append(obj.getScheduledOrdersQty() + ";");
     	
     	out.append(obj.getCustomerDemandIds() + ";");
     	out.append(obj.getCustomerDemandQty() + ";");
     	
     	out.append(obj.getAllOrdersIds() + ";");
     	out.append(obj.getAllOrdersQty() + ";");
     	
     	out.append(obj.getProdOrder().getOrderId() + ";");
     	out.append(obj.getProdOrder().getQuantity() + ";");
     	out.append(obj.getProdOrder().getPlannedStart() + ";");
     	out.append(obj.getProdOrder().getPlannedEnd() + ";");
     	out.append(obj.getLotNumber() + ";");
     	     
     	return out.toString();
     	
     }

    
	
	@Override
	public String toString() {
		return super.toString();
	}

	/**
	 * This number is here for model snapshot storing purpose<br>
	 * It needs to be changed when this class gets changed
	 */ 
	private static final long serialVersionUID = 1L;

}]]></Text>
		</JavaClass>
		<!--   =========   Java Class   ========  -->
		<JavaClass>
			<Id>1679470169326</Id>
			<Name><![CDATA[ClearingFunctionSegments]]></Name>
			<Text><![CDATA[/**
 * ClearingFunctionSegments
 */	
public class ClearingFunctionSegments implements Serializable {

	public static boolean USE_IDEAL_CF_LINE = true;
	
    /**
     * Default constructor
     */
	
	public ClearingFunctionSegments(String lotPolicy, int lotParameter, int productionStage,
			int cFSegment, double yIntercept, double slope, String experiment, String resource) {
	
		this.lotPolicy = lotPolicy;
		this.lotParameter = lotParameter;
		this.productionStage = productionStage;
		this.cFSegment = cFSegment;
		this.yIntercept = yIntercept;
		this.slope = slope;	
		this.experiment = experiment;
		this.resource = resource;
	}
	
	private String lotPolicy;
	private String resource;
	private int lotParameter;
	private int productionStage;
	private int cFSegment;
	private double yIntercept;
	private double slope;
	private String experiment;
	
	public String getExperiment() {
		return experiment;
	}
	public void setExperiment(String experiment) {
		this.experiment = experiment;
	}
		
	public String getResource() {
		return resource;
	}
	public void setResource(String resource) {
		this.resource = resource;
	}
	
	public String getLotPolicy() {
		return lotPolicy;
	}
	public void setLotPolicy(String lotPolicy) {
		this.lotPolicy = lotPolicy;
	}
	public int getLotParameter() {
		return lotParameter;
	}
	public void setLotParameter(int lotParameter) {
		this.lotParameter = lotParameter;
	}
	public int getProductionStage() {
		return productionStage;
	}
	public void setProductionStage(int productionStage) {
		this.productionStage = productionStage;
	}
	public int getcFSegment() {
		return cFSegment;
	}
	public void setcFSegment(int cFSegment) {
		this.cFSegment = cFSegment;
	}
	public double getyIntercept() {
		return yIntercept;
	}
	public void setyIntercept(double yIntercept) {
		this.yIntercept = yIntercept;
	}
	public double getSlope() {
		return slope;
	}
	public void setSlope(double slope) {
		this.slope = slope;
	}
	
	
	public static List<ClearingFunctionSegments> GetClearingFunctionSegments(int UseCFLineType){
		
		List<ClearingFunctionSegments> segis = new ArrayList();
		
		ClearingFunctionSegments cf = null;				

		//ideal CFs
		if(UseCFLineType == 1) {								
			
			segis.add(new ClearingFunctionSegments("FOP",1,1,1,0,1,"ExpCF2","M11"));		
			segis.add(new ClearingFunctionSegments("FOP",1,1,1,0,1,"ExpCF2","M12"));		
			segis.add(new ClearingFunctionSegments("FOP",1,1,1,0,1,"ExpCF2","M13"));			
			segis.add(new ClearingFunctionSegments("FOP",1,1,1,0,1,"ExpCF2","M14"));			
			segis.add(new ClearingFunctionSegments("FOP",1,1,1,0,1,"ExpCF2","M21"));		
			segis.add(new ClearingFunctionSegments("FOP",1,1,1,0,1,"ExpCF2","M22"));			
			segis.add(new ClearingFunctionSegments("FOP",1,1,1,0,1,"ExpCF2","M23"));			
			segis.add(new ClearingFunctionSegments("FOP",1,1,1,0,1,"ExpCF2","M24"));
			segis.add(new ClearingFunctionSegments("FOP",1,1,1,0,1,"ExpCF2","M31"));			
			segis.add(new ClearingFunctionSegments("FOP",1,1,1,0,1,"ExpCF2","M32"));			
			segis.add(new ClearingFunctionSegments("FOP",1,1,1,0,1,"ExpCF2","M33"));			
			segis.add(new ClearingFunctionSegments("FOP",1,1,1,0,1,"ExpCF2","M34"));
			segis.add(new ClearingFunctionSegments("FOP",1,1,1,0,1,"ExpCF2","M41"));			
			segis.add(new ClearingFunctionSegments("FOP",1,1,1,0,1,"ExpCF2","M42"));			
			segis.add(new ClearingFunctionSegments("FOP",1,1,1,0,1,"ExpCF2","M43"));			
			segis.add(new ClearingFunctionSegments("FOP",1,1,1,0,1,"ExpCF2","M44"));			

			segis.add(new ClearingFunctionSegments("FOP",2,1,1,0,1,"ExpCF2","M11"));		
			segis.add(new ClearingFunctionSegments("FOP",2,1,1,0,1,"ExpCF2","M12"));		
			segis.add(new ClearingFunctionSegments("FOP",2,1,1,0,1,"ExpCF2","M13"));			
			segis.add(new ClearingFunctionSegments("FOP",2,1,1,0,1,"ExpCF2","M14"));			
			segis.add(new ClearingFunctionSegments("FOP",2,1,1,0,1,"ExpCF2","M21"));		
			segis.add(new ClearingFunctionSegments("FOP",2,1,1,0,1,"ExpCF2","M22"));			
			segis.add(new ClearingFunctionSegments("FOP",2,1,1,0,1,"ExpCF2","M23"));			
			segis.add(new ClearingFunctionSegments("FOP",2,1,1,0,1,"ExpCF2","M24"));
			segis.add(new ClearingFunctionSegments("FOP",2,1,1,0,1,"ExpCF2","M31"));			
			segis.add(new ClearingFunctionSegments("FOP",2,1,1,0,1,"ExpCF2","M32"));			
			segis.add(new ClearingFunctionSegments("FOP",2,1,1,0,1,"ExpCF2","M33"));			
			segis.add(new ClearingFunctionSegments("FOP",2,1,1,0,1,"ExpCF2","M34"));
			segis.add(new ClearingFunctionSegments("FOP",2,1,1,0,1,"ExpCF2","M41"));			
			segis.add(new ClearingFunctionSegments("FOP",2,1,1,0,1,"ExpCF2","M42"));			
			segis.add(new ClearingFunctionSegments("FOP",2,1,1,0,1,"ExpCF2","M43"));			
			segis.add(new ClearingFunctionSegments("FOP",2,1,1,0,1,"ExpCF2","M44"));
			
			segis.add(new ClearingFunctionSegments("FOP",3,1,1,0,1,"ExpCF2","M11"));		
			segis.add(new ClearingFunctionSegments("FOP",3,1,1,0,1,"ExpCF2","M12"));		
			segis.add(new ClearingFunctionSegments("FOP",3,1,1,0,1,"ExpCF2","M13"));			
			segis.add(new ClearingFunctionSegments("FOP",3,1,1,0,1,"ExpCF2","M14"));			
			segis.add(new ClearingFunctionSegments("FOP",3,1,1,0,1,"ExpCF2","M21"));		
			segis.add(new ClearingFunctionSegments("FOP",3,1,1,0,1,"ExpCF2","M22"));			
			segis.add(new ClearingFunctionSegments("FOP",3,1,1,0,1,"ExpCF2","M23"));			
			segis.add(new ClearingFunctionSegments("FOP",3,1,1,0,1,"ExpCF2","M24"));
			segis.add(new ClearingFunctionSegments("FOP",3,1,1,0,1,"ExpCF2","M31"));			
			segis.add(new ClearingFunctionSegments("FOP",3,1,1,0,1,"ExpCF2","M32"));			
			segis.add(new ClearingFunctionSegments("FOP",3,1,1,0,1,"ExpCF2","M33"));			
			segis.add(new ClearingFunctionSegments("FOP",3,1,1,0,1,"ExpCF2","M34"));
			segis.add(new ClearingFunctionSegments("FOP",3,1,1,0,1,"ExpCF2","M41"));			
			segis.add(new ClearingFunctionSegments("FOP",3,1,1,0,1,"ExpCF2","M42"));			
			segis.add(new ClearingFunctionSegments("FOP",3,1,1,0,1,"ExpCF2","M43"));			
			segis.add(new ClearingFunctionSegments("FOP",3,1,1,0,1,"ExpCF2","M44"));			
			
			segis.add(new ClearingFunctionSegments("FOP",4,1,1,0,1,"ExpCF2","M11"));		
			segis.add(new ClearingFunctionSegments("FOP",4,1,1,0,1,"ExpCF2","M12"));		
			segis.add(new ClearingFunctionSegments("FOP",4,1,1,0,1,"ExpCF2","M13"));			
			segis.add(new ClearingFunctionSegments("FOP",4,1,1,0,1,"ExpCF2","M14"));			
			segis.add(new ClearingFunctionSegments("FOP",4,1,1,0,1,"ExpCF2","M21"));		
			segis.add(new ClearingFunctionSegments("FOP",4,1,1,0,1,"ExpCF2","M22"));			
			segis.add(new ClearingFunctionSegments("FOP",4,1,1,0,1,"ExpCF2","M23"));			
			segis.add(new ClearingFunctionSegments("FOP",4,1,1,0,1,"ExpCF2","M24"));
			segis.add(new ClearingFunctionSegments("FOP",4,1,1,0,1,"ExpCF2","M31"));			
			segis.add(new ClearingFunctionSegments("FOP",4,1,1,0,1,"ExpCF2","M32"));			
			segis.add(new ClearingFunctionSegments("FOP",4,1,1,0,1,"ExpCF2","M33"));			
			segis.add(new ClearingFunctionSegments("FOP",4,1,1,0,1,"ExpCF2","M34"));
			segis.add(new ClearingFunctionSegments("FOP",4,1,1,0,1,"ExpCF2","M41"));			
			segis.add(new ClearingFunctionSegments("FOP",4,1,1,0,1,"ExpCF2","M42"));			
			segis.add(new ClearingFunctionSegments("FOP",4,1,1,0,1,"ExpCF2","M43"));			
			segis.add(new ClearingFunctionSegments("FOP",4,1,1,0,1,"ExpCF2","M44"));			
			
			segis.add(new ClearingFunctionSegments("FOP",5,1,1,0,1,"ExpCF2","M11"));		
			segis.add(new ClearingFunctionSegments("FOP",5,1,1,0,1,"ExpCF2","M12"));		
			segis.add(new ClearingFunctionSegments("FOP",5,1,1,0,1,"ExpCF2","M13"));			
			segis.add(new ClearingFunctionSegments("FOP",5,1,1,0,1,"ExpCF2","M14"));			
			segis.add(new ClearingFunctionSegments("FOP",5,1,1,0,1,"ExpCF2","M21"));		
			segis.add(new ClearingFunctionSegments("FOP",5,1,1,0,1,"ExpCF2","M22"));			
			segis.add(new ClearingFunctionSegments("FOP",5,1,1,0,1,"ExpCF2","M23"));			
			segis.add(new ClearingFunctionSegments("FOP",5,1,1,0,1,"ExpCF2","M24"));
			segis.add(new ClearingFunctionSegments("FOP",5,1,1,0,1,"ExpCF2","M31"));			
			segis.add(new ClearingFunctionSegments("FOP",5,1,1,0,1,"ExpCF2","M32"));			
			segis.add(new ClearingFunctionSegments("FOP",5,1,1,0,1,"ExpCF2","M33"));			
			segis.add(new ClearingFunctionSegments("FOP",5,1,1,0,1,"ExpCF2","M34"));
			segis.add(new ClearingFunctionSegments("FOP",5,1,1,0,1,"ExpCF2","M41"));			
			segis.add(new ClearingFunctionSegments("FOP",5,1,1,0,1,"ExpCF2","M42"));			
			segis.add(new ClearingFunctionSegments("FOP",5,1,1,0,1,"ExpCF2","M43"));			
			segis.add(new ClearingFunctionSegments("FOP",5,1,1,0,1,"ExpCF2","M44"));	
			
			
			segis.add(new ClearingFunctionSegments("FOQ",10,1,1,0,1,"ExpCF2","M11"));		
			segis.add(new ClearingFunctionSegments("FOQ",10,1,1,0,1,"ExpCF2","M12"));		
			segis.add(new ClearingFunctionSegments("FOQ",10,1,1,0,1,"ExpCF2","M13"));			
			segis.add(new ClearingFunctionSegments("FOQ",10,1,1,0,1,"ExpCF2","M14"));			
			segis.add(new ClearingFunctionSegments("FOQ",10,1,1,0,1,"ExpCF2","M21"));		
			segis.add(new ClearingFunctionSegments("FOQ",10,1,1,0,1,"ExpCF2","M22"));			
			segis.add(new ClearingFunctionSegments("FOQ",10,1,1,0,1,"ExpCF2","M23"));			
			segis.add(new ClearingFunctionSegments("FOQ",10,1,1,0,1,"ExpCF2","M24"));
			segis.add(new ClearingFunctionSegments("FOQ",10,1,1,0,1,"ExpCF2","M31"));			
			segis.add(new ClearingFunctionSegments("FOQ",10,1,1,0,1,"ExpCF2","M32"));			
			segis.add(new ClearingFunctionSegments("FOQ",10,1,1,0,1,"ExpCF2","M33"));			
			segis.add(new ClearingFunctionSegments("FOQ",10,1,1,0,1,"ExpCF2","M34"));
			segis.add(new ClearingFunctionSegments("FOQ",10,1,1,0,1,"ExpCF2","M41"));			
			segis.add(new ClearingFunctionSegments("FOQ",10,1,1,0,1,"ExpCF2","M42"));			
			segis.add(new ClearingFunctionSegments("FOQ",10,1,1,0,1,"ExpCF2","M43"));			
			segis.add(new ClearingFunctionSegments("FOQ",10,1,1,0,1,"ExpCF2","M44"));			
			
			
			segis.add(new ClearingFunctionSegments("FOQ",20,1,1,0,1,"ExpCF2","M11"));		
			segis.add(new ClearingFunctionSegments("FOQ",20,1,1,0,1,"ExpCF2","M12"));		
			segis.add(new ClearingFunctionSegments("FOQ",20,1,1,0,1,"ExpCF2","M13"));			
			segis.add(new ClearingFunctionSegments("FOQ",20,1,1,0,1,"ExpCF2","M14"));			
			segis.add(new ClearingFunctionSegments("FOQ",20,1,1,0,1,"ExpCF2","M21"));		
			segis.add(new ClearingFunctionSegments("FOQ",20,1,1,0,1,"ExpCF2","M22"));			
			segis.add(new ClearingFunctionSegments("FOQ",20,1,1,0,1,"ExpCF2","M23"));			
			segis.add(new ClearingFunctionSegments("FOQ",20,1,1,0,1,"ExpCF2","M24"));
			segis.add(new ClearingFunctionSegments("FOQ",20,1,1,0,1,"ExpCF2","M31"));			
			segis.add(new ClearingFunctionSegments("FOQ",20,1,1,0,1,"ExpCF2","M32"));			
			segis.add(new ClearingFunctionSegments("FOQ",20,1,1,0,1,"ExpCF2","M33"));			
			segis.add(new ClearingFunctionSegments("FOQ",20,1,1,0,1,"ExpCF2","M34"));
			segis.add(new ClearingFunctionSegments("FOQ",20,1,1,0,1,"ExpCF2","M41"));			
			segis.add(new ClearingFunctionSegments("FOQ",20,1,1,0,1,"ExpCF2","M42"));			
			segis.add(new ClearingFunctionSegments("FOQ",20,1,1,0,1,"ExpCF2","M43"));			
			segis.add(new ClearingFunctionSegments("FOQ",20,1,1,0,1,"ExpCF2","M44"));			
			
			segis.add(new ClearingFunctionSegments("FOQ",30,1,1,0,1,"ExpCF2","M11"));		
			segis.add(new ClearingFunctionSegments("FOQ",30,1,1,0,1,"ExpCF2","M12"));		
			segis.add(new ClearingFunctionSegments("FOQ",30,1,1,0,1,"ExpCF2","M13"));			
			segis.add(new ClearingFunctionSegments("FOQ",30,1,1,0,1,"ExpCF2","M14"));			
			segis.add(new ClearingFunctionSegments("FOQ",30,1,1,0,1,"ExpCF2","M21"));		
			segis.add(new ClearingFunctionSegments("FOQ",30,1,1,0,1,"ExpCF2","M22"));			
			segis.add(new ClearingFunctionSegments("FOQ",30,1,1,0,1,"ExpCF2","M23"));			
			segis.add(new ClearingFunctionSegments("FOQ",30,1,1,0,1,"ExpCF2","M24"));
			segis.add(new ClearingFunctionSegments("FOQ",30,1,1,0,1,"ExpCF2","M31"));			
			segis.add(new ClearingFunctionSegments("FOQ",30,1,1,0,1,"ExpCF2","M32"));			
			segis.add(new ClearingFunctionSegments("FOQ",30,1,1,0,1,"ExpCF2","M33"));			
			segis.add(new ClearingFunctionSegments("FOQ",30,1,1,0,1,"ExpCF2","M34"));
			segis.add(new ClearingFunctionSegments("FOQ",30,1,1,0,1,"ExpCF2","M41"));			
			segis.add(new ClearingFunctionSegments("FOQ",30,1,1,0,1,"ExpCF2","M42"));			
			segis.add(new ClearingFunctionSegments("FOQ",30,1,1,0,1,"ExpCF2","M43"));			
			segis.add(new ClearingFunctionSegments("FOQ",30,1,1,0,1,"ExpCF2","M44"));			

			segis.add(new ClearingFunctionSegments("FOQ",40,1,1,0,1,"ExpCF2","M11"));		
			segis.add(new ClearingFunctionSegments("FOQ",40,1,1,0,1,"ExpCF2","M12"));		
			segis.add(new ClearingFunctionSegments("FOQ",40,1,1,0,1,"ExpCF2","M13"));			
			segis.add(new ClearingFunctionSegments("FOQ",40,1,1,0,1,"ExpCF2","M14"));			
			segis.add(new ClearingFunctionSegments("FOQ",40,1,1,0,1,"ExpCF2","M21"));		
			segis.add(new ClearingFunctionSegments("FOQ",40,1,1,0,1,"ExpCF2","M22"));			
			segis.add(new ClearingFunctionSegments("FOQ",40,1,1,0,1,"ExpCF2","M23"));			
			segis.add(new ClearingFunctionSegments("FOQ",40,1,1,0,1,"ExpCF2","M24"));
			segis.add(new ClearingFunctionSegments("FOQ",40,1,1,0,1,"ExpCF2","M31"));			
			segis.add(new ClearingFunctionSegments("FOQ",40,1,1,0,1,"ExpCF2","M32"));			
			segis.add(new ClearingFunctionSegments("FOQ",40,1,1,0,1,"ExpCF2","M33"));			
			segis.add(new ClearingFunctionSegments("FOQ",40,1,1,0,1,"ExpCF2","M34"));
			segis.add(new ClearingFunctionSegments("FOQ",40,1,1,0,1,"ExpCF2","M41"));			
			segis.add(new ClearingFunctionSegments("FOQ",40,1,1,0,1,"ExpCF2","M42"));			
			segis.add(new ClearingFunctionSegments("FOQ",40,1,1,0,1,"ExpCF2","M43"));			
			segis.add(new ClearingFunctionSegments("FOQ",40,1,1,0,1,"ExpCF2","M44"));			
			
			segis.add(new ClearingFunctionSegments("FOQ",50,1,1,0,1,"ExpCF2","M11"));		
			segis.add(new ClearingFunctionSegments("FOQ",50,1,1,0,1,"ExpCF2","M12"));		
			segis.add(new ClearingFunctionSegments("FOQ",50,1,1,0,1,"ExpCF2","M13"));			
			segis.add(new ClearingFunctionSegments("FOQ",50,1,1,0,1,"ExpCF2","M14"));			
			segis.add(new ClearingFunctionSegments("FOQ",50,1,1,0,1,"ExpCF2","M21"));		
			segis.add(new ClearingFunctionSegments("FOQ",50,1,1,0,1,"ExpCF2","M22"));			
			segis.add(new ClearingFunctionSegments("FOQ",50,1,1,0,1,"ExpCF2","M23"));			
			segis.add(new ClearingFunctionSegments("FOQ",50,1,1,0,1,"ExpCF2","M24"));
			segis.add(new ClearingFunctionSegments("FOQ",50,1,1,0,1,"ExpCF2","M31"));			
			segis.add(new ClearingFunctionSegments("FOQ",50,1,1,0,1,"ExpCF2","M32"));			
			segis.add(new ClearingFunctionSegments("FOQ",50,1,1,0,1,"ExpCF2","M33"));			
			segis.add(new ClearingFunctionSegments("FOQ",50,1,1,0,1,"ExpCF2","M34"));
			segis.add(new ClearingFunctionSegments("FOQ",50,1,1,0,1,"ExpCF2","M41"));			
			segis.add(new ClearingFunctionSegments("FOQ",50,1,1,0,1,"ExpCF2","M42"));			
			segis.add(new ClearingFunctionSegments("FOQ",50,1,1,0,1,"ExpCF2","M43"));			
			segis.add(new ClearingFunctionSegments("FOQ",50,1,1,0,1,"ExpCF2","M44"));
			
			segis.add(new ClearingFunctionSegments("FOQ",60,1,1,0,1,"ExpCF2","M11"));		
			segis.add(new ClearingFunctionSegments("FOQ",60,1,1,0,1,"ExpCF2","M12"));		
			segis.add(new ClearingFunctionSegments("FOQ",60,1,1,0,1,"ExpCF2","M13"));			
			segis.add(new ClearingFunctionSegments("FOQ",60,1,1,0,1,"ExpCF2","M14"));			
			segis.add(new ClearingFunctionSegments("FOQ",60,1,1,0,1,"ExpCF2","M21"));		
			segis.add(new ClearingFunctionSegments("FOQ",60,1,1,0,1,"ExpCF2","M22"));			
			segis.add(new ClearingFunctionSegments("FOQ",60,1,1,0,1,"ExpCF2","M23"));			
			segis.add(new ClearingFunctionSegments("FOQ",60,1,1,0,1,"ExpCF2","M24"));
			segis.add(new ClearingFunctionSegments("FOQ",60,1,1,0,1,"ExpCF2","M31"));			
			segis.add(new ClearingFunctionSegments("FOQ",60,1,1,0,1,"ExpCF2","M32"));			
			segis.add(new ClearingFunctionSegments("FOQ",60,1,1,0,1,"ExpCF2","M33"));			
			segis.add(new ClearingFunctionSegments("FOQ",60,1,1,0,1,"ExpCF2","M34"));
			segis.add(new ClearingFunctionSegments("FOQ",60,1,1,0,1,"ExpCF2","M41"));			
			segis.add(new ClearingFunctionSegments("FOQ",60,1,1,0,1,"ExpCF2","M42"));			
			segis.add(new ClearingFunctionSegments("FOQ",60,1,1,0,1,"ExpCF2","M43"));			
			segis.add(new ClearingFunctionSegments("FOQ",60,1,1,0,1,"ExpCF2","M44"));			
			
			segis.add(new ClearingFunctionSegments("FOQ",70,1,1,0,1,"ExpCF2","M11"));		
			segis.add(new ClearingFunctionSegments("FOQ",70,1,1,0,1,"ExpCF2","M12"));		
			segis.add(new ClearingFunctionSegments("FOQ",70,1,1,0,1,"ExpCF2","M13"));			
			segis.add(new ClearingFunctionSegments("FOQ",70,1,1,0,1,"ExpCF2","M14"));			
			segis.add(new ClearingFunctionSegments("FOQ",70,1,1,0,1,"ExpCF2","M21"));		
			segis.add(new ClearingFunctionSegments("FOQ",70,1,1,0,1,"ExpCF2","M22"));			
			segis.add(new ClearingFunctionSegments("FOQ",70,1,1,0,1,"ExpCF2","M23"));			
			segis.add(new ClearingFunctionSegments("FOQ",70,1,1,0,1,"ExpCF2","M24"));
			segis.add(new ClearingFunctionSegments("FOQ",70,1,1,0,1,"ExpCF2","M31"));			
			segis.add(new ClearingFunctionSegments("FOQ",70,1,1,0,1,"ExpCF2","M32"));			
			segis.add(new ClearingFunctionSegments("FOQ",70,1,1,0,1,"ExpCF2","M33"));			
			segis.add(new ClearingFunctionSegments("FOQ",70,1,1,0,1,"ExpCF2","M34"));
			segis.add(new ClearingFunctionSegments("FOQ",70,1,1,0,1,"ExpCF2","M41"));			
			segis.add(new ClearingFunctionSegments("FOQ",70,1,1,0,1,"ExpCF2","M42"));			
			segis.add(new ClearingFunctionSegments("FOQ",70,1,1,0,1,"ExpCF2","M43"));			
			segis.add(new ClearingFunctionSegments("FOQ",70,1,1,0,1,"ExpCF2","M44"));	
			
			segis.add(new ClearingFunctionSegments("FOQ",80,1,1,0,1,"ExpCF2","M11"));		
			segis.add(new ClearingFunctionSegments("FOQ",80,1,1,0,1,"ExpCF2","M12"));		
			segis.add(new ClearingFunctionSegments("FOQ",80,1,1,0,1,"ExpCF2","M13"));			
			segis.add(new ClearingFunctionSegments("FOQ",80,1,1,0,1,"ExpCF2","M14"));			
			segis.add(new ClearingFunctionSegments("FOQ",80,1,1,0,1,"ExpCF2","M21"));		
			segis.add(new ClearingFunctionSegments("FOQ",80,1,1,0,1,"ExpCF2","M22"));			
			segis.add(new ClearingFunctionSegments("FOQ",80,1,1,0,1,"ExpCF2","M23"));			
			segis.add(new ClearingFunctionSegments("FOQ",80,1,1,0,1,"ExpCF2","M24"));
			segis.add(new ClearingFunctionSegments("FOQ",80,1,1,0,1,"ExpCF2","M31"));			
			segis.add(new ClearingFunctionSegments("FOQ",80,1,1,0,1,"ExpCF2","M32"));			
			segis.add(new ClearingFunctionSegments("FOQ",80,1,1,0,1,"ExpCF2","M33"));			
			segis.add(new ClearingFunctionSegments("FOQ",80,1,1,0,1,"ExpCF2","M34"));
			segis.add(new ClearingFunctionSegments("FOQ",80,1,1,0,1,"ExpCF2","M41"));			
			segis.add(new ClearingFunctionSegments("FOQ",80,1,1,0,1,"ExpCF2","M42"));			
			segis.add(new ClearingFunctionSegments("FOQ",80,1,1,0,1,"ExpCF2","M43"));			
			segis.add(new ClearingFunctionSegments("FOQ",80,1,1,0,1,"ExpCF2","M44"));			
			
			segis.add(new ClearingFunctionSegments("FOQ",90,1,1,0,1,"ExpCF2","M11"));		
			segis.add(new ClearingFunctionSegments("FOQ",90,1,1,0,1,"ExpCF2","M12"));		
			segis.add(new ClearingFunctionSegments("FOQ",90,1,1,0,1,"ExpCF2","M13"));			
			segis.add(new ClearingFunctionSegments("FOQ",90,1,1,0,1,"ExpCF2","M14"));			
			segis.add(new ClearingFunctionSegments("FOQ",90,1,1,0,1,"ExpCF2","M21"));		
			segis.add(new ClearingFunctionSegments("FOQ",90,1,1,0,1,"ExpCF2","M22"));			
			segis.add(new ClearingFunctionSegments("FOQ",90,1,1,0,1,"ExpCF2","M23"));			
			segis.add(new ClearingFunctionSegments("FOQ",90,1,1,0,1,"ExpCF2","M24"));
			segis.add(new ClearingFunctionSegments("FOQ",90,1,1,0,1,"ExpCF2","M31"));			
			segis.add(new ClearingFunctionSegments("FOQ",90,1,1,0,1,"ExpCF2","M32"));			
			segis.add(new ClearingFunctionSegments("FOQ",90,1,1,0,1,"ExpCF2","M33"));			
			segis.add(new ClearingFunctionSegments("FOQ",90,1,1,0,1,"ExpCF2","M34"));
			segis.add(new ClearingFunctionSegments("FOQ",90,1,1,0,1,"ExpCF2","M41"));			
			segis.add(new ClearingFunctionSegments("FOQ",90,1,1,0,1,"ExpCF2","M42"));			
			segis.add(new ClearingFunctionSegments("FOQ",90,1,1,0,1,"ExpCF2","M43"));			
			segis.add(new ClearingFunctionSegments("FOQ",90,1,1,0,1,"ExpCF2","M44"));			
			
			segis.add(new ClearingFunctionSegments("FOQ",100,1,1,0,1,"ExpCF2","M11"));		
			segis.add(new ClearingFunctionSegments("FOQ",100,1,1,0,1,"ExpCF2","M12"));		
			segis.add(new ClearingFunctionSegments("FOQ",100,1,1,0,1,"ExpCF2","M13"));			
			segis.add(new ClearingFunctionSegments("FOQ",100,1,1,0,1,"ExpCF2","M14"));			
			segis.add(new ClearingFunctionSegments("FOQ",100,1,1,0,1,"ExpCF2","M21"));		
			segis.add(new ClearingFunctionSegments("FOQ",100,1,1,0,1,"ExpCF2","M22"));			
			segis.add(new ClearingFunctionSegments("FOQ",100,1,1,0,1,"ExpCF2","M23"));			
			segis.add(new ClearingFunctionSegments("FOQ",100,1,1,0,1,"ExpCF2","M24"));
			segis.add(new ClearingFunctionSegments("FOQ",100,1,1,0,1,"ExpCF2","M31"));			
			segis.add(new ClearingFunctionSegments("FOQ",100,1,1,0,1,"ExpCF2","M32"));			
			segis.add(new ClearingFunctionSegments("FOQ",100,1,1,0,1,"ExpCF2","M33"));			
			segis.add(new ClearingFunctionSegments("FOQ",100,1,1,0,1,"ExpCF2","M34"));
			segis.add(new ClearingFunctionSegments("FOQ",100,1,1,0,1,"ExpCF2","M41"));			
			segis.add(new ClearingFunctionSegments("FOQ",100,1,1,0,1,"ExpCF2","M42"));			
			segis.add(new ClearingFunctionSegments("FOQ",100,1,1,0,1,"ExpCF2","M43"));			
			segis.add(new ClearingFunctionSegments("FOQ",100,1,1,0,1,"ExpCF2","M44"));	
			
			segis.add(new ClearingFunctionSegments("FOP",1,1,1,0,1,"ExpCF3","M11"));		
			segis.add(new ClearingFunctionSegments("FOP",1,1,1,0,1,"ExpCF3","M12"));					
			segis.add(new ClearingFunctionSegments("FOP",1,1,1,0,1,"ExpCF3","M21"));		
			
			segis.add(new ClearingFunctionSegments("FOP",2,1,1,0,1,"ExpCF3","M11"));		
			segis.add(new ClearingFunctionSegments("FOP",2,1,1,0,1,"ExpCF3","M12"));		
			segis.add(new ClearingFunctionSegments("FOP",2,1,1,0,1,"ExpCF3","M21"));		
						
			segis.add(new ClearingFunctionSegments("FOP",3,1,1,0,1,"ExpCF3","M11"));		
			segis.add(new ClearingFunctionSegments("FOP",3,1,1,0,1,"ExpCF3","M12"));		
			segis.add(new ClearingFunctionSegments("FOP",3,1,1,0,1,"ExpCF3","M21"));		
			
			segis.add(new ClearingFunctionSegments("FOP",4,1,1,0,1,"ExpCF3","M11"));		
			segis.add(new ClearingFunctionSegments("FOP",4,1,1,0,1,"ExpCF3","M12"));		
			segis.add(new ClearingFunctionSegments("FOP",4,1,1,0,1,"ExpCF3","M21"));		
			
			segis.add(new ClearingFunctionSegments("FOP",5,1,1,0,1,"ExpCF3","M11"));		
			segis.add(new ClearingFunctionSegments("FOP",5,1,1,0,1,"ExpCF3","M12"));		
			segis.add(new ClearingFunctionSegments("FOP",5,1,1,0,1,"ExpCF3","M21"));		
						
			segis.add(new ClearingFunctionSegments("FOQ",10,1,1,0,1,"ExpCF3","M11"));		
			segis.add(new ClearingFunctionSegments("FOQ",10,1,1,0,1,"ExpCF3","M12"));		
			segis.add(new ClearingFunctionSegments("FOQ",10,1,1,0,1,"ExpCF3","M21"));								
			
			segis.add(new ClearingFunctionSegments("FOQ",20,1,1,0,1,"ExpCF3","M11"));		
			segis.add(new ClearingFunctionSegments("FOQ",20,1,1,0,1,"ExpCF3","M12"));		
			segis.add(new ClearingFunctionSegments("FOQ",20,1,1,0,1,"ExpCF3","M21"));		
			
			segis.add(new ClearingFunctionSegments("FOQ",30,1,1,0,1,"ExpCF3","M11"));		
			segis.add(new ClearingFunctionSegments("FOQ",30,1,1,0,1,"ExpCF3","M12"));		
			segis.add(new ClearingFunctionSegments("FOQ",30,1,1,0,1,"ExpCF3","M21"));		

			segis.add(new ClearingFunctionSegments("FOQ",40,1,1,0,1,"ExpCF3","M11"));		
			segis.add(new ClearingFunctionSegments("FOQ",40,1,1,0,1,"ExpCF3","M12"));		
			segis.add(new ClearingFunctionSegments("FOQ",40,1,1,0,1,"ExpCF3","M21"));		
			
			segis.add(new ClearingFunctionSegments("FOQ",50,1,1,0,1,"ExpCF3","M11"));		
			segis.add(new ClearingFunctionSegments("FOQ",50,1,1,0,1,"ExpCF3","M12"));		
			segis.add(new ClearingFunctionSegments("FOQ",50,1,1,0,1,"ExpCF3","M21"));		
			
			segis.add(new ClearingFunctionSegments("FOQ",60,1,1,0,1,"ExpCF3","M11"));		
			segis.add(new ClearingFunctionSegments("FOQ",60,1,1,0,1,"ExpCF3","M12"));		
			segis.add(new ClearingFunctionSegments("FOQ",60,1,1,0,1,"ExpCF3","M21"));		
			
			segis.add(new ClearingFunctionSegments("FOQ",70,1,1,0,1,"ExpCF3","M11"));		
			segis.add(new ClearingFunctionSegments("FOQ",70,1,1,0,1,"ExpCF3","M12"));		
			segis.add(new ClearingFunctionSegments("FOQ",70,1,1,0,1,"ExpCF3","M21"));		
			
			segis.add(new ClearingFunctionSegments("FOQ",80,1,1,0,1,"ExpCF3","M11"));		
			segis.add(new ClearingFunctionSegments("FOQ",80,1,1,0,1,"ExpCF3","M12"));		
			segis.add(new ClearingFunctionSegments("FOQ",80,1,1,0,1,"ExpCF3","M21"));		
			
			segis.add(new ClearingFunctionSegments("FOQ",90,1,1,0,1,"ExpCF3","M11"));		
			segis.add(new ClearingFunctionSegments("FOQ",90,1,1,0,1,"ExpCF3","M12"));		
			segis.add(new ClearingFunctionSegments("FOQ",90,1,1,0,1,"ExpCF3","M21"));		
			
			segis.add(new ClearingFunctionSegments("FOQ",100,1,1,0,1,"ExpCF3","M11"));		
			segis.add(new ClearingFunctionSegments("FOQ",100,1,1,0,1,"ExpCF3","M12"));		
			segis.add(new ClearingFunctionSegments("FOQ",100,1,1,0,1,"ExpCF3","M21"));	
			
		}else if(UseCFLineType == 2){//Generated basd on MRP			
		}
		else if(UseCFLineType == 3) {//generated based on Ideal CF
		}else if(UseCFLineType == 4) {			
		//ideal with ACF
		}else if(UseCFLineType == 5) {
			
			segis.add(new ClearingFunctionSegments("FOP",1,1,1,0,1,"ExpCF2","M11"));		
			segis.add(new ClearingFunctionSegments("FOP",1,1,1,0,1,"ExpCF2","M12"));		
			segis.add(new ClearingFunctionSegments("FOP",1,1,1,0,1,"ExpCF2","M13"));			
			segis.add(new ClearingFunctionSegments("FOP",1,1,1,0,1,"ExpCF2","M14"));			
			segis.add(new ClearingFunctionSegments("FOP",1,1,1,0,1,"ExpCF2","M21"));		
			segis.add(new ClearingFunctionSegments("FOP",1,1,1,0,1,"ExpCF2","M22"));			
			segis.add(new ClearingFunctionSegments("FOP",1,1,1,0,1,"ExpCF2","M23"));			
			segis.add(new ClearingFunctionSegments("FOP",1,1,1,0,1,"ExpCF2","M24"));
			segis.add(new ClearingFunctionSegments("FOP",1,1,1,0,1,"ExpCF2","M31"));			
			segis.add(new ClearingFunctionSegments("FOP",1,1,1,0,1,"ExpCF2","M32"));			
			segis.add(new ClearingFunctionSegments("FOP",1,1,1,0,1,"ExpCF2","M33"));			
			segis.add(new ClearingFunctionSegments("FOP",1,1,1,0,1,"ExpCF2","M34"));
			segis.add(new ClearingFunctionSegments("FOP",1,1,1,0,1,"ExpCF2","M41"));			
			segis.add(new ClearingFunctionSegments("FOP",1,1,1,0,1,"ExpCF2","M42"));			
			segis.add(new ClearingFunctionSegments("FOP",1,1,1,0,1,"ExpCF2","M43"));			
			segis.add(new ClearingFunctionSegments("FOP",1,1,1,0,1,"ExpCF2","M44"));			

			segis.add(new ClearingFunctionSegments("FOP",1,1,2,1440,0,"ExpCF2","M11"));		
			segis.add(new ClearingFunctionSegments("FOP",1,1,2,1440,0,"ExpCF2","M12"));		
			segis.add(new ClearingFunctionSegments("FOP",1,1,2,1440,0,"ExpCF2","M13"));			
			segis.add(new ClearingFunctionSegments("FOP",1,1,2,1440,0,"ExpCF2","M14"));			
			segis.add(new ClearingFunctionSegments("FOP",1,1,2,1440,0,"ExpCF2","M21"));		
			segis.add(new ClearingFunctionSegments("FOP",1,1,2,1440,0,"ExpCF2","M22"));			
			segis.add(new ClearingFunctionSegments("FOP",1,1,2,1440,0,"ExpCF2","M23"));			
			segis.add(new ClearingFunctionSegments("FOP",1,1,2,1440,0,"ExpCF2","M24"));
			segis.add(new ClearingFunctionSegments("FOP",1,1,2,1440,0,"ExpCF2","M31"));			
			segis.add(new ClearingFunctionSegments("FOP",1,1,2,1440,0,"ExpCF2","M32"));			
			segis.add(new ClearingFunctionSegments("FOP",1,1,2,1440,0,"ExpCF2","M33"));			
			segis.add(new ClearingFunctionSegments("FOP",1,1,2,1440,0,"ExpCF2","M34"));
			segis.add(new ClearingFunctionSegments("FOP",1,1,2,1440,0,"ExpCF2","M41"));			
			segis.add(new ClearingFunctionSegments("FOP",1,1,2,1440,0,"ExpCF2","M42"));			
			segis.add(new ClearingFunctionSegments("FOP",1,1,2,1440,0,"ExpCF2","M43"));			
			segis.add(new ClearingFunctionSegments("FOP",1,1,2,1440,0,"ExpCF2","M44"));
						
			segis.add(new ClearingFunctionSegments("FOP",2,1,1,0,1,"ExpCF2","M11"));		
			segis.add(new ClearingFunctionSegments("FOP",2,1,1,0,1,"ExpCF2","M12"));		
			segis.add(new ClearingFunctionSegments("FOP",2,1,1,0,1,"ExpCF2","M13"));			
			segis.add(new ClearingFunctionSegments("FOP",2,1,1,0,1,"ExpCF2","M14"));			
			segis.add(new ClearingFunctionSegments("FOP",2,1,1,0,1,"ExpCF2","M21"));		
			segis.add(new ClearingFunctionSegments("FOP",2,1,1,0,1,"ExpCF2","M22"));			
			segis.add(new ClearingFunctionSegments("FOP",2,1,1,0,1,"ExpCF2","M23"));			
			segis.add(new ClearingFunctionSegments("FOP",2,1,1,0,1,"ExpCF2","M24"));
			segis.add(new ClearingFunctionSegments("FOP",2,1,1,0,1,"ExpCF2","M31"));			
			segis.add(new ClearingFunctionSegments("FOP",2,1,1,0,1,"ExpCF2","M32"));			
			segis.add(new ClearingFunctionSegments("FOP",2,1,1,0,1,"ExpCF2","M33"));			
			segis.add(new ClearingFunctionSegments("FOP",2,1,1,0,1,"ExpCF2","M34"));
			segis.add(new ClearingFunctionSegments("FOP",2,1,1,0,1,"ExpCF2","M41"));			
			segis.add(new ClearingFunctionSegments("FOP",2,1,1,0,1,"ExpCF2","M42"));			
			segis.add(new ClearingFunctionSegments("FOP",2,1,1,0,1,"ExpCF2","M43"));			
			segis.add(new ClearingFunctionSegments("FOP",2,1,1,0,1,"ExpCF2","M44"));
			
			segis.add(new ClearingFunctionSegments("FOP",2,1,2,1440,0,"ExpCF2","M11"));		
			segis.add(new ClearingFunctionSegments("FOP",2,1,2,1440,0,"ExpCF2","M12"));		
			segis.add(new ClearingFunctionSegments("FOP",2,1,2,1440,0,"ExpCF2","M13"));			
			segis.add(new ClearingFunctionSegments("FOP",2,1,2,1440,0,"ExpCF2","M14"));			
			segis.add(new ClearingFunctionSegments("FOP",2,1,2,1440,0,"ExpCF2","M21"));		
			segis.add(new ClearingFunctionSegments("FOP",2,1,2,1440,0,"ExpCF2","M22"));			
			segis.add(new ClearingFunctionSegments("FOP",2,1,2,1440,0,"ExpCF2","M23"));			
			segis.add(new ClearingFunctionSegments("FOP",2,1,2,1440,0,"ExpCF2","M24"));
			segis.add(new ClearingFunctionSegments("FOP",2,1,2,1440,0,"ExpCF2","M31"));			
			segis.add(new ClearingFunctionSegments("FOP",2,1,2,1440,0,"ExpCF2","M32"));			
			segis.add(new ClearingFunctionSegments("FOP",2,1,2,1440,0,"ExpCF2","M33"));			
			segis.add(new ClearingFunctionSegments("FOP",2,1,2,1440,0,"ExpCF2","M34"));
			segis.add(new ClearingFunctionSegments("FOP",2,1,2,1440,0,"ExpCF2","M41"));			
			segis.add(new ClearingFunctionSegments("FOP",2,1,2,1440,0,"ExpCF2","M42"));			
			segis.add(new ClearingFunctionSegments("FOP",2,1,2,1440,0,"ExpCF2","M43"));			
			segis.add(new ClearingFunctionSegments("FOP",2,1,2,1440,0,"ExpCF2","M44"));
			
			segis.add(new ClearingFunctionSegments("FOP",3,1,1,0,1,"ExpCF2","M11"));		
			segis.add(new ClearingFunctionSegments("FOP",3,1,1,0,1,"ExpCF2","M12"));		
			segis.add(new ClearingFunctionSegments("FOP",3,1,1,0,1,"ExpCF2","M13"));			
			segis.add(new ClearingFunctionSegments("FOP",3,1,1,0,1,"ExpCF2","M14"));			
			segis.add(new ClearingFunctionSegments("FOP",3,1,1,0,1,"ExpCF2","M21"));		
			segis.add(new ClearingFunctionSegments("FOP",3,1,1,0,1,"ExpCF2","M22"));			
			segis.add(new ClearingFunctionSegments("FOP",3,1,1,0,1,"ExpCF2","M23"));			
			segis.add(new ClearingFunctionSegments("FOP",3,1,1,0,1,"ExpCF2","M24"));
			segis.add(new ClearingFunctionSegments("FOP",3,1,1,0,1,"ExpCF2","M31"));			
			segis.add(new ClearingFunctionSegments("FOP",3,1,1,0,1,"ExpCF2","M32"));			
			segis.add(new ClearingFunctionSegments("FOP",3,1,1,0,1,"ExpCF2","M33"));			
			segis.add(new ClearingFunctionSegments("FOP",3,1,1,0,1,"ExpCF2","M34"));
			segis.add(new ClearingFunctionSegments("FOP",3,1,1,0,1,"ExpCF2","M41"));			
			segis.add(new ClearingFunctionSegments("FOP",3,1,1,0,1,"ExpCF2","M42"));			
			segis.add(new ClearingFunctionSegments("FOP",3,1,1,0,1,"ExpCF2","M43"));			
			segis.add(new ClearingFunctionSegments("FOP",3,1,1,0,1,"ExpCF2","M44"));
			
			segis.add(new ClearingFunctionSegments("FOP",3,1,2,1440,0,"ExpCF2","M11"));		
			segis.add(new ClearingFunctionSegments("FOP",3,1,2,1440,0,"ExpCF2","M12"));		
			segis.add(new ClearingFunctionSegments("FOP",3,1,2,1440,0,"ExpCF2","M13"));			
			segis.add(new ClearingFunctionSegments("FOP",3,1,2,1440,0,"ExpCF2","M14"));			
			segis.add(new ClearingFunctionSegments("FOP",3,1,2,1440,0,"ExpCF2","M21"));		
			segis.add(new ClearingFunctionSegments("FOP",3,1,2,1440,0,"ExpCF2","M22"));			
			segis.add(new ClearingFunctionSegments("FOP",3,1,2,1440,0,"ExpCF2","M23"));			
			segis.add(new ClearingFunctionSegments("FOP",3,1,2,1440,0,"ExpCF2","M24"));
			segis.add(new ClearingFunctionSegments("FOP",3,1,2,1440,0,"ExpCF2","M31"));			
			segis.add(new ClearingFunctionSegments("FOP",3,1,2,1440,0,"ExpCF2","M32"));			
			segis.add(new ClearingFunctionSegments("FOP",3,1,2,1440,0,"ExpCF2","M33"));			
			segis.add(new ClearingFunctionSegments("FOP",3,1,2,1440,0,"ExpCF2","M34"));
			segis.add(new ClearingFunctionSegments("FOP",3,1,2,1440,0,"ExpCF2","M41"));			
			segis.add(new ClearingFunctionSegments("FOP",3,1,2,1440,0,"ExpCF2","M42"));			
			segis.add(new ClearingFunctionSegments("FOP",3,1,2,1440,0,"ExpCF2","M43"));			
			segis.add(new ClearingFunctionSegments("FOP",3,1,2,1440,0,"ExpCF2","M44"));
			
			
			segis.add(new ClearingFunctionSegments("FOP",4,1,1,0,1,"ExpCF2","M11"));		
			segis.add(new ClearingFunctionSegments("FOP",4,1,1,0,1,"ExpCF2","M12"));		
			segis.add(new ClearingFunctionSegments("FOP",4,1,1,0,1,"ExpCF2","M13"));			
			segis.add(new ClearingFunctionSegments("FOP",4,1,1,0,1,"ExpCF2","M14"));			
			segis.add(new ClearingFunctionSegments("FOP",4,1,1,0,1,"ExpCF2","M21"));		
			segis.add(new ClearingFunctionSegments("FOP",4,1,1,0,1,"ExpCF2","M22"));			
			segis.add(new ClearingFunctionSegments("FOP",4,1,1,0,1,"ExpCF2","M23"));			
			segis.add(new ClearingFunctionSegments("FOP",4,1,1,0,1,"ExpCF2","M24"));
			segis.add(new ClearingFunctionSegments("FOP",4,1,1,0,1,"ExpCF2","M31"));			
			segis.add(new ClearingFunctionSegments("FOP",4,1,1,0,1,"ExpCF2","M32"));			
			segis.add(new ClearingFunctionSegments("FOP",4,1,1,0,1,"ExpCF2","M33"));			
			segis.add(new ClearingFunctionSegments("FOP",4,1,1,0,1,"ExpCF2","M34"));
			segis.add(new ClearingFunctionSegments("FOP",4,1,1,0,1,"ExpCF2","M41"));			
			segis.add(new ClearingFunctionSegments("FOP",4,1,1,0,1,"ExpCF2","M42"));			
			segis.add(new ClearingFunctionSegments("FOP",4,1,1,0,1,"ExpCF2","M43"));			
			segis.add(new ClearingFunctionSegments("FOP",4,1,1,0,1,"ExpCF2","M44"));
			
			segis.add(new ClearingFunctionSegments("FOP",4,1,2,1440,0,"ExpCF2","M11"));		
			segis.add(new ClearingFunctionSegments("FOP",4,1,2,1440,0,"ExpCF2","M12"));		
			segis.add(new ClearingFunctionSegments("FOP",4,1,2,1440,0,"ExpCF2","M13"));			
			segis.add(new ClearingFunctionSegments("FOP",4,1,2,1440,0,"ExpCF2","M14"));			
			segis.add(new ClearingFunctionSegments("FOP",4,1,2,1440,0,"ExpCF2","M21"));		
			segis.add(new ClearingFunctionSegments("FOP",4,1,2,1440,0,"ExpCF2","M22"));			
			segis.add(new ClearingFunctionSegments("FOP",4,1,2,1440,0,"ExpCF2","M23"));			
			segis.add(new ClearingFunctionSegments("FOP",4,1,2,1440,0,"ExpCF2","M24"));
			segis.add(new ClearingFunctionSegments("FOP",4,1,2,1440,0,"ExpCF2","M31"));			
			segis.add(new ClearingFunctionSegments("FOP",4,1,2,1440,0,"ExpCF2","M32"));			
			segis.add(new ClearingFunctionSegments("FOP",4,1,2,1440,0,"ExpCF2","M33"));			
			segis.add(new ClearingFunctionSegments("FOP",4,1,2,1440,0,"ExpCF2","M34"));
			segis.add(new ClearingFunctionSegments("FOP",4,1,2,1440,0,"ExpCF2","M41"));			
			segis.add(new ClearingFunctionSegments("FOP",4,1,2,1440,0,"ExpCF2","M42"));			
			segis.add(new ClearingFunctionSegments("FOP",4,1,2,1440,0,"ExpCF2","M43"));			
			segis.add(new ClearingFunctionSegments("FOP",4,1,2,1440,0,"ExpCF2","M44"));
			
			segis.add(new ClearingFunctionSegments("FOP",5,1,1,0,1,"ExpCF2","M11"));		
			segis.add(new ClearingFunctionSegments("FOP",5,1,1,0,1,"ExpCF2","M12"));		
			segis.add(new ClearingFunctionSegments("FOP",5,1,1,0,1,"ExpCF2","M13"));			
			segis.add(new ClearingFunctionSegments("FOP",5,1,1,0,1,"ExpCF2","M14"));			
			segis.add(new ClearingFunctionSegments("FOP",5,1,1,0,1,"ExpCF2","M21"));		
			segis.add(new ClearingFunctionSegments("FOP",5,1,1,0,1,"ExpCF2","M22"));			
			segis.add(new ClearingFunctionSegments("FOP",5,1,1,0,1,"ExpCF2","M23"));			
			segis.add(new ClearingFunctionSegments("FOP",5,1,1,0,1,"ExpCF2","M24"));
			segis.add(new ClearingFunctionSegments("FOP",5,1,1,0,1,"ExpCF2","M31"));			
			segis.add(new ClearingFunctionSegments("FOP",5,1,1,0,1,"ExpCF2","M32"));			
			segis.add(new ClearingFunctionSegments("FOP",5,1,1,0,1,"ExpCF2","M33"));			
			segis.add(new ClearingFunctionSegments("FOP",5,1,1,0,1,"ExpCF2","M34"));
			segis.add(new ClearingFunctionSegments("FOP",5,1,1,0,1,"ExpCF2","M41"));			
			segis.add(new ClearingFunctionSegments("FOP",5,1,1,0,1,"ExpCF2","M42"));			
			segis.add(new ClearingFunctionSegments("FOP",5,1,1,0,1,"ExpCF2","M43"));			
			segis.add(new ClearingFunctionSegments("FOP",5,1,1,0,1,"ExpCF2","M44"));
			
			segis.add(new ClearingFunctionSegments("FOP",5,1,2,1440,0,"ExpCF2","M11"));		
			segis.add(new ClearingFunctionSegments("FOP",5,1,2,1440,0,"ExpCF2","M12"));		
			segis.add(new ClearingFunctionSegments("FOP",5,1,2,1440,0,"ExpCF2","M13"));			
			segis.add(new ClearingFunctionSegments("FOP",5,1,2,1440,0,"ExpCF2","M14"));			
			segis.add(new ClearingFunctionSegments("FOP",5,1,2,1440,0,"ExpCF2","M21"));		
			segis.add(new ClearingFunctionSegments("FOP",5,1,2,1440,0,"ExpCF2","M22"));			
			segis.add(new ClearingFunctionSegments("FOP",5,1,2,1440,0,"ExpCF2","M23"));			
			segis.add(new ClearingFunctionSegments("FOP",5,1,2,1440,0,"ExpCF2","M24"));
			segis.add(new ClearingFunctionSegments("FOP",5,1,2,1440,0,"ExpCF2","M31"));			
			segis.add(new ClearingFunctionSegments("FOP",5,1,2,1440,0,"ExpCF2","M32"));			
			segis.add(new ClearingFunctionSegments("FOP",5,1,2,1440,0,"ExpCF2","M33"));			
			segis.add(new ClearingFunctionSegments("FOP",5,1,2,1440,0,"ExpCF2","M34"));
			segis.add(new ClearingFunctionSegments("FOP",5,1,2,1440,0,"ExpCF2","M41"));			
			segis.add(new ClearingFunctionSegments("FOP",5,1,2,1440,0,"ExpCF2","M42"));			
			segis.add(new ClearingFunctionSegments("FOP",5,1,2,1440,0,"ExpCF2","M43"));			
			segis.add(new ClearingFunctionSegments("FOP",5,1,2,1440,0,"ExpCF2","M44"));
			
			//#####################################################################
			segis.add(new ClearingFunctionSegments("FOP",1,1,1,0,1,"ExpCF3","M11"));		
			segis.add(new ClearingFunctionSegments("FOP",1,1,1,0,1,"ExpCF3","M12"));		
			segis.add(new ClearingFunctionSegments("FOP",1,1,1,0,1,"ExpCF3","M13"));			
			segis.add(new ClearingFunctionSegments("FOP",1,1,1,0,1,"ExpCF3","M14"));			
			segis.add(new ClearingFunctionSegments("FOP",1,1,1,0,1,"ExpCF3","M21"));		
			segis.add(new ClearingFunctionSegments("FOP",1,1,1,0,1,"ExpCF3","M22"));			
			segis.add(new ClearingFunctionSegments("FOP",1,1,1,0,1,"ExpCF3","M23"));			
			segis.add(new ClearingFunctionSegments("FOP",1,1,1,0,1,"ExpCF3","M24"));
			segis.add(new ClearingFunctionSegments("FOP",1,1,1,0,1,"ExpCF3","M31"));			
			segis.add(new ClearingFunctionSegments("FOP",1,1,1,0,1,"ExpCF3","M32"));			
			segis.add(new ClearingFunctionSegments("FOP",1,1,1,0,1,"ExpCF3","M33"));			
			segis.add(new ClearingFunctionSegments("FOP",1,1,1,0,1,"ExpCF3","M34"));
			segis.add(new ClearingFunctionSegments("FOP",1,1,1,0,1,"ExpCF3","M41"));			
			segis.add(new ClearingFunctionSegments("FOP",1,1,1,0,1,"ExpCF3","M42"));			
			segis.add(new ClearingFunctionSegments("FOP",1,1,1,0,1,"ExpCF3","M43"));			
			segis.add(new ClearingFunctionSegments("FOP",1,1,1,0,1,"ExpCF3","M44"));			

			segis.add(new ClearingFunctionSegments("FOP",1,1,2,1440,0,"ExpCF3","M11"));		
			segis.add(new ClearingFunctionSegments("FOP",1,1,2,1440,0,"ExpCF3","M12"));		
			segis.add(new ClearingFunctionSegments("FOP",1,1,2,1440,0,"ExpCF3","M13"));			
			segis.add(new ClearingFunctionSegments("FOP",1,1,2,1440,0,"ExpCF3","M14"));			
			segis.add(new ClearingFunctionSegments("FOP",1,1,2,1440,0,"ExpCF3","M21"));		
			segis.add(new ClearingFunctionSegments("FOP",1,1,2,1440,0,"ExpCF3","M22"));			
			segis.add(new ClearingFunctionSegments("FOP",1,1,2,1440,0,"ExpCF3","M23"));			
			segis.add(new ClearingFunctionSegments("FOP",1,1,2,1440,0,"ExpCF3","M24"));
			segis.add(new ClearingFunctionSegments("FOP",1,1,2,1440,0,"ExpCF3","M31"));			
			segis.add(new ClearingFunctionSegments("FOP",1,1,2,1440,0,"ExpCF3","M32"));			
			segis.add(new ClearingFunctionSegments("FOP",1,1,2,1440,0,"ExpCF3","M33"));			
			segis.add(new ClearingFunctionSegments("FOP",1,1,2,1440,0,"ExpCF3","M34"));
			segis.add(new ClearingFunctionSegments("FOP",1,1,2,1440,0,"ExpCF3","M41"));			
			segis.add(new ClearingFunctionSegments("FOP",1,1,2,1440,0,"ExpCF3","M42"));			
			segis.add(new ClearingFunctionSegments("FOP",1,1,2,1440,0,"ExpCF3","M43"));			
			segis.add(new ClearingFunctionSegments("FOP",1,1,2,1440,0,"ExpCF3","M44"));
						
			segis.add(new ClearingFunctionSegments("FOP",2,1,1,0,1,"ExpCF3","M11"));		
			segis.add(new ClearingFunctionSegments("FOP",2,1,1,0,1,"ExpCF3","M12"));		
			segis.add(new ClearingFunctionSegments("FOP",2,1,1,0,1,"ExpCF3","M13"));			
			segis.add(new ClearingFunctionSegments("FOP",2,1,1,0,1,"ExpCF3","M14"));			
			segis.add(new ClearingFunctionSegments("FOP",2,1,1,0,1,"ExpCF3","M21"));		
			segis.add(new ClearingFunctionSegments("FOP",2,1,1,0,1,"ExpCF3","M22"));			
			segis.add(new ClearingFunctionSegments("FOP",2,1,1,0,1,"ExpCF3","M23"));			
			segis.add(new ClearingFunctionSegments("FOP",2,1,1,0,1,"ExpCF3","M24"));
			segis.add(new ClearingFunctionSegments("FOP",2,1,1,0,1,"ExpCF3","M31"));			
			segis.add(new ClearingFunctionSegments("FOP",2,1,1,0,1,"ExpCF3","M32"));			
			segis.add(new ClearingFunctionSegments("FOP",2,1,1,0,1,"ExpCF3","M33"));			
			segis.add(new ClearingFunctionSegments("FOP",2,1,1,0,1,"ExpCF3","M34"));
			segis.add(new ClearingFunctionSegments("FOP",2,1,1,0,1,"ExpCF3","M41"));			
			segis.add(new ClearingFunctionSegments("FOP",2,1,1,0,1,"ExpCF3","M42"));			
			segis.add(new ClearingFunctionSegments("FOP",2,1,1,0,1,"ExpCF3","M43"));			
			segis.add(new ClearingFunctionSegments("FOP",2,1,1,0,1,"ExpCF3","M44"));
			
			segis.add(new ClearingFunctionSegments("FOP",2,1,2,1440,0,"ExpCF3","M11"));		
			segis.add(new ClearingFunctionSegments("FOP",2,1,2,1440,0,"ExpCF3","M12"));		
			segis.add(new ClearingFunctionSegments("FOP",2,1,2,1440,0,"ExpCF3","M13"));			
			segis.add(new ClearingFunctionSegments("FOP",2,1,2,1440,0,"ExpCF3","M14"));			
			segis.add(new ClearingFunctionSegments("FOP",2,1,2,1440,0,"ExpCF3","M21"));		
			segis.add(new ClearingFunctionSegments("FOP",2,1,2,1440,0,"ExpCF3","M22"));			
			segis.add(new ClearingFunctionSegments("FOP",2,1,2,1440,0,"ExpCF3","M23"));			
			segis.add(new ClearingFunctionSegments("FOP",2,1,2,1440,0,"ExpCF3","M24"));
			segis.add(new ClearingFunctionSegments("FOP",2,1,2,1440,0,"ExpCF3","M31"));			
			segis.add(new ClearingFunctionSegments("FOP",2,1,2,1440,0,"ExpCF3","M32"));			
			segis.add(new ClearingFunctionSegments("FOP",2,1,2,1440,0,"ExpCF3","M33"));			
			segis.add(new ClearingFunctionSegments("FOP",2,1,2,1440,0,"ExpCF3","M34"));
			segis.add(new ClearingFunctionSegments("FOP",2,1,2,1440,0,"ExpCF3","M41"));			
			segis.add(new ClearingFunctionSegments("FOP",2,1,2,1440,0,"ExpCF3","M42"));			
			segis.add(new ClearingFunctionSegments("FOP",2,1,2,1440,0,"ExpCF3","M43"));			
			segis.add(new ClearingFunctionSegments("FOP",2,1,2,1440,0,"ExpCF3","M44"));
			
			segis.add(new ClearingFunctionSegments("FOP",3,1,1,0,1,"ExpCF3","M11"));		
			segis.add(new ClearingFunctionSegments("FOP",3,1,1,0,1,"ExpCF3","M12"));		
			segis.add(new ClearingFunctionSegments("FOP",3,1,1,0,1,"ExpCF3","M13"));			
			segis.add(new ClearingFunctionSegments("FOP",3,1,1,0,1,"ExpCF3","M14"));			
			segis.add(new ClearingFunctionSegments("FOP",3,1,1,0,1,"ExpCF3","M21"));		
			segis.add(new ClearingFunctionSegments("FOP",3,1,1,0,1,"ExpCF3","M22"));			
			segis.add(new ClearingFunctionSegments("FOP",3,1,1,0,1,"ExpCF3","M23"));			
			segis.add(new ClearingFunctionSegments("FOP",3,1,1,0,1,"ExpCF3","M24"));
			segis.add(new ClearingFunctionSegments("FOP",3,1,1,0,1,"ExpCF3","M31"));			
			segis.add(new ClearingFunctionSegments("FOP",3,1,1,0,1,"ExpCF3","M32"));			
			segis.add(new ClearingFunctionSegments("FOP",3,1,1,0,1,"ExpCF3","M33"));			
			segis.add(new ClearingFunctionSegments("FOP",3,1,1,0,1,"ExpCF3","M34"));
			segis.add(new ClearingFunctionSegments("FOP",3,1,1,0,1,"ExpCF3","M41"));			
			segis.add(new ClearingFunctionSegments("FOP",3,1,1,0,1,"ExpCF3","M42"));			
			segis.add(new ClearingFunctionSegments("FOP",3,1,1,0,1,"ExpCF3","M43"));			
			segis.add(new ClearingFunctionSegments("FOP",3,1,1,0,1,"ExpCF3","M44"));
			
			segis.add(new ClearingFunctionSegments("FOP",3,1,2,1440,0,"ExpCF3","M11"));		
			segis.add(new ClearingFunctionSegments("FOP",3,1,2,1440,0,"ExpCF3","M12"));		
			segis.add(new ClearingFunctionSegments("FOP",3,1,2,1440,0,"ExpCF3","M13"));			
			segis.add(new ClearingFunctionSegments("FOP",3,1,2,1440,0,"ExpCF3","M14"));			
			segis.add(new ClearingFunctionSegments("FOP",3,1,2,1440,0,"ExpCF3","M21"));		
			segis.add(new ClearingFunctionSegments("FOP",3,1,2,1440,0,"ExpCF3","M22"));			
			segis.add(new ClearingFunctionSegments("FOP",3,1,2,1440,0,"ExpCF3","M23"));			
			segis.add(new ClearingFunctionSegments("FOP",3,1,2,1440,0,"ExpCF3","M24"));
			segis.add(new ClearingFunctionSegments("FOP",3,1,2,1440,0,"ExpCF3","M31"));			
			segis.add(new ClearingFunctionSegments("FOP",3,1,2,1440,0,"ExpCF3","M32"));			
			segis.add(new ClearingFunctionSegments("FOP",3,1,2,1440,0,"ExpCF3","M33"));			
			segis.add(new ClearingFunctionSegments("FOP",3,1,2,1440,0,"ExpCF3","M34"));
			segis.add(new ClearingFunctionSegments("FOP",3,1,2,1440,0,"ExpCF3","M41"));			
			segis.add(new ClearingFunctionSegments("FOP",3,1,2,1440,0,"ExpCF3","M42"));			
			segis.add(new ClearingFunctionSegments("FOP",3,1,2,1440,0,"ExpCF3","M43"));			
			segis.add(new ClearingFunctionSegments("FOP",3,1,2,1440,0,"ExpCF3","M44"));
			
			
			segis.add(new ClearingFunctionSegments("FOP",4,1,1,0,1,"ExpCF3","M11"));		
			segis.add(new ClearingFunctionSegments("FOP",4,1,1,0,1,"ExpCF3","M12"));		
			segis.add(new ClearingFunctionSegments("FOP",4,1,1,0,1,"ExpCF3","M13"));			
			segis.add(new ClearingFunctionSegments("FOP",4,1,1,0,1,"ExpCF3","M14"));			
			segis.add(new ClearingFunctionSegments("FOP",4,1,1,0,1,"ExpCF3","M21"));		
			segis.add(new ClearingFunctionSegments("FOP",4,1,1,0,1,"ExpCF3","M22"));			
			segis.add(new ClearingFunctionSegments("FOP",4,1,1,0,1,"ExpCF3","M23"));			
			segis.add(new ClearingFunctionSegments("FOP",4,1,1,0,1,"ExpCF3","M24"));
			segis.add(new ClearingFunctionSegments("FOP",4,1,1,0,1,"ExpCF3","M31"));			
			segis.add(new ClearingFunctionSegments("FOP",4,1,1,0,1,"ExpCF3","M32"));			
			segis.add(new ClearingFunctionSegments("FOP",4,1,1,0,1,"ExpCF3","M33"));			
			segis.add(new ClearingFunctionSegments("FOP",4,1,1,0,1,"ExpCF3","M34"));
			segis.add(new ClearingFunctionSegments("FOP",4,1,1,0,1,"ExpCF3","M41"));			
			segis.add(new ClearingFunctionSegments("FOP",4,1,1,0,1,"ExpCF3","M42"));			
			segis.add(new ClearingFunctionSegments("FOP",4,1,1,0,1,"ExpCF3","M43"));			
			segis.add(new ClearingFunctionSegments("FOP",4,1,1,0,1,"ExpCF3","M44"));
			
			segis.add(new ClearingFunctionSegments("FOP",4,1,2,1440,0,"ExpCF3","M11"));		
			segis.add(new ClearingFunctionSegments("FOP",4,1,2,1440,0,"ExpCF3","M12"));		
			segis.add(new ClearingFunctionSegments("FOP",4,1,2,1440,0,"ExpCF3","M13"));			
			segis.add(new ClearingFunctionSegments("FOP",4,1,2,1440,0,"ExpCF3","M14"));			
			segis.add(new ClearingFunctionSegments("FOP",4,1,2,1440,0,"ExpCF3","M21"));		
			segis.add(new ClearingFunctionSegments("FOP",4,1,2,1440,0,"ExpCF3","M22"));			
			segis.add(new ClearingFunctionSegments("FOP",4,1,2,1440,0,"ExpCF3","M23"));			
			segis.add(new ClearingFunctionSegments("FOP",4,1,2,1440,0,"ExpCF3","M24"));
			segis.add(new ClearingFunctionSegments("FOP",4,1,2,1440,0,"ExpCF3","M31"));			
			segis.add(new ClearingFunctionSegments("FOP",4,1,2,1440,0,"ExpCF3","M32"));			
			segis.add(new ClearingFunctionSegments("FOP",4,1,2,1440,0,"ExpCF3","M33"));			
			segis.add(new ClearingFunctionSegments("FOP",4,1,2,1440,0,"ExpCF3","M34"));
			segis.add(new ClearingFunctionSegments("FOP",4,1,2,1440,0,"ExpCF3","M41"));			
			segis.add(new ClearingFunctionSegments("FOP",4,1,2,1440,0,"ExpCF3","M42"));			
			segis.add(new ClearingFunctionSegments("FOP",4,1,2,1440,0,"ExpCF3","M43"));			
			segis.add(new ClearingFunctionSegments("FOP",4,1,2,1440,0,"ExpCF3","M44"));
			
			segis.add(new ClearingFunctionSegments("FOP",5,1,1,0,1,"ExpCF3","M11"));		
			segis.add(new ClearingFunctionSegments("FOP",5,1,1,0,1,"ExpCF3","M12"));		
			segis.add(new ClearingFunctionSegments("FOP",5,1,1,0,1,"ExpCF3","M13"));			
			segis.add(new ClearingFunctionSegments("FOP",5,1,1,0,1,"ExpCF3","M14"));			
			segis.add(new ClearingFunctionSegments("FOP",5,1,1,0,1,"ExpCF3","M21"));		
			segis.add(new ClearingFunctionSegments("FOP",5,1,1,0,1,"ExpCF3","M22"));			
			segis.add(new ClearingFunctionSegments("FOP",5,1,1,0,1,"ExpCF3","M23"));			
			segis.add(new ClearingFunctionSegments("FOP",5,1,1,0,1,"ExpCF3","M24"));
			segis.add(new ClearingFunctionSegments("FOP",5,1,1,0,1,"ExpCF3","M31"));			
			segis.add(new ClearingFunctionSegments("FOP",5,1,1,0,1,"ExpCF3","M32"));			
			segis.add(new ClearingFunctionSegments("FOP",5,1,1,0,1,"ExpCF3","M33"));			
			segis.add(new ClearingFunctionSegments("FOP",5,1,1,0,1,"ExpCF3","M34"));
			segis.add(new ClearingFunctionSegments("FOP",5,1,1,0,1,"ExpCF3","M41"));			
			segis.add(new ClearingFunctionSegments("FOP",5,1,1,0,1,"ExpCF3","M42"));			
			segis.add(new ClearingFunctionSegments("FOP",5,1,1,0,1,"ExpCF3","M43"));			
			segis.add(new ClearingFunctionSegments("FOP",5,1,1,0,1,"ExpCF3","M44"));
			
			segis.add(new ClearingFunctionSegments("FOP",5,1,2,1440,0,"ExpCF3","M11"));		
			segis.add(new ClearingFunctionSegments("FOP",5,1,2,1440,0,"ExpCF3","M12"));		
			segis.add(new ClearingFunctionSegments("FOP",5,1,2,1440,0,"ExpCF3","M13"));			
			segis.add(new ClearingFunctionSegments("FOP",5,1,2,1440,0,"ExpCF3","M14"));			
			segis.add(new ClearingFunctionSegments("FOP",5,1,2,1440,0,"ExpCF3","M21"));		
			segis.add(new ClearingFunctionSegments("FOP",5,1,2,1440,0,"ExpCF3","M22"));			
			segis.add(new ClearingFunctionSegments("FOP",5,1,2,1440,0,"ExpCF3","M23"));			
			segis.add(new ClearingFunctionSegments("FOP",5,1,2,1440,0,"ExpCF3","M24"));
			segis.add(new ClearingFunctionSegments("FOP",5,1,2,1440,0,"ExpCF3","M31"));			
			segis.add(new ClearingFunctionSegments("FOP",5,1,2,1440,0,"ExpCF3","M32"));			
			segis.add(new ClearingFunctionSegments("FOP",5,1,2,1440,0,"ExpCF3","M33"));			
			segis.add(new ClearingFunctionSegments("FOP",5,1,2,1440,0,"ExpCF3","M34"));
			segis.add(new ClearingFunctionSegments("FOP",5,1,2,1440,0,"ExpCF3","M41"));			
			segis.add(new ClearingFunctionSegments("FOP",5,1,2,1440,0,"ExpCF3","M42"));			
			segis.add(new ClearingFunctionSegments("FOP",5,1,2,1440,0,"ExpCF3","M43"));			
			segis.add(new ClearingFunctionSegments("FOP",5,1,2,1440,0,"ExpCF3","M44"));
		//ACF with additional Segment
		}else if(UseCFLineType == 6) {			
			
			segis.add(new ClearingFunctionSegments("FOP",1,1,1,0,1,"ExpCF3","M11"));		
			segis.add(new ClearingFunctionSegments("FOP",1,1,1,0,1,"ExpCF3","M12"));		
			segis.add(new ClearingFunctionSegments("FOP",1,1,1,0,1,"ExpCF3","M13"));			
			segis.add(new ClearingFunctionSegments("FOP",1,1,1,0,1,"ExpCF3","M14"));			
			segis.add(new ClearingFunctionSegments("FOP",1,1,1,0,1,"ExpCF3","M21"));		
			segis.add(new ClearingFunctionSegments("FOP",1,1,1,0,1,"ExpCF3","M22"));			
			segis.add(new ClearingFunctionSegments("FOP",1,1,1,0,1,"ExpCF3","M23"));			
			segis.add(new ClearingFunctionSegments("FOP",1,1,1,0,1,"ExpCF3","M24"));
			segis.add(new ClearingFunctionSegments("FOP",1,1,1,0,1,"ExpCF3","M31"));			
			segis.add(new ClearingFunctionSegments("FOP",1,1,1,0,1,"ExpCF3","M32"));			
			segis.add(new ClearingFunctionSegments("FOP",1,1,1,0,1,"ExpCF3","M33"));			
			segis.add(new ClearingFunctionSegments("FOP",1,1,1,0,1,"ExpCF3","M34"));
			segis.add(new ClearingFunctionSegments("FOP",1,1,1,0,1,"ExpCF3","M41"));			
			segis.add(new ClearingFunctionSegments("FOP",1,1,1,0,1,"ExpCF3","M42"));			
			segis.add(new ClearingFunctionSegments("FOP",1,1,1,0,1,"ExpCF3","M43"));			
			segis.add(new ClearingFunctionSegments("FOP",1,1,1,0,1,"ExpCF3","M44"));	
			
			segis.add(new ClearingFunctionSegments("FOP",1,1,2,1224,0.5,"ExpCF3","M11"));		
			segis.add(new ClearingFunctionSegments("FOP",1,1,2,1224,0.5,"ExpCF3","M12"));		
			segis.add(new ClearingFunctionSegments("FOP",1,1,2,1224,0.5,"ExpCF3","M13"));			
			segis.add(new ClearingFunctionSegments("FOP",1,1,2,1224,0.5,"ExpCF3","M14"));			
			segis.add(new ClearingFunctionSegments("FOP",1,1,2,1224,0.5,"ExpCF3","M21"));		
			segis.add(new ClearingFunctionSegments("FOP",1,1,2,1224,0.5,"ExpCF3","M22"));			
			segis.add(new ClearingFunctionSegments("FOP",1,1,2,1224,0.5,"ExpCF3","M23"));			
			segis.add(new ClearingFunctionSegments("FOP",1,1,2,1224,0.5,"ExpCF3","M24"));
			segis.add(new ClearingFunctionSegments("FOP",1,1,2,1224,0.5,"ExpCF3","M31"));			
			segis.add(new ClearingFunctionSegments("FOP",1,1,2,1224,0.5,"ExpCF3","M32"));			
			segis.add(new ClearingFunctionSegments("FOP",1,1,2,1224,0.5,"ExpCF3","M33"));			
			segis.add(new ClearingFunctionSegments("FOP",1,1,2,1224,0.5,"ExpCF3","M34"));
			segis.add(new ClearingFunctionSegments("FOP",1,1,2,1224,0.5,"ExpCF3","M41"));			
			segis.add(new ClearingFunctionSegments("FOP",1,1,2,1224,0.5,"ExpCF3","M42"));			
			segis.add(new ClearingFunctionSegments("FOP",1,1,2,1224,0.5,"ExpCF3","M43"));			
			segis.add(new ClearingFunctionSegments("FOP",1,1,2,1224,0.5,"ExpCF3","M44"));
			
			segis.add(new ClearingFunctionSegments("FOP",1,1,3,1440,0,"ExpCF3","M11"));		
			segis.add(new ClearingFunctionSegments("FOP",1,1,3,1440,0,"ExpCF3","M12"));		
			segis.add(new ClearingFunctionSegments("FOP",1,1,3,1440,0,"ExpCF3","M13"));			
			segis.add(new ClearingFunctionSegments("FOP",1,1,3,1440,0,"ExpCF3","M14"));			
			segis.add(new ClearingFunctionSegments("FOP",1,1,3,1440,0,"ExpCF3","M21"));		
			segis.add(new ClearingFunctionSegments("FOP",1,1,3,1440,0,"ExpCF3","M22"));			
			segis.add(new ClearingFunctionSegments("FOP",1,1,3,1440,0,"ExpCF3","M23"));			
			segis.add(new ClearingFunctionSegments("FOP",1,1,3,1440,0,"ExpCF3","M24"));
			segis.add(new ClearingFunctionSegments("FOP",1,1,3,1440,0,"ExpCF3","M31"));			
			segis.add(new ClearingFunctionSegments("FOP",1,1,3,1440,0,"ExpCF3","M32"));			
			segis.add(new ClearingFunctionSegments("FOP",1,1,3,1440,0,"ExpCF3","M33"));			
			segis.add(new ClearingFunctionSegments("FOP",1,1,3,1440,0,"ExpCF3","M34"));
			segis.add(new ClearingFunctionSegments("FOP",1,1,3,1440,0,"ExpCF3","M41"));			
			segis.add(new ClearingFunctionSegments("FOP",1,1,3,1440,0,"ExpCF3","M42"));			
			segis.add(new ClearingFunctionSegments("FOP",1,1,3,1440,0,"ExpCF3","M43"));			
			segis.add(new ClearingFunctionSegments("FOP",1,1,3,1440,0,"ExpCF3","M44"));
			
			segis.add(new ClearingFunctionSegments("FOP",2,1,1,0,1,"ExpCF3","M11"));		
			segis.add(new ClearingFunctionSegments("FOP",2,1,1,0,1,"ExpCF3","M12"));		
			segis.add(new ClearingFunctionSegments("FOP",2,1,1,0,1,"ExpCF3","M13"));			
			segis.add(new ClearingFunctionSegments("FOP",2,1,1,0,1,"ExpCF3","M14"));			
			segis.add(new ClearingFunctionSegments("FOP",2,1,1,0,1,"ExpCF3","M21"));		
			segis.add(new ClearingFunctionSegments("FOP",2,1,1,0,1,"ExpCF3","M22"));			
			segis.add(new ClearingFunctionSegments("FOP",2,1,1,0,1,"ExpCF3","M23"));			
			segis.add(new ClearingFunctionSegments("FOP",2,1,1,0,1,"ExpCF3","M24"));
			segis.add(new ClearingFunctionSegments("FOP",2,1,1,0,1,"ExpCF3","M31"));			
			segis.add(new ClearingFunctionSegments("FOP",2,1,1,0,1,"ExpCF3","M32"));			
			segis.add(new ClearingFunctionSegments("FOP",2,1,1,0,1,"ExpCF3","M33"));			
			segis.add(new ClearingFunctionSegments("FOP",2,1,1,0,1,"ExpCF3","M34"));
			segis.add(new ClearingFunctionSegments("FOP",2,1,1,0,1,"ExpCF3","M41"));			
			segis.add(new ClearingFunctionSegments("FOP",2,1,1,0,1,"ExpCF3","M42"));			
			segis.add(new ClearingFunctionSegments("FOP",2,1,1,0,1,"ExpCF3","M43"));			
			segis.add(new ClearingFunctionSegments("FOP",2,1,1,0,1,"ExpCF3","M44"));	
			
			segis.add(new ClearingFunctionSegments("FOP",2,1,2,1224,0.5,"ExpCF3","M11"));		
			segis.add(new ClearingFunctionSegments("FOP",2,1,2,1224,0.5,"ExpCF3","M12"));		
			segis.add(new ClearingFunctionSegments("FOP",2,1,2,1224,0.5,"ExpCF3","M13"));			
			segis.add(new ClearingFunctionSegments("FOP",2,1,2,1224,0.5,"ExpCF3","M14"));			
			segis.add(new ClearingFunctionSegments("FOP",2,1,2,1224,0.5,"ExpCF3","M21"));		
			segis.add(new ClearingFunctionSegments("FOP",2,1,2,1224,0.5,"ExpCF3","M22"));			
			segis.add(new ClearingFunctionSegments("FOP",2,1,2,1224,0.5,"ExpCF3","M23"));			
			segis.add(new ClearingFunctionSegments("FOP",2,1,2,1224,0.5,"ExpCF3","M24"));
			segis.add(new ClearingFunctionSegments("FOP",2,1,2,1224,0.5,"ExpCF3","M31"));			
			segis.add(new ClearingFunctionSegments("FOP",2,1,2,1224,0.5,"ExpCF3","M32"));			
			segis.add(new ClearingFunctionSegments("FOP",2,1,2,1224,0.5,"ExpCF3","M33"));			
			segis.add(new ClearingFunctionSegments("FOP",2,1,2,1224,0.5,"ExpCF3","M34"));
			segis.add(new ClearingFunctionSegments("FOP",2,1,2,1224,0.5,"ExpCF3","M41"));			
			segis.add(new ClearingFunctionSegments("FOP",2,1,2,1224,0.5,"ExpCF3","M42"));			
			segis.add(new ClearingFunctionSegments("FOP",2,1,2,1224,0.5,"ExpCF3","M43"));			
			segis.add(new ClearingFunctionSegments("FOP",2,1,2,1224,0.5,"ExpCF3","M44"));
			
			segis.add(new ClearingFunctionSegments("FOP",2,1,3,1440,0,"ExpCF3","M11"));		
			segis.add(new ClearingFunctionSegments("FOP",2,1,3,1440,0,"ExpCF3","M12"));		
			segis.add(new ClearingFunctionSegments("FOP",2,1,3,1440,0,"ExpCF3","M13"));			
			segis.add(new ClearingFunctionSegments("FOP",2,1,3,1440,0,"ExpCF3","M14"));			
			segis.add(new ClearingFunctionSegments("FOP",2,1,3,1440,0,"ExpCF3","M21"));		
			segis.add(new ClearingFunctionSegments("FOP",2,1,3,1440,0,"ExpCF3","M22"));			
			segis.add(new ClearingFunctionSegments("FOP",2,1,3,1440,0,"ExpCF3","M23"));			
			segis.add(new ClearingFunctionSegments("FOP",2,1,3,1440,0,"ExpCF3","M24"));
			segis.add(new ClearingFunctionSegments("FOP",2,1,3,1440,0,"ExpCF3","M31"));			
			segis.add(new ClearingFunctionSegments("FOP",2,1,3,1440,0,"ExpCF3","M32"));			
			segis.add(new ClearingFunctionSegments("FOP",2,1,3,1440,0,"ExpCF3","M33"));			
			segis.add(new ClearingFunctionSegments("FOP",2,1,3,1440,0,"ExpCF3","M34"));
			segis.add(new ClearingFunctionSegments("FOP",2,1,3,1440,0,"ExpCF3","M41"));			
			segis.add(new ClearingFunctionSegments("FOP",2,1,3,1440,0,"ExpCF3","M42"));			
			segis.add(new ClearingFunctionSegments("FOP",2,1,3,1440,0,"ExpCF3","M43"));			
			segis.add(new ClearingFunctionSegments("FOP",2,1,3,1440,0,"ExpCF3","M44"));
			
			segis.add(new ClearingFunctionSegments("FOP",3,1,1,0,1,"ExpCF3","M11"));		
			segis.add(new ClearingFunctionSegments("FOP",3,1,1,0,1,"ExpCF3","M12"));		
			segis.add(new ClearingFunctionSegments("FOP",3,1,1,0,1,"ExpCF3","M13"));			
			segis.add(new ClearingFunctionSegments("FOP",3,1,1,0,1,"ExpCF3","M14"));			
			segis.add(new ClearingFunctionSegments("FOP",3,1,1,0,1,"ExpCF3","M21"));		
			segis.add(new ClearingFunctionSegments("FOP",3,1,1,0,1,"ExpCF3","M22"));			
			segis.add(new ClearingFunctionSegments("FOP",3,1,1,0,1,"ExpCF3","M23"));			
			segis.add(new ClearingFunctionSegments("FOP",3,1,1,0,1,"ExpCF3","M24"));
			segis.add(new ClearingFunctionSegments("FOP",3,1,1,0,1,"ExpCF3","M31"));			
			segis.add(new ClearingFunctionSegments("FOP",3,1,1,0,1,"ExpCF3","M32"));			
			segis.add(new ClearingFunctionSegments("FOP",3,1,1,0,1,"ExpCF3","M33"));			
			segis.add(new ClearingFunctionSegments("FOP",3,1,1,0,1,"ExpCF3","M34"));
			segis.add(new ClearingFunctionSegments("FOP",3,1,1,0,1,"ExpCF3","M41"));			
			segis.add(new ClearingFunctionSegments("FOP",3,1,1,0,1,"ExpCF3","M42"));			
			segis.add(new ClearingFunctionSegments("FOP",3,1,1,0,1,"ExpCF3","M43"));			
			segis.add(new ClearingFunctionSegments("FOP",3,1,1,0,1,"ExpCF3","M44"));	
			
			segis.add(new ClearingFunctionSegments("FOP",3,1,2,1224,0.5,"ExpCF3","M11"));		
			segis.add(new ClearingFunctionSegments("FOP",3,1,2,1224,0.5,"ExpCF3","M12"));		
			segis.add(new ClearingFunctionSegments("FOP",3,1,2,1224,0.5,"ExpCF3","M13"));			
			segis.add(new ClearingFunctionSegments("FOP",3,1,2,1224,0.5,"ExpCF3","M14"));			
			segis.add(new ClearingFunctionSegments("FOP",3,1,2,1224,0.5,"ExpCF3","M21"));		
			segis.add(new ClearingFunctionSegments("FOP",3,1,2,1224,0.5,"ExpCF3","M22"));			
			segis.add(new ClearingFunctionSegments("FOP",3,1,2,1224,0.5,"ExpCF3","M23"));			
			segis.add(new ClearingFunctionSegments("FOP",3,1,2,1224,0.5,"ExpCF3","M24"));
			segis.add(new ClearingFunctionSegments("FOP",3,1,2,1224,0.5,"ExpCF3","M31"));			
			segis.add(new ClearingFunctionSegments("FOP",3,1,2,1224,0.5,"ExpCF3","M32"));			
			segis.add(new ClearingFunctionSegments("FOP",3,1,2,1224,0.5,"ExpCF3","M33"));			
			segis.add(new ClearingFunctionSegments("FOP",3,1,2,1224,0.5,"ExpCF3","M34"));
			segis.add(new ClearingFunctionSegments("FOP",3,1,2,1224,0.5,"ExpCF3","M41"));			
			segis.add(new ClearingFunctionSegments("FOP",3,1,2,1224,0.5,"ExpCF3","M42"));			
			segis.add(new ClearingFunctionSegments("FOP",3,1,2,1224,0.5,"ExpCF3","M43"));			
			segis.add(new ClearingFunctionSegments("FOP",3,1,2,1224,0.5,"ExpCF3","M44"));
			
			segis.add(new ClearingFunctionSegments("FOP",3,1,3,1440,0,"ExpCF3","M11"));		
			segis.add(new ClearingFunctionSegments("FOP",3,1,3,1440,0,"ExpCF3","M12"));		
			segis.add(new ClearingFunctionSegments("FOP",3,1,3,1440,0,"ExpCF3","M13"));			
			segis.add(new ClearingFunctionSegments("FOP",3,1,3,1440,0,"ExpCF3","M14"));			
			segis.add(new ClearingFunctionSegments("FOP",3,1,3,1440,0,"ExpCF3","M21"));		
			segis.add(new ClearingFunctionSegments("FOP",3,1,3,1440,0,"ExpCF3","M22"));			
			segis.add(new ClearingFunctionSegments("FOP",3,1,3,1440,0,"ExpCF3","M23"));			
			segis.add(new ClearingFunctionSegments("FOP",3,1,3,1440,0,"ExpCF3","M24"));
			segis.add(new ClearingFunctionSegments("FOP",3,1,3,1440,0,"ExpCF3","M31"));			
			segis.add(new ClearingFunctionSegments("FOP",3,1,3,1440,0,"ExpCF3","M32"));			
			segis.add(new ClearingFunctionSegments("FOP",3,1,3,1440,0,"ExpCF3","M33"));			
			segis.add(new ClearingFunctionSegments("FOP",3,1,3,1440,0,"ExpCF3","M34"));
			segis.add(new ClearingFunctionSegments("FOP",3,1,3,1440,0,"ExpCF3","M41"));			
			segis.add(new ClearingFunctionSegments("FOP",3,1,3,1440,0,"ExpCF3","M42"));			
			segis.add(new ClearingFunctionSegments("FOP",3,1,3,1440,0,"ExpCF3","M43"));			
			segis.add(new ClearingFunctionSegments("FOP",3,1,3,1440,0,"ExpCF3","M44"));
		}else if(UseCFLineType == 7) {	//80%
			
			//fop 1
			segis.add(new ClearingFunctionSegments("FOP",1,1,1,0,1,"ExpCF3","M11"));		
			segis.add(new ClearingFunctionSegments("FOP",1,1,1,0,1,"ExpCF3","M12"));		
			segis.add(new ClearingFunctionSegments("FOP",1,1,1,0,1,"ExpCF3","M13"));			
			segis.add(new ClearingFunctionSegments("FOP",1,1,1,0,1,"ExpCF3","M14"));			
			segis.add(new ClearingFunctionSegments("FOP",1,1,1,0,1,"ExpCF3","M21"));		
			segis.add(new ClearingFunctionSegments("FOP",1,1,1,0,1,"ExpCF3","M22"));			
			segis.add(new ClearingFunctionSegments("FOP",1,1,1,0,1,"ExpCF3","M23"));			
			segis.add(new ClearingFunctionSegments("FOP",1,1,1,0,1,"ExpCF3","M24"));
			segis.add(new ClearingFunctionSegments("FOP",1,1,1,0,1,"ExpCF3","M31"));			
			segis.add(new ClearingFunctionSegments("FOP",1,1,1,0,1,"ExpCF3","M32"));			
			segis.add(new ClearingFunctionSegments("FOP",1,1,1,0,1,"ExpCF3","M33"));			
			segis.add(new ClearingFunctionSegments("FOP",1,1,1,0,1,"ExpCF3","M34"));
			segis.add(new ClearingFunctionSegments("FOP",1,1,1,0,1,"ExpCF3","M41"));			
			segis.add(new ClearingFunctionSegments("FOP",1,1,1,0,1,"ExpCF3","M42"));			
			segis.add(new ClearingFunctionSegments("FOP",1,1,1,0,1,"ExpCF3","M43"));			
			segis.add(new ClearingFunctionSegments("FOP",1,1,1,0,1,"ExpCF3","M44"));	
			
			segis.add(new ClearingFunctionSegments("FOP",1,1,2,1152,0.276,"ExpCF3","M11"));		
			segis.add(new ClearingFunctionSegments("FOP",1,1,2,1152,0.276,"ExpCF3","M12"));		
			segis.add(new ClearingFunctionSegments("FOP",1,1,2,1152,0.276,"ExpCF3","M13"));			
			segis.add(new ClearingFunctionSegments("FOP",1,1,2,1152,0.276,"ExpCF3","M14"));			
			segis.add(new ClearingFunctionSegments("FOP",1,1,2,1152,0.276,"ExpCF3","M21"));		
			segis.add(new ClearingFunctionSegments("FOP",1,1,2,1152,0.276,"ExpCF3","M22"));			
			segis.add(new ClearingFunctionSegments("FOP",1,1,2,1152,0.276,"ExpCF3","M23"));			
			segis.add(new ClearingFunctionSegments("FOP",1,1,2,1152,0.276,"ExpCF3","M24"));
			segis.add(new ClearingFunctionSegments("FOP",1,1,2,1152,0.276,"ExpCF3","M31"));			
			segis.add(new ClearingFunctionSegments("FOP",1,1,2,1152,0.276,"ExpCF3","M32"));			
			segis.add(new ClearingFunctionSegments("FOP",1,1,2,1152,0.276,"ExpCF3","M33"));			
			segis.add(new ClearingFunctionSegments("FOP",1,1,2,1152,0.276,"ExpCF3","M34"));
			segis.add(new ClearingFunctionSegments("FOP",1,1,2,1152,0.276,"ExpCF3","M41"));			
			segis.add(new ClearingFunctionSegments("FOP",1,1,2,1152,0.276,"ExpCF3","M42"));			
			segis.add(new ClearingFunctionSegments("FOP",1,1,2,1152,0.276,"ExpCF3","M43"));			
			segis.add(new ClearingFunctionSegments("FOP",1,1,2,1152,0.276,"ExpCF3","M44"));
			
			segis.add(new ClearingFunctionSegments("FOP",1,1,3,1440,0,"ExpCF3","M11"));		
			segis.add(new ClearingFunctionSegments("FOP",1,1,3,1440,0,"ExpCF3","M12"));		
			segis.add(new ClearingFunctionSegments("FOP",1,1,3,1440,0,"ExpCF3","M13"));			
			segis.add(new ClearingFunctionSegments("FOP",1,1,3,1440,0,"ExpCF3","M14"));			
			segis.add(new ClearingFunctionSegments("FOP",1,1,3,1440,0,"ExpCF3","M21"));		
			segis.add(new ClearingFunctionSegments("FOP",1,1,3,1440,0,"ExpCF3","M22"));			
			segis.add(new ClearingFunctionSegments("FOP",1,1,3,1440,0,"ExpCF3","M23"));			
			segis.add(new ClearingFunctionSegments("FOP",1,1,3,1440,0,"ExpCF3","M24"));
			segis.add(new ClearingFunctionSegments("FOP",1,1,3,1440,0,"ExpCF3","M31"));			
			segis.add(new ClearingFunctionSegments("FOP",1,1,3,1440,0,"ExpCF3","M32"));			
			segis.add(new ClearingFunctionSegments("FOP",1,1,3,1440,0,"ExpCF3","M33"));			
			segis.add(new ClearingFunctionSegments("FOP",1,1,3,1440,0,"ExpCF3","M34"));
			segis.add(new ClearingFunctionSegments("FOP",1,1,3,1440,0,"ExpCF3","M41"));			
			segis.add(new ClearingFunctionSegments("FOP",1,1,3,1440,0,"ExpCF3","M42"));			
			segis.add(new ClearingFunctionSegments("FOP",1,1,3,1440,0,"ExpCF3","M43"));			
			segis.add(new ClearingFunctionSegments("FOP",1,1,3,1440,0,"ExpCF3","M44"));				
		
			//fop 2
			segis.add(new ClearingFunctionSegments("FOP",2,1,1,0,1,"ExpCF3","M11"));		
			segis.add(new ClearingFunctionSegments("FOP",2,1,1,0,1,"ExpCF3","M12"));		
			segis.add(new ClearingFunctionSegments("FOP",2,1,1,0,1,"ExpCF3","M13"));			
			segis.add(new ClearingFunctionSegments("FOP",2,1,1,0,1,"ExpCF3","M14"));			
			segis.add(new ClearingFunctionSegments("FOP",2,1,1,0,1,"ExpCF3","M21"));		
			segis.add(new ClearingFunctionSegments("FOP",2,1,1,0,1,"ExpCF3","M22"));			
			segis.add(new ClearingFunctionSegments("FOP",2,1,1,0,1,"ExpCF3","M23"));			
			segis.add(new ClearingFunctionSegments("FOP",2,1,1,0,1,"ExpCF3","M24"));
			segis.add(new ClearingFunctionSegments("FOP",2,1,1,0,1,"ExpCF3","M31"));			
			segis.add(new ClearingFunctionSegments("FOP",2,1,1,0,1,"ExpCF3","M32"));			
			segis.add(new ClearingFunctionSegments("FOP",2,1,1,0,1,"ExpCF3","M33"));			
			segis.add(new ClearingFunctionSegments("FOP",2,1,1,0,1,"ExpCF3","M34"));
			segis.add(new ClearingFunctionSegments("FOP",2,1,1,0,1,"ExpCF3","M41"));			
			segis.add(new ClearingFunctionSegments("FOP",2,1,1,0,1,"ExpCF3","M42"));			
			segis.add(new ClearingFunctionSegments("FOP",2,1,1,0,1,"ExpCF3","M43"));			
			segis.add(new ClearingFunctionSegments("FOP",2,1,1,0,1,"ExpCF3","M44"));	
			
			segis.add(new ClearingFunctionSegments("FOP",2,1,2,1152,0.276,"ExpCF3","M11"));		
			segis.add(new ClearingFunctionSegments("FOP",2,1,2,1152,0.276,"ExpCF3","M12"));		
			segis.add(new ClearingFunctionSegments("FOP",2,1,2,1152,0.276,"ExpCF3","M13"));			
			segis.add(new ClearingFunctionSegments("FOP",2,1,2,1152,0.276,"ExpCF3","M14"));			
			segis.add(new ClearingFunctionSegments("FOP",2,1,2,1152,0.276,"ExpCF3","M21"));		
			segis.add(new ClearingFunctionSegments("FOP",2,1,2,1152,0.276,"ExpCF3","M22"));			
			segis.add(new ClearingFunctionSegments("FOP",2,1,2,1152,0.276,"ExpCF3","M23"));			
			segis.add(new ClearingFunctionSegments("FOP",2,1,2,1152,0.276,"ExpCF3","M24"));
			segis.add(new ClearingFunctionSegments("FOP",2,1,2,1152,0.276,"ExpCF3","M31"));			
			segis.add(new ClearingFunctionSegments("FOP",2,1,2,1152,0.276,"ExpCF3","M32"));			
			segis.add(new ClearingFunctionSegments("FOP",2,1,2,1152,0.276,"ExpCF3","M33"));			
			segis.add(new ClearingFunctionSegments("FOP",2,1,2,1152,0.276,"ExpCF3","M34"));
			segis.add(new ClearingFunctionSegments("FOP",2,1,2,1152,0.276,"ExpCF3","M41"));			
			segis.add(new ClearingFunctionSegments("FOP",2,1,2,1152,0.276,"ExpCF3","M42"));			
			segis.add(new ClearingFunctionSegments("FOP",2,1,2,1152,0.276,"ExpCF3","M43"));			
			segis.add(new ClearingFunctionSegments("FOP",2,1,2,1152,0.276,"ExpCF3","M44"));
			
			segis.add(new ClearingFunctionSegments("FOP",2,1,3,1440,0,"ExpCF3","M11"));		
			segis.add(new ClearingFunctionSegments("FOP",2,1,3,1440,0,"ExpCF3","M12"));		
			segis.add(new ClearingFunctionSegments("FOP",2,1,3,1440,0,"ExpCF3","M13"));			
			segis.add(new ClearingFunctionSegments("FOP",2,1,3,1440,0,"ExpCF3","M14"));			
			segis.add(new ClearingFunctionSegments("FOP",2,1,3,1440,0,"ExpCF3","M21"));		
			segis.add(new ClearingFunctionSegments("FOP",2,1,3,1440,0,"ExpCF3","M22"));			
			segis.add(new ClearingFunctionSegments("FOP",2,1,3,1440,0,"ExpCF3","M23"));			
			segis.add(new ClearingFunctionSegments("FOP",2,1,3,1440,0,"ExpCF3","M24"));
			segis.add(new ClearingFunctionSegments("FOP",2,1,3,1440,0,"ExpCF3","M31"));			
			segis.add(new ClearingFunctionSegments("FOP",2,1,3,1440,0,"ExpCF3","M32"));			
			segis.add(new ClearingFunctionSegments("FOP",2,1,3,1440,0,"ExpCF3","M33"));			
			segis.add(new ClearingFunctionSegments("FOP",2,1,3,1440,0,"ExpCF3","M34"));
			segis.add(new ClearingFunctionSegments("FOP",2,1,3,1440,0,"ExpCF3","M41"));			
			segis.add(new ClearingFunctionSegments("FOP",2,1,3,1440,0,"ExpCF3","M42"));			
			segis.add(new ClearingFunctionSegments("FOP",2,1,3,1440,0,"ExpCF3","M43"));			
			segis.add(new ClearingFunctionSegments("FOP",2,1,3,1440,0,"ExpCF3","M44"));		
			
			//fop 3
			segis.add(new ClearingFunctionSegments("FOP",3,1,1,0,1,"ExpCF3","M11"));		
			segis.add(new ClearingFunctionSegments("FOP",3,1,1,0,1,"ExpCF3","M12"));		
			segis.add(new ClearingFunctionSegments("FOP",3,1,1,0,1,"ExpCF3","M13"));			
			segis.add(new ClearingFunctionSegments("FOP",3,1,1,0,1,"ExpCF3","M14"));			
			segis.add(new ClearingFunctionSegments("FOP",3,1,1,0,1,"ExpCF3","M21"));		
			segis.add(new ClearingFunctionSegments("FOP",3,1,1,0,1,"ExpCF3","M22"));			
			segis.add(new ClearingFunctionSegments("FOP",3,1,1,0,1,"ExpCF3","M23"));			
			segis.add(new ClearingFunctionSegments("FOP",3,1,1,0,1,"ExpCF3","M24"));
			segis.add(new ClearingFunctionSegments("FOP",3,1,1,0,1,"ExpCF3","M31"));			
			segis.add(new ClearingFunctionSegments("FOP",3,1,1,0,1,"ExpCF3","M32"));			
			segis.add(new ClearingFunctionSegments("FOP",3,1,1,0,1,"ExpCF3","M33"));			
			segis.add(new ClearingFunctionSegments("FOP",3,1,1,0,1,"ExpCF3","M34"));
			segis.add(new ClearingFunctionSegments("FOP",3,1,1,0,1,"ExpCF3","M41"));			
			segis.add(new ClearingFunctionSegments("FOP",3,1,1,0,1,"ExpCF3","M42"));			
			segis.add(new ClearingFunctionSegments("FOP",3,1,1,0,1,"ExpCF3","M43"));			
			segis.add(new ClearingFunctionSegments("FOP",3,1,1,0,1,"ExpCF3","M44"));	
			
			segis.add(new ClearingFunctionSegments("FOP",3,1,2,1152,0.276,"ExpCF3","M11"));		
			segis.add(new ClearingFunctionSegments("FOP",3,1,2,1152,0.276,"ExpCF3","M12"));		
			segis.add(new ClearingFunctionSegments("FOP",3,1,2,1152,0.276,"ExpCF3","M13"));			
			segis.add(new ClearingFunctionSegments("FOP",3,1,2,1152,0.276,"ExpCF3","M14"));			
			segis.add(new ClearingFunctionSegments("FOP",3,1,2,1152,0.276,"ExpCF3","M21"));		
			segis.add(new ClearingFunctionSegments("FOP",3,1,2,1152,0.276,"ExpCF3","M22"));			
			segis.add(new ClearingFunctionSegments("FOP",3,1,2,1152,0.276,"ExpCF3","M23"));			
			segis.add(new ClearingFunctionSegments("FOP",3,1,2,1152,0.276,"ExpCF3","M24"));
			segis.add(new ClearingFunctionSegments("FOP",3,1,2,1152,0.276,"ExpCF3","M31"));			
			segis.add(new ClearingFunctionSegments("FOP",3,1,2,1152,0.276,"ExpCF3","M32"));			
			segis.add(new ClearingFunctionSegments("FOP",3,1,2,1152,0.276,"ExpCF3","M33"));			
			segis.add(new ClearingFunctionSegments("FOP",3,1,2,1152,0.276,"ExpCF3","M34"));
			segis.add(new ClearingFunctionSegments("FOP",3,1,2,1152,0.276,"ExpCF3","M41"));			
			segis.add(new ClearingFunctionSegments("FOP",3,1,2,1152,0.276,"ExpCF3","M42"));			
			segis.add(new ClearingFunctionSegments("FOP",3,1,2,1152,0.276,"ExpCF3","M43"));			
			segis.add(new ClearingFunctionSegments("FOP",3,1,2,1152,0.276,"ExpCF3","M44"));
			
			segis.add(new ClearingFunctionSegments("FOP",3,1,3,1440,0,"ExpCF3","M11"));		
			segis.add(new ClearingFunctionSegments("FOP",3,1,3,1440,0,"ExpCF3","M12"));		
			segis.add(new ClearingFunctionSegments("FOP",3,1,3,1440,0,"ExpCF3","M13"));			
			segis.add(new ClearingFunctionSegments("FOP",3,1,3,1440,0,"ExpCF3","M14"));			
			segis.add(new ClearingFunctionSegments("FOP",3,1,3,1440,0,"ExpCF3","M21"));		
			segis.add(new ClearingFunctionSegments("FOP",3,1,3,1440,0,"ExpCF3","M22"));			
			segis.add(new ClearingFunctionSegments("FOP",3,1,3,1440,0,"ExpCF3","M23"));			
			segis.add(new ClearingFunctionSegments("FOP",3,1,3,1440,0,"ExpCF3","M24"));
			segis.add(new ClearingFunctionSegments("FOP",3,1,3,1440,0,"ExpCF3","M31"));			
			segis.add(new ClearingFunctionSegments("FOP",3,1,3,1440,0,"ExpCF3","M32"));			
			segis.add(new ClearingFunctionSegments("FOP",3,1,3,1440,0,"ExpCF3","M33"));			
			segis.add(new ClearingFunctionSegments("FOP",3,1,3,1440,0,"ExpCF3","M34"));
			segis.add(new ClearingFunctionSegments("FOP",3,1,3,1440,0,"ExpCF3","M41"));			
			segis.add(new ClearingFunctionSegments("FOP",3,1,3,1440,0,"ExpCF3","M42"));			
			segis.add(new ClearingFunctionSegments("FOP",3,1,3,1440,0,"ExpCF3","M43"));			
			segis.add(new ClearingFunctionSegments("FOP",3,1,3,1440,0,"ExpCF3","M44"));		
			
		}else if(UseCFLineType == 8) {	//60%
			segis.add(new ClearingFunctionSegments("FOP",1,1,1,0,1,"ExpCF3","M11"));		
			segis.add(new ClearingFunctionSegments("FOP",1,1,1,0,1,"ExpCF3","M12"));		
			segis.add(new ClearingFunctionSegments("FOP",1,1,1,0,1,"ExpCF3","M13"));			
			segis.add(new ClearingFunctionSegments("FOP",1,1,1,0,1,"ExpCF3","M14"));			
			segis.add(new ClearingFunctionSegments("FOP",1,1,1,0,1,"ExpCF3","M21"));		
			segis.add(new ClearingFunctionSegments("FOP",1,1,1,0,1,"ExpCF3","M22"));			
			segis.add(new ClearingFunctionSegments("FOP",1,1,1,0,1,"ExpCF3","M23"));			
			segis.add(new ClearingFunctionSegments("FOP",1,1,1,0,1,"ExpCF3","M24"));
			segis.add(new ClearingFunctionSegments("FOP",1,1,1,0,1,"ExpCF3","M31"));			
			segis.add(new ClearingFunctionSegments("FOP",1,1,1,0,1,"ExpCF3","M32"));			
			segis.add(new ClearingFunctionSegments("FOP",1,1,1,0,1,"ExpCF3","M33"));			
			segis.add(new ClearingFunctionSegments("FOP",1,1,1,0,1,"ExpCF3","M34"));
			segis.add(new ClearingFunctionSegments("FOP",1,1,1,0,1,"ExpCF3","M41"));			
			segis.add(new ClearingFunctionSegments("FOP",1,1,1,0,1,"ExpCF3","M42"));			
			segis.add(new ClearingFunctionSegments("FOP",1,1,1,0,1,"ExpCF3","M43"));			
			segis.add(new ClearingFunctionSegments("FOP",1,1,1,0,1,"ExpCF3","M44"));	
			
			segis.add(new ClearingFunctionSegments("FOP",1,1,2,864,0.276,"ExpCF3","M13"));			
			segis.add(new ClearingFunctionSegments("FOP",1,1,2,864,0.276,"ExpCF3","M14"));			
			segis.add(new ClearingFunctionSegments("FOP",1,1,2,864,0.276,"ExpCF3","M21"));		
			segis.add(new ClearingFunctionSegments("FOP",1,1,2,864,0.276,"ExpCF3","M22"));			
			segis.add(new ClearingFunctionSegments("FOP",1,1,2,864,0.276,"ExpCF3","M23"));			
			segis.add(new ClearingFunctionSegments("FOP",1,1,2,864,0.276,"ExpCF3","M24"));
			segis.add(new ClearingFunctionSegments("FOP",1,1,2,864,0.276,"ExpCF3","M31"));			
			segis.add(new ClearingFunctionSegments("FOP",1,1,2,864,0.276,"ExpCF3","M32"));			
			segis.add(new ClearingFunctionSegments("FOP",1,1,2,864,0.276,"ExpCF3","M33"));			
			segis.add(new ClearingFunctionSegments("FOP",1,1,2,864,0.276,"ExpCF3","M34"));
			segis.add(new ClearingFunctionSegments("FOP",1,1,2,864,0.276,"ExpCF3","M41"));			
			segis.add(new ClearingFunctionSegments("FOP",1,1,2,864,0.276,"ExpCF3","M42"));			
			segis.add(new ClearingFunctionSegments("FOP",1,1,2,864,0.276,"ExpCF3","M43"));			
			segis.add(new ClearingFunctionSegments("FOP",1,1,2,864,0.276,"ExpCF3","M44"));
			
			segis.add(new ClearingFunctionSegments("FOP",1,1,3,1440,0,"ExpCF3","M11"));		
			segis.add(new ClearingFunctionSegments("FOP",1,1,3,1440,0,"ExpCF3","M12"));		
			segis.add(new ClearingFunctionSegments("FOP",1,1,3,1440,0,"ExpCF3","M13"));			
			segis.add(new ClearingFunctionSegments("FOP",1,1,3,1440,0,"ExpCF3","M14"));			
			segis.add(new ClearingFunctionSegments("FOP",1,1,3,1440,0,"ExpCF3","M21"));		
			segis.add(new ClearingFunctionSegments("FOP",1,1,3,1440,0,"ExpCF3","M22"));			
			segis.add(new ClearingFunctionSegments("FOP",1,1,3,1440,0,"ExpCF3","M23"));			
			segis.add(new ClearingFunctionSegments("FOP",1,1,3,1440,0,"ExpCF3","M24"));
			segis.add(new ClearingFunctionSegments("FOP",1,1,3,1440,0,"ExpCF3","M31"));			
			segis.add(new ClearingFunctionSegments("FOP",1,1,3,1440,0,"ExpCF3","M32"));			
			segis.add(new ClearingFunctionSegments("FOP",1,1,3,1440,0,"ExpCF3","M33"));			
			segis.add(new ClearingFunctionSegments("FOP",1,1,3,1440,0,"ExpCF3","M34"));
			segis.add(new ClearingFunctionSegments("FOP",1,1,3,1440,0,"ExpCF3","M41"));			
			segis.add(new ClearingFunctionSegments("FOP",1,1,3,1440,0,"ExpCF3","M42"));			
			segis.add(new ClearingFunctionSegments("FOP",1,1,3,1440,0,"ExpCF3","M43"));			
			segis.add(new ClearingFunctionSegments("FOP",1,1,3,1440,0,"ExpCF3","M44"));
			
			//fop 2
			segis.add(new ClearingFunctionSegments("FOP",2,1,1,0,1,"ExpCF3","M11"));		
			segis.add(new ClearingFunctionSegments("FOP",2,1,1,0,1,"ExpCF3","M12"));		
			segis.add(new ClearingFunctionSegments("FOP",2,1,1,0,1,"ExpCF3","M13"));			
			segis.add(new ClearingFunctionSegments("FOP",2,1,1,0,1,"ExpCF3","M14"));			
			segis.add(new ClearingFunctionSegments("FOP",2,1,1,0,1,"ExpCF3","M21"));		
			segis.add(new ClearingFunctionSegments("FOP",2,1,1,0,1,"ExpCF3","M22"));			
			segis.add(new ClearingFunctionSegments("FOP",2,1,1,0,1,"ExpCF3","M23"));			
			segis.add(new ClearingFunctionSegments("FOP",2,1,1,0,1,"ExpCF3","M24"));
			segis.add(new ClearingFunctionSegments("FOP",2,1,1,0,1,"ExpCF3","M31"));			
			segis.add(new ClearingFunctionSegments("FOP",2,1,1,0,1,"ExpCF3","M32"));			
			segis.add(new ClearingFunctionSegments("FOP",2,1,1,0,1,"ExpCF3","M33"));			
			segis.add(new ClearingFunctionSegments("FOP",2,1,1,0,1,"ExpCF3","M34"));
			segis.add(new ClearingFunctionSegments("FOP",2,1,1,0,1,"ExpCF3","M41"));			
			segis.add(new ClearingFunctionSegments("FOP",2,1,1,0,1,"ExpCF3","M42"));			
			segis.add(new ClearingFunctionSegments("FOP",2,1,1,0,1,"ExpCF3","M43"));			
			segis.add(new ClearingFunctionSegments("FOP",2,1,1,0,1,"ExpCF3","M44"));	
			
			segis.add(new ClearingFunctionSegments("FOP",2,1,2,864,0.276,"ExpCF3","M13"));			
			segis.add(new ClearingFunctionSegments("FOP",2,1,2,864,0.276,"ExpCF3","M14"));			
			segis.add(new ClearingFunctionSegments("FOP",2,1,2,864,0.276,"ExpCF3","M21"));		
			segis.add(new ClearingFunctionSegments("FOP",2,1,2,864,0.276,"ExpCF3","M22"));			
			segis.add(new ClearingFunctionSegments("FOP",2,1,2,864,0.276,"ExpCF3","M23"));			
			segis.add(new ClearingFunctionSegments("FOP",2,1,2,864,0.276,"ExpCF3","M24"));
			segis.add(new ClearingFunctionSegments("FOP",2,1,2,864,0.276,"ExpCF3","M31"));			
			segis.add(new ClearingFunctionSegments("FOP",2,1,2,864,0.276,"ExpCF3","M32"));			
			segis.add(new ClearingFunctionSegments("FOP",2,1,2,864,0.276,"ExpCF3","M33"));			
			segis.add(new ClearingFunctionSegments("FOP",2,1,2,864,0.276,"ExpCF3","M34"));
			segis.add(new ClearingFunctionSegments("FOP",2,1,2,864,0.276,"ExpCF3","M41"));			
			segis.add(new ClearingFunctionSegments("FOP",2,1,2,864,0.276,"ExpCF3","M42"));			
			segis.add(new ClearingFunctionSegments("FOP",2,1,2,864,0.276,"ExpCF3","M43"));			
			segis.add(new ClearingFunctionSegments("FOP",2,1,2,864,0.276,"ExpCF3","M44"));
			
			segis.add(new ClearingFunctionSegments("FOP",2,1,3,1440,0,"ExpCF3","M11"));		
			segis.add(new ClearingFunctionSegments("FOP",2,1,3,1440,0,"ExpCF3","M12"));		
			segis.add(new ClearingFunctionSegments("FOP",2,1,3,1440,0,"ExpCF3","M13"));			
			segis.add(new ClearingFunctionSegments("FOP",2,1,3,1440,0,"ExpCF3","M14"));			
			segis.add(new ClearingFunctionSegments("FOP",2,1,3,1440,0,"ExpCF3","M21"));		
			segis.add(new ClearingFunctionSegments("FOP",2,1,3,1440,0,"ExpCF3","M22"));			
			segis.add(new ClearingFunctionSegments("FOP",2,1,3,1440,0,"ExpCF3","M23"));			
			segis.add(new ClearingFunctionSegments("FOP",2,1,3,1440,0,"ExpCF3","M24"));
			segis.add(new ClearingFunctionSegments("FOP",2,1,3,1440,0,"ExpCF3","M31"));			
			segis.add(new ClearingFunctionSegments("FOP",2,1,3,1440,0,"ExpCF3","M32"));			
			segis.add(new ClearingFunctionSegments("FOP",2,1,3,1440,0,"ExpCF3","M33"));			
			segis.add(new ClearingFunctionSegments("FOP",2,1,3,1440,0,"ExpCF3","M34"));
			segis.add(new ClearingFunctionSegments("FOP",2,1,3,1440,0,"ExpCF3","M41"));			
			segis.add(new ClearingFunctionSegments("FOP",2,1,3,1440,0,"ExpCF3","M42"));			
			segis.add(new ClearingFunctionSegments("FOP",2,1,3,1440,0,"ExpCF3","M43"));			
			segis.add(new ClearingFunctionSegments("FOP",2,1,3,1440,0,"ExpCF3","M44"));

			//fop 3
			segis.add(new ClearingFunctionSegments("FOP",3,1,1,0,1,"ExpCF3","M11"));		
			segis.add(new ClearingFunctionSegments("FOP",3,1,1,0,1,"ExpCF3","M12"));		
			segis.add(new ClearingFunctionSegments("FOP",3,1,1,0,1,"ExpCF3","M13"));			
			segis.add(new ClearingFunctionSegments("FOP",3,1,1,0,1,"ExpCF3","M14"));			
			segis.add(new ClearingFunctionSegments("FOP",3,1,1,0,1,"ExpCF3","M21"));		
			segis.add(new ClearingFunctionSegments("FOP",3,1,1,0,1,"ExpCF3","M22"));			
			segis.add(new ClearingFunctionSegments("FOP",3,1,1,0,1,"ExpCF3","M23"));			
			segis.add(new ClearingFunctionSegments("FOP",3,1,1,0,1,"ExpCF3","M24"));
			segis.add(new ClearingFunctionSegments("FOP",3,1,1,0,1,"ExpCF3","M31"));			
			segis.add(new ClearingFunctionSegments("FOP",3,1,1,0,1,"ExpCF3","M32"));			
			segis.add(new ClearingFunctionSegments("FOP",3,1,1,0,1,"ExpCF3","M33"));			
			segis.add(new ClearingFunctionSegments("FOP",3,1,1,0,1,"ExpCF3","M34"));
			segis.add(new ClearingFunctionSegments("FOP",3,1,1,0,1,"ExpCF3","M41"));			
			segis.add(new ClearingFunctionSegments("FOP",3,1,1,0,1,"ExpCF3","M42"));			
			segis.add(new ClearingFunctionSegments("FOP",3,1,1,0,1,"ExpCF3","M43"));			
			segis.add(new ClearingFunctionSegments("FOP",3,1,1,0,1,"ExpCF3","M44"));	
			
			segis.add(new ClearingFunctionSegments("FOP",3,1,2,864,0.276,"ExpCF3","M13"));			
			segis.add(new ClearingFunctionSegments("FOP",3,1,2,864,0.276,"ExpCF3","M14"));			
			segis.add(new ClearingFunctionSegments("FOP",3,1,2,864,0.276,"ExpCF3","M21"));		
			segis.add(new ClearingFunctionSegments("FOP",3,1,2,864,0.276,"ExpCF3","M22"));			
			segis.add(new ClearingFunctionSegments("FOP",3,1,2,864,0.276,"ExpCF3","M23"));			
			segis.add(new ClearingFunctionSegments("FOP",3,1,2,864,0.276,"ExpCF3","M24"));
			segis.add(new ClearingFunctionSegments("FOP",3,1,2,864,0.276,"ExpCF3","M31"));			
			segis.add(new ClearingFunctionSegments("FOP",3,1,2,864,0.276,"ExpCF3","M32"));			
			segis.add(new ClearingFunctionSegments("FOP",3,1,2,864,0.276,"ExpCF3","M33"));			
			segis.add(new ClearingFunctionSegments("FOP",3,1,2,864,0.276,"ExpCF3","M34"));
			segis.add(new ClearingFunctionSegments("FOP",3,1,2,864,0.276,"ExpCF3","M41"));			
			segis.add(new ClearingFunctionSegments("FOP",3,1,2,864,0.276,"ExpCF3","M42"));			
			segis.add(new ClearingFunctionSegments("FOP",3,1,2,864,0.276,"ExpCF3","M43"));			
			segis.add(new ClearingFunctionSegments("FOP",3,1,2,864,0.276,"ExpCF3","M44"));
			
			segis.add(new ClearingFunctionSegments("FOP",3,1,3,1440,0,"ExpCF3","M11"));		
			segis.add(new ClearingFunctionSegments("FOP",3,1,3,1440,0,"ExpCF3","M12"));		
			segis.add(new ClearingFunctionSegments("FOP",3,1,3,1440,0,"ExpCF3","M13"));			
			segis.add(new ClearingFunctionSegments("FOP",3,1,3,1440,0,"ExpCF3","M14"));			
			segis.add(new ClearingFunctionSegments("FOP",3,1,3,1440,0,"ExpCF3","M21"));		
			segis.add(new ClearingFunctionSegments("FOP",3,1,3,1440,0,"ExpCF3","M22"));			
			segis.add(new ClearingFunctionSegments("FOP",3,1,3,1440,0,"ExpCF3","M23"));			
			segis.add(new ClearingFunctionSegments("FOP",3,1,3,1440,0,"ExpCF3","M24"));
			segis.add(new ClearingFunctionSegments("FOP",3,1,3,1440,0,"ExpCF3","M31"));			
			segis.add(new ClearingFunctionSegments("FOP",3,1,3,1440,0,"ExpCF3","M32"));			
			segis.add(new ClearingFunctionSegments("FOP",3,1,3,1440,0,"ExpCF3","M33"));			
			segis.add(new ClearingFunctionSegments("FOP",3,1,3,1440,0,"ExpCF3","M34"));
			segis.add(new ClearingFunctionSegments("FOP",3,1,3,1440,0,"ExpCF3","M41"));			
			segis.add(new ClearingFunctionSegments("FOP",3,1,3,1440,0,"ExpCF3","M42"));			
			segis.add(new ClearingFunctionSegments("FOP",3,1,3,1440,0,"ExpCF3","M43"));			
			segis.add(new ClearingFunctionSegments("FOP",3,1,3,1440,0,"ExpCF3","M44"));
							
		}else if(UseCFLineType == 9) {	//40%
			segis.add(new ClearingFunctionSegments("FOP",1,1,1,0,1,"ExpCF3","M11"));		
			segis.add(new ClearingFunctionSegments("FOP",1,1,1,0,1,"ExpCF3","M12"));		
			segis.add(new ClearingFunctionSegments("FOP",1,1,1,0,1,"ExpCF3","M13"));			
			segis.add(new ClearingFunctionSegments("FOP",1,1,1,0,1,"ExpCF3","M14"));			
			segis.add(new ClearingFunctionSegments("FOP",1,1,1,0,1,"ExpCF3","M21"));		
			segis.add(new ClearingFunctionSegments("FOP",1,1,1,0,1,"ExpCF3","M22"));			
			segis.add(new ClearingFunctionSegments("FOP",1,1,1,0,1,"ExpCF3","M23"));			
			segis.add(new ClearingFunctionSegments("FOP",1,1,1,0,1,"ExpCF3","M24"));
			segis.add(new ClearingFunctionSegments("FOP",1,1,1,0,1,"ExpCF3","M31"));			
			segis.add(new ClearingFunctionSegments("FOP",1,1,1,0,1,"ExpCF3","M32"));			
			segis.add(new ClearingFunctionSegments("FOP",1,1,1,0,1,"ExpCF3","M33"));			
			segis.add(new ClearingFunctionSegments("FOP",1,1,1,0,1,"ExpCF3","M34"));
			segis.add(new ClearingFunctionSegments("FOP",1,1,1,0,1,"ExpCF3","M41"));			
			segis.add(new ClearingFunctionSegments("FOP",1,1,1,0,1,"ExpCF3","M42"));			
			segis.add(new ClearingFunctionSegments("FOP",1,1,1,0,1,"ExpCF3","M43"));			
			segis.add(new ClearingFunctionSegments("FOP",1,1,1,0,1,"ExpCF3","M44"));	
			
			segis.add(new ClearingFunctionSegments("FOP",1,1,2,576,0.276,"ExpCF3","M11"));		
			segis.add(new ClearingFunctionSegments("FOP",1,1,2,576,0.276,"ExpCF3","M12"));		
			segis.add(new ClearingFunctionSegments("FOP",1,1,2,576,0.276,"ExpCF3","M13"));			
			segis.add(new ClearingFunctionSegments("FOP",1,1,2,576,0.276,"ExpCF3","M14"));			
			segis.add(new ClearingFunctionSegments("FOP",1,1,2,576,0.276,"ExpCF3","M21"));		
			segis.add(new ClearingFunctionSegments("FOP",1,1,2,576,0.276,"ExpCF3","M22"));			
			segis.add(new ClearingFunctionSegments("FOP",1,1,2,576,0.276,"ExpCF3","M23"));			
			segis.add(new ClearingFunctionSegments("FOP",1,1,2,576,0.276,"ExpCF3","M24"));
			segis.add(new ClearingFunctionSegments("FOP",1,1,2,576,0.276,"ExpCF3","M31"));			
			segis.add(new ClearingFunctionSegments("FOP",1,1,2,576,0.276,"ExpCF3","M32"));			
			segis.add(new ClearingFunctionSegments("FOP",1,1,2,576,0.276,"ExpCF3","M33"));			
			segis.add(new ClearingFunctionSegments("FOP",1,1,2,576,0.276,"ExpCF3","M34"));
			segis.add(new ClearingFunctionSegments("FOP",1,1,2,576,0.276,"ExpCF3","M41"));			
			segis.add(new ClearingFunctionSegments("FOP",1,1,2,576,0.276,"ExpCF3","M42"));			
			segis.add(new ClearingFunctionSegments("FOP",1,1,2,576,0.276,"ExpCF3","M43"));			
			segis.add(new ClearingFunctionSegments("FOP",1,1,2,576,0.276,"ExpCF3","M44"));
			
			segis.add(new ClearingFunctionSegments("FOP",1,1,3,1440,0,"ExpCF3","M11"));		
			segis.add(new ClearingFunctionSegments("FOP",1,1,3,1440,0,"ExpCF3","M12"));		
			segis.add(new ClearingFunctionSegments("FOP",1,1,3,1440,0,"ExpCF3","M13"));			
			segis.add(new ClearingFunctionSegments("FOP",1,1,3,1440,0,"ExpCF3","M14"));			
			segis.add(new ClearingFunctionSegments("FOP",1,1,3,1440,0,"ExpCF3","M21"));		
			segis.add(new ClearingFunctionSegments("FOP",1,1,3,1440,0,"ExpCF3","M22"));			
			segis.add(new ClearingFunctionSegments("FOP",1,1,3,1440,0,"ExpCF3","M23"));			
			segis.add(new ClearingFunctionSegments("FOP",1,1,3,1440,0,"ExpCF3","M24"));
			segis.add(new ClearingFunctionSegments("FOP",1,1,3,1440,0,"ExpCF3","M31"));			
			segis.add(new ClearingFunctionSegments("FOP",1,1,3,1440,0,"ExpCF3","M32"));			
			segis.add(new ClearingFunctionSegments("FOP",1,1,3,1440,0,"ExpCF3","M33"));			
			segis.add(new ClearingFunctionSegments("FOP",1,1,3,1440,0,"ExpCF3","M34"));
			segis.add(new ClearingFunctionSegments("FOP",1,1,3,1440,0,"ExpCF3","M41"));			
			segis.add(new ClearingFunctionSegments("FOP",1,1,3,1440,0,"ExpCF3","M42"));			
			segis.add(new ClearingFunctionSegments("FOP",1,1,3,1440,0,"ExpCF3","M43"));			
			segis.add(new ClearingFunctionSegments("FOP",1,1,3,1440,0,"ExpCF3","M44"));				
			
			//fop 2
			segis.add(new ClearingFunctionSegments("FOP",2,1,1,0,1,"ExpCF3","M11"));		
			segis.add(new ClearingFunctionSegments("FOP",2,1,1,0,1,"ExpCF3","M12"));		
			segis.add(new ClearingFunctionSegments("FOP",2,1,1,0,1,"ExpCF3","M13"));			
			segis.add(new ClearingFunctionSegments("FOP",2,1,1,0,1,"ExpCF3","M14"));			
			segis.add(new ClearingFunctionSegments("FOP",2,1,1,0,1,"ExpCF3","M21"));		
			segis.add(new ClearingFunctionSegments("FOP",2,1,1,0,1,"ExpCF3","M22"));			
			segis.add(new ClearingFunctionSegments("FOP",2,1,1,0,1,"ExpCF3","M23"));			
			segis.add(new ClearingFunctionSegments("FOP",2,1,1,0,1,"ExpCF3","M24"));
			segis.add(new ClearingFunctionSegments("FOP",2,1,1,0,1,"ExpCF3","M31"));			
			segis.add(new ClearingFunctionSegments("FOP",2,1,1,0,1,"ExpCF3","M32"));			
			segis.add(new ClearingFunctionSegments("FOP",2,1,1,0,1,"ExpCF3","M33"));			
			segis.add(new ClearingFunctionSegments("FOP",2,1,1,0,1,"ExpCF3","M34"));
			segis.add(new ClearingFunctionSegments("FOP",2,1,1,0,1,"ExpCF3","M41"));			
			segis.add(new ClearingFunctionSegments("FOP",2,1,1,0,1,"ExpCF3","M42"));			
			segis.add(new ClearingFunctionSegments("FOP",2,1,1,0,1,"ExpCF3","M43"));			
			segis.add(new ClearingFunctionSegments("FOP",2,1,1,0,1,"ExpCF3","M44"));	
			
			segis.add(new ClearingFunctionSegments("FOP",2,1,2,576,0.276,"ExpCF3","M11"));		
			segis.add(new ClearingFunctionSegments("FOP",2,1,2,576,0.276,"ExpCF3","M12"));		
			segis.add(new ClearingFunctionSegments("FOP",2,1,2,576,0.276,"ExpCF3","M13"));			
			segis.add(new ClearingFunctionSegments("FOP",2,1,2,576,0.276,"ExpCF3","M14"));			
			segis.add(new ClearingFunctionSegments("FOP",2,1,2,576,0.276,"ExpCF3","M21"));		
			segis.add(new ClearingFunctionSegments("FOP",2,1,2,576,0.276,"ExpCF3","M22"));			
			segis.add(new ClearingFunctionSegments("FOP",2,1,2,576,0.276,"ExpCF3","M23"));			
			segis.add(new ClearingFunctionSegments("FOP",2,1,2,576,0.276,"ExpCF3","M24"));
			segis.add(new ClearingFunctionSegments("FOP",2,1,2,576,0.276,"ExpCF3","M31"));			
			segis.add(new ClearingFunctionSegments("FOP",2,1,2,576,0.276,"ExpCF3","M32"));			
			segis.add(new ClearingFunctionSegments("FOP",2,1,2,576,0.276,"ExpCF3","M33"));			
			segis.add(new ClearingFunctionSegments("FOP",2,1,2,576,0.276,"ExpCF3","M34"));
			segis.add(new ClearingFunctionSegments("FOP",2,1,2,576,0.276,"ExpCF3","M41"));			
			segis.add(new ClearingFunctionSegments("FOP",2,1,2,576,0.276,"ExpCF3","M42"));			
			segis.add(new ClearingFunctionSegments("FOP",2,1,2,576,0.276,"ExpCF3","M43"));			
			segis.add(new ClearingFunctionSegments("FOP",2,1,2,576,0.276,"ExpCF3","M44"));
			
			segis.add(new ClearingFunctionSegments("FOP",2,1,3,1440,0,"ExpCF3","M11"));		
			segis.add(new ClearingFunctionSegments("FOP",2,1,3,1440,0,"ExpCF3","M12"));		
			segis.add(new ClearingFunctionSegments("FOP",2,1,3,1440,0,"ExpCF3","M13"));			
			segis.add(new ClearingFunctionSegments("FOP",2,1,3,1440,0,"ExpCF3","M14"));			
			segis.add(new ClearingFunctionSegments("FOP",2,1,3,1440,0,"ExpCF3","M21"));		
			segis.add(new ClearingFunctionSegments("FOP",2,1,3,1440,0,"ExpCF3","M22"));			
			segis.add(new ClearingFunctionSegments("FOP",2,1,3,1440,0,"ExpCF3","M23"));			
			segis.add(new ClearingFunctionSegments("FOP",2,1,3,1440,0,"ExpCF3","M24"));
			segis.add(new ClearingFunctionSegments("FOP",2,1,3,1440,0,"ExpCF3","M31"));			
			segis.add(new ClearingFunctionSegments("FOP",2,1,3,1440,0,"ExpCF3","M32"));			
			segis.add(new ClearingFunctionSegments("FOP",2,1,3,1440,0,"ExpCF3","M33"));			
			segis.add(new ClearingFunctionSegments("FOP",2,1,3,1440,0,"ExpCF3","M34"));
			segis.add(new ClearingFunctionSegments("FOP",2,1,3,1440,0,"ExpCF3","M41"));			
			segis.add(new ClearingFunctionSegments("FOP",2,1,3,1440,0,"ExpCF3","M42"));			
			segis.add(new ClearingFunctionSegments("FOP",2,1,3,1440,0,"ExpCF3","M43"));			
			segis.add(new ClearingFunctionSegments("FOP",2,1,3,1440,0,"ExpCF3","M44"));	
			
			//fop 3
			segis.add(new ClearingFunctionSegments("FOP",3,1,1,0,1,"ExpCF3","M11"));		
			segis.add(new ClearingFunctionSegments("FOP",3,1,1,0,1,"ExpCF3","M12"));		
			segis.add(new ClearingFunctionSegments("FOP",3,1,1,0,1,"ExpCF3","M13"));			
			segis.add(new ClearingFunctionSegments("FOP",3,1,1,0,1,"ExpCF3","M14"));			
			segis.add(new ClearingFunctionSegments("FOP",3,1,1,0,1,"ExpCF3","M21"));		
			segis.add(new ClearingFunctionSegments("FOP",3,1,1,0,1,"ExpCF3","M22"));			
			segis.add(new ClearingFunctionSegments("FOP",3,1,1,0,1,"ExpCF3","M23"));			
			segis.add(new ClearingFunctionSegments("FOP",3,1,1,0,1,"ExpCF3","M24"));
			segis.add(new ClearingFunctionSegments("FOP",3,1,1,0,1,"ExpCF3","M31"));			
			segis.add(new ClearingFunctionSegments("FOP",3,1,1,0,1,"ExpCF3","M32"));			
			segis.add(new ClearingFunctionSegments("FOP",3,1,1,0,1,"ExpCF3","M33"));			
			segis.add(new ClearingFunctionSegments("FOP",3,1,1,0,1,"ExpCF3","M34"));
			segis.add(new ClearingFunctionSegments("FOP",3,1,1,0,1,"ExpCF3","M41"));			
			segis.add(new ClearingFunctionSegments("FOP",3,1,1,0,1,"ExpCF3","M42"));			
			segis.add(new ClearingFunctionSegments("FOP",3,1,1,0,1,"ExpCF3","M43"));			
			segis.add(new ClearingFunctionSegments("FOP",3,1,1,0,1,"ExpCF3","M44"));	
			
			segis.add(new ClearingFunctionSegments("FOP",3,1,2,576,0.276,"ExpCF3","M11"));		
			segis.add(new ClearingFunctionSegments("FOP",3,1,2,576,0.276,"ExpCF3","M12"));		
			segis.add(new ClearingFunctionSegments("FOP",3,1,2,576,0.276,"ExpCF3","M13"));			
			segis.add(new ClearingFunctionSegments("FOP",3,1,2,576,0.276,"ExpCF3","M14"));			
			segis.add(new ClearingFunctionSegments("FOP",3,1,2,576,0.276,"ExpCF3","M21"));		
			segis.add(new ClearingFunctionSegments("FOP",3,1,2,576,0.276,"ExpCF3","M22"));			
			segis.add(new ClearingFunctionSegments("FOP",3,1,2,576,0.276,"ExpCF3","M23"));			
			segis.add(new ClearingFunctionSegments("FOP",3,1,2,576,0.276,"ExpCF3","M24"));
			segis.add(new ClearingFunctionSegments("FOP",3,1,2,576,0.276,"ExpCF3","M31"));			
			segis.add(new ClearingFunctionSegments("FOP",3,1,2,576,0.276,"ExpCF3","M32"));			
			segis.add(new ClearingFunctionSegments("FOP",3,1,2,576,0.276,"ExpCF3","M33"));			
			segis.add(new ClearingFunctionSegments("FOP",3,1,2,576,0.276,"ExpCF3","M34"));
			segis.add(new ClearingFunctionSegments("FOP",3,1,2,576,0.276,"ExpCF3","M41"));			
			segis.add(new ClearingFunctionSegments("FOP",3,1,2,576,0.276,"ExpCF3","M42"));			
			segis.add(new ClearingFunctionSegments("FOP",3,1,2,576,0.276,"ExpCF3","M43"));			
			segis.add(new ClearingFunctionSegments("FOP",3,1,2,576,0.276,"ExpCF3","M44"));
			
			segis.add(new ClearingFunctionSegments("FOP",3,1,3,1440,0,"ExpCF3","M11"));		
			segis.add(new ClearingFunctionSegments("FOP",3,1,3,1440,0,"ExpCF3","M12"));		
			segis.add(new ClearingFunctionSegments("FOP",3,1,3,1440,0,"ExpCF3","M13"));			
			segis.add(new ClearingFunctionSegments("FOP",3,1,3,1440,0,"ExpCF3","M14"));			
			segis.add(new ClearingFunctionSegments("FOP",3,1,3,1440,0,"ExpCF3","M21"));		
			segis.add(new ClearingFunctionSegments("FOP",3,1,3,1440,0,"ExpCF3","M22"));			
			segis.add(new ClearingFunctionSegments("FOP",3,1,3,1440,0,"ExpCF3","M23"));			
			segis.add(new ClearingFunctionSegments("FOP",3,1,3,1440,0,"ExpCF3","M24"));
			segis.add(new ClearingFunctionSegments("FOP",3,1,3,1440,0,"ExpCF3","M31"));			
			segis.add(new ClearingFunctionSegments("FOP",3,1,3,1440,0,"ExpCF3","M32"));			
			segis.add(new ClearingFunctionSegments("FOP",3,1,3,1440,0,"ExpCF3","M33"));			
			segis.add(new ClearingFunctionSegments("FOP",3,1,3,1440,0,"ExpCF3","M34"));
			segis.add(new ClearingFunctionSegments("FOP",3,1,3,1440,0,"ExpCF3","M41"));			
			segis.add(new ClearingFunctionSegments("FOP",3,1,3,1440,0,"ExpCF3","M42"));			
			segis.add(new ClearingFunctionSegments("FOP",3,1,3,1440,0,"ExpCF3","M43"));			
			segis.add(new ClearingFunctionSegments("FOP",3,1,3,1440,0,"ExpCF3","M44"));		
			
		}else if(UseCFLineType == 10) {	//20%
			segis.add(new ClearingFunctionSegments("FOP",1,1,1,0,1,"ExpCF3","M11"));		
			segis.add(new ClearingFunctionSegments("FOP",1,1,1,0,1,"ExpCF3","M12"));		
			segis.add(new ClearingFunctionSegments("FOP",1,1,1,0,1,"ExpCF3","M13"));			
			segis.add(new ClearingFunctionSegments("FOP",1,1,1,0,1,"ExpCF3","M14"));			
			segis.add(new ClearingFunctionSegments("FOP",1,1,1,0,1,"ExpCF3","M21"));		
			segis.add(new ClearingFunctionSegments("FOP",1,1,1,0,1,"ExpCF3","M22"));			
			segis.add(new ClearingFunctionSegments("FOP",1,1,1,0,1,"ExpCF3","M23"));			
			segis.add(new ClearingFunctionSegments("FOP",1,1,1,0,1,"ExpCF3","M24"));
			segis.add(new ClearingFunctionSegments("FOP",1,1,1,0,1,"ExpCF3","M31"));			
			segis.add(new ClearingFunctionSegments("FOP",1,1,1,0,1,"ExpCF3","M32"));			
			segis.add(new ClearingFunctionSegments("FOP",1,1,1,0,1,"ExpCF3","M33"));			
			segis.add(new ClearingFunctionSegments("FOP",1,1,1,0,1,"ExpCF3","M34"));
			segis.add(new ClearingFunctionSegments("FOP",1,1,1,0,1,"ExpCF3","M41"));			
			segis.add(new ClearingFunctionSegments("FOP",1,1,1,0,1,"ExpCF3","M42"));			
			segis.add(new ClearingFunctionSegments("FOP",1,1,1,0,1,"ExpCF3","M43"));			
			segis.add(new ClearingFunctionSegments("FOP",1,1,1,0,1,"ExpCF3","M44"));	
			
			segis.add(new ClearingFunctionSegments("FOP",1,1,2,288,0.276,"ExpCF3","M11"));		
			segis.add(new ClearingFunctionSegments("FOP",1,1,2,288,0.276,"ExpCF3","M12"));		
			segis.add(new ClearingFunctionSegments("FOP",1,1,2,288,0.276,"ExpCF3","M13"));			
			segis.add(new ClearingFunctionSegments("FOP",1,1,2,288,0.276,"ExpCF3","M14"));			
			segis.add(new ClearingFunctionSegments("FOP",1,1,2,288,0.276,"ExpCF3","M21"));		
			segis.add(new ClearingFunctionSegments("FOP",1,1,2,288,0.276,"ExpCF3","M22"));			
			segis.add(new ClearingFunctionSegments("FOP",1,1,2,288,0.276,"ExpCF3","M23"));			
			segis.add(new ClearingFunctionSegments("FOP",1,1,2,288,0.276,"ExpCF3","M24"));
			segis.add(new ClearingFunctionSegments("FOP",1,1,2,288,0.276,"ExpCF3","M31"));			
			segis.add(new ClearingFunctionSegments("FOP",1,1,2,288,0.276,"ExpCF3","M32"));			
			segis.add(new ClearingFunctionSegments("FOP",1,1,2,288,0.276,"ExpCF3","M33"));			
			segis.add(new ClearingFunctionSegments("FOP",1,1,2,288,0.276,"ExpCF3","M34"));
			segis.add(new ClearingFunctionSegments("FOP",1,1,2,288,0.276,"ExpCF3","M41"));			
			segis.add(new ClearingFunctionSegments("FOP",1,1,2,288,0.276,"ExpCF3","M42"));			
			segis.add(new ClearingFunctionSegments("FOP",1,1,2,288,0.276,"ExpCF3","M43"));			
			segis.add(new ClearingFunctionSegments("FOP",1,1,2,288,0.276,"ExpCF3","M44"));
			
			segis.add(new ClearingFunctionSegments("FOP",1,1,3,1440,0,"ExpCF3","M11"));		
			segis.add(new ClearingFunctionSegments("FOP",1,1,3,1440,0,"ExpCF3","M12"));		
			segis.add(new ClearingFunctionSegments("FOP",1,1,3,1440,0,"ExpCF3","M13"));			
			segis.add(new ClearingFunctionSegments("FOP",1,1,3,1440,0,"ExpCF3","M14"));			
			segis.add(new ClearingFunctionSegments("FOP",1,1,3,1440,0,"ExpCF3","M21"));		
			segis.add(new ClearingFunctionSegments("FOP",1,1,3,1440,0,"ExpCF3","M22"));			
			segis.add(new ClearingFunctionSegments("FOP",1,1,3,1440,0,"ExpCF3","M23"));			
			segis.add(new ClearingFunctionSegments("FOP",1,1,3,1440,0,"ExpCF3","M24"));
			segis.add(new ClearingFunctionSegments("FOP",1,1,3,1440,0,"ExpCF3","M31"));			
			segis.add(new ClearingFunctionSegments("FOP",1,1,3,1440,0,"ExpCF3","M32"));			
			segis.add(new ClearingFunctionSegments("FOP",1,1,3,1440,0,"ExpCF3","M33"));			
			segis.add(new ClearingFunctionSegments("FOP",1,1,3,1440,0,"ExpCF3","M34"));
			segis.add(new ClearingFunctionSegments("FOP",1,1,3,1440,0,"ExpCF3","M41"));			
			segis.add(new ClearingFunctionSegments("FOP",1,1,3,1440,0,"ExpCF3","M42"));			
			segis.add(new ClearingFunctionSegments("FOP",1,1,3,1440,0,"ExpCF3","M43"));			
			segis.add(new ClearingFunctionSegments("FOP",1,1,3,1440,0,"ExpCF3","M44"));		
			
			//fop2
			segis.add(new ClearingFunctionSegments("FOP",2,1,1,0,1,"ExpCF3","M11"));		
			segis.add(new ClearingFunctionSegments("FOP",2,1,1,0,1,"ExpCF3","M12"));		
			segis.add(new ClearingFunctionSegments("FOP",2,1,1,0,1,"ExpCF3","M13"));			
			segis.add(new ClearingFunctionSegments("FOP",2,1,1,0,1,"ExpCF3","M14"));			
			segis.add(new ClearingFunctionSegments("FOP",2,1,1,0,1,"ExpCF3","M21"));		
			segis.add(new ClearingFunctionSegments("FOP",2,1,1,0,1,"ExpCF3","M22"));			
			segis.add(new ClearingFunctionSegments("FOP",2,1,1,0,1,"ExpCF3","M23"));			
			segis.add(new ClearingFunctionSegments("FOP",2,1,1,0,1,"ExpCF3","M24"));
			segis.add(new ClearingFunctionSegments("FOP",2,1,1,0,1,"ExpCF3","M31"));			
			segis.add(new ClearingFunctionSegments("FOP",2,1,1,0,1,"ExpCF3","M32"));			
			segis.add(new ClearingFunctionSegments("FOP",2,1,1,0,1,"ExpCF3","M33"));			
			segis.add(new ClearingFunctionSegments("FOP",2,1,1,0,1,"ExpCF3","M34"));
			segis.add(new ClearingFunctionSegments("FOP",2,1,1,0,1,"ExpCF3","M41"));			
			segis.add(new ClearingFunctionSegments("FOP",2,1,1,0,1,"ExpCF3","M42"));			
			segis.add(new ClearingFunctionSegments("FOP",2,1,1,0,1,"ExpCF3","M43"));			
			segis.add(new ClearingFunctionSegments("FOP",2,1,1,0,1,"ExpCF3","M44"));	
			
			segis.add(new ClearingFunctionSegments("FOP",2,1,2,288,0.276,"ExpCF3","M11"));		
			segis.add(new ClearingFunctionSegments("FOP",2,1,2,288,0.276,"ExpCF3","M12"));		
			segis.add(new ClearingFunctionSegments("FOP",2,1,2,288,0.276,"ExpCF3","M13"));			
			segis.add(new ClearingFunctionSegments("FOP",2,1,2,288,0.276,"ExpCF3","M14"));			
			segis.add(new ClearingFunctionSegments("FOP",2,1,2,288,0.276,"ExpCF3","M21"));		
			segis.add(new ClearingFunctionSegments("FOP",2,1,2,288,0.276,"ExpCF3","M22"));			
			segis.add(new ClearingFunctionSegments("FOP",2,1,2,288,0.276,"ExpCF3","M23"));			
			segis.add(new ClearingFunctionSegments("FOP",2,1,2,288,0.276,"ExpCF3","M24"));
			segis.add(new ClearingFunctionSegments("FOP",2,1,2,288,0.276,"ExpCF3","M31"));			
			segis.add(new ClearingFunctionSegments("FOP",2,1,2,288,0.276,"ExpCF3","M32"));			
			segis.add(new ClearingFunctionSegments("FOP",2,1,2,288,0.276,"ExpCF3","M33"));			
			segis.add(new ClearingFunctionSegments("FOP",2,1,2,288,0.276,"ExpCF3","M34"));
			segis.add(new ClearingFunctionSegments("FOP",2,1,2,288,0.276,"ExpCF3","M41"));			
			segis.add(new ClearingFunctionSegments("FOP",2,1,2,288,0.276,"ExpCF3","M42"));			
			segis.add(new ClearingFunctionSegments("FOP",2,1,2,288,0.276,"ExpCF3","M43"));			
			segis.add(new ClearingFunctionSegments("FOP",2,1,2,288,0.276,"ExpCF3","M44"));
			
			segis.add(new ClearingFunctionSegments("FOP",2,1,3,1440,0,"ExpCF3","M11"));		
			segis.add(new ClearingFunctionSegments("FOP",2,1,3,1440,0,"ExpCF3","M12"));		
			segis.add(new ClearingFunctionSegments("FOP",2,1,3,1440,0,"ExpCF3","M13"));			
			segis.add(new ClearingFunctionSegments("FOP",2,1,3,1440,0,"ExpCF3","M14"));			
			segis.add(new ClearingFunctionSegments("FOP",2,1,3,1440,0,"ExpCF3","M21"));		
			segis.add(new ClearingFunctionSegments("FOP",2,1,3,1440,0,"ExpCF3","M22"));			
			segis.add(new ClearingFunctionSegments("FOP",2,1,3,1440,0,"ExpCF3","M23"));			
			segis.add(new ClearingFunctionSegments("FOP",2,1,3,1440,0,"ExpCF3","M24"));
			segis.add(new ClearingFunctionSegments("FOP",2,1,3,1440,0,"ExpCF3","M31"));			
			segis.add(new ClearingFunctionSegments("FOP",2,1,3,1440,0,"ExpCF3","M32"));			
			segis.add(new ClearingFunctionSegments("FOP",2,1,3,1440,0,"ExpCF3","M33"));			
			segis.add(new ClearingFunctionSegments("FOP",2,1,3,1440,0,"ExpCF3","M34"));
			segis.add(new ClearingFunctionSegments("FOP",2,1,3,1440,0,"ExpCF3","M41"));			
			segis.add(new ClearingFunctionSegments("FOP",2,1,3,1440,0,"ExpCF3","M42"));			
			segis.add(new ClearingFunctionSegments("FOP",2,1,3,1440,0,"ExpCF3","M43"));			
			segis.add(new ClearingFunctionSegments("FOP",2,1,3,1440,0,"ExpCF3","M44"));		
			
			//fop3
			segis.add(new ClearingFunctionSegments("FOP",3,1,1,0,1,"ExpCF3","M11"));		
			segis.add(new ClearingFunctionSegments("FOP",3,1,1,0,1,"ExpCF3","M12"));		
			segis.add(new ClearingFunctionSegments("FOP",3,1,1,0,1,"ExpCF3","M13"));			
			segis.add(new ClearingFunctionSegments("FOP",3,1,1,0,1,"ExpCF3","M14"));			
			segis.add(new ClearingFunctionSegments("FOP",3,1,1,0,1,"ExpCF3","M21"));		
			segis.add(new ClearingFunctionSegments("FOP",3,1,1,0,1,"ExpCF3","M22"));			
			segis.add(new ClearingFunctionSegments("FOP",3,1,1,0,1,"ExpCF3","M23"));			
			segis.add(new ClearingFunctionSegments("FOP",3,1,1,0,1,"ExpCF3","M24"));
			segis.add(new ClearingFunctionSegments("FOP",3,1,1,0,1,"ExpCF3","M31"));			
			segis.add(new ClearingFunctionSegments("FOP",3,1,1,0,1,"ExpCF3","M32"));			
			segis.add(new ClearingFunctionSegments("FOP",3,1,1,0,1,"ExpCF3","M33"));			
			segis.add(new ClearingFunctionSegments("FOP",3,1,1,0,1,"ExpCF3","M34"));
			segis.add(new ClearingFunctionSegments("FOP",3,1,1,0,1,"ExpCF3","M41"));			
			segis.add(new ClearingFunctionSegments("FOP",3,1,1,0,1,"ExpCF3","M42"));			
			segis.add(new ClearingFunctionSegments("FOP",3,1,1,0,1,"ExpCF3","M43"));			
			segis.add(new ClearingFunctionSegments("FOP",3,1,1,0,1,"ExpCF3","M44"));	
			
			segis.add(new ClearingFunctionSegments("FOP",3,1,2,288,0.276,"ExpCF3","M11"));		
			segis.add(new ClearingFunctionSegments("FOP",3,1,2,288,0.276,"ExpCF3","M12"));		
			segis.add(new ClearingFunctionSegments("FOP",3,1,2,288,0.276,"ExpCF3","M13"));			
			segis.add(new ClearingFunctionSegments("FOP",3,1,2,288,0.276,"ExpCF3","M14"));			
			segis.add(new ClearingFunctionSegments("FOP",3,1,2,288,0.276,"ExpCF3","M21"));		
			segis.add(new ClearingFunctionSegments("FOP",3,1,2,288,0.276,"ExpCF3","M22"));			
			segis.add(new ClearingFunctionSegments("FOP",3,1,2,288,0.276,"ExpCF3","M23"));			
			segis.add(new ClearingFunctionSegments("FOP",3,1,2,288,0.276,"ExpCF3","M24"));
			segis.add(new ClearingFunctionSegments("FOP",3,1,2,288,0.276,"ExpCF3","M31"));			
			segis.add(new ClearingFunctionSegments("FOP",3,1,2,288,0.276,"ExpCF3","M32"));			
			segis.add(new ClearingFunctionSegments("FOP",3,1,2,288,0.276,"ExpCF3","M33"));			
			segis.add(new ClearingFunctionSegments("FOP",3,1,2,288,0.276,"ExpCF3","M34"));
			segis.add(new ClearingFunctionSegments("FOP",3,1,2,288,0.276,"ExpCF3","M41"));			
			segis.add(new ClearingFunctionSegments("FOP",3,1,2,288,0.276,"ExpCF3","M42"));			
			segis.add(new ClearingFunctionSegments("FOP",3,1,2,288,0.276,"ExpCF3","M43"));			
			segis.add(new ClearingFunctionSegments("FOP",3,1,2,288,0.276,"ExpCF3","M44"));
			
			segis.add(new ClearingFunctionSegments("FOP",3,1,3,1440,0,"ExpCF3","M11"));		
			segis.add(new ClearingFunctionSegments("FOP",3,1,3,1440,0,"ExpCF3","M12"));		
			segis.add(new ClearingFunctionSegments("FOP",3,1,3,1440,0,"ExpCF3","M13"));			
			segis.add(new ClearingFunctionSegments("FOP",3,1,3,1440,0,"ExpCF3","M14"));			
			segis.add(new ClearingFunctionSegments("FOP",3,1,3,1440,0,"ExpCF3","M21"));		
			segis.add(new ClearingFunctionSegments("FOP",3,1,3,1440,0,"ExpCF3","M22"));			
			segis.add(new ClearingFunctionSegments("FOP",3,1,3,1440,0,"ExpCF3","M23"));			
			segis.add(new ClearingFunctionSegments("FOP",3,1,3,1440,0,"ExpCF3","M24"));
			segis.add(new ClearingFunctionSegments("FOP",3,1,3,1440,0,"ExpCF3","M31"));			
			segis.add(new ClearingFunctionSegments("FOP",3,1,3,1440,0,"ExpCF3","M32"));			
			segis.add(new ClearingFunctionSegments("FOP",3,1,3,1440,0,"ExpCF3","M33"));			
			segis.add(new ClearingFunctionSegments("FOP",3,1,3,1440,0,"ExpCF3","M34"));
			segis.add(new ClearingFunctionSegments("FOP",3,1,3,1440,0,"ExpCF3","M41"));			
			segis.add(new ClearingFunctionSegments("FOP",3,1,3,1440,0,"ExpCF3","M42"));			
			segis.add(new ClearingFunctionSegments("FOP",3,1,3,1440,0,"ExpCF3","M43"));			
			segis.add(new ClearingFunctionSegments("FOP",3,1,3,1440,0,"ExpCF3","M44"));		
				
	}
	
		return segis;		
	}
	
	
	
	@Override
	public String toString() {
		return super.toString();
	}

	/**
	 * This number is here for model snapshot storing purpose<br>
	 * It needs to be changed when this class gets changed
	 */ 
	private static final long serialVersionUID = 1L;

}]]></Text>
		</JavaClass>
		<!--   =========   Java Class   ========  -->
		<JavaClass>
			<Id>1681973351639</Id>
			<Name><![CDATA[Tools]]></Name>
			<Text><![CDATA[import java.io.FileWriter;
import java.io.IOException;


/**
 * Tools
 */	
public class Tools implements Serializable {


    /**
     * Default constructor
     */
    public Tools() {
    }
    
    public static final boolean Log_PL_SL_Values = false;
    public static final String LogPLSLValues = "LogPLSLValues";
        
    public static final boolean Log_Releases_Values = true;
    public static final String LogReleases = "LogReleases";
    
    public static final boolean Log_CF_Optimization_Values = true;
    public static final String LogCFOptimization = "LogCFOptimizationValues";
        
    public static final boolean Log_CF_Lp_Files = false;
    //public static final String Log_CF_Lp_Files = "Log_CF_Lp_Files";
    

	@Override
	public String toString() {
		return super.toString();
	}

	public void log(Object text, String type) {
		
		if(type.equalsIgnoreCase(LogPLSLValues) && Log_PL_SL_Values) {
			traceln(text.toString());
		}
		
		if(type.equalsIgnoreCase(LogReleases) && Log_Releases_Values) {
			traceln(text.toString());
		}
		
		if(type.equalsIgnoreCase(LogCFOptimization) && Log_CF_Optimization_Values) {
			traceln(text.toString());
		}		
		
	}
		
	 public static void appendTextToFile(String filePath, String textToAppend) {
	        try (FileWriter fileWriter = new FileWriter(filePath, true)) {
	            fileWriter.write(textToAppend);
	            System.out.println("Text appended successfully to " + filePath);
	        } catch (IOException e) {
	            System.out.println("An error occurred while appending text to the file.");
	            e.printStackTrace();
	        }
	    }
	
	/**
	 * This number is here for model snapshot storing purpose<br>
	 * It needs to be changed when this class gets changed
	 */ 
	private static final long serialVersionUID = 1L;

}]]></Text>
		</JavaClass>
		<!--   =========   Java Class   ========  -->
		<JavaClass>
			<Id>1698132781110</Id>
			<Name><![CDATA[ProblemFoundException]]></Name>
			<Text><![CDATA[
class ProblemFoundException extends Exception {
    public ProblemFoundException(String message) {
        super(message);
    }
}]]></Text>
		</JavaClass>
		<!--   =========   Java Class   ========  -->
		<JavaClass>
			<Id>1709207930230</Id>
			<Name><![CDATA[ConWip]]></Name>
			<Text><![CDATA[import java.util.HashSet;
import java.util.List;
import java.util.Set;
import java.util.stream.*;
import one.util.streamex.StreamEx;
import java.util.stream.*;
import org.eclipse.jetty.client.api.Response.DemandedContentListener;
import one.util.streamex.StreamEx;
import java.io.IOException;
import java.text.DecimalFormatSymbols;
import java.io.BufferedReader;
import java.io.FileReader;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.PrintWriter;
import java.io.IOException;
import java.text.SimpleDateFormat;
import org.h2.expression.aggregate.ListaggArguments;
import one.util.streamex.StreamEx;
import simopt.ProductionOrder;
import simopt.MRP;


/**
 * ConWip
 */	
public class ConWip implements Serializable {

    /**
     * Default constructor
     */
    public ConWip() {
    }

	@Override
	public String toString() {
		return super.toString();
	}
		
	
	public void CreateProductionOrdersConWip(List<MRP> mrpTable, double time, int prodOrderId, List<Routing> routingList,
			SimulationParameter simParams, List<Item> items, Main main){
				
					
		for(MRP mrpPeriod : mrpTable.stream().filter(e -> e.getPlannedOrderReleases() > 0 && (e.getRunningPeriod() - e.getTime() ) <= simParams.getWaW()).collect(Collectors.toList())) {		
			double totalProcessingTime = 0;               		

			ProductionOrder order = new ProductionOrder();			
			int orderId = main.prodOrderId++;
			order.setOrderId(orderId);
			order.setItem(mrpPeriod.getItem());	
			
			int minimumRoutingStep = Routing.GetMinimumStep(routingList, order.getItem() , simParams);
			int maximumRoutingStep = Routing.GetMaximumStep(routingList, order.getItem() , simParams);
			
			
    		List<Routing> routingStepsOfItem = StreamEx.of(main.routings).filter(e -> e.getItem().getItem() == order.getItem().getItem()).collect(Collectors.toList());        		        		        
		
			order.setMinimumRoutingStep(minimumRoutingStep);
			order.setMaximumRoutingStep(maximumRoutingStep);			
			order.setCurrentRoutingStep(minimumRoutingStep);
			
			order.setQuantity(mrpPeriod.getPlannedOrderReleases());		
			
			order.setPlannedCapacity(Routing.GetPlannedCapacityPerItem(routingList, order.getItem(), simParams, order));
			order.setPlannedSetupTime(Routing.GetPlannedSetupTimePerItem(routingList, order.getItem(), simParams, order));
			
			order.setCreatedAt(time);			
			order.setPlannedStart(mrpPeriod.getRunningPeriod() + MRP.PERIOD_BALANCING);
			
			double earliestRelease = mrpPeriod.getRunningPeriod() - simParams.getWaW() + MRP.PERIOD_BALANCING;			
			
			order.setPlannedStartEarliestRelease(earliestRelease);
						
			if(MRP.FIXED_LEAD_TIME_FOR_PRODUCTIONORDERS==1) {
				order.setPlannedEnd(mrpPeriod.getRunningPeriod() + mrpPeriod.getItem().getLeadTime());
			}else {
				order.setPlannedEnd(mrpPeriod.getPlannedEnd());
			}
			
			order.setStatus(ProductionOrder.PRODUCTION_ORDER_STATUS_UNPROCESSED);
						
			
			Routing routingObject = main.routings.stream().filter(e -> e.getItem().getItem() == order.getItem().getItem() && e.getStep() == minimumRoutingStep).findFirst().get();			
			order.setRouting(routingObject);
    		
    		for(Routing r : routingStepsOfItem) {
    			totalProcessingTime += r.getESetupTime() + r.getEProcessingTime() * order.getQuantity();        			
    		}
    		        		    	
 		
    		if(order.getItem().getType().equalsIgnoreCase(Item.ITEM_TYPE_SALES)) {	        		
    			order.setWorkLoad(totalProcessingTime);
    		}	        		
    		
    		if(order.getItem().getType().equalsIgnoreCase(Item.ITEM_TYPE_COMPONENT)) {	        		
    			order.setWorkLoad(totalProcessingTime);
    		}
    		    			        
    		order.setConWipStatus(ProductionOrder.PRODUCTION_ORDER_CONWIP_STATUS_NOT_RELEASED);
    		order.setStatus(ProductionOrder.PRODUCTION_ORDER_CONWIP_STATUS_NOT_RELEASED);
			
    		if((order.getItem().getType().equalsIgnoreCase(Item.ITEM_TYPE_COMPONENT) && mrpPeriod.getRunningPeriod() - mrpPeriod.getTime() == 0) || 
    				(order.getItem().getType().equalsIgnoreCase(Item.ITEM_TYPE_SALES))) {    		
    			    		
    			main.productionOrders.add(order);								
    		}
		
		}//for										
	}
	
	
	public List<ProductionOrder> ApplyConWipPlanning(List<BOM> bomList, SimulationParameter simParam,OrderFuture off, CustomerOrder co, Main main, double time) {
						
		
		//Is list of all items and components required for customer order
		
		traceln("############################# Time --> " + time);
		
        
        traceln("----");
        List<ProductionOrder> conWipProdOrderList = new ArrayList();

        traceln("Current SystemWorkload: " + main.varSystemWorkload);
    	traceln("WipCap: " + main.simParams.getWipCap());
    	traceln("WaW: " + main.simParams.getWaW());
		   
		traceln("Size Customer Order: " + main.customerOrders.size());
		
		//for(CustomerOrder o : main.customerOrders) {
			//traceln("Due Dates: " + o.getOrderId() + " duedate: " + o.getDueDate());
		//}
		
		
        //List<ProductionOrder> sortedconWipProdOrderList  = StreamEx.of(conWipProdOrderList)
                //.sorted(Comparator.comparing(ProductionOrder::getPlannedEnd)).distinct(ProductionOrder::getParentProdOrderId).toList();				
		
		for(CustomerOrder custOrder : StreamEx.of(main.customerOrders).filter(e -> e.getConWipStatus() == CustomerOrder.ORDER_STATUS_UNPROCESSED &&
				e.getDueDate() <= main.simParams.getWaW() + time).sorted(Comparator.comparing(CustomerOrder::getDueDate)).collect(Collectors.toList())){
			
			double totalProcessingTime = 0;               		
	    	main.parentProdOrderId++;
	    	
	    	traceln("Customer Order Due Date: " + custOrder.getDueDate());
	    	traceln("Customer Order Id: " + custOrder.getOrderId());
	    	traceln("Customer Order qty: " + custOrder.getQuantity());
	    	
	    	custOrder.setConWipReleaseCheckAt(time);

	    	List<BOM> uniqueBOMs = BOM.getAggregatedBOMList(bomList, custOrder.getItem());
	    	
			for(BOM i : uniqueBOMs) {
	        	if(i.getItem().getType().equalsIgnoreCase(Item.ITEM_TYPE_SALES) || i.getItem().getType().equalsIgnoreCase(Item.ITEM_TYPE_COMPONENT)) {
	        
	        		ProductionOrder prodOrder = new ProductionOrder();
	        		prodOrder.setParentProdOrderId(main.parentProdOrderId);
	        		main.prodOrderId++;        		
	        		
	        		prodOrder.setOrderId(main.prodOrderId);
	        		prodOrder.setItem(i.getItem());
	        		prodOrder.setCreatedAt(time);
	        		
	        		prodOrder.setQuantity(custOrder.getQuantity() * i.getQuantity());
	        			        			        		
	        		prodOrder.setStatus(ProductionOrder.PRODUCTION_ORDER_STATUS_UNPROCESSED);
	        		
	        		List<Routing> routingStepsOfItem = StreamEx.of(main.routings).filter(e -> e.getItem().getItem() == prodOrder.getItem().getItem()).collect(Collectors.toList());        		        		        
	        		
	        		int minimumRoutingStep = Routing.GetMinimumStep(main.routings, prodOrder.getItem() , main.simParams);
	    			int maximumRoutingStep = Routing.GetMaximumStep(main.routings, prodOrder.getItem() , main.simParams);
	    			
	    			prodOrder.setMinimumRoutingStep(minimumRoutingStep);
	    			prodOrder.setMaximumRoutingStep(maximumRoutingStep);			
	    			prodOrder.setCurrentRoutingStep(minimumRoutingStep);
	        		
	    			Routing routingObject = main.routings.stream().filter(e -> e.getItem().getItem() == prodOrder.getItem().getItem() && e.getStep() == minimumRoutingStep).findFirst().get();			
	    			prodOrder.setRouting(routingObject);
	        		
	        		for(Routing r : routingStepsOfItem) {
	        			totalProcessingTime += r.getESetupTime() + r.getEProcessingTime() * prodOrder.getQuantity();        			
	        		}
	        		        		
	        		prodOrder.setCustomerOrderId(custOrder.getOrderId());
	        		prodOrder.setPlannedStart(time);
	        		prodOrder.setPlannedEnd(custOrder.getDueDate());
	        		conWipProdOrderList.add(prodOrder);
	                		        	
	        	}        	
        	}//for uniqueBomItems
			
			double tmpTotalProcessingTime = totalProcessingTime;
			conWipProdOrderList.stream()
            .filter(prodOrder -> prodOrder.getParentProdOrderId() == main.parentProdOrderId)
            .forEach(prodOrder -> prodOrder.setWorkLoad(tmpTotalProcessingTime));
			
			custOrder.setWorkLoad(tmpTotalProcessingTime);
			
		}//forCustomerOrders
				
        List<ProductionOrder> sortedconWipProdOrderList  = StreamEx.of(conWipProdOrderList)
                .sorted(Comparator.comparing(ProductionOrder::getPlannedEnd)).distinct(ProductionOrder::getParentProdOrderId).toList();						
        
        traceln("conwip Release of order:");
        traceln(ProductionOrder.GetCSVHeader());        
		for(ProductionOrder o : sortedconWipProdOrderList) {
			traceln(ProductionOrder.GetCSVString(o));			
		}
               
		for(ProductionOrder ordi : sortedconWipProdOrderList) {
			if((main.varSystemWorkload + ordi.getWorkLoad()) < main.simParams.getWipCap()) {
				main.varSystemWorkload += ordi.getWorkLoad();

			 	main.StatisticSystemWorkLoad.add(main.varSystemWorkload);
				
				//now add all the production orders positions to the final production order list
				
				List<ProductionOrder> ordersToAdd = StreamEx.of(conWipProdOrderList).filter(e -> e.getParentProdOrderId() == ordi.getParentProdOrderId()).toList();
				
				main.productionOrders.addAll(ordersToAdd);
				
				traceln("systemload: " + main.varSystemWorkload);
				
				main.customerOrders.stream()
			    .filter(customerOrder -> customerOrder.getOrderId() == ordi.getCustomerOrderId())
			    .forEach(customerOrder -> {
			        customerOrder.setConWipStatus(CustomerOrder.CONWIP_STATUS_RELEASED);
			        customerOrder.setConWipReleasedAt(time);
			        customerOrder.setProductionOrderId(ordi.getOrderId());
			    });															
			}else {
				break;
			}
		}
        

		// Step 1: Filter the unprocessed orders into a new list
		List<CustomerOrder> unprocessedOrders = main.customerOrders.stream()
		        .filter(e -> e.getConWipReleasedAt() <= 0)
		        .collect(Collectors.toList());

		// Step 2: Remove the unprocessed orders from the original list
		main.customerOrders.removeIf(e -> e.getConWipReleasedAt() <= 0);

		// Step 3: Sort the filtered list of unprocessed orders
		List<CustomerOrder> sortedUnprocessedOrders = unprocessedOrders.stream()
		        .sorted(Comparator.comparing(CustomerOrder::getDueDate))
		        .collect(Collectors.toList());

		// Step 4: Add the sorted unprocessed orders back to the original list
		main.customerOrders.addAll(sortedUnprocessedOrders);
		
		traceln("ConWipProdOrderSize: " + conWipProdOrderList.size());
		
        //traceln(ProductionOrder.GetCSVHeader());
        //for(ProductionOrder o : conWipProdOrderList) {
        	//traceln(ProductionOrder.GetCSVString(o));
        	
        //}	
        
		return null;	
		
	}
	
	

	
	/**
	 * This number is here for model snapshot storing purpose<br>
	 * It needs to be changed when this class gets changed
	 */ 
	private static final long serialVersionUID = 1L;

}]]></Text>
		</JavaClass>
		<!--   =========   Java Class   ========  -->
		<JavaClass>
			<Id>1636552273805</Id>
			<Name><![CDATA[SimulationParameters]]></Name>
			<Text><![CDATA[
import java.io.Serializable;
import java.sql.Connection;
import java.sql.SQLException;
import java.util.ArrayDeque;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Calendar;
import java.util.Collection;
import java.util.Collections;
import java.util.Comparator;
import java.util.Currency;
import java.util.Date;
import java.util.Enumeration;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Hashtable;
import java.util.Iterator;
import java.util.LinkedHashMap;
import java.util.LinkedHashSet;
import java.util.LinkedList;
import java.util.List;
import java.util.ListIterator;
import java.util.Locale;
import java.util.Map;
import java.util.PriorityQueue;
import java.util.Random;
import java.util.Set;
import java.util.SortedMap;
import java.util.SortedSet;
import java.util.Stack;
import java.util.Timer;
import java.util.TreeMap;
import java.util.TreeSet;
import java.util.Vector;
import java.awt.Color;
import java.awt.Font;
import com.anylogic.engine.connectivity.ResultSet;
import com.anylogic.engine.connectivity.Statement;
import com.anylogic.engine.elements.*;
import com.anylogic.engine.markup.Network;
import com.anylogic.engine.Position;
import com.anylogic.engine.markup.PedFlowStatistics;
import com.anylogic.engine.markup.DensityMap;


import static java.lang.Math.*;
import static com.anylogic.engine.UtilitiesArray.*;
import static com.anylogic.engine.UtilitiesCollection.*;
import static com.anylogic.engine.presentation.UtilitiesColor.*;
import static com.anylogic.engine.HyperArray.*;

import com.anylogic.engine.*;
import com.anylogic.engine.analysis.*;
import com.anylogic.engine.connectivity.*;
import com.anylogic.engine.database.*;
import com.anylogic.engine.gis.*;
import com.anylogic.engine.markup.*;
import com.anylogic.engine.routing.*;
import com.anylogic.engine.presentation.*;
import com.anylogic.engine.gui.*;

import com.anylogic.libraries.modules.markup_descriptors.*;
import com.anylogic.libraries.processmodeling.*;
import com.anylogic.libraries.pypeline.*;

import static com.anylogic.engine.Utilities.*;


import java.io.Serializable;
import java.sql.Connection;
import java.sql.SQLException;
import java.util.ArrayDeque;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Calendar;
import java.util.Collection;
import java.util.Collections;
import java.util.Comparator;
import java.util.Currency;
import java.util.Date;
import java.util.Enumeration;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Hashtable;
import java.util.Iterator;
import java.util.LinkedHashMap;
import java.util.LinkedHashSet;
import java.util.LinkedList;
import java.util.List;
import java.util.ListIterator;
import java.util.Locale;
import java.util.Map;
import java.util.PriorityQueue;
import java.util.Random;
import java.util.Set;
import java.util.SortedMap;
import java.util.SortedSet;
import java.util.Stack;
import java.util.Timer;
import java.util.TreeMap;
import java.util.TreeSet;
import java.util.Vector;
import java.awt.Color;
import java.awt.Font;
import com.anylogic.engine.connectivity.ResultSet;
import com.anylogic.engine.connectivity.Statement;
import com.anylogic.engine.elements.*;
import com.anylogic.engine.markup.Network;
import com.anylogic.engine.Position;
import com.anylogic.engine.markup.PedFlowStatistics;
import com.anylogic.engine.markup.DensityMap;


import static java.lang.Math.*;
import static com.anylogic.engine.UtilitiesArray.*;
import static com.anylogic.engine.UtilitiesCollection.*;
import static com.anylogic.engine.presentation.UtilitiesColor.*;
import static com.anylogic.engine.HyperArray.*;

import com.anylogic.engine.*;
import com.anylogic.engine.analysis.*;
import com.anylogic.engine.connectivity.*;
import com.anylogic.engine.database.*;
import com.anylogic.engine.gis.*;
import com.anylogic.engine.markup.*;
import com.anylogic.engine.routing.*;
import com.anylogic.engine.presentation.*;
import com.anylogic.engine.gui.*;

import com.anylogic.libraries.modules.markup_descriptors.*;
import com.anylogic.libraries.processmodeling.*;
import com.anylogic.libraries.pypeline.*;

import static com.anylogic.engine.Utilities.*;


import java.io.Serializable;
import java.sql.Connection;
import java.sql.SQLException;
import java.util.ArrayDeque;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Calendar;
import java.util.Collection;
import java.util.Collections;
import java.util.Comparator;
import java.util.Currency;
import java.util.Date;
import java.util.Enumeration;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Hashtable;
import java.util.Iterator;
import java.util.LinkedHashMap;
import java.util.LinkedHashSet;
import java.util.LinkedList;
import java.util.List;
import java.util.ListIterator;
import java.util.Locale;
import java.util.Map;
import java.util.PriorityQueue;
import java.util.Random;
import java.util.Set;
import java.util.SortedMap;
import java.util.SortedSet;
import java.util.Stack;
import java.util.Timer;
import java.util.TreeMap;
import java.util.TreeSet;
import java.util.Vector;
import java.awt.Color;
import java.awt.Font;
import com.anylogic.engine.connectivity.ResultSet;
import com.anylogic.engine.connectivity.Statement;
import com.anylogic.engine.elements.*;
import com.anylogic.engine.markup.Network;
import com.anylogic.engine.Position;
import com.anylogic.engine.markup.PedFlowStatistics;
import com.anylogic.engine.markup.DensityMap;


import static java.lang.Math.*;
import static com.anylogic.engine.UtilitiesArray.*;
import static com.anylogic.engine.UtilitiesCollection.*;
import static com.anylogic.engine.presentation.UtilitiesColor.*;
import static com.anylogic.engine.HyperArray.*;

import com.anylogic.engine.*;
import com.anylogic.engine.analysis.*;
import com.anylogic.engine.connectivity.*;
import com.anylogic.engine.database.*;
import com.anylogic.engine.gis.*;
import com.anylogic.engine.markup.*;
import com.anylogic.engine.routing.*;
import com.anylogic.engine.presentation.*;
import com.anylogic.engine.gui.*;

import com.anylogic.libraries.modules.markup_descriptors.*;
import com.anylogic.libraries.processmodeling.*;
import com.anylogic.libraries.pypeline.*;

import static com.anylogic.engine.Utilities.*;


import java.io.Serializable;
import java.sql.Connection;
import java.sql.SQLException;
import java.util.ArrayDeque;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Calendar;
import java.util.Collection;
import java.util.Collections;
import java.util.Comparator;
import java.util.Currency;
import java.util.Date;
import java.util.Enumeration;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Hashtable;
import java.util.Iterator;
import java.util.LinkedHashMap;
import java.util.LinkedHashSet;
import java.util.LinkedList;
import java.util.List;
import java.util.ListIterator;
import java.util.Locale;
import java.util.Map;
import java.util.PriorityQueue;
import java.util.Random;
import java.util.Set;
import java.util.SortedMap;
import java.util.SortedSet;
import java.util.Stack;
import java.util.Timer;
import java.util.TreeMap;
import java.util.TreeSet;
import java.util.Vector;
import java.awt.Color;
import java.awt.Font;
import com.anylogic.engine.connectivity.ResultSet;
import com.anylogic.engine.connectivity.Statement;
import com.anylogic.engine.elements.*;
import com.anylogic.engine.markup.Network;
import com.anylogic.engine.Position;
import com.anylogic.engine.markup.PedFlowStatistics;
import com.anylogic.engine.markup.DensityMap;


import static java.lang.Math.*;
import static com.anylogic.engine.UtilitiesArray.*;
import static com.anylogic.engine.UtilitiesCollection.*;
import static com.anylogic.engine.presentation.UtilitiesColor.*;
import static com.anylogic.engine.HyperArray.*;

import com.anylogic.engine.*;
import com.anylogic.engine.analysis.*;
import com.anylogic.engine.connectivity.*;
import com.anylogic.engine.database.*;
import com.anylogic.engine.gis.*;
import com.anylogic.engine.markup.*;
import com.anylogic.engine.routing.*;
import com.anylogic.engine.presentation.*;
import com.anylogic.engine.gui.*;

import com.anylogic.libraries.modules.markup_descriptors.*;
import com.anylogic.libraries.processmodeling.*;
import com.anylogic.libraries.pypeline.*;

import static com.anylogic.engine.Utilities.*;


import java.io.Serializable;
import java.sql.Connection;
import java.sql.SQLException;
import java.util.ArrayDeque;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Calendar;
import java.util.Collection;
import java.util.Collections;
import java.util.Comparator;
import java.util.Currency;
import java.util.Date;
import java.util.Enumeration;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Hashtable;
import java.util.Iterator;
import java.util.LinkedHashMap;
import java.util.LinkedHashSet;
import java.util.LinkedList;
import java.util.List;
import java.util.ListIterator;
import java.util.Locale;
import java.util.Map;
import java.util.PriorityQueue;
import java.util.Random;
import java.util.Set;
import java.util.SortedMap;
import java.util.SortedSet;
import java.util.Stack;
import java.util.Timer;
import java.util.TreeMap;
import java.util.TreeSet;
import java.util.Vector;
import java.awt.Color;
import java.awt.Font;
import com.anylogic.engine.connectivity.ResultSet;
import com.anylogic.engine.connectivity.Statement;
import com.anylogic.engine.elements.*;
import com.anylogic.engine.markup.Network;
import com.anylogic.engine.Position;
import com.anylogic.engine.markup.PedFlowStatistics;
import com.anylogic.engine.markup.DensityMap;


import static java.lang.Math.*;
import static com.anylogic.engine.UtilitiesArray.*;
import static com.anylogic.engine.UtilitiesCollection.*;
import static com.anylogic.engine.presentation.UtilitiesColor.*;
import static com.anylogic.engine.HyperArray.*;

import com.anylogic.engine.*;
import com.anylogic.engine.analysis.*;
import com.anylogic.engine.connectivity.*;
import com.anylogic.engine.database.*;
import com.anylogic.engine.gis.*;
import com.anylogic.engine.markup.*;
import com.anylogic.engine.routing.*;
import com.anylogic.engine.presentation.*;
import com.anylogic.engine.gui.*;

import com.anylogic.libraries.modules.markup_descriptors.*;
import com.anylogic.libraries.processmodeling.*;
import com.anylogic.libraries.pypeline.*;

import static com.anylogic.engine.Utilities.*;

//package simopt;

import java.io.Serializable;
import java.sql.Connection;
import java.sql.SQLException;
import java.util.ArrayDeque;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Calendar;
import java.util.Collection;
import java.util.Collections;
import java.util.Comparator;
import java.util.Currency;
import java.util.Date;
import java.util.Enumeration;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Hashtable;
import java.util.Iterator;
import java.util.LinkedHashMap;
import java.util.LinkedHashSet;
import java.util.LinkedList;
import java.util.List;
import java.util.ListIterator;
import java.util.Locale;
import java.util.Map;
import java.util.PriorityQueue;
import java.util.Random;
import java.util.Set;
import java.util.SortedMap;
import java.util.SortedSet;
import java.util.Stack;
import java.util.Timer;
import java.util.TreeMap;
import java.util.TreeSet;
import java.util.Vector;
import java.awt.Color;
import java.awt.Font;
import com.anylogic.engine.connectivity.ResultSet;
import com.anylogic.engine.connectivity.Statement;
import com.anylogic.engine.elements.*;
import com.anylogic.engine.markup.Network;
import com.anylogic.engine.Position;
import com.anylogic.engine.markup.PedFlowStatistics;
import com.anylogic.engine.markup.DensityMap;


import static java.lang.Math.*;
import static com.anylogic.engine.UtilitiesArray.*;
import static com.anylogic.engine.UtilitiesCollection.*;
import static com.anylogic.engine.presentation.UtilitiesColor.*;
import static com.anylogic.engine.HyperArray.*;

import com.anylogic.engine.*;
import com.anylogic.engine.analysis.*;
import com.anylogic.engine.connectivity.*;
import com.anylogic.engine.database.*;
import com.anylogic.engine.gis.*;
import com.anylogic.engine.markup.*;
import com.anylogic.engine.routing.*;
import com.anylogic.engine.presentation.*;
import com.anylogic.engine.gui.*;

import com.anylogic.libraries.modules.markup_descriptors.*;
import com.anylogic.libraries.processmodeling.*;
import com.anylogic.libraries.pypeline.*;

import static com.anylogic.engine.Utilities.*;

//package simopt;

import java.io.Serializable;
import java.sql.Connection;
import java.sql.SQLException;
import java.util.ArrayDeque;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Calendar;
import java.util.Collection;
import java.util.Collections;
import java.util.Comparator;
import java.util.Currency;
import java.util.Date;
import java.util.Enumeration;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Hashtable;
import java.util.Iterator;
import java.util.LinkedHashMap;
import java.util.LinkedHashSet;
import java.util.LinkedList;
import java.util.List;
import java.util.ListIterator;
import java.util.Locale;
import java.util.Map;
import java.util.PriorityQueue;
import java.util.Random;
import java.util.Set;
import java.util.SortedMap;
import java.util.SortedSet;
import java.util.Stack;
import java.util.Timer;
import java.util.TreeMap;
import java.util.TreeSet;
import java.util.Vector;
import java.awt.Color;
import java.awt.Font;
import com.anylogic.engine.connectivity.ResultSet;
import com.anylogic.engine.connectivity.Statement;
import com.anylogic.engine.elements.*;
import com.anylogic.engine.markup.Network;
import com.anylogic.engine.Position;
import com.anylogic.engine.markup.PedFlowStatistics;
import com.anylogic.engine.markup.DensityMap;


import static java.lang.Math.*;
import static com.anylogic.engine.UtilitiesArray.*;
import static com.anylogic.engine.UtilitiesCollection.*;
import static com.anylogic.engine.presentation.UtilitiesColor.*;
import static com.anylogic.engine.HyperArray.*;

import com.anylogic.engine.*;
import com.anylogic.engine.analysis.*;
import com.anylogic.engine.connectivity.*;
import com.anylogic.engine.database.*;
import com.anylogic.engine.gis.*;
import com.anylogic.engine.markup.*;
import com.anylogic.engine.routing.*;
import com.anylogic.engine.presentation.*;
import com.anylogic.engine.gui.*;

import com.anylogic.libraries.modules.markup_descriptors.*;
import com.anylogic.libraries.processmodeling.*;
import com.anylogic.libraries.pypeline.*;

import static com.anylogic.engine.Utilities.*;

//package simopt;

import java.io.Serializable;
import java.sql.Connection;
import java.sql.SQLException;
import java.util.ArrayDeque;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Calendar;
import java.util.Collection;
import java.util.Collections;
import java.util.Comparator;
import java.util.Currency;
import java.util.Date;
import java.util.Enumeration;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Hashtable;
import java.util.Iterator;
import java.util.LinkedHashMap;
import java.util.LinkedHashSet;
import java.util.LinkedList;
import java.util.List;
import java.util.ListIterator;
import java.util.Locale;
import java.util.Map;
import java.util.PriorityQueue;
import java.util.Random;
import java.util.Set;
import java.util.SortedMap;
import java.util.SortedSet;
import java.util.Stack;
import java.util.Timer;
import java.util.TreeMap;
import java.util.TreeSet;
import java.util.Vector;
import java.awt.Color;
import java.awt.Font;
import com.anylogic.engine.connectivity.ResultSet;
import com.anylogic.engine.connectivity.Statement;
import com.anylogic.engine.elements.*;
import com.anylogic.engine.markup.Network;
import com.anylogic.engine.Position;
import com.anylogic.engine.markup.PedFlowStatistics;
import com.anylogic.engine.markup.DensityMap;


import static java.lang.Math.*;
import static com.anylogic.engine.UtilitiesArray.*;
import static com.anylogic.engine.UtilitiesCollection.*;
import static com.anylogic.engine.presentation.UtilitiesColor.*;
import static com.anylogic.engine.HyperArray.*;

import com.anylogic.engine.*;
import com.anylogic.engine.analysis.*;
import com.anylogic.engine.connectivity.*;
import com.anylogic.engine.database.*;
import com.anylogic.engine.gis.*;
import com.anylogic.engine.markup.*;
import com.anylogic.engine.routing.*;
import com.anylogic.engine.presentation.*;
import com.anylogic.engine.gui.*;

import com.anylogic.libraries.modules.markup_descriptors.*;
import com.anylogic.libraries.processmodeling.*;
import com.anylogic.libraries.pypeline.*;

import static com.anylogic.engine.Utilities.*;

//package simopt;

import java.io.Serializable;
import java.sql.Connection;
import java.sql.SQLException;
import java.util.ArrayDeque;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Calendar;
import java.util.Collection;
import java.util.Collections;
import java.util.Comparator;
import java.util.Currency;
import java.util.Date;
import java.util.Enumeration;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Hashtable;
import java.util.Iterator;
import java.util.LinkedHashMap;
import java.util.LinkedHashSet;
import java.util.LinkedList;
import java.util.List;
import java.util.ListIterator;
import java.util.Locale;
import java.util.Map;
import java.util.PriorityQueue;
import java.util.Random;
import java.util.Set;
import java.util.SortedMap;
import java.util.SortedSet;
import java.util.Stack;
import java.util.Timer;
import java.util.TreeMap;
import java.util.TreeSet;
import java.util.Vector;
import java.awt.Color;
import java.awt.Font;
import com.anylogic.engine.connectivity.ResultSet;
import com.anylogic.engine.connectivity.Statement;
import com.anylogic.engine.elements.*;
import com.anylogic.engine.markup.Network;
import com.anylogic.engine.Position;
import com.anylogic.engine.markup.PedFlowStatistics;
import com.anylogic.engine.markup.DensityMap;


import static java.lang.Math.*;
import static com.anylogic.engine.UtilitiesArray.*;
import static com.anylogic.engine.UtilitiesCollection.*;
import static com.anylogic.engine.presentation.UtilitiesColor.*;
import static com.anylogic.engine.HyperArray.*;

import com.anylogic.engine.*;
import com.anylogic.engine.analysis.*;
import com.anylogic.engine.connectivity.*;
import com.anylogic.engine.database.*;
import com.anylogic.engine.gis.*;
import com.anylogic.engine.markup.*;
import com.anylogic.engine.routing.*;
import com.anylogic.engine.presentation.*;
import com.anylogic.engine.gui.*;

import com.anylogic.libraries.modules.markup_descriptors.*;
import com.anylogic.libraries.processmodeling.*;
import com.anylogic.libraries.pypeline.*;

import static com.anylogic.engine.Utilities.*;

//package simopt;

import java.io.Serializable;
import java.sql.Connection;
import java.sql.SQLException;
import java.util.ArrayDeque;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Calendar;
import java.util.Collection;
import java.util.Collections;
import java.util.Comparator;
import java.util.Currency;
import java.util.Date;
import java.util.Enumeration;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Hashtable;
import java.util.Iterator;
import java.util.LinkedHashMap;
import java.util.LinkedHashSet;
import java.util.LinkedList;
import java.util.List;
import java.util.ListIterator;
import java.util.Locale;
import java.util.Map;
import java.util.PriorityQueue;
import java.util.Random;
import java.util.Set;
import java.util.SortedMap;
import java.util.SortedSet;
import java.util.Stack;
import java.util.Timer;
import java.util.TreeMap;
import java.util.TreeSet;
import java.util.Vector;
import java.awt.Color;
import java.awt.Font;
import com.anylogic.engine.connectivity.ResultSet;
import com.anylogic.engine.connectivity.Statement;
import com.anylogic.engine.elements.*;
import com.anylogic.engine.markup.Network;
import com.anylogic.engine.Position;
import com.anylogic.engine.markup.PedFlowStatistics;
import com.anylogic.engine.markup.DensityMap;


import static java.lang.Math.*;
import static com.anylogic.engine.UtilitiesArray.*;
import static com.anylogic.engine.UtilitiesCollection.*;
import static com.anylogic.engine.presentation.UtilitiesColor.*;
import static com.anylogic.engine.HyperArray.*;

import com.anylogic.engine.*;
import com.anylogic.engine.analysis.*;
import com.anylogic.engine.connectivity.*;
import com.anylogic.engine.database.*;
import com.anylogic.engine.gis.*;
import com.anylogic.engine.markup.*;
import com.anylogic.engine.routing.*;
import com.anylogic.engine.presentation.*;
import com.anylogic.engine.gui.*;

import com.anylogic.libraries.modules.markup_descriptors.*;
import com.anylogic.libraries.processmodeling.*;
import com.anylogic.libraries.pypeline.*;

import static com.anylogic.engine.Utilities.*;

//package simopt;

import java.io.Serializable;

/**
 * SimulationParameters
 */
public class SimulationParameters implements Serializable {

    private static final long serialVersionUID = 1L; // For model snapshot storing purposes

    private String experiment;

    private static SimulationParameters singleInstance = null;

    // Private constructor to enforce singleton pattern
    private SimulationParameters() {
        experiment = "Test";
    }

    // Static method to get the singleton instance
    public static SimulationParameters getInstance() {
        if (singleInstance == null) {
            singleInstance = new SimulationParameters();
        }
        return singleInstance;
    }

    // Getter for the experiment field
    public String getExperiment() {
        return experiment;
    }

    // Setter for the experiment field
    public void setExperiment(String experiment) {
        this.experiment = experiment;
    }
}
 
 
 
 
 
 
 
 
 
 
 
]]></Text>
		</JavaClass>
		<!--   =========   Java Class   ========  -->
		<JavaClass>
			<Id>1712649697556</Id>
			<Name><![CDATA[EnergyPrice]]></Name>
			<Text><![CDATA[import org.apache.poi.ss.usermodel.*;
import org.apache.poi.xssf.usermodel.XSSFWorkbook;

import java.io.File;
import java.io.FileInputStream;
import java.util.ArrayList;
import java.util.List;

/**
 * EnergyPrice
 */	
public class EnergyPrice implements Serializable {

	
	 private int month;
	    private int hour;
	    private double price;

	    // Getter for month
	    public int getMonth() {
	        return month;
	    }

	    // Setter for month
	    public void setMonth(int month) {
	        this.month = month;
	    }

	    // Getter for hour
	    public int getHour() {
	        return hour;
	    }

	    // Setter for hour
	    public void setHour(int hour) {
	        this.hour = hour;
	    }

	    // Getter for price
	    public double getPrice() {
	        return price;
	    }

	    // Setter for price
	    public void setPrice(double price) {
	        this.price = price;
	    }
	
    /**
     * Default constructor
     */
    public EnergyPrice() {
    }
    
    public EnergyPrice(int month, int hour, double price) {
        this.month = month;
        this.hour = hour;
        this.price = price;
    }

    
    public EnergyPrice(int month, double price) {
        this.month = month;
        this.price = price;
    }
    
    public static void GetEnergyPrices(Main main) {
    	
        String filePath = main.simParams.getLocationEnergyPricesInputExcel();
        

        try {
            FileInputStream excelFile = new FileInputStream(new File(filePath));
            Workbook workbook = new XSSFWorkbook(excelFile);
            Sheet sheet = workbook.getSheet("InputDataSim");

            List<EnergyPrice> energyPrices = new ArrayList<>();

            // Assuming the first row is headers and actual data starts from the second row
            for (int rowNum = 1; rowNum <= sheet.getLastRowNum(); rowNum++) {
                Row row = sheet.getRow(rowNum);
                int month = (int) row.getCell(0).getNumericCellValue();
                int hour = (int) row.getCell(1).getNumericCellValue();
                double price = row.getCell(2).getNumericCellValue();

                energyPrices.add(new EnergyPrice(month, hour, price));
            }

            main.EnergyPrices.addAll(energyPrices);
            
            // Here you can use the read data as needed, for now we'll just print it
            //traceln("Month;Hour;Price");
            //for (EnergyPrice data : energyPrices) {
              //  System.out.println(data.getMonth() + ";" + data.getHour() + ";" + data.getPrice());
            //}

            workbook.close();
            excelFile.close();
        } catch (Exception e) {
            e.printStackTrace();
        }    	    
    }
    
    public static void GetEnergyPricesPerMonth(Main main) {
    	
        String filePath = main.simParams.getLocationEnergyPricesInputExcel();
        

        try {
            FileInputStream excelFile = new FileInputStream(new File(filePath));
            Workbook workbook = new XSSFWorkbook(excelFile);
            Sheet sheet = workbook.getSheet("InputDataSimAverages");

            List<EnergyPrice> energyPrices = new ArrayList<>();

            // Assuming the first row is headers and actual data starts from the second row
            for (int rowNum = 1; rowNum <= sheet.getLastRowNum(); rowNum++) {
                Row row = sheet.getRow(rowNum);
                int month = (int) row.getCell(0).getNumericCellValue();
                double price = row.getCell(1).getNumericCellValue();

                energyPrices.add(new EnergyPrice(month, price));
            }

            main.EnergyPricesPerMonth.addAll(energyPrices);
            
            // Here you can use the read data as needed, for now we'll just print it
            //traceln("Month;Hour;Price");
            //for (EnergyPrice data : energyPrices) {
               // System.out.println(data.getMonth() + ";" + ";" + data.getPrice());
            //}

            workbook.close();
            excelFile.close();
        } catch (Exception e) {
            e.printStackTrace();
        }    	    
    }
    
    
    public static double GetEnergyPrice(Main main) {
    	
    	EnergyPrice energyPrice = main.EnergyPrices.stream().filter(e -> e.getMonth() == (main.getMonth() + 1) 
    			&& e.getHour() == main.getHourOfDay()).findFirst().get();    	
    	
    	return energyPrice.getPrice();
    	
    }

	@Override
	public String toString() {
		return super.toString();
	}

	/**
	 * This number is here for model snapshot storing purpose<br>
	 * It needs to be changed when this class gets changed
	 */ 
	private static final long serialVersionUID = 1L;

}]]></Text>
		</JavaClass>
		<!--   =========   Java Class   ========  -->
		<JavaClass>
			<Id>1712671662987</Id>
			<Name><![CDATA[EnergyRelease]]></Name>
			<Text><![CDATA[import java.time.Duration;
import java.time.temporal.ChronoUnit;
/**
 * EnergyRelease
 */	
public class EnergyRelease implements Serializable {

    /**
     * Default constructor
     */
    public EnergyRelease() {
    }

    
    public static boolean EnergyBasedReleasesBlockIt(Main main, double time) {
    	
    	boolean releaseToMachineDelay = false;
    	
    	//traceln("Test Energy Release at: " + time + " Month " + (main.getMonth() + 1) + " Hours " + main.getHourOfDay());
    	
    	EnergyPrice treshold = main.EnergyPricesPerMonth.stream().filter(e -> (e.getMonth() == (main.getMonth() + 1))).findFirst().get();    	
    	
    	EnergyPrice priceToCompare = main.EnergyPrices.stream().filter(e -> e.getMonth() == (main.getMonth() + 1) && e.getHour() == main.getHourOfDay()).findFirst().get();    	
    	
    	//traceln("Test Production Order " + prodOrder.getOrderId() + " item " + prodOrder.getItem().getItem() + " current step " + prodOrder.getCurrentRoutingStep() + " max step " + prodOrder.getMaximumRoutingStep());
    	//traceln("Info Head Production Order " + ProductionOrder.GetCSVHeader());
    	//traceln("Info Tested Production Order " + ProductionOrder.GetCSVString(prodOrder));    	
    	
    	//for(ProductionOrder order : main.productionOrders.stream().filter(e -> e.getStatus() == ProductionOrder.PRODUCTION_ORDER_ENERGY_NOT_RELEASED))
    		    
    	// immer wenn ein aufrag in die maschine will machen wir die berprfung
    	// wenn wir darber sind wir sollen warten, dann nach 1h wieder den release berprfen
    	
    	double finalEnergyTresholdToCompare = treshold.getPrice() * main.simParams.getEnergyPriceFactor();
    	//traceln("Final energy treshold: " + finalEnergyTresholdToCompare + " Factor " + main.simParams.getEnergyPriceFactor() + " AverageEnergyPrice " + treshold.getPrice());
    	
    	//traceln("In ReleaseMethod: Months " +( main.getMonth() + 1)+ " hours " + main.getHourOfDay() + "Price to compare: " + priceToCompare.getPrice() + " < " + finalEnergyTresholdToCompare);
    	
    	if(priceToCompare.getPrice() < (finalEnergyTresholdToCompare)) {
    		//todo: release the order, the machine should work like a wahnsinniger, the created production order should be released. 
    		releaseToMachineDelay = true;
    	}else {    		    		    	    	
    		//verzgere Anlage bei der Abarbeitung    		    		   
    		releaseToMachineDelay = false;

    	}    	 
    	
    	return releaseToMachineDelay;
    }
        
    
	@Override
	public String toString() {
		return super.toString();
	}

	
	/**
	 * This number is here for model snapshot storing purpose<br>
	 * It needs to be changed when this class gets changed
	 */ 
	private static final long serialVersionUID = 1L;

}]]></Text>
		</JavaClass>
		<!--   =========   Java Class   ========  -->
		<JavaClass>
			<Id>1719828102993</Id>
			<Name><![CDATA[InterArrivalTime]]></Name>
			<Text><![CDATA[/**
 * InterArrivalTime
 */	
public class InterArrivalTime implements Serializable {

    /**
     * Default constructor
     */
    public InterArrivalTime() {
    }

    private int id;
    private int item;
    private String experiment;
    private int status;
    private double probabilityOfItem;
    private double meanOrderAmount;
    private double varCoeOrderAmount;
    private double leadTimeFixPart;
    private double meanLeadTimeVariablePart;
    private double varCoeLeadTimeVariablePart;
    private String demandScenario;

    // Getter and Setter for id
    public int getId() {
        return id;
    }

    public void setId(int id) {
        this.id = id;
    }

    // Getter and Setter for item
    public int getItem() {
        return item;
    }

    public void setItem(int item) {
        this.item = item;
    }

    // Getter and Setter for experiment
    public String getExperiment() {
        return experiment;
    }

    public void setExperiment(String experiment) {
        this.experiment = experiment;
    }

    // Getter and Setter for status
    public int getStatus() {
        return status;
    }

    public void setStatus(int status) {
        this.status = status;
    }
    
    // Getter and Setter for probabilityOfItem
    public double getProbabilityOfItem() {
        return probabilityOfItem;
    }

    public void setProbabilityOfItem(double probabilityOfItem) {
        this.probabilityOfItem = probabilityOfItem;
    }

    // Getter and Setter for meanOrderAmount
    public double getMeanOrderAmount() {
        return meanOrderAmount;
    }

    public void setMeanOrderAmount(double meanOrderAmount) {
        this.meanOrderAmount = meanOrderAmount;
    }

    // Getter and Setter for varCoeOrderAmount
    public double getVarCoeOrderAmount() {
        return varCoeOrderAmount;
    }

    public void setVarCoeOrderAmount(double varCoeOrderAmount) {
        this.varCoeOrderAmount = varCoeOrderAmount;
    }

    // Getter and Setter for leadTimeFixPart
    public double getLeadTimeFixPart() {
        return leadTimeFixPart;
    }

    public void setLeadTimeFixPart(double leadTimeFixPart) {
        this.leadTimeFixPart = leadTimeFixPart;
    }

    // Getter and Setter for meanLeadTimeVariablePart
    public double getMeanLeadTimeVariablePart() {
        return meanLeadTimeVariablePart;
    }

    public void setMeanLeadTimeVariablePart(double meanLeadTimeVariablePart) {
        this.meanLeadTimeVariablePart = meanLeadTimeVariablePart;
    }

    // Getter and Setter for varCoeLeadTimeVariablePart
    public double getVarCoeLeadTimeVariablePart() {
        return varCoeLeadTimeVariablePart;
    }

    public void setVarCoeLeadTimeVariablePart(double varCoeLeadTimeVariablePart) {
        this.varCoeLeadTimeVariablePart = varCoeLeadTimeVariablePart;
    }
    
    public String getDemandScenario() {
        return demandScenario;
    }

    public void setDemandScenario(String value) {
        this.demandScenario = value;
    }
    
    
	@Override
	public String toString() {
		return super.toString();
	}

	/**
	 * This number is here for model snapshot storing purpose<br>
	 * It needs to be changed when this class gets changed
	 */ 
	private static final long serialVersionUID = 1L;

}]]></Text>
		</JavaClass>
		<!--   =========   Java Class   ========  -->
		<JavaClass>
			<Id>1719831555049</Id>
			<Name><![CDATA[RandomItemSelector]]></Name>
			<Text><![CDATA[import java.util.HashMap;
import java.util.Map;
import java.util.Random;
import java.io.Serializable;
 
public class RandomItemSelector implements Serializable {
    /**
     * This number is here for model snapshot storing purpose<br>
     * It needs to be changed when this class gets changed
     */ 
    private static final long serialVersionUID = 1L;
 
    public static int rand(int min, int max, Random random) {
        if (min > max || (max - min + 1 > Integer.MAX_VALUE)) {
            throw new IllegalArgumentException("Invalid range");
        }
 
        return random.nextInt(max - min + 1) + min;
    }
 
    // Function to generate random nums from a list according to the
    // given probabilities
    public static int random(int[] nums, double[] probability, Random random) {
        int n = nums.length;
        if (n != probability.length) {
            return -1;        // error
        }
 
        // construct a sum array from the given probabilities
        double[] probSum = new double[n];
 
        // `probSum[i]` holds the cumulative sum of probabilities up to `i`
        probSum[0] = probability[0];
        for (int i = 1; i < n; i++) {
            probSum[i] = probSum[i - 1] + probability[i];
        }
 
        // generate a random double between 0 and the maximum sum
        double r = random.nextDouble() * probSum[n - 1];
 
        // find the index where `r` falls in the cumulative probability array
        int index = 0;
        while (index < n && r > probSum[index]) {
            index++;
        }
 
        // return the corresponding element from the input list
        return nums[index];
    }
 
    public RandomItemSelector() {
    }
 
    @Override
    public String toString() {
        return super.toString();
    }
}]]></Text>
		</JavaClass>
		<!--   =========   Java Class   ========  -->
		<JavaClass>
			<Id>1721801121844</Id>
			<Name><![CDATA[ExcelWriter]]></Name>
			<Text><![CDATA[import org.apache.poi.ss.usermodel.*;
import org.apache.poi.xssf.usermodel.XSSFWorkbook;

import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;
import java.util.*;

public class ExcelWriter {

    public void writeOutputToExcel(String header, String data, String filePath, String sheetName, Set<String> excludeColumns) {
        Workbook workbook;
        Sheet sheet;
        boolean sheetExists = false;

        File file = new File(filePath);
        if (file.exists()) {
            try (FileInputStream fileIn = new FileInputStream(file)) {
                workbook = new XSSFWorkbook(fileIn);
            } catch (IOException e) {
                e.printStackTrace();
                return;
            }
        } else {
            workbook = new XSSFWorkbook();
        }

        // Check if sheet already exists
        for (int i = 0; i < workbook.getNumberOfSheets(); i++) {
            if (workbook.getSheetName(i).equals(sheetName)) {
                sheetExists = true;
                break;
            }
        }

        Map<Integer, String> headersMap = new LinkedHashMap<>();
        List<Integer> excludeIndices = new ArrayList<>();
        String[] headers = header.split("\t");
        for (int i = 1, columnIndex = 0; i < headers.length; i++) { // Start from 1 to skip the leading empty string
            if (!excludeColumns.contains(headers[i])) {
                headersMap.put(columnIndex++, headers[i]);
            } else {
                excludeIndices.add(i - 1); // Add the index to the exclude list
            }
        }

        if (sheetExists) {
            sheet = workbook.getSheet(sheetName);
        } else {
            sheet = workbook.createSheet(sheetName);

            // Create header row
            Row headerRow = sheet.createRow(0);
            for (Map.Entry<Integer, String> entry : headersMap.entrySet()) {
                Cell cell = headerRow.createCell(entry.getKey());
                cell.setCellValue(entry.getValue());
            }
        }

        // Find the last row to append the new data
        int lastRowNum = sheet.getLastRowNum();
        Row dataRow = sheet.createRow(lastRowNum + 1);
        String[] values = data.split("\t");
        for (int i = 1, columnIndex = 0; i < values.length; i++) { // Start from 1 to skip the leading empty string
            if (!excludeIndices.contains(i - 1)) { // Check if this index is not in the exclude list
                Cell cell = dataRow.createCell(columnIndex++);
                String value = values[i];
                if (isNumeric(value)) {
                    cell.setCellValue(Double.parseDouble(value));
                } else {
                    cell.setCellValue(value);
                }
            }
        }

        // Write the output to an Excel file
        try (FileOutputStream fileOut = new FileOutputStream(filePath)) {
            workbook.write(fileOut);
            workbook.close();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    // Helper method to check if a string is numeric
    private boolean isNumeric(String str) {
        try {
            Double.parseDouble(str);
            return true;
        } catch (NumberFormatException e) {
            return false;
        }
    }
}
]]></Text>
		</JavaClass>
		<!--   =========   Java Class   ========  -->
		<JavaClass>
			<Id>1723007305110</Id>
			<Name><![CDATA[ItemRelaxedStatus]]></Name>
			<Text><![CDATA[/**
 * ItemRelaxedStatus
 */	
public class ItemRelaxedStatus implements Serializable {

    /**
     * Default constructor
     */
    public ItemRelaxedStatus() {
    }

    private Item item;
    private int status;
    private double quantity;
    private double time;
    private double period;

    // Getter and Setter for item
    public Item getItem() {
        return item;
    }

    public void setItem(Item item) {
        this.item = item;
    }

    // Getter and Setter for status
    public int getStatus() {
        return status;
    }

    public void setStatus(int status) {
        this.status = status;
    }

    // Getter and Setter for quantity
    public double getQuantity() {
        return quantity;
    }

    public void setQuantity(double quantity) {
        this.quantity = quantity;
    }

    // Getter and Setter for time
    public double getTime() {
        return time;
    }

    public void setTime(double time) {
        this.time = time;
    }

    // Getter and Setter for period
    public double getPeriod() {
        return period;
    }

    public void setPeriod(double period) {
        this.period = period;
    }
    
    
	@Override
	public String toString() {
		return super.toString();
	}

	/**
	 * This number is here for model snapshot storing purpose<br>
	 * It needs to be changed when this class gets changed
	 */ 
	private static final long serialVersionUID = 1L;

}]]></Text>
		</JavaClass>
		<!--   =========   Java Class   ========  -->
		<JavaClass>
			<Id>1724696842620</Id>
			<Name><![CDATA[SimHeuristic]]></Name>
			<Text><![CDATA[/**
 * SimHeuristic
 */
import org.apache.commons.math3.*;
import org.apache.commons.math3.stat.descriptive.DescriptiveStatistics;
import org.apache.commons.math3.distribution.NormalDistribution;
import java.sql.DriverManager;
import java.sql.SQLException;
import java.sql.Connection; 
import org.apache.commons.math3.stat.descriptive.rank.*;
import java.util.Arrays;
import java.util.List;
import java.io.*;
import java.net.*;
import java.util.Optional;


import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.SQLException;
import java.util.ArrayList;
import java.util.List;


public class SimHeuristic implements Serializable {

	static final String JDBC_DRIVER = "org.h2.Driver"; 		 
	
	//  Database credentials 
	static final String USER = "sa"; 
	static final String PASS = "simgen"; 
	
	public static final String REPLICATION_STATUS_TO_INCLUDE = "0";

	public static final String mat101 = "101";
	public static final String mat102 = "102";
	public static final String mat103 = "103";
	public static final String mat104 = "104";
	public static final String mat105 = "105";
	public static final String mat106 = "106";
	public static final String mat107 = "107";
	public static final String mat108 = "108";
	public static final String mat201 = "201";
	public static final String mat202 = "202";
	public static final String mat301 = "301";

	public static List<String> materials = Arrays.asList(
		    SimHeuristic.mat101, SimHeuristic.mat102, 
		    SimHeuristic.mat103, SimHeuristic.mat104,
		    SimHeuristic.mat105, SimHeuristic.mat106,
		    SimHeuristic.mat107, SimHeuristic.mat108,
		    SimHeuristic.mat201, SimHeuristic.mat202,
		    SimHeuristic.mat301
		    // Add more materials here as needed
		);
	

	public static final double OUTLIERCORRECTION_UPPER_BOUND = 85;   
	public static final double OUTLIERCORRECTION_LOWER_BOUND = 15;   
	public static final double OUTLIERCORRECTION_START_FROM_REPLICATIONS = 5; //5 was default value   
	
	public static final boolean USE_FIXED_PARAMETERSET = false;
	public static final String FIXED_PARAMETERSET = "600.0;3.0;2.0;700.0;3.0;2.0;450.0;3.0;2.0;450.0;3.0;2.0;1800.0;20.0";
	
	public static final String FILE_RANGE_REDUCTION = "c:\\1\\Output\\RangeReduction.txt";
	public static final boolean FILE_RANGE_REDUCTION_WRITE = false;
			
	public static final String FILE_OUTLIER_CORRECTION = "c:\\1\\Output\\OutlierCorrection.txt";
	public static final boolean FILE_OUTLIER_CORRECTION_WRITE = false;

	public static final String FILE_CREDIT_RANGE_REDUCTION = "c:\\1\\Output\\CreditRangeReduction.txt";
	public static final boolean FILE_CREDIT_RANGE_REDUCTION_WRITE = false;

	public static final String FILE_CREDIT_SA = "c:\\1\\Output\\SimulatedAnnealing.txt";
	public static final boolean FILE_SA_REDUCTION_WRITE = false;
	
	public static final int MAX_V_PARAMETERS = 54;
	
	public static final String RESULT_TYPE_ITERATION = "ITERATION";
	public static final String RESULT_TYPE_VALUE = "VALUE";

		
	enum DistributionType {
		  TRIANGULAR,
		  UNIFORM
		}

	public static String defaultDistribution = DistributionType.TRIANGULAR.toString();
		
    /**
     * Default constructor
     */
    public SimHeuristic() {
    }

	@Override
	public String toString() {
		return super.toString();
	}

	public static String GetDBURL() {
		
		String fileName = "config.properties";
		String dbUrl = "";
		try {
			PropertyValues properties = new PropertyValues(fileName);
	
			//String host = properties.Host;
			String host = "";
			dbUrl = "jdbc:h2:tcp://"+host+"/~/simgen";
		}
		 catch(IOException ie) {
		            ie.printStackTrace();
		}  
		
		return dbUrl;
	}
	
		
	public static List<InputParameter> DistributionValues (List<InputParameter> inputList, int n, String distributionType, Random rand) {
		
		//Random rand = new Random(n); 								
				
		for(InputParameter item : inputList){

			traceln("Input for distribution " + distributionType + " " + item.toString() + " Rand " + rand);
							
				double newValue = 0;
				
				if(!distributionType.toUpperCase().equals(DistributionType.TRIANGULAR.toString()) 
						&& !distributionType.toUpperCase().equals(DistributionType.UNIFORM.toString()))
					distributionType = defaultDistribution;
				
				if(distributionType.toUpperCase().equals(DistributionType.TRIANGULAR.toString())) {
					traceln("Apply Triangular Distributio with LB: " + item.getLowerBound() + " UB: " + item.getUpperBound() + " Mod: " + item.getMod());
					newValue = Utilities.triangular(
							item.getLowerBound(),
							item.getUpperBound(),
							item.getMod(),
							rand);
				}
				
				if(distributionType.toUpperCase().equals(DistributionType.UNIFORM.toString())) {
					traceln("Apply Triangular Uniform.");

					newValue = Utilities.uniform(
							item.getLowerBound(),
							item.getUpperBound(),
							rand);
				}
				
				traceln("New Value Before HalfStep und Bound Check: " + newValue);
				
				if (item.getHalfSteps() == 1) {
		            // Round to the nearest 0.5
					newValue = Math.round(newValue * 2) / 2.0;
		        } else {
		            // Round to the nearest whole number
		        	newValue = Math.round(newValue);
		        }
				
				if(newValue > item.getUpperBound())
					newValue = item.getUpperBound();
				
				if(newValue < item.getLowerBound())
					newValue = item.getLowerBound();
				
				traceln("Final new value: " + newValue);			
				
				item.setValue(newValue);
				
				traceln("Output from distribution " + distributionType + " " + item.toString());

		}//for
		
		return inputList;
		
	}

	 public static double GetBestSolutionValue(String resultType, String simulationexperiment, 
	            SimulationParameter simParams, boolean parameterVariation, OptimizationParameter optParam) {
	        double bestSolution = 0;
	        String sqlQuery = "SELECT AVG(overallcosts_inkl_not_Delivered) AS minOverallCosts, iteration, " +
	                          "COUNT(replication) AS replicationCount " +
	                          "FROM  \"RESULT\" WHERE simulationexperiment = ? AND optimizationparameter = ? " +
	                          "AND replicationstatus IN (" + REPLICATION_STATUS_TO_INCLUDE + ") " +
	                          "GROUP BY iteration HAVING COUNT(replication) = ? " +
	                          "ORDER BY minOverallCosts ASC LIMIT 1";

	        try {
	            DBQueries db = new DBQueries();
	            Connection connection = parameterVariation && simParams.getOptimizationParameterSource()
	                    .equalsIgnoreCase(SimulationParameter.OPTIMIZATION_PARAMETER_SOURCE_POSTGRES) 
	                    ? db.ConnectPostGreSql() : db.connect();

	            PreparedStatement pstmt = connection.prepareStatement(sqlQuery);
	            pstmt.setString(1, simulationexperiment);
	            pstmt.setInt(2, optParam.getId());
	            pstmt.setInt(3, optParam.getFixedNumberReplications());

	            System.out.println("SQL Query GetBestSolutionValue: " + pstmt.toString());

	            java.sql.ResultSet resultSet = pstmt.executeQuery();

	            if (resultSet.next()) {
	                bestSolution = resultSet.getDouble("minOverallCosts");
	                int replicationCount = resultSet.getInt("replicationCount");

	                if (replicationCount != optParam.getFixedNumberReplications()) {
	                    System.err.println(String.format("Error: Replication count mismatch. Expected %d, but got %d.",
	                            optParam.getFixedNumberReplications(), replicationCount));
	                    System.exit(1);
	                }

	                if (resultType.equalsIgnoreCase(RESULT_TYPE_ITERATION)) {
	                    bestSolution = resultSet.getDouble("iteration");
	                } else if (resultType.equalsIgnoreCase(RESULT_TYPE_VALUE)) {
	                    bestSolution = resultSet.getDouble("minOverallCosts");
	                }

	                System.out.println("Best Solution " + bestSolution + " Iteration " + resultSet.getDouble("iteration") + " for ResultType " + resultType);
	            }

	            resultSet.close();
	            pstmt.close();
	            connection.close();

	        } catch (SQLException | IOException e) {
	            System.err.println("SQL/IO error: " + e.getMessage());
	        }

	        return bestSolution;
	    }
	
	@Deprecated	
	public static double GetBestSolutionValue__OldVersion(String resultType, String simulationexperiment, 
			SimulationParameter simParams, boolean parameterVariation, OptimizationParameter optparam) {
		
	double bestSolution = 0;
	StringBuilder sqlQueryString = new StringBuilder();

          try {
		  DBQueries db = new DBQueries();

          java.sql.Connection connection = db.connect();            
		  
		  sqlQueryString.append("select avg(overallcosts_inkl_not_Delivered) as minOverallCosts, ");
		  sqlQueryString.append("iteration, count(replication) as replicationCount ");
		  sqlQueryString.append("from \"RESULT\" ");
		  sqlQueryString.append("where simulationexperiment = '" + simulationexperiment + "' and optimizationparameter=" + optparam.getId() + " ");
		  sqlQueryString.append("and replicationstatus in (" + REPLICATION_STATUS_TO_INCLUDE + ") ");
		  sqlQueryString.append("group by iteration ");
		  sqlQueryString.append("having count(replication) = " + optparam.getFixedNumberReplications() + " ");  // Filter for rows where replicationCount = 20
		  sqlQueryString.append("order by minOverallCosts asc ");
		  sqlQueryString.append("limit 1;");
		  
		  
          if (simParams.getOptimizationParameterSource().toUpperCase().equals(SimulationParameter.OPTIMIZATION_PARAMETER_SOURCE_POSTGRES) && parameterVariation) {
        	  connection = db.ConnectPostGreSql();   
          }
          		  
	      traceln("sqlString " + sqlQueryString.toString());
		  
		  java.sql.Statement statement = connection.createStatement();
	      java.sql.ResultSet resultSet = statement.executeQuery(sqlQueryString.toString());
	      	      
	      if (resultSet.next()) {
	    	  bestSolution = resultSet.getDouble("minOverallCosts");
	    	  
	    	    int replicationCount = resultSet.getInt("replicationCount"); // Retrieve the replication count
	    	    
	    	    if (replicationCount != optparam.getFixedNumberReplications()) {
	    	        //throw new IllegalStateException("Replication count is not " + optparam.getFixedNumberReplications() + ". Actual count: " + replicationCount);	    	        
	    	    	System.err.println(String.format("Error: Replication count mismatch. Expected %d, but got %d.",
	    	    	        optparam.getFixedNumberReplications(), replicationCount));
	    	    	    System.exit(1); // Exit the program with a non-zero status to indicate an error
 	    	        
	    	    }
	    	  
	    	  traceln("Best Solution " + bestSolution + " Iteration " + resultSet.getDouble("iteration") + " for ResultType " + resultType);
	    	  
	    	  //while (resultSet.next()) {
	    		    if (resultType.equalsIgnoreCase(RESULT_TYPE_ITERATION)) {
	    		    	traceln("Give back Iteration");
	    		        bestSolution = resultSet.getDouble("iteration");	    		      
	    		    } else if (resultType.equalsIgnoreCase(RESULT_TYPE_VALUE)) {
	    		    	traceln("Give back Value");
	    		        bestSolution = resultSet.getDouble("minOverallCosts");
	    		    }
	    		//}
	      }

	      connection.close();

	    } catch (Exception e) {
	      traceln("error:" + e);
	    }
		 
         traceln("Give Back BestSolution Value/Iteration: " + bestSolution); 
	return bestSolution;		   		   					
	
	}			
	
	

    public static double GetCurrentSolutionValue(int iteration, String simulationexperiment, SimulationParameter simParams, boolean parameterVariation, OptimizationParameter optParam) {
        double currentSolution = 0;
        String sqlQuery = "SELECT AVG(overallcosts_inkl_not_Delivered) AS currentSolution, COUNT(replication) AS replicationCount " +
                          "FROM \"RESULT\" WHERE simulationexperiment = ? AND iteration = ? AND optimizationparameter = ? " +
                          "AND replicationstatus IN (" + REPLICATION_STATUS_TO_INCLUDE + ")";

        try {
            DBQueries db = new DBQueries();
            Connection connection = parameterVariation && simParams.getOptimizationParameterSource()
                    .equalsIgnoreCase(SimulationParameter.OPTIMIZATION_PARAMETER_SOURCE_POSTGRES) 
                    ? db.ConnectPostGreSql() : db.connect();

            PreparedStatement pstmt = connection.prepareStatement(sqlQuery);
            pstmt.setString(1, simulationexperiment);
            pstmt.setInt(2, iteration);
            pstmt.setInt(3, optParam.getId());

            System.out.println("SQL Query GetCurrentSolutionValue: " + pstmt.toString());

            java.sql.ResultSet resultSet = pstmt.executeQuery();

            if (resultSet.next()) {
                currentSolution = resultSet.getDouble("currentSolution");
                System.out.println("GetCurrentSolutionValue: " + currentSolution);
            }

            resultSet.close();
            pstmt.close();
            connection.close();

        } catch (SQLException | IOException e) {
            System.err.println("SQL/IO error: " + e.getMessage());
        }

        return currentSolution;
    }
	
    @Deprecated
	public static double GetCurrentSolutionValue__OldVersion(int iteration, String simulationexperiment, SimulationParameter simParams, boolean parameterVariation, OptimizationParameter optParam) {
			
	double currentSolution = 0;	
	StringBuilder sqlQueryString = new StringBuilder();				
		
	try{				

		DBQueries db = new DBQueries();
        java.sql.Connection connection = db.connect();  
		
    	sqlQueryString.append("select avg(overallcosts_inkl_not_Delivered) as currentSolution, count(replication) as replicationCount  ");
    	sqlQueryString.append("from \"RESULT\" ");
    	sqlQueryString.append("where simulationexperiment = '" + simulationexperiment + "'  and iteration=" + iteration + " and optimizationparameter=" + optParam.getId() + " " );
    	sqlQueryString.append("and replicationstatus in ("  + REPLICATION_STATUS_TO_INCLUDE + ");" );
    	
        if (simParams.getOptimizationParameterSource().toUpperCase().equals(SimulationParameter.OPTIMIZATION_PARAMETER_SOURCE_POSTGRES) && parameterVariation) {        	
      	  connection = db.ConnectPostGreSql();   
        }
		//current solution
		  	
         traceln("sqlString " + sqlQueryString.toString());
		  
		  java.sql.Statement statement = connection.createStatement();
	      java.sql.ResultSet resultSet = statement.executeQuery(sqlQueryString.toString());
	      
		   while(resultSet.next()){
		    	currentSolution = resultSet.getDouble("currentSolution");	
		    	traceln("GetCurrentSolutionValue: " + currentSolution);
		   }

	      connection.close();

	    } catch (Exception e) {
	      traceln("error:" + e);
	    }
		 

	return currentSolution;
	
	}
	

    public static double GetCurrentSolutionValueIterationCount(int iteration, String simulationexperiment, SimulationParameter simParams, boolean parameterVariation, OptimizationParameter optParam) {
        double currentSolution = 0;
        String sqlQuery = "SELECT AVG(overallcosts_inkl_not_Delivered) AS currentSolution, COUNT(replication) AS replicationCount " +
                          "FROM \"RESULT\" WHERE simulationexperiment = ? AND iteration = ? AND optimizationparameter = ? " +
                          "AND replicationstatus IN (" + REPLICATION_STATUS_TO_INCLUDE + ") " +
                          "GROUP BY iteration";

        try {
            DBQueries db = new DBQueries();
            Connection connection = parameterVariation && simParams.getOptimizationParameterSource()
                    .equalsIgnoreCase(SimulationParameter.OPTIMIZATION_PARAMETER_SOURCE_POSTGRES) 
                    ? db.ConnectPostGreSql() : db.connect();

            PreparedStatement pstmt = connection.prepareStatement(sqlQuery);
            pstmt.setString(1, simulationexperiment);
            pstmt.setInt(2, iteration);
            pstmt.setInt(3, optParam.getId());

            System.out.println("SQL Query GetCurrentSolutionValueIterationCount: " + pstmt.toString());

            java.sql.ResultSet resultSet = pstmt.executeQuery();

            if (resultSet.next()) {
                currentSolution = resultSet.getDouble("replicationCount");
                System.out.println("GetCurrentSolutionValue Replication Count: " + currentSolution);
            }

            resultSet.close();
            pstmt.close();
            connection.close();

        } catch (SQLException | IOException e) {
            System.err.println("SQL/IO error: " + e.getMessage());
        }

        return currentSolution;
    }
	
	@Deprecated
	public static double GetCurrentSolutionValueIterationCount___OldVersion(int iteration, String simulationexperiment, SimulationParameter simParams, boolean parameterVariation, OptimizationParameter optParam) {
		
	double currentSolution = 0;	
	StringBuilder sqlQueryString = new StringBuilder();				
		
	try{				

		DBQueries db = new DBQueries();
        java.sql.Connection connection = db.connect();  
		
    	sqlQueryString.append("select avg(overallcosts_inkl_not_Delivered) as currentSolution, count(replication) as replicationCount  ");
    	sqlQueryString.append("from \"RESULT\" ");
    	sqlQueryString.append("where simulationexperiment = '" + simulationexperiment + "'  and iteration=" + iteration + " and optimizationparameter=" + optParam.getId() + " " );
    	sqlQueryString.append("and replicationstatus in ("  + REPLICATION_STATUS_TO_INCLUDE + ") " );
    	sqlQueryString.append("group by iteration; ");
  		
        if (simParams.getOptimizationParameterSource().toUpperCase().equals(SimulationParameter.OPTIMIZATION_PARAMETER_SOURCE_POSTGRES) && parameterVariation) {        	
      	  connection = db.ConnectPostGreSql();   
        }
		//current solution
		  	
         traceln("sqlString " + sqlQueryString.toString());
		  
		  java.sql.Statement statement = connection.createStatement();
	      java.sql.ResultSet resultSet = statement.executeQuery(sqlQueryString.toString());
	      
		   while(resultSet.next()){
		    	currentSolution = resultSet.getDouble("replicationCount");	
		    	traceln("GetCurrentSolutionValue Replication Count: " + currentSolution);
		   }

	      connection.close();

	    } catch (Exception e) {
	      traceln("error:" + e);
	    }
		 

	return currentSolution;
	
	}
	
	public static List<ResultObject> GetIterationBasedSolution(String simulationexperiment, int iteration, 
	        SimulationParameter simParams, boolean parameterVariation, OptimizationParameter optParam, int fallbackIteration) {

	    traceln("GetIterationBasedSolution For iteration " + iteration);
	    
	    String[] bestConfigurationString = null;
	    List<ResultObject> resultObjects = new ArrayList<>();

	    try {
	        // Attempt to fetch results
	        java.sql.ResultSet rs = fetchResults(simulationexperiment, iteration, simParams, parameterVariation, optParam);
	        
	        if (rs == null || !rs.isBeforeFirst()) { 
	            traceln("Apply FallbackIteration " + fallbackIteration +  " for iteration " + iteration + " No results returned by the query");
	                       
	            int bestSolutionIteration = (int) SimHeuristic.GetBestSolutionValue(RESULT_TYPE_ITERATION,
	            		simulationexperiment, simParams, parameterVariation, optParam);

		        rs = fetchResults(simulationexperiment, bestSolutionIteration, simParams, parameterVariation, optParam);  
	        }

	        while (rs.next()) {
	            traceln("optimizationparameter id: " + rs.getString("optimizationparameter") + " in while");

	            bestConfigurationString = SimHeuristic.USE_FIXED_PARAMETERSET 
	                    ? SimHeuristic.FIXED_PARAMETERSET.split(";") 
	                    : rs.getString("Optimization_String").split(";");

	            if (bestConfigurationString != null) {
	                for (String param : bestConfigurationString) {
	                    traceln(param);
	                }

	                for (int i = 0; i < bestConfigurationString.length; i++) {
	                    ResultObject resultObj = new ResultObject();
	                    int materialIndex = i / 5;
	                    String currentMaterial = SimHeuristic.materials.get(materialIndex);

	                    int parameterTypeIndex = i % 5;
	                    switch (parameterTypeIndex) {
	                        case 0: resultObj.setType(InputParameter.ParameterType.FOQLOTSIZE.toString()); break;
	                        case 1: resultObj.setType(InputParameter.ParameterType.LEADTIME.toString()); break;
	                        case 2: resultObj.setType(InputParameter.ParameterType.SAFETYSTOCK.toString()); break;
	                        case 3: resultObj.setType(InputParameter.ParameterType.WIPCAP.toString()); break;
	                        case 4: resultObj.setType(InputParameter.ParameterType.WAWBUFFER.toString()); break;
	                    }

	                    resultObj.setItem(currentMaterial);
	                    resultObj.setDoubleValue(Double.parseDouble(bestConfigurationString[i]));
	                    resultObjects.add(resultObj);
	                }
	            }
	        }
	    } catch (Exception e) {
	        System.out.println("error:" + e);
	    }

	    return resultObjects;
	}

    private static java.sql.ResultSet  fetchResults(String simulationexperiment, int iteration, 
            SimulationParameter simParams, boolean parameterVariation, OptimizationParameter optParam) throws SQLException, IOException {

        String sqlQuery = "SELECT AVG(overallcosts_inkl_not_Delivered) AS minOverallCosts, " +
                          "optimizationparameter, iteration, Optimization_String " +
                          "FROM \"RESULT\" WHERE simulationexperiment = ? AND iteration = ? " +
                          "AND optimizationparameter = ? AND replicationstatus IN (" + REPLICATION_STATUS_TO_INCLUDE + ") " +
                          "GROUP BY iteration, optimizationparameter, Optimization_String " +
                          "ORDER BY minOverallCosts ASC LIMIT 1";

        DBQueries db = new DBQueries();
        Connection connection = parameterVariation && simParams.getOptimizationParameterSource()
                .equalsIgnoreCase(SimulationParameter.OPTIMIZATION_PARAMETER_SOURCE_POSTGRES) 
                ? db.ConnectPostGreSql() : db.connect();

        PreparedStatement pstmt = connection.prepareStatement(sqlQuery);
        pstmt.setString(1, simulationexperiment);
        pstmt.setInt(2, iteration);
        pstmt.setInt(3, optParam.getId());

        System.out.println("SQL Query fetchResults: " + pstmt.toString());

        return pstmt.executeQuery();
    }


    
	@Deprecated
	private static java.sql.ResultSet fetchResults___Old(String simulationexperiment, int iteration, 
	        SimulationParameter simParams, boolean parameterVariation, OptimizationParameter optParam) throws SQLException {
	    
	    DBQueries db = new DBQueries();
	    java.sql.Connection connection = db.connect();
	    StringBuilder sqlQueryString = new StringBuilder();

	    try {	    	
		    sqlQueryString.append("select avg(overallcosts_inkl_not_Delivered) as minOverallCosts, optimizationparameter, iteration");
		    sqlQueryString.append(", Optimization_String ");
		    sqlQueryString.append("from \"RESULT\" ");
		    sqlQueryString.append("where simulationexperiment = '" + simulationexperiment + "' and iteration=" + iteration + " and optimizationparameter=" + optParam.getId() + " ");
		    sqlQueryString.append("and replicationstatus in (" + REPLICATION_STATUS_TO_INCLUDE + ") ");
		    sqlQueryString.append("group by iteration, optimizationparameter, Optimization_String ");
		    sqlQueryString.append("order by minOverallCosts asc ");
		    sqlQueryString.append("limit 1;");

	    if (simParams.getOptimizationParameterSource().toUpperCase().equals(SimulationParameter.OPTIMIZATION_PARAMETER_SOURCE_POSTGRES) && parameterVariation) {
	        connection = db.ConnectPostGreSql();
	    }

	    traceln("sqlString fetchResults: " + sqlQueryString.toString());

	    
    } catch (Exception e) {
        System.out.println("error:" + e);
    }
	    java.sql.Statement statement = connection.createStatement();

	    return statement.executeQuery(sqlQueryString.toString());
	}

	

		
	public static double[] getRange(double lb, double mid, double ub, double alpha, int iteration, 
	        String simulationexperiment, String parameterType, int optParamItem, List<Item> items) {        
	    
		traceln("Applied Alpha: " + alpha);
		traceln("Input for getRange: LB: " + lb + " MID(MOD): " + mid + " UB: " + ub + " Iteration: " + iteration);

	    double[] newRange = new double[2];
	                        
	    double range = (1 - alpha) * Math.abs(mid - ub);
	    
	    double newLowerBound = lb + alpha; //must be changed if we do not update the mid value!!!!!!!!!!!!!!!
	    
	    if (newLowerBound < 0)
	        newLowerBound = 0;
	    
	    traceln("getRange Check Item: " + optParamItem + " parameterType: " + parameterType + " Computed Range: " + range);
	    Optional<Item> optionalItem = items.stream().filter(e -> e.getItem() == optParamItem).findFirst();
	    
	    if(optionalItem.isPresent()) {
	        Item item = optionalItem.get();
    		traceln("Found item: " + Item.GetCSVString(item));

    // Handle FOQLOTSIZE parameter
    
    traceln("Lot Policy: " + item.getLotsizePolicy());
    		
    if (parameterType.equalsIgnoreCase(InputParameter.ParameterType.FOQLOTSIZE.toString())) {
    	
    	traceln("At lotpolicy Parametertype with Old Input Lowerbound lb: " + lb + " new Computed Lowerbound newLowerBound: " + newLowerBound);
    		
        if (item.getLotsizePolicy().equalsIgnoreCase("FOP")) {
            traceln("Changed FOP Lowerbound From " + newLowerBound);
            newLowerBound = Math.max(newLowerBound, 1);
            traceln("Changed FOP Lowerbound To " + newLowerBound);
        }

        if (item.getLotsizePolicy().equalsIgnoreCase("FOQ") || newLowerBound > 5) {
            traceln("Changed FOQ Lowerbound From " + newLowerBound);
            newLowerBound = Math.max(newLowerBound, 5.5);
            traceln("Changed FOQ Lowerbound To " + newLowerBound);
        }
    }
    
    // Handle LEADTIME parameter
    if (parameterType.equalsIgnoreCase(InputParameter.ParameterType.LEADTIME.toString())) {
        traceln("Changed Leadtime Lowerbound From " + newLowerBound);
        newLowerBound = Math.max(newLowerBound, 1);    
        traceln("Changed Leadtime Lowerbound To " + newLowerBound);
    }   
    
    // Handle SAFETYSTOCK parameter
    if (parameterType.equalsIgnoreCase(InputParameter.ParameterType.SAFETYSTOCK.toString())) {
        traceln("Changed Safetystock Lowerbound From " + newLowerBound);
        newLowerBound = Math.max(newLowerBound, 0);  // Adjust as per your logic
        traceln("Changed Safetystock Lowerbound To " + newLowerBound);
    }

    // Handle WIPCAP parameter
    if (parameterType.equalsIgnoreCase(InputParameter.ParameterType.WIPCAP.toString())) {
        traceln("Changed WIPCAP Lowerbound From " + newLowerBound);
        newLowerBound = Math.max(newLowerBound, 1);  // Adjust the lower bound logic as needed
        traceln("Changed WIPCAP Lowerbound To " + newLowerBound);
    }

    // Handle WAW parameter
    if (parameterType.equalsIgnoreCase(InputParameter.ParameterType.WAWBUFFER.toString())) {
        traceln("Changed WAW Lowerbound From " + newLowerBound);
        newLowerBound = Math.max(newLowerBound, 0);  // Adjust the lower bound logic as needed
        traceln("Changed WAW Lowerbound To " + newLowerBound);
    }

    double newUpperBound = ub - alpha;                                                        
    
    newRange[0] = newLowerBound;
    newRange[1] = newUpperBound;
    
    StringBuilder output = new StringBuilder();
    output.append("simulationexperiment " + simulationexperiment  + " Iteration " + iteration + " Range " + range + " Old LowerBound " + lb +  " New LowerBound " + newRange[0] + " Old UpperBound " + ub +  " New UpperBound " + newRange[1] + " Middle Value " + mid + " Alpha " + alpha);
    
    traceln(output.toString());
    
    WriteToFileAppend(FILE_RANGE_REDUCTION, output.toString(), FILE_RANGE_REDUCTION_WRITE);
    
    return newRange;
	    	
	    	
	    }else {
	    	
	    	traceln("Item "  + " is not part of productionsytem ");
	    	return null;
	    }	    
	}

		
public static List<InputParameter> SetBestSolutionForPopulation(String simulationexperiment, int range, 
			List<InputParameter> paramsInList, int simAnnealingActive,List<ResultObject> baseSol,
			double creditRangeReduction, double bestSoluationValue, int iteration, int replication, int minCBRRItems, 
			SimulationParameter simParams, boolean parameterVariation, OptimizationParameter optParam) {
	
		StringBuilder sqlQueryString = new StringBuilder();			
		StringBuilder output = new StringBuilder();
	    traceln("---------------------------- Heuristic 3 START ---------------------------");			
		try{													
	         //current solution
			DBQueries db = new DBQueries();
		      //Connection connection = db.ConnectH2();

			java.sql.Connection connection = db.connect();  
			
	         sqlQueryString.setLength(0);	
				
	         if(creditRangeReduction > 0) {
	        	 
	        	 int countResults = GetCountNumberSmallerCreditRange(simulationexperiment, bestSoluationValue, creditRangeReduction, simParams, parameterVariation, optParam.getId());
	        	 
	        	 if(countResults >= minCBRRItems) {	        	 

	        	          sqlQueryString.append("select optimizationparameter ,AVG(overallcosts_inkl_not_Delivered) AS avg_overallcosts  from \"RESULT\" ");
	        			  sqlQueryString.append("where simulationexperiment = '" + simulationexperiment + "' ");
	        		  	  sqlQueryString.append("and replicationstatus in ("  + REPLICATION_STATUS_TO_INCLUDE + ") " );

	        			  sqlQueryString.append("group by optimizationparameter ");
	        			  sqlQueryString.append("having avg_overallcosts < " + (bestSoluationValue + creditRangeReduction) + ";");
	        	        
	        	        if (simParams.getOptimizationParameterSource().toUpperCase().equals(SimulationParameter.OPTIMIZATION_PARAMETER_SOURCE_POSTGRES) && parameterVariation) {
	        	      	  connection = db.ConnectPostGreSql();   
	        	        }

	        		 
	        	 }else {
	        		 
	        	          sqlQueryString.append("select avg(overallcosts_inkl_not_Delivered) as minOverallCosts,*  from \"RESULT\" ");
	        			  sqlQueryString.append("where simulationexperiment = '" + simulationexperiment + "' ");
	        		  	  sqlQueryString.append("and replicationstatus in ("  + REPLICATION_STATUS_TO_INCLUDE + ") " );

	        			  sqlQueryString.append("group by optimizationparameter ");
	        			  sqlQueryString.append("order by minOverallCosts ");
	        			  sqlQueryString.append("Limit " + minCBRRItems + ";");
	        	        
	        	        if (simParams.getOptimizationParameterSource().toUpperCase().equals(SimulationParameter.OPTIMIZATION_PARAMETER_SOURCE_POSTGRES) && parameterVariation) {
	        	      	  connection = db.ConnectPostGreSql();   
	        	        }	        		 
	        	 }
	        		         			        	 
	        	 output.append("---------------------------------------\n");
	        	 output.append("Iteration " + iteration + " Replication " + replication + "\n");

	        	 output.append(sqlQueryString.toString() + "\n");
	        	 output.append("Bestsolution Value " + bestSoluationValue + "\n");
	        	 output.append("creditRangeReduction " + creditRangeReduction + "\n");
	        	 output.append("Found Credit Items " + countResults + " for Lower Bound Items " + minCBRRItems + "\n");
	        		        	 
	         }else {
	        	 
   	          sqlQueryString.append("select avg(overallcosts_inkl_not_Delivered) as minOverallCosts,optimizationparameter, Optimization_String  from \"RESULT\" ");
   			  sqlQueryString.append("where simulationexperiment = '" + simulationexperiment + "' ");
   			  sqlQueryString.append("and replicationstatus in ("  + REPLICATION_STATUS_TO_INCLUDE + ") " );

   			  sqlQueryString.append("group by optimizationparameter, optimization_string ");
   			  sqlQueryString.append("order by minOverallCosts ");
   			  sqlQueryString.append("Limit " + range + ";");
   	        
	   	        if (simParams.getOptimizationParameterSource().toUpperCase().equals(SimulationParameter.OPTIMIZATION_PARAMETER_SOURCE_POSTGRES) && parameterVariation) {          	 
	   	      	  connection = db.ConnectPostGreSql();   
	   	        }	  
	         }
	         
			//traceln(sqlQueryString);					  	
	        //java.sql.ResultSet rs = stmt.executeQuery(sqlQueryString.toString()); 	    	   	       
	        
	   	  
	   	  traceln("Below params before setting from Heuristic 3:");	
	   	    for(InputParameter input : paramsInList) {
	   	    	traceln(input.toString());
	   	    	//output.append(input.toString() + " \n");
	   	    }
	   	
	         
	        try {
	            traceln("Query String SetBestSolutionForPopulation: " + sqlQueryString);
	  		  	java.sql.Statement statement = connection.createStatement();
	            java.sql.ResultSet rs = statement.executeQuery(sqlQueryString.toString());

	            int sizeOfMatParams = 3;
	            List<Double> foq = new ArrayList<>();
	            List<Double> leadTime = new ArrayList<>();
	            List<Double> safetyStock = new ArrayList<>();
	            String[] stringToSplit;

	            int cntRows = 0;

	            
	            while (rs.next()) {
	                stringToSplit = rs.getString("Optimization_String").split(";");

	                // Determine the number of materials that can be fully processed
	                int maxMaterials = stringToSplit.length / sizeOfMatParams;

	                // Dynamically handle parameters for each material, limited by the available data
	                for (int i = 0; i < Math.min(SimHeuristic.materials.size(), maxMaterials); i++) {
	                    int offset = i * sizeOfMatParams; // Offset based on the current material

	                    // Process data for the current material
	                    foq.add(Double.parseDouble(stringToSplit[offset]));
	                    leadTime.add(Double.parseDouble(stringToSplit[offset + 1]));
	                    safetyStock.add(Double.parseDouble(stringToSplit[offset + 2]));
	                }

	                cntRows++;
	            }//while


	            // Process each material and its associated parameters
	            for (int i = 0; i < SimHeuristic.materials.size(); i++) {
	                String currentMaterial = SimHeuristic.materials.get(i);
	                //Dieser Aufruf muss noch korrigiert werden, damit diese Methode korrekt funktioniert.
	                //processMaterialParameters(currentMaterial, foq, leadTime, safetyStock, paramsInList, baseSol, simAnnealingActive);

	            }//for

	            if(creditRangeReduction > 0)
	                output.append("Table contains " + cntRows + "\n");
	            
	            /*
	            traceln("Below adapted parameter list from Heuristic 3:");	
	            for(InputParameter input : paramsInList) {
	                traceln(input.toString());
	                //output.append(input.toString() + " \n");
	            }
	            */
	            connection.close();
	        } catch(Exception e) {
	            System.out.println("error: " + e.getMessage());
	        }
	        
	      
		  traceln("Below adapted parameter list from Heuristic 3:");	
		    for(InputParameter input : paramsInList) {
		    	traceln(input.toString());
		    	//output.append(input.toString() + " \n");
		    }
			connection.close();
		}catch(Exception e){
			System.out.println("error: " + e.getMessage());
		}		   
		
	    traceln("---------------------------- Heuristic 3 END ---------------------------");
	    
	    SimHeuristic.WriteToFileAppend(FILE_RANGE_REDUCTION, output.toString(), FILE_CREDIT_RANGE_REDUCTION_WRITE);
	    
		return paramsInList;	
			
		}


//The helper method to process material parameters
/*****************************************/

//The helper method to process material parameters
private static void processMaterialParameters(
	    String material, 
	    List<Double> foq, 
	    List<Double> leadTime, 
	    List<Double> safetyStock, 
	    List<Double> wipCap, // New List for WIPCAP
	    List<Double> waw, // New List for WAW
	    List<InputParameter> paramsInList, 
	    List<ResultObject> baseSol, 
	    int simAnnealingActive) {

	/*  
	    traceln("Below params before setting from Heuristic 3:");
	    for(InputParameter input : paramsInList) {
	        traceln(input.toString());
	    }
	*/
	    // Check for null inputs
	    if (material == null) {
	        traceln("Error: material is null");
	    }
	    if (foq == null) {
	        traceln("Error: foq list is null");
	    }
	    if (leadTime == null) {
	        traceln("Error: leadTime list is null");
	    }
	    if (safetyStock == null) {
	        traceln("Error: safetyStock list is null");
	    }
	    if (wipCap == null) {
	        traceln("Error: wipCap list is null");
	    }
	    if (waw == null) {
	        traceln("Error: waw list is null");
	    }
	    if (paramsInList == null) {
	        traceln("Error: paramsInList is null");
	    }
	    if (baseSol == null) {
	        traceln("Error: baseSol list is null");
	    }

	    // Process FOQLOTSIZE
	    paramsInList.stream().filter(entry -> {
	        if (entry.material == null || entry.parameterType == null) {
	            traceln("Error: Null entry detected in FOQLOTSIZE filter");
	        }
	        return entry.material.equals(material)
	            && entry.parameterType.equalsIgnoreCase(InputParameter.ParameterType.FOQLOTSIZE.toString());
	    }).forEach(k -> {
	        if (foq.isEmpty()) {
	            traceln("Error: foq list is empty");
	        }
	        k.lowerBound = Collections.min(foq);
	        k.upperBound = Collections.max(foq);
	        k.mod = (k.lowerBound + k.upperBound) / 2;

	        if (simAnnealingActive == 1) {
	            double baseSolValFOQLOTSIZE = baseSol.stream().filter(entry -> {
	                if (entry.getItem() == null || entry.getType() == null) {
	                    traceln("Error: Null entry detected in baseSol filter for FOQLOTSIZE");
	                }
	                return entry.getItem().equals(material)
	                    && entry.getType().equalsIgnoreCase(InputParameter.ParameterType.FOQLOTSIZE.toString());
	            }).mapToDouble(ResultObject::getDoubleValue).findFirst().orElse(k.mod);

	            if (baseSolValFOQLOTSIZE >= k.lowerBound && baseSolValFOQLOTSIZE <= k.upperBound) {
	                k.mod = baseSolValFOQLOTSIZE;
	            }
	        }
	    });

	    // Process LEADTIME
	    paramsInList.stream().filter(entry -> {
	        if (entry.material == null || entry.parameterType == null) {
	            traceln("Error: Null entry detected in LEADTIME filter");
	        }
	        return entry.material.equals(material)
	            && entry.parameterType.equalsIgnoreCase(InputParameter.ParameterType.LEADTIME.toString());
	    }).forEach(k -> {
	        if (leadTime.isEmpty()) {
	            traceln("Error: leadTime list is empty");
	        }
	        k.lowerBound = Collections.min(leadTime);
	        k.upperBound = Collections.max(leadTime);
	        k.mod = (k.lowerBound + k.upperBound) / 2;

	        if (simAnnealingActive == 1) {
	            double baseSolValLEADTIME = baseSol.stream().filter(entry -> {
	                if (entry.getItem() == null || entry.getType() == null) {
	                    traceln("Error: Null entry detected in baseSol filter for LEADTIME");
	                }
	                return entry.getItem().equals(material)
	                    && entry.getType().equalsIgnoreCase(InputParameter.ParameterType.LEADTIME.toString());
	            }).mapToDouble(ResultObject::getDoubleValue).findFirst().orElse(k.mod);

	            if (baseSolValLEADTIME >= k.lowerBound && baseSolValLEADTIME <= k.upperBound) {
	                k.mod = baseSolValLEADTIME;
	            }
	        }
	    });

	    // Process SAFETYSTOCK
	    paramsInList.stream().filter(entry -> {
	        if (entry.material == null || entry.parameterType == null) {
	            traceln("Error: Null entry detected in SAFETYSTOCK filter");
	        }
	        return entry.material.equals(material)
	            && entry.parameterType.equalsIgnoreCase(InputParameter.ParameterType.SAFETYSTOCK.toString());
	    }).forEach(k -> {
	        if (safetyStock.isEmpty()) {
	            traceln("Error: safetyStock list is empty");
	        }
	        k.lowerBound = Collections.min(safetyStock);
	        k.upperBound = Collections.max(safetyStock);
	        k.mod = (k.lowerBound + k.upperBound) / 2;

	        if (simAnnealingActive == 1) {
	            double baseSolValSAFETYSTOCK = baseSol.stream().filter(entry -> {
	                if (entry.getItem() == null || entry.getType() == null) {
	                    traceln("Error: Null entry detected in baseSol filter for SAFETYSTOCK");
	                }
	                return entry.getItem().equals(material)
	                    && entry.getType().equalsIgnoreCase(InputParameter.ParameterType.SAFETYSTOCK.toString());
	            }).mapToDouble(ResultObject::getDoubleValue).findFirst().orElse(k.mod);

	            if (baseSolValSAFETYSTOCK >= k.lowerBound && baseSolValSAFETYSTOCK <= k.upperBound) {
	                k.mod = baseSolValSAFETYSTOCK;
	            }
	        }
	    });

	    // Process WIPCAP
	    paramsInList.stream().filter(entry -> {
	        if (entry.material == null || entry.parameterType == null) {
	            traceln("Error: Null entry detected in WIPCAP filter");
	        }
	        return entry.material.equals(material)
	            && entry.parameterType.equalsIgnoreCase(InputParameter.ParameterType.WIPCAP.toString());
	    }).forEach(k -> {
	        if (wipCap.isEmpty()) {
	            traceln("Error: wipCap list is empty");
	        }
	        k.lowerBound = Collections.min(wipCap);
	        k.upperBound = Collections.max(wipCap);
	        k.mod = (k.lowerBound + k.upperBound) / 2;

	        if (simAnnealingActive == 1) {
	            double baseSolValWIPCAP = baseSol.stream().filter(entry -> {
	                if (entry.getItem() == null || entry.getType() == null) {
	                    traceln("Error: Null entry detected in baseSol filter for WIPCAP");
	                }
	                return entry.getItem().equals(material)
	                    && entry.getType().equalsIgnoreCase(InputParameter.ParameterType.WIPCAP.toString());
	            }).mapToDouble(ResultObject::getDoubleValue).findFirst().orElse(k.mod);

	            if (baseSolValWIPCAP >= k.lowerBound && baseSolValWIPCAP <= k.upperBound) {
	                k.mod = baseSolValWIPCAP;
	            }
	        }
	    });

	    // Process WAW
	    paramsInList.stream().filter(entry -> {
	        if (entry.material == null || entry.parameterType == null) {
	            traceln("Error: Null entry detected in WAW filter");
	        }
	        return entry.material.equals(material)
	            && entry.parameterType.equalsIgnoreCase(InputParameter.ParameterType.WAWBUFFER.toString());
	    }).forEach(k -> {
	        if (waw.isEmpty()) {
	            traceln("Error: waw list is empty");
	        }
	        k.lowerBound = Collections.min(waw);
	        k.upperBound = Collections.max(waw);
	        k.mod = (k.lowerBound + k.upperBound) / 2;

	        if (simAnnealingActive == 1) {
	            double baseSolValWAW = baseSol.stream().filter(entry -> {
	                if (entry.getItem() == null || entry.getType() == null) {
	                    traceln("Error: Null entry detected in baseSol filter for WAW");
	                }
	                return entry.getItem().equals(material)
	                    && entry.getType().equalsIgnoreCase(InputParameter.ParameterType.WAWBUFFER.toString());
	            }).mapToDouble(ResultObject::getDoubleValue).findFirst().orElse(k.mod);

	            if (baseSolValWAW >= k.lowerBound && baseSolValWAW <= k.upperBound) {
	                k.mod = baseSolValWAW;
	            }
	        }
	    });
	}


/*********** end ******************** */

	public static int GetMinIdFromTable(String tableName, String where) {
		
	int resultId = 0;
	StringBuilder sqlQueryString = new StringBuilder();
	
	try {	
		
		java.sql.Connection conn = null; 
		java.sql.Statement stmt = null; 
	     	     
        Class.forName(JDBC_DRIVER);          
        
          conn = DriverManager.getConnection(GetDBURL(),USER,PASS);           
          stmt = conn.createStatement();
          
		  //Query Simulation Results	
		  sqlQueryString.append("select min(id) as MINID from ");		  						  
		  sqlQueryString.append(tableName);
		  
		  if(where.length() > 0)
			  sqlQueryString.append(" where " +   where); 
		  
	      java.sql.ResultSet rs = stmt.executeQuery(sqlQueryString.toString()); 
	
	      
		   while(rs.next()){			   
			resultId = rs.getInt("MINID");				
		   }
		   conn.close();
	}catch(Exception e){
		System.out.println("error:"+e);
	}
   		   
	return resultId;		   		   					
	
	}			
		
	
	public static double[] GetAVGCostPreviousIterations___Old(String simulationexperiment, int currentIteration, int initPhase, 
			SimulationParameter simParams, boolean parameterVariation, int optimizationParameter){
		
		double[] dataArray = new double[currentIteration - initPhase];
		StringBuilder sqlQueryString = new StringBuilder();
		
		java.sql.Connection conn = null; 
		java.sql.Statement stmt = null; 
		
		try { 	     
			DBQueries db = new DBQueries();

			java.sql.Connection connection = db.connect();  
			
	         sqlQueryString.setLength(0);	

			  	sqlQueryString.append("select iteration, count(replications) replications, avg(overallcosts_inkl_not_Delivered) as overallcosts_inkl_not_Delivered ");
		  		sqlQueryString.append("from \"RESULT\" ");
		  		sqlQueryString.append("where simulationexperiment = '" + simulationexperiment + "' and  iteration between " + initPhase + " and " + currentIteration + " ");
		  		sqlQueryString.append("and replication > 0 and optimizationparameter=" + optimizationParameter + " ");
		  		sqlQueryString.append("and replicationstatus in ("  + REPLICATION_STATUS_TO_INCLUDE + ") " );
		  		sqlQueryString.append("group by iteration; ");
	         
		         if (simParams.getOptimizationParameterSource().toUpperCase().equals(SimulationParameter.OPTIMIZATION_PARAMETER_SOURCE_POSTGRES) && parameterVariation) {  
		       	  	connection = db.ConnectPostGreSql();   
		         } 
	         	         
		    java.sql.ResultSet rs = stmt.executeQuery(sqlQueryString.toString()); 
		
		    int i = 0;
		 
			while(rs.next()){	
				dataArray[i] = rs.getDouble("overallcosts_inkl_not_Delivered");								
				i++;				
			}
			connection.close();
			traceln(sqlQueryString);
		}
		
     catch(Exception e) {
        System.out.println("error: " + e.getMessage());
    }
		
		return dataArray;		   		   					
		
		}			

	public static double[] GetAVGCostPreviousIterations(String simulationexperiment, int currentIteration, int initPhase, 
	        SimulationParameter simParams, boolean parameterVariation, int optimizationParameter) throws IOException {

	    double[] dataArray = new double[currentIteration - initPhase];
	    String sqlQuery = "SELECT iteration, AVG(overallcosts_inkl_not_Delivered) AS overallcosts_inkl_not_Delivered " +
	                      "FROM RESULT WHERE simulationexperiment = ? AND iteration BETWEEN ? AND ? " +
	                      "AND replication > 0 AND optimizationparameter = ? AND replicationstatus IN (" + REPLICATION_STATUS_TO_INCLUDE + ") " +
	                      "GROUP BY iteration";

	    Connection connection = null;
	    PreparedStatement pstmt = null;
	    ResultSet rs = null;

	    try {
	        DBQueries db = new DBQueries();
	        connection = parameterVariation && simParams.getOptimizationParameterSource().equalsIgnoreCase(SimulationParameter.OPTIMIZATION_PARAMETER_SOURCE_POSTGRES) ? 
	                     db.ConnectPostGreSql() : db.connect();

	        pstmt = connection.prepareStatement(sqlQuery);
	        pstmt.setString(1, simulationexperiment);
	        pstmt.setInt(2, initPhase);
	        pstmt.setInt(3, currentIteration);
	        pstmt.setInt(4, optimizationParameter);

	        rs = (ResultSet) pstmt.executeQuery();
	        List<Double> dataList = new ArrayList<>();
	        while (rs.next()) {
	            dataList.add(rs.getDouble("overallcosts_inkl_not_Delivered"));
	        }
	        dataArray = dataList.stream().mapToDouble(Double::doubleValue).toArray();

	    } catch (SQLException e) {
	        System.err.println("SQL error: " + e.getMessage());
	    } finally {
	        try {
	            if (rs != null) rs.close();
	            if (pstmt != null) pstmt.close();
	            if (connection != null) connection.close();
	        } catch (SQLException e) {
	            System.err.println("Error closing resources: " + e.getMessage());
	        }
	    }

	    return dataArray;
	}

	
	public static ArrayList<Entry_simresults> RemoveSimulationResultsPercentile(ArrayList<Entry_simresults> list_simresults, int correctionType) {
		
		StringBuilder output = new StringBuilder();
		
		if(list_simresults.size() >= OUTLIERCORRECTION_START_FROM_REPLICATIONS) {		
			if(correctionType == 1) {

				int pos = 0;
				double[] dataArray = new double[list_simresults.size()];	
				
				for(Entry_simresults replResult :  list_simresults){
					dataArray[pos] = replResult.inventory_costs  + replResult.tardiness_costs_medium;		
					pos++;
				}
				
				Arrays.sort(dataArray);
				
				Percentile percentile = new Percentile();
		        
			    percentile.setData(dataArray);
					
				double percentilValueUpperBound = percentile.evaluate(dataArray,
						0,list_simresults.size(),OUTLIERCORRECTION_UPPER_BOUND);
				
				double percentilValueLowerBound = percentile.evaluate(dataArray,
						0,list_simresults.size(),OUTLIERCORRECTION_LOWER_BOUND);
						
				//traceln("Percentile Lower Bound " + percentilValueLowerBound);
				//traceln("Percentile Upper Bound " + percentilValueUpperBound);
				
				//for (int i = 0; i < dataArray.length; i++) {  	    
			   	//	traceln(i + " " + dataArray[i]);
				//}
				
			
				list_simresults.removeIf(r -> (r.inventory_costs + r.tardiness_costs_medium) < percentilValueLowerBound);
				list_simresults.removeIf(r -> (r.inventory_costs + r.tardiness_costs_medium) > percentilValueUpperBound);
				
				//traceln("------- START Percentil Array");
				
			  	//for (int i = 0; i < dataArray.length; i++) {  	    
			  		//traceln(i + " " + dataArray[i]);
				//}
				//traceln("------- FINISH Percentil Array");  
				
				//traceln("Percentile Bound Value " + percentilValueLowerBound + "/" + percentilValueUpperBound 
				//		+ " Size Before/After " + dataArray.length + "/" + list_simresults.size());
				
				//list_simresults.forEach(o -> traceln(o.inventory_costs + o.tardiness_costs_medium));
					
			}else if(correctionType == 2) {

				DescriptiveStatistics values = new DescriptiveStatistics();
				values.clear(); 
				
				for(Entry_simresults item : list_simresults) {
					    values.addValue(item.overall_costs_medium_tardiness);							
				}
																													
				//if(values.getN() > 0) {		
		        	 double mean = values.getMean();
					 double stdDev = values.getStandardDeviation();


				//if(stdDev > 0){
					double upperBound = new NormalDistribution(values.getMean(),values.getStandardDeviation())
							.inverseCumulativeProbability(OUTLIERCORRECTION_UPPER_BOUND/100);
					
					double lowerBound = new NormalDistribution(values.getMean(),values.getStandardDeviation())
							.inverseCumulativeProbability(OUTLIERCORRECTION_LOWER_BOUND/100);
				//}else {
				//	upperBound = defaultLongtermForecast;
				//	lowerBound = 0;												
				//}	
				
				
				if(FILE_OUTLIER_CORRECTION_WRITE) {
					output.append("-----------");
					output.append("mean " + mean + "\n");	 
					output.append("stdDev " + stdDev + "\n");
					output.append("CorrectionType " + correctionType + "\n");
					output.append("Percentile Lower Bound " + lowerBound + "\n");
					output.append("Percentile Upper Bound " + upperBound + "\n");						
					output.append("Before Removing" + "\n");
					
					for(Entry_simresults item : list_simresults) { 	    
						output.append(item.overall_costs_medium_tardiness + ";");
					}	
				}
												
				list_simresults.removeIf(r -> (r.inventory_costs + r.tardiness_costs_medium) < lowerBound);
				list_simresults.removeIf(r -> (r.inventory_costs + r.tardiness_costs_medium) > upperBound);
												
				if(FILE_OUTLIER_CORRECTION_WRITE) {
					output.append("\nAfter Removing" + "\n");
					
					for(Entry_simresults item : list_simresults) {				
						output.append(item.overall_costs_medium_tardiness + ";");
					}
					output.append("\n-----------" + "\n");
				}
				
			}//else if
		}
		
		SimHeuristic.WriteToFileAppend(FILE_OUTLIER_CORRECTION, output.toString(), FILE_OUTLIER_CORRECTION_WRITE);
		
		return list_simresults;
		
	}
	
public static void WriteToFileAppend(String fileName, String textToAppend, boolean doWrite) {
	
	if(textToAppend.length() > 0) {	
		if(doWrite) {
			try{	        		

			    FileOutputStream outputStream = new FileOutputStream(fileName, true);
			    textToAppend = textToAppend + "\r\n";
			    byte[] strToBytes = textToAppend.getBytes();
			    outputStream.write(strToBytes);
			  
			    outputStream.close();
				}
			catch (Exception e)
			{
				traceln("Could not write to file " + fileName + " " +  e.getMessage());
			}
		 }
	}
}
	
	public static String GetSimulationPCName() {
		
		String computerName = "Undefined";
		
      try {
		 computerName=InetAddress.getLocalHost().getHostName();		
	  }catch (Exception e){
		  System.out.println("Exception caught ="+e.getMessage());
	  }
		 return computerName;
	}
	

	public static int GetCountNumberSmallerCreditRange(String simulationexperiment, double bestSoluationValue , double creditRangeReduction, 
			SimulationParameter simParams, boolean parameterVariation, int optimizationParameter) {
		
		int count = 0;
		StringBuilder sqlQueryString = new StringBuilder();
		
		try {	
			
			java.sql.Statement stmt = null; 
	         //current solution
			DBQueries db = new DBQueries();
		     Connection connection = db.ConnectH2();
	         sqlQueryString.setLength(0);	 	     
	          
	          
	          sqlQueryString.append("select count(*) as COUNT from \"RESULT\" "); 
	          sqlQueryString.append(" where overallcosts_inkl_not_Delivered < " + (bestSoluationValue + creditRangeReduction) );
	          sqlQueryString.append(" and replicationstatus in ("  + REPLICATION_STATUS_TO_INCLUDE + ") " );

	          sqlQueryString.append(" and  simulationexperiment = '" + simulationexperiment + "' and optimizationparameter=" + optimizationParameter + ";");
	          
	          
	          if (simParams.getOptimizationParameterSource().toUpperCase().equals(SimulationParameter.OPTIMIZATION_PARAMETER_SOURCE_POSTGRES) && parameterVariation) {
	        	  connection = db.ConnectPostGreSql();   
	          }
	          
	          
	  		  java.sql.Statement statement = connection.createStatement();
	          java.sql.ResultSet rs = statement.executeQuery(sqlQueryString.toString()); 
	            
			  SimHeuristic.WriteToFileAppend(FILE_RANGE_REDUCTION, sqlQueryString.toString(), FILE_CREDIT_RANGE_REDUCTION_WRITE);
		      
			   while(rs.next()){			   
				count = rs.getInt("COUNT");				
			   }
			   
			   connection.close();
		}catch(Exception e){
			System.out.println("error:"+e);
		}
	   		   
		return count;		   		   					
		
		}
	
	
	public static double GetTotalReplicationCount(String simulationexperiment, SimulationParameter simParams, boolean parameterVariation, OptimizationParameter optparam) {
		
	double count = 0;
	StringBuilder sqlQueryString = new StringBuilder();

          try {
		  DBQueries db = new DBQueries();
	      //Connection connection = db.ConnectH2();

          java.sql.Connection connection = db.connect();            
          sqlQueryString.append("select count(*) as count ");
          sqlQueryString.append("from \"RESULT\" ");
		  sqlQueryString.append("where simulationexperiment = '" + simulationexperiment + "' and optimizationparameter=" + optparam.getId() + " ");
	  	  sqlQueryString.append("and replicationstatus in ("  + REPLICATION_STATUS_TO_INCLUDE + ") " );

		  sqlQueryString.append("group by optimizationparameter;");
          
          if (simParams.getOptimizationParameterSource().toUpperCase().equals(SimulationParameter.OPTIMIZATION_PARAMETER_SOURCE_POSTGRES) && parameterVariation) {
        	  connection = db.ConnectPostGreSql();   
          }
          		  
	      traceln("sqlString " + sqlQueryString.toString());
		  
		  java.sql.Statement statement = connection.createStatement();
	      java.sql.ResultSet resultSet = statement.executeQuery(sqlQueryString.toString());
	      
	      
	      if (resultSet.next()) {
	    	  count = resultSet.getDouble("count");
	    	  
	    	  traceln("Foud " + count + " replications for optimizationparameter id: " + optparam.getId() + " SimulationExperiement: " + simulationexperiment);

	      }

	      connection.close();

	    } catch (Exception e) {
	      traceln("error:" + e);
	    }
		 
          
	return count;		   		   					
	
	}
	
	/**
	 * This number is here for model snapshot storing purpose<br>
	 * It needs to be changed when this class gets changed
	 */ 
	private static final long serialVersionUID = 1L;

}]]></Text>
		</JavaClass>
		<!--   =========   Java Class   ========  -->
		<JavaClass>
			<Id>1724696920361</Id>
			<Name><![CDATA[InputParameter]]></Name>
			<Text><![CDATA[import java.lang.reflect.Method;
import java.lang.reflect.InvocationTargetException;
import java.io.Serializable;
import java.util.ArrayList;
import java.util.List;

/**
 * InputParameter
 */ 
public class InputParameter implements Serializable {

    // Class fields
    String name;
    double value;
    String material;
    double lowerBound;
    double upperBound;
    String parameterType;
    double mod;
    int halfSteps;

    // Enum types
    enum ParameterType {
    	FOQLOTSIZE,
    	LEADTIME,
        SAFETYSTOCK,               
        WIPCAP,
        WAWBUFFER
    }

    enum HeuristicType {
        Basic,
        Triangular,
        Extension1,
        Extension2,
        Random
    }

    /**
     * Default constructor initializing the fields
     */
    public InputParameter(String material, String name, String parameterType) {
        this.material = material;
        this.name = name;
        this.parameterType = parameterType;
    }

    // Getter and setter methods
    public double getLowerBound() {
        return lowerBound;
    }

    public void setLowerBound(double value) {
        this.lowerBound = value;
    }

    public double getUpperBound() {
        return upperBound;
    }

    public void setUpperBound(double value) {
        this.upperBound = value;
    }

    public double getValue() {
        return value;
    }

    public void setValue(double value) {
        this.value = value;
    }

    public String getName() {
        return name;
    }

    public void setName(String value) {
        this.name = value;
    }

    public String getMaterial() {
        return material;
    }

    public void setMaterial(String value) {
        this.material = value;
    }

    public double getMod() {
        return mod;
    }

    public void setMod(double value) {
        this.mod = value;
    }

    public String getParameterType() {
        return parameterType;
    }

    public void setParameterType(String value) {
        this.parameterType = value;
    }

    public int getHalfSteps() {
        return halfSteps;
    }

    public void setHalfSteps(int value) {
        this.halfSteps = value;
    }

    // Process parameters method with reflection and proper exception handling
    public static List<InputParameter> processParameters(Object optimizationParameters) {
        List<InputParameter> inputParameterList = new ArrayList<>();
      	
        traceln("Optimization parameter input for process Parameters");
        traceln(optimizationParameters.toString());
        
        // Assuming the materials list is in SimHeuristic class
        List<String> materials = SimHeuristic.materials; // This is your materials list
        traceln("SimHeuristic Material Size: " + materials.size());
        for (int i = 0; i < materials.size(); i++) {
            String currentMaterial = materials.get(i);
            String spNumber = String.format("%03d", i);
            String vBaseNumber = String.format("%03d", i * 5);  // Calculate base index for each material group (e.g., 000, 005, 010, ...)

            traceln("Processing material: " + currentMaterial + " with vBaseNumber: " + vBaseNumber);

            try {
                // SP retrieval logic remains the same
                Method getSPMethod = optimizationParameters.getClass().getMethod("getSP" + spNumber);
                String spValue = (String) getSPMethod.invoke(optimizationParameters);
                String[] bounds = spValue.split(";");
                
                if (bounds.length < 15) {
                    System.out.println("Error: bounds array has insufficient elements for material " + currentMaterial);
                    continue;
                }
                
                traceln("Resolving method: getV" + String.format("%03d", Integer.parseInt(vBaseNumber)));

                // FOQLOTSIZE
                //Method getVMethod = optimizationParameters.getClass().getMethod("getV" + vBaseNumber);
                Method getVMethod = optimizationParameters.getClass().getMethod("getV" + String.format("%03d", Integer.parseInt(vBaseNumber)));
                double vValue = Double.parseDouble(getVMethod.invoke(optimizationParameters).toString());
                InputParameter input = new InputParameter(currentMaterial, "", InputParameter.ParameterType.FOQLOTSIZE.toString());
                input.setValue(vValue);
                input.setLowerBound(parseDoubleSafely(bounds[0], "Lower Bound", currentMaterial));
                input.setUpperBound(parseDoubleSafely(bounds[1], "Upper Bound", currentMaterial));
                input.setHalfSteps(parseIntSafely(bounds[10], "Half Steps", currentMaterial));
                inputParameterList.add(input);

                // LEADTIME
                getVMethod = optimizationParameters.getClass().getMethod("getV" + String.format("%03d", Integer.parseInt(vBaseNumber) + 1));
                vValue = Double.parseDouble(getVMethod.invoke(optimizationParameters).toString());
                input = new InputParameter(currentMaterial, "", InputParameter.ParameterType.LEADTIME.toString());
                input.setValue(vValue);
                input.setLowerBound(parseDoubleSafely(bounds[2], "Lower Bound", currentMaterial));
                input.setUpperBound(parseDoubleSafely(bounds[3], "Upper Bound", currentMaterial));
                input.setHalfSteps(parseIntSafely(bounds[11], "Half Steps", currentMaterial));
                inputParameterList.add(input);

                // SAFETYSTOCK
                getVMethod = optimizationParameters.getClass().getMethod("getV" + String.format("%03d", Integer.parseInt(vBaseNumber) + 2));
                vValue = Double.parseDouble(getVMethod.invoke(optimizationParameters).toString());
                input = new InputParameter(currentMaterial, "", InputParameter.ParameterType.SAFETYSTOCK.toString());
                input.setValue(vValue);
                input.setLowerBound(parseDoubleSafely(bounds[4], "Lower Bound", currentMaterial));
                input.setUpperBound(parseDoubleSafely(bounds[5], "Upper Bound", currentMaterial));
                input.setHalfSteps(parseIntSafely(bounds[12], "Half Steps", currentMaterial));
                inputParameterList.add(input);

                // WIPCAP
                getVMethod = optimizationParameters.getClass().getMethod("getV" + String.format("%03d", Integer.parseInt(vBaseNumber) + 3));
                vValue = Double.parseDouble(getVMethod.invoke(optimizationParameters).toString());
                input = new InputParameter(currentMaterial, "", InputParameter.ParameterType.WIPCAP.toString());
                input.setValue(vValue);
                input.setLowerBound(parseDoubleSafely(bounds[6], "Lower Bound", currentMaterial));
                input.setUpperBound(parseDoubleSafely(bounds[7], "Upper Bound", currentMaterial));
                input.setHalfSteps(parseIntSafely(bounds[13], "Half Steps", currentMaterial));
                inputParameterList.add(input);

                // WAWBUFFER
                getVMethod = optimizationParameters.getClass().getMethod("getV" + String.format("%03d", Integer.parseInt(vBaseNumber) + 4));
                vValue = Double.parseDouble(getVMethod.invoke(optimizationParameters).toString());
                input = new InputParameter(currentMaterial, "", InputParameter.ParameterType.WAWBUFFER.toString());
                input.setValue(vValue);
                input.setLowerBound(parseDoubleSafely(bounds[8], "Lower Bound", currentMaterial));
                input.setUpperBound(parseDoubleSafely(bounds[9], "Upper Bound", currentMaterial));
                input.setHalfSteps(parseIntSafely(bounds[14], "Half Steps", currentMaterial));
                inputParameterList.add(input);

            } catch (NoSuchMethodException | IllegalAccessException | InvocationTargetException e) {
                System.out.println("Error processing parameters for material " + currentMaterial + ": " + e.getMessage());
                e.printStackTrace();
            }
        }

        traceln("processParameters - input before passed back - not Bestsolution!:");
        for (InputParameter item: inputParameterList) {
            traceln(item.toString());
        }
        
        
        return inputParameterList;
    }

    // Helper method to safely parse a double and handle non-numeric values
    private static double parseDoubleSafely(String value, String paramName, String material) {
        try {
            return Double.parseDouble(value);
        } catch (NumberFormatException e) {
            System.err.println("Warning: Non-numeric value encountered for " + paramName + " in material " + material + ": " + value);
            return 0.0; // or some other default value or error handling
        }
    }

 // Method to process and set the 'mod' values based on the best configuration
    public static List<InputParameter> processAndSetModValues(List<InputParameter> inputParameterList, List<ResultObject> bestConfiguration) {

        // Best configuration for setting the mod
        traceln("In Method process and SetModValues Used Best Configuration Setting for mod");
        traceln("Size of Best configuration: " + bestConfiguration.size());
        for (ResultObject ro : bestConfiguration) {
            traceln(ro.toString());
        }

        for (InputParameter item : inputParameterList) {
            for (String material : SimHeuristic.materials) {
                if (item.getMaterial().equals(material)) {
                    if (item.getParameterType().equals(InputParameter.ParameterType.FOQLOTSIZE.toString())) {
                        item.setMod(bestConfiguration.stream()
                            .filter(e -> e.getItem().equals(material) && e.getType().equals(InputParameter.ParameterType.FOQLOTSIZE.toString()))
                            .mapToDouble(ResultObject::getDoubleValue)
                            .findFirst()
                            .orElse(0.0));
                    }
                    if (item.getParameterType().equals(InputParameter.ParameterType.SAFETYSTOCK.toString())) {
                        item.setMod(bestConfiguration.stream()
                            .filter(e -> e.getItem().equals(material) && e.getType().equals(InputParameter.ParameterType.SAFETYSTOCK.toString()))
                            .mapToDouble(ResultObject::getDoubleValue)
                            .findFirst()
                            .orElse(0.0));
                    }
                    if (item.getParameterType().equals(InputParameter.ParameterType.LEADTIME.toString())) {
                        item.setMod(bestConfiguration.stream()
                            .filter(e -> e.getItem().equals(material) && e.getType().equals(InputParameter.ParameterType.LEADTIME.toString()))
                            .mapToDouble(ResultObject::getDoubleValue)
                            .findFirst()
                            .orElse(0.0));
                    }
                    
                    // Set mod for WIPCAP
                    if (item.getParameterType().equals(InputParameter.ParameterType.WIPCAP.toString())) {
                        item.setMod(bestConfiguration.stream()
                            .filter(e -> e.getItem().equals(material) && e.getType().equals(InputParameter.ParameterType.WIPCAP.toString()))
                            .mapToDouble(ResultObject::getDoubleValue)
                            .findFirst()
                            .orElse(0.0));
                    }
                    
                    // Set mod for WAWBUFFER
                    if (item.getParameterType().equals(InputParameter.ParameterType.WAWBUFFER.toString())) {
                        item.setMod(bestConfiguration.stream()
                            .filter(e -> e.getItem().equals(material) && e.getType().equals(InputParameter.ParameterType.WAWBUFFER.toString()))
                            .mapToDouble(ResultObject::getDoubleValue)
                            .findFirst()
                            .orElse(0.0));
                    }
                }
            }
        }

        traceln("Input before passed back:");
        for (InputParameter item : inputParameterList) {
            traceln(item.toString());
        }

        return inputParameterList;
    }

    
    
    public static int parseIntSafely(String value, String fieldName, String materialName) {
        try {
            return Integer.parseInt(value);
        } catch (NumberFormatException e) {
            System.err.println("Error parsing " + fieldName + " for material " + materialName + ": " + e.getMessage());
            throw new IllegalArgumentException("Invalid integer format for " + fieldName + " in material " + materialName);
        }
    }
    @Override
    public String toString() {
        return "Material = " + material + " " +
                "Name = " + name + " " +
                "Type = " + parameterType + " " +
                "value = " + value + " " +
                "LowerBound = " + lowerBound + " " +
                "UpperBound = " + upperBound + " " +
                "HalfSteps = " + halfSteps + " " +
                "Mod = " + mod;
    }

    /**
     * This number is here for model snapshot storing purpose
     * It needs to be changed when this class gets changed
     */
    private static final long serialVersionUID = 1L;
}
]]></Text>
		</JavaClass>
		<!--   =========   Java Class   ========  -->
		<JavaClass>
			<Id>1724696995334</Id>
			<Name><![CDATA[ResultObject]]></Name>
			<Text><![CDATA[/**
 * ResultObject
 */
public class ResultObject implements Serializable {

	private double DoubleValue;

	private String Name;

	private String Type;
	
	private String Item;

	/**
	 * Default constructor
	 */
	public ResultObject() {
	}

	public double getDoubleValue() {
		return this.DoubleValue;
	}

	public void setDoubleValue(double value) {
		this.DoubleValue = value;
	}

	public String getName() {
		return this.Name;
	}

	public void setName(String value) {
		this.Name = value;
	}

	public String getType() {
		return this.Type;
	}

	public void setType(String value) {
		this.Type = value;
	}

	public String getItem() {
		return this.Item;
	}

	public void setItem(String value) {
		this.Item = value;
	}
	
	public String toString() {
		return  
			"Item = " + Item +" " +
			"Type = " + Type +" " +
			"Name = " + Name +" " +
			"DoubleValue = " + DoubleValue;
		
	}

	/**
	 * This number is here for model snapshot storing
	 * purpose<br>
	 * It needs to be changed when this class gets changed
	 */
	private static final long serialVersionUID = 1L;

}]]></Text>
		</JavaClass>
		<!--   =========   Java Class   ========  -->
		<JavaClass>
			<Id>1724697128807</Id>
			<Name><![CDATA[Entry_simresults]]></Name>
			<Text><![CDATA[/**
 * Entry_simresults
 */	
public class Entry_simresults implements Serializable {

	int iteration_nr;
	int run_nr;
	String optimization_parameter;
	boolean run_canceled;
	double par_simulation_time;
	double time_for_simulation;
	double utilization;
	int wip;
	int wip_kanban;
	int wip_mrp;
	int fgi;
	int fgi_kanban;
	int fgi_mrp;
	int inventory_costs;
	int inventory_on_stock;
	int inventory_on_stock_kanban;
	int inventory_on_stock_mrp;
	int production_order_inventory;
	int production_order_inventory_kanban;
	int production_order_inventory_mrp;
	int wait_time_production_order_inventory;
	int wait_time_production_order_inventory_kanban;
	int wait_time_production_order_inventory_mrp;
	double wip_rawmaterialcosts;
	double leadtime_rawmaterialcosts;
	double throughput_rawmaterialcosts;
	double throughput_customer_orders_percentage;
	double throughput_production_orders_percentage;
	int overall_inventory_weight;
	double service_level;
	double service_level_kanban;
	double service_level_mrp;
	double service_level_week;
	double tardiness;
	int tardiness_costs_high;
	int tardiness_costs_low;
	int tardiness_costs_medium;
	int tardiness_costs_medium_kanban;
	int tardiness_costs_medium_mrp;
	double tardiness_of_late_orders;
	int overall_costs_low_tardiness;
	int overall_costs_medium_tardiness;
	int overall_costs_high_tardiness;
	double inventory_costs_wip;
	double inventory_costs_fgi;
	double target_utilization;
	int plattenlager;


	

    /**
     * Default constructor
     */
    public Entry_simresults(){
    }

    /**
     * Constructor initializing the fieKanbans
     */     
    public Entry_simresults(int iteration_nr, int run_nr, String optimization_parameter, boolean run_canceled, double par_simulation_time, double time_for_simulation, double utilization, int wip, int wip_kanban, int wip_mrp, int fgi, int fgi_kanban, int fgi_mrp, int inventory_costs, int inventory_on_stock, int inventory_on_stock_kanban, int inventory_on_stock_mrp, int production_order_inventory, int production_order_inventory_kanban, int production_order_inventory_mrp, int wait_time_production_order_inventory, int wait_time_production_order_inventory_kanban, int wait_time_production_order_inventory_mrp, double wip_rawmaterialcosts, double leadtime_rawmaterialcosts, double throughput_rawmaterialcosts, double throughput_customer_orders_percentage, double throughput_production_orders_percentage, int overall_inventory_weight, double service_level, double service_level_kanban, double service_level_mrp, double service_level_week, double tardiness, int tardiness_costs_high, int tardiness_costs_low, int tardiness_costs_medium, int tardiness_costs_medium_kanban, int tardiness_costs_medium_mrp, double tardiness_of_late_orders, int overall_costs_low_tardiness, int overall_costs_medium_tardiness, int overall_costs_high_tardiness, double inventory_costs_wip, double inventory_costs_fgi, double target_utilization, int plattenlager){
    	this.iteration_nr = iteration_nr;
    	this.run_nr = run_nr;
    	this.optimization_parameter = optimization_parameter;
    	this.run_canceled = run_canceled;
    	this.par_simulation_time = par_simulation_time;
    	this.time_for_simulation = time_for_simulation;
    	this.utilization = utilization;
    	this.wip = wip;
    	this.wip_kanban = wip_kanban;
    	this.wip_mrp = wip_mrp;
    	this.fgi = fgi;
    	this.fgi_kanban = fgi_kanban;
    	this.fgi_mrp = fgi_mrp;
    	this.inventory_costs = inventory_costs;
    	this.inventory_on_stock = inventory_on_stock;
    	this.inventory_on_stock_kanban = inventory_on_stock_kanban;
    	this.inventory_on_stock_mrp = inventory_on_stock_mrp;
    	this.production_order_inventory = production_order_inventory;
    	this.production_order_inventory_kanban = production_order_inventory_kanban;
    	this.production_order_inventory_mrp = production_order_inventory_mrp;
    	this.wait_time_production_order_inventory = wait_time_production_order_inventory;
    	this.wait_time_production_order_inventory_kanban = wait_time_production_order_inventory_kanban;
    	this.wait_time_production_order_inventory_mrp = wait_time_production_order_inventory_mrp;
    	this.wip_rawmaterialcosts = wip_rawmaterialcosts;
    	this.leadtime_rawmaterialcosts = leadtime_rawmaterialcosts;
    	this.throughput_rawmaterialcosts = throughput_rawmaterialcosts;
    	this.throughput_customer_orders_percentage = throughput_customer_orders_percentage;
    	this.throughput_production_orders_percentage = throughput_production_orders_percentage;
    	this.overall_inventory_weight = overall_inventory_weight;
    	this.service_level = service_level;
    	this.service_level_kanban = service_level_kanban;
    	this.service_level_mrp = service_level_mrp;
    	this.service_level_week = service_level_week;
    	this.tardiness = tardiness;
    	this.tardiness_costs_high = tardiness_costs_high;
    	this.tardiness_costs_low = tardiness_costs_low;
    	this.tardiness_costs_medium = tardiness_costs_medium;
    	this.tardiness_costs_medium_kanban = tardiness_costs_medium_kanban;
    	this.tardiness_costs_medium_mrp = tardiness_costs_medium_mrp;
    	this.tardiness_of_late_orders = tardiness_of_late_orders;
    	this.overall_costs_low_tardiness = overall_costs_low_tardiness;
    	this.overall_costs_medium_tardiness = overall_costs_medium_tardiness;
    	this.overall_costs_high_tardiness = overall_costs_high_tardiness;
    	this.inventory_costs_wip = inventory_costs_wip;
    	this.inventory_costs_fgi = inventory_costs_fgi;
    	this.target_utilization = target_utilization;
    	this.plattenlager = plattenlager;


    }     
	
	@Override
	public String toString() {
		return  
			"iteration_nr = " + iteration_nr + " " + 
			"run_nr = " + run_nr + " " + 
			"optimization_parameter = " + optimization_parameter + " " + 
			"run_canceled = " + run_canceled + " " + 
			"par_simulation_time = " + par_simulation_time + " " + 
			"time_for_simulation = " + time_for_simulation + " " + 
			"utilization = " + utilization + " " + 
			"wip = " + wip + " " + 
			"wip_kanban = " + wip_kanban + " " + 
			"wip_mrp = " + wip_mrp + " " + 
			"fgi = " + fgi + " " + 
			"fgi_kanban = " + fgi_kanban + " " + 
			"fgi_mrp = " + fgi_mrp + " " + 
			"inventory_costs = " + inventory_costs + " " + 
			"inventory_on_stock = " + inventory_on_stock + " " + 
			"inventory_on_stock_kanban = " + inventory_on_stock_kanban + " " + 
			"inventory_on_stock_mrp = " + inventory_on_stock_mrp + " " + 
			"production_order_inventory = " + production_order_inventory + " " + 
			"production_order_inventory_kanban = " + production_order_inventory_kanban + " " + 
			"production_order_inventory_mrp = " + production_order_inventory_mrp + " " + 
			"wait_time_production_order_inventory = " + wait_time_production_order_inventory + " " + 
			"wait_time_production_order_inventory_kanban = " + wait_time_production_order_inventory_kanban + " " + 
			"wait_time_production_order_inventory_mrp = " + wait_time_production_order_inventory_mrp + " " + 
			"wip_rawmaterialcosts = " + wip_rawmaterialcosts + " " + 
			"leadtime_rawmaterialcosts = " + leadtime_rawmaterialcosts + " " + 
			"throughput_rawmaterialcosts = " + throughput_rawmaterialcosts + " " + 
			"throughput_customer_orders_percentage = " + throughput_customer_orders_percentage + " " + 
			"throughput_production_orders_percentage = " + throughput_production_orders_percentage + " " + 
			"overall_inventory_weight = " + overall_inventory_weight + " " + 
			"service_level = " + service_level + " " + 
			"service_level_kanban = " + service_level_kanban + " " + 
			"service_level_mrp = " + service_level_mrp + " " + 
			"service_level_week = " + service_level_week + " " + 
			"tardiness = " + tardiness + " " + 
			"tardiness_costs_high = " + tardiness_costs_high + " " + 
			"tardiness_costs_low = " + tardiness_costs_low + " " + 
			"tardiness_costs_medium = " + tardiness_costs_medium + " " + 
			"tardiness_costs_medium_kanban = " + tardiness_costs_medium_kanban + " " + 
			"tardiness_costs_medium_mrp = " + tardiness_costs_medium_mrp + " " + 
			"tardiness_of_late_orders = " + tardiness_of_late_orders + " " + 
			"overall_costs_low_tardiness = " + overall_costs_low_tardiness + " " + 
			"overall_costs_medium_tardiness = " + overall_costs_medium_tardiness + " " + 
			"overall_costs_high_tardiness = " + overall_costs_high_tardiness + " " + 
			"inventory_costs_wip = " + inventory_costs_wip + " " +
			"inventory_costs_fgi = " + inventory_costs_fgi+ " " +
			"target_utilization = " + target_utilization + " "+
			"plattenlager = " + plattenlager + " ";


	}

	/**
	 * This number is here for model snapshot storing purpose<br>
	 * It needs to be changed when this class gets changed
	 */ 
	private static final long serialVersionUID = 1L;

}]]></Text>
		</JavaClass>
		<!--   =========   Java Class   ========  -->
		<JavaClass>
			<Id>1727983088612</Id>
			<Name><![CDATA[JavaRandomAdapter]]></Name>
			<Text><![CDATA[import org.apache.commons.math3.random.RandomGenerator;
import java.util.Random;

public class JavaRandomAdapter implements RandomGenerator {

    private final Random random;

    public JavaRandomAdapter(Random random) {
        this.random = random;
    }

    @Override
    public void setSeed(int seed) {
        random.setSeed(seed);
    }

    @Override
    public void setSeed(long seed) {
        random.setSeed(seed);
    }

    @Override
    public void setSeed(int[] seed) {
        throw new UnsupportedOperationException("setSeed(int[]) not supported");
    }

    @Override
    public double nextDouble() {
        return random.nextDouble();
    }

    @Override
    public int nextInt() {
        return random.nextInt();
    }

    @Override
    public int nextInt(int n) {
        return random.nextInt(n);
    }

    @Override
    public long nextLong() {
        return random.nextLong();
    }

    @Override
    public boolean nextBoolean() {
        return random.nextBoolean();
    }

    @Override
    public float nextFloat() {
        return random.nextFloat();
    }

    @Override
    public double nextGaussian() {
        return random.nextGaussian();
    }

    @Override
    public void nextBytes(byte[] bytes) {
        random.nextBytes(bytes);
    }
}
]]></Text>
		</JavaClass>
	</JavaClasses>
	<ModelResources>
		<Resource>
			<Path><![CDATA[gson-2.8.9.jar]]></Path>
			<ReferencedFromUserCode>false</ReferencedFromUserCode>
			<Location>FILE_SYSTEM</Location>
		</Resource>
		<Resource>
			<Path><![CDATA[sqlite-jdbc-3.34.0.jar]]></Path>
			<ReferencedFromUserCode>false</ReferencedFromUserCode>
			<Location>FILE_SYSTEM</Location>
		</Resource>
		<Resource>
			<Path><![CDATA[streamex-0.8.0.jar]]></Path>
			<ReferencedFromUserCode>false</ReferencedFromUserCode>
			<Location>FILE_SYSTEM</Location>
		</Resource>
		<Resource>
			<Path><![CDATA[poi-ooxml-full-5.0.0.jar]]></Path>
			<ReferencedFromUserCode>false</ReferencedFromUserCode>
			<Location>FILE_SYSTEM</Location>
		</Resource>
		<Resource>
			<Path><![CDATA[poi-5.0.0.jar]]></Path>
			<ReferencedFromUserCode>false</ReferencedFromUserCode>
			<Location>FILE_SYSTEM</Location>
		</Resource>
		<Resource>
			<Path><![CDATA[poi-ooxml-5.0.0.jar]]></Path>
			<ReferencedFromUserCode>false</ReferencedFromUserCode>
			<Location>FILE_SYSTEM</Location>
		</Resource>
		<Resource>
			<Path><![CDATA[xmlbeans-4.0.0.jar]]></Path>
			<ReferencedFromUserCode>false</ReferencedFromUserCode>
			<Location>FILE_SYSTEM</Location>
		</Resource>
		<Resource>
			<Path><![CDATA[commons-compress-1.20.jar]]></Path>
			<ReferencedFromUserCode>false</ReferencedFromUserCode>
			<Location>FILE_SYSTEM</Location>
		</Resource>
		<Resource>
			<Path><![CDATA[xml-apis-ext-1.3.04.jar]]></Path>
			<ReferencedFromUserCode>false</ReferencedFromUserCode>
			<Location>FILE_SYSTEM</Location>
		</Resource>
		<Resource>
			<Path><![CDATA[xmlgraphics-commons-2.4.jar]]></Path>
			<ReferencedFromUserCode>false</ReferencedFromUserCode>
			<Location>FILE_SYSTEM</Location>
		</Resource>
		<Resource>
			<Path><![CDATA[commons-collections4-4.4.jar]]></Path>
			<ReferencedFromUserCode>false</ReferencedFromUserCode>
			<Location>FILE_SYSTEM</Location>
		</Resource>
		<Resource>
			<Path><![CDATA[commons-math3-3.6.1.jar]]></Path>
			<ReferencedFromUserCode>false</ReferencedFromUserCode>
			<Location>FILE_SYSTEM</Location>
		</Resource>
		<Resource>
			<Path><![CDATA[h2-2.1.210.jar]]></Path>
			<ReferencedFromUserCode>false</ReferencedFromUserCode>
			<Location>FILE_SYSTEM</Location>
		</Resource>
		<Resource>
			<Path><![CDATA[cplex.jar]]></Path>
			<ReferencedFromUserCode>false</ReferencedFromUserCode>
			<Location>FILE_SYSTEM</Location>
		</Resource>
		<Resource>
			<Path><![CDATA[3d/person.dae]]></Path>
			<ReferencedFromUserCode>false</ReferencedFromUserCode>
			<Location>FILE_SYSTEM</Location>
		</Resource>
		<Resource>
			<Path><![CDATA[postgresql-42.5.4.jar]]></Path>
			<ReferencedFromUserCode>false</ReferencedFromUserCode>
			<Location>FILE_SYSTEM</Location>
		</Resource>
	</ModelResources>
    <RequiredLibraryReference>
		<LibraryName><![CDATA[com.anylogic.libraries.modules.markup_descriptors]]></LibraryName>
		<VersionMajor>1</VersionMajor>
		<VersionMinor>0</VersionMinor>
		<VersionBuild>0</VersionBuild>
    </RequiredLibraryReference>
    <RequiredLibraryReference>
		<LibraryName><![CDATA[com.anylogic.libraries.processmodeling]]></LibraryName>
		<VersionMajor>8</VersionMajor>
		<VersionMinor>0</VersionMinor>
		<VersionBuild>5</VersionBuild>
    </RequiredLibraryReference>
    <RequiredLibraryReference>
		<LibraryName><![CDATA[com.anylogic.libraries.pypeline]]></LibraryName>
		<VersionMajor>1</VersionMajor>
		<VersionMinor>9</VersionMinor>
		<VersionBuild>5</VersionBuild>
    </RequiredLibraryReference>
	<ClassPathEntry>
		<ResourceReference>
			<PackageName><![CDATA[simopt]]></PackageName>
			<ClassName><![CDATA[gson-2.8.9.jar]]></ClassName>
		</ResourceReference>
		<Imported>true</Imported>
		<Folder>false</Folder>
	</ClassPathEntry>
	<ClassPathEntry>
		<ResourceReference>
			<PackageName><![CDATA[simopt]]></PackageName>
			<ClassName><![CDATA[sqlite-jdbc-3.34.0.jar]]></ClassName>
		</ResourceReference>
		<Imported>true</Imported>
		<Folder>false</Folder>
	</ClassPathEntry>
	<ClassPathEntry>
		<ResourceReference>
			<PackageName><![CDATA[simopt]]></PackageName>
			<ClassName><![CDATA[streamex-0.8.0.jar]]></ClassName>
		</ResourceReference>
		<Imported>true</Imported>
		<Folder>false</Folder>
	</ClassPathEntry>
	<ClassPathEntry>
		<ResourceReference>
			<PackageName><![CDATA[simopt]]></PackageName>
			<ClassName><![CDATA[poi-5.0.0.jar]]></ClassName>
		</ResourceReference>
		<Imported>true</Imported>
		<Folder>false</Folder>
	</ClassPathEntry>
	<ClassPathEntry>
		<ResourceReference>
			<PackageName><![CDATA[simopt]]></PackageName>
			<ClassName><![CDATA[poi-ooxml-5.0.0.jar]]></ClassName>
		</ResourceReference>
		<Imported>true</Imported>
		<Folder>false</Folder>
	</ClassPathEntry>
	<ClassPathEntry>
		<ResourceReference>
			<PackageName><![CDATA[simopt]]></PackageName>
			<ClassName><![CDATA[poi-ooxml-full-5.0.0.jar]]></ClassName>
		</ResourceReference>
		<Imported>true</Imported>
		<Folder>false</Folder>
	</ClassPathEntry>
	<ClassPathEntry>
		<ResourceReference>
			<PackageName><![CDATA[simopt]]></PackageName>
			<ClassName><![CDATA[xmlbeans-4.0.0.jar]]></ClassName>
		</ResourceReference>
		<Imported>true</Imported>
		<Folder>false</Folder>
	</ClassPathEntry>
	<ClassPathEntry>
		<ResourceReference>
			<PackageName><![CDATA[simopt]]></PackageName>
			<ClassName><![CDATA[commons-compress-1.20.jar]]></ClassName>
		</ResourceReference>
		<Imported>true</Imported>
		<Folder>false</Folder>
	</ClassPathEntry>
	<ClassPathEntry>
		<ResourceReference>
			<PackageName><![CDATA[simopt]]></PackageName>
			<ClassName><![CDATA[xml-apis-ext-1.3.04.jar]]></ClassName>
		</ResourceReference>
		<Imported>true</Imported>
		<Folder>false</Folder>
	</ClassPathEntry>
	<ClassPathEntry>
		<ResourceReference>
			<PackageName><![CDATA[simopt]]></PackageName>
			<ClassName><![CDATA[xmlgraphics-commons-2.4.jar]]></ClassName>
		</ResourceReference>
		<Imported>true</Imported>
		<Folder>false</Folder>
	</ClassPathEntry>
	<ClassPathEntry>
		<ResourceReference>
			<PackageName><![CDATA[simopt]]></PackageName>
			<ClassName><![CDATA[commons-compress-1.20.jar]]></ClassName>
		</ResourceReference>
		<Imported>true</Imported>
		<Folder>false</Folder>
	</ClassPathEntry>
	<ClassPathEntry>
		<ResourceReference>
			<PackageName><![CDATA[simopt]]></PackageName>
			<ClassName><![CDATA[xmlbeans-4.0.0.jar]]></ClassName>
		</ResourceReference>
		<Imported>true</Imported>
		<Folder>false</Folder>
	</ClassPathEntry>
	<ClassPathEntry>
		<ResourceReference>
			<PackageName><![CDATA[simopt]]></PackageName>
			<ClassName><![CDATA[commons-collections4-4.4.jar]]></ClassName>
		</ResourceReference>
		<Imported>true</Imported>
		<Folder>false</Folder>
	</ClassPathEntry>
	<ClassPathEntry>
		<ResourceReference>
			<PackageName><![CDATA[simopt]]></PackageName>
			<ClassName><![CDATA[commons-math3-3.6.1.jar]]></ClassName>
		</ResourceReference>
		<Imported>true</Imported>
		<Folder>false</Folder>
	</ClassPathEntry>
	<ClassPathEntry>
		<ResourceReference>
			<PackageName><![CDATA[simopt]]></PackageName>
			<ClassName><![CDATA[h2-2.1.210.jar]]></ClassName>
		</ResourceReference>
		<Imported>true</Imported>
		<Folder>false</Folder>
	</ClassPathEntry>
	<ClassPathEntry>
		<ResourceReference>
			<PackageName><![CDATA[simopt]]></PackageName>
			<ClassName><![CDATA[cplex.jar]]></ClassName>
		</ResourceReference>
		<Imported>true</Imported>
		<Folder>false</Folder>
	</ClassPathEntry>
	<ClassPathEntry>
		<ResourceReference>
			<PackageName><![CDATA[simopt]]></PackageName>
			<ClassName><![CDATA[postgresql-42.5.4.jar]]></ClassName>
		</ResourceReference>
		<Imported>true</Imported>
		<Folder>false</Folder>
	</ClassPathEntry>
</Model>
</AnyLogicWorkspace>